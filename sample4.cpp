# 1 "main.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 416 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "main.cpp" 2
# 1 "./boost/multiprecision/cpp_int.hpp" 1
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iostream" 1 3
# 37 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iostream" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__config" 1 3
# 22 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__config" 3
# 449 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__config" 3
# 38 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iostream" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ios" 1 3
# 215 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ios" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iosfwd" 1 3
# 90 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iosfwd" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/wchar.h" 1 3
# 113 "/Library/Developer/CommandLineTools/usr/include/c++/v1/wchar.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wchar.h" 1 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wchar.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types.h" 1 3 4
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/cdefs.h" 1 3 4
# 608 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/cdefs.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_symbol_aliasing.h" 1 3 4
# 609 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/cdefs.h" 2 3 4
# 674 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/cdefs.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_posix_availability.h" 1 3 4
# 675 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/cdefs.h" 2 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/machine/_types.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/machine/_types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/_types.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/_types.h" 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/_types.h" 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/machine/_types.h" 2 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types.h" 2 3 4
# 55 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_types.h" 1 3 4
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_types.h" 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types.h" 2 3 4
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types.h" 2 3 4
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types.h" 3 4
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/Availability.h" 1 3 4
# 232 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/Availability.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/AvailabilityInternal.h" 1 3 4
# 233 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/Availability.h" 2 3 4
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_null.h" 1 3 4
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_size_t.h" 3 4
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_mbstate_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_mbstate_t.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/machine/types.h" 1 3 4
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/machine/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/types.h" 1 3 4
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_int8_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_int8_t.h" 3 4
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_int16_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_int16_t.h" 3 4
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_int32_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_int32_t.h" 3 4
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_int64_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_int64_t.h" 3 4
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_u_int8_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_u_int8_t.h" 3 4
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_u_int16_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_u_int16_t.h" 3 4
# 83 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_u_int32_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_u_int32_t.h" 3 4
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_u_int64_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_u_int64_t.h" 3 4
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_intptr_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_intptr_t.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/machine/types.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_intptr_t.h" 2 3 4
# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_uintptr_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_uintptr_t.h" 3 4
# 94 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/types.h" 2 3 4
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/machine/types.h" 2 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_mbstate_t.h" 2 3 4
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_ct_rune_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_ct_rune_t.h" 3 4
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_rune_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_rune_t.h" 3 4
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wchar.h" 2 3 4
# 89 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wchar.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/stdarg.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/stdarg.h" 3 4
# 48 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/stdarg.h" 3 4
# 90 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdio.h" 1 3 4
# 106 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdio.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdio.h" 1 3 4
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdio.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_stdio.h" 1 3 4
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_stdio.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_va_list.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_va_list.h" 3 4
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_stdio.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/stdio.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/stdio.h" 3 4
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_stdio.h" 2 3 4
# 92 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_stdio.h" 3 4
# 126 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_stdio.h" 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdio.h" 2 3 4
# 141 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdio.h" 3 4
# 204 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdio.h" 3 4
# 231 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdio.h" 3 4
# 252 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdio.h" 3 4
# 289 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdio.h" 3 4
# 328 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdio.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_off_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_off_t.h" 3 4
# 329 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdio.h" 2 3 4
# 353 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdio.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_ssize_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_ssize_t.h" 3 4
# 354 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdio.h" 2 3 4
# 109 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdio.h" 2 3
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/time.h" 1 3 4
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/time.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_clock_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_clock_t.h" 3 4
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_time_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_time_t.h" 3 4
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_timespec.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_timespec.h" 3 4
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/time.h" 2 3 4
# 97 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/time.h" 3 4
# 152 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/time.h" 3 4
# 92 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_wctype.h" 1 3 4
# 42 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_wctype.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/__wctype.h" 1 3 4
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/__wctype.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_wint_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_wint_t.h" 3 4
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/__wctype.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types/_wctype_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types/_wctype_t.h" 3 4
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/__wctype.h" 2 3 4
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/__wctype.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ctype.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ctype.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/ctype.h" 1 3 4
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/ctype.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_ctype.h" 1 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_ctype.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/runetype.h" 1 3 4
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/runetype.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/runetype.h" 2 3 4
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/runetype.h" 3 4
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_ctype.h" 2 3 4
# 128 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_ctype.h" 3 4
# 147 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_ctype.h" 3 4
# 187 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_ctype.h" 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/ctype.h" 2 3 4
# 40 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ctype.h" 2 3
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/__wctype.h" 2 3 4
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_wctype.h" 2 3 4
# 155 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_wctype.h" 3 4
# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wchar.h" 2 3 4
# 169 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wchar.h" 3 4
# 194 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wchar.h" 3 4
# 120 "/Library/Developer/CommandLineTools/usr/include/c++/v1/wchar.h" 2 3
# 135 "/Library/Developer/CommandLineTools/usr/include/c++/v1/wchar.h" 3
# 91 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iosfwd" 2 3
# 94 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iosfwd" 3
# 216 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ios" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__locale" 1 3
# 15 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__locale" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string" 1 3
# 477 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string_view" 1 3
# 176 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string_view" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__string" 1 3
# 56 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__string" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/algorithm" 1 3
# 639 "/Library/Developer/CommandLineTools/usr/include/c++/v1/algorithm" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/initializer_list" 1 3
# 47 "/Library/Developer/CommandLineTools/usr/include/c++/v1/initializer_list" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstddef" 1 3
# 41 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstddef" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/stddef.h" 1 3 4
# 51 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/stddef.h" 3 4
# 76 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/stddef.h" 3 4
# 118 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/stddef.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/__stddef_max_align_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/__stddef_max_align_t.h" 3 4
# 119 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/stddef.h" 2 3 4
# 45 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstddef" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__nullptr" 1 3
# 18 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__nullptr" 3
# 55 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__nullptr" 3
# 46 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstddef" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 1 3
# 402 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstddef" 1 3
# 403 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 2 3
# 406 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 508 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 823 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 849 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 902 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 974 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 1159 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 1191 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 1413 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 1445 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 1536 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 1573 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 1599 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 1619 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 1762 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 1787 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 2086 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 2228 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 2357 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 2379 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 2836 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 3017 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 3139 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 3324 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 3378 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 3500 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 3584 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 3640 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 3660 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 3806 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 3920 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 4016 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 4039 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 4328 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 4751 "/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits" 3
# 111 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstddef" 2 3
# 48 "/Library/Developer/CommandLineTools/usr/include/c++/v1/initializer_list" 2 3
# 51 "/Library/Developer/CommandLineTools/usr/include/c++/v1/initializer_list" 3
# 640 "/Library/Developer/CommandLineTools/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstring" 1 3
# 61 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstring" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string.h" 1 3
# 59 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/string.h" 1 3 4
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/string.h" 3 4
# 103 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/string.h" 3 4
# 115 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/string.h" 3 4
# 129 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/string.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_rsize_t.h" 1 3 4
# 142 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/string.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_errno_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_errno_t.h" 3 4
# 143 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/string.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/strings.h" 1 3 4
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/strings.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string.h" 1 3 4
# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/strings.h" 2 3 4
# 181 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/string.h" 2 3 4
# 62 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string.h" 2 3
# 72 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string.h" 3
# 62 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstring" 2 3
# 65 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstring" 3
# 642 "/Library/Developer/CommandLineTools/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/utility" 1 3
# 198 "/Library/Developer/CommandLineTools/usr/include/c++/v1/utility" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__tuple" 1 3
# 20 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__tuple" 3
# 144 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__tuple" 3
# 284 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__tuple" 3
# 348 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__tuple" 3
# 199 "/Library/Developer/CommandLineTools/usr/include/c++/v1/utility" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstdint" 1 3
# 145 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstdint" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdint.h" 1 3
# 106 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdint.h" 3
# 119 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdint.h" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/stdint.h" 1 3 4
# 63 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/stdint.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdint.h" 1 3 4
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdint.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types/_uint8_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types/_uint8_t.h" 3 4
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types/_uint16_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types/_uint16_t.h" 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types/_uint32_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types/_uint32_t.h" 3 4
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types/_uint64_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types/_uint64_t.h" 3 4
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdint.h" 2 3 4
# 58 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdint.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types/_intmax_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types/_intmax_t.h" 3 4
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types/_uintmax_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types/_uintmax_t.h" 3 4
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdint.h" 2 3 4
# 64 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/stdint.h" 2 3 4
# 120 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdint.h" 2 3
# 146 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstdint" 2 3
# 149 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstdint" 3
# 204 "/Library/Developer/CommandLineTools/usr/include/c++/v1/utility" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__debug" 1 3
# 18 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__debug" 3
# 54 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__debug" 3
# 299 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__debug" 3
# 205 "/Library/Developer/CommandLineTools/usr/include/c++/v1/utility" 2 3
# 208 "/Library/Developer/CommandLineTools/usr/include/c++/v1/utility" 3
# 311 "/Library/Developer/CommandLineTools/usr/include/c++/v1/utility" 3
# 348 "/Library/Developer/CommandLineTools/usr/include/c++/v1/utility" 3
# 657 "/Library/Developer/CommandLineTools/usr/include/c++/v1/utility" 3
# 880 "/Library/Developer/CommandLineTools/usr/include/c++/v1/utility" 3
# 1505 "/Library/Developer/CommandLineTools/usr/include/c++/v1/utility" 3
# 643 "/Library/Developer/CommandLineTools/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 1 3
# 653 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/typeinfo" 1 3
# 61 "/Library/Developer/CommandLineTools/usr/include/c++/v1/typeinfo" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/exception" 1 3
# 82 "/Library/Developer/CommandLineTools/usr/include/c++/v1/exception" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstdlib" 1 3
# 86 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstdlib" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdlib.h" 1 3
# 92 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdlib.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdlib.h" 1 3 4
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdlib.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/wait.h" 1 3 4
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/wait.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_pid_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_pid_t.h" 3 4
# 90 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/wait.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_id_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_id_t.h" 3 4
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/wait.h" 2 3 4
# 109 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/wait.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/signal.h" 1 3 4
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/signal.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/appleapiopts.h" 1 3 4
# 74 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/machine/signal.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/machine/signal.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/signal.h" 1 3 4
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/signal.h" 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/machine/signal.h" 2 3 4
# 83 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/signal.h" 2 3 4
# 146 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/signal.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/machine/_mcontext.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/machine/_mcontext.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/_mcontext.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/_mcontext.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/mach/machine/_structs.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/mach/machine/_structs.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/mach/i386/_structs.h" 1 3 4
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/mach/i386/_structs.h" 3 4
# 92 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/mach/i386/_structs.h" 3 4
# 150 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/mach/i386/_structs.h" 3 4
# 194 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/mach/i386/_structs.h" 3 4
# 213 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/mach/i386/_structs.h" 3 4
# 229 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/mach/i386/_structs.h" 3 4
# 245 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/mach/i386/_structs.h" 3 4
# 259 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/mach/i386/_structs.h" 3 4
# 281 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/mach/i386/_structs.h" 3 4
# 575 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/mach/i386/_structs.h" 3 4
# 595 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/mach/i386/_structs.h" 3 4
# 627 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/mach/i386/_structs.h" 3 4
# 682 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/mach/i386/_structs.h" 3 4
# 1140 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/mach/i386/_structs.h" 3 4
# 1160 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/mach/i386/_structs.h" 3 4
# 1188 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/mach/i386/_structs.h" 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/mach/machine/_structs.h" 2 3 4
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/_mcontext.h" 2 3 4
# 97 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/_mcontext.h" 3 4
# 156 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/_mcontext.h" 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/machine/_mcontext.h" 2 3 4
# 147 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_attr_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_attr_t.h" 3 4
# 149 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_sigaltstack.h" 1 3 4
# 42 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_sigaltstack.h" 3 4
# 151 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_ucontext.h" 1 3 4
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_ucontext.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/machine/_mcontext.h" 1 3 4
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_ucontext.h" 2 3 4
# 152 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_sigset_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_sigset_t.h" 3 4
# 155 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_uid_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_uid_t.h" 3 4
# 157 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/signal.h" 2 3 4
# 269 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/signal.h" 3 4
# 331 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/signal.h" 3 4
# 348 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/signal.h" 3 4
# 367 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/signal.h" 3 4
# 389 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/signal.h" 3 4
# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/wait.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/resource.h" 1 3 4
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/resource.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_timeval.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_timeval.h" 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/resource.h" 2 3 4
# 152 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/resource.h" 3 4
# 163 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/resource.h" 3 4
# 193 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/resource.h" 3 4
# 366 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/resource.h" 3 4
# 401 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/resource.h" 3 4
# 436 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/resource.h" 3 4
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/wait.h" 2 3 4
# 186 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/wait.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/machine/endian.h" 1 3 4
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/machine/endian.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/endian.h" 1 3 4
# 99 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/endian.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_endian.h" 1 3 4
# 130 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_endian.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/libkern/_OSByteOrder.h" 1 3 4
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/libkern/_OSByteOrder.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/libkern/i386/_OSByteOrder.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/libkern/i386/_OSByteOrder.h" 3 4
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/libkern/_OSByteOrder.h" 2 3 4
# 131 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_endian.h" 2 3 4
# 100 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/endian.h" 2 3 4
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/machine/endian.h" 2 3 4
# 187 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/wait.h" 2 3 4
# 247 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/wait.h" 3 4
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdlib.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/alloca.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/alloca.h" 3 4
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdlib.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdlib.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdlib.h" 2 3 4
# 118 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdlib.h" 3 4
# 128 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdlib.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/malloc/_malloc.h" 1 3 4
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/malloc/_malloc.h" 3 4
# 129 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdlib.h" 2 3 4
# 187 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdlib.h" 3 4
# 261 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdlib.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_dev_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_dev_t.h" 3 4
# 262 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdlib.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_mode_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_mode_t.h" 3 4
# 263 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdlib.h" 2 3 4
# 95 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdlib.h" 2 3
# 111 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdlib.h" 3
# 87 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstdlib" 2 3
# 90 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstdlib" 3
# 162 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstdlib" 3
# 83 "/Library/Developer/CommandLineTools/usr/include/c++/v1/exception" 2 3
# 91 "/Library/Developer/CommandLineTools/usr/include/c++/v1/exception" 3
# 124 "/Library/Developer/CommandLineTools/usr/include/c++/v1/exception" 3
# 234 "/Library/Developer/CommandLineTools/usr/include/c++/v1/exception" 3
# 62 "/Library/Developer/CommandLineTools/usr/include/c++/v1/typeinfo" 2 3
# 70 "/Library/Developer/CommandLineTools/usr/include/c++/v1/typeinfo" 3
# 80 "/Library/Developer/CommandLineTools/usr/include/c++/v1/typeinfo" 3
# 103 "/Library/Developer/CommandLineTools/usr/include/c++/v1/typeinfo" 3
# 113 "/Library/Developer/CommandLineTools/usr/include/c++/v1/typeinfo" 3
# 179 "/Library/Developer/CommandLineTools/usr/include/c++/v1/typeinfo" 3
# 654 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/new" 1 3
# 103 "/Library/Developer/CommandLineTools/usr/include/c++/v1/new" 3
# 116 "/Library/Developer/CommandLineTools/usr/include/c++/v1/new" 3
# 181 "/Library/Developer/CommandLineTools/usr/include/c++/v1/new" 3
# 657 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/limits" 1 3
# 117 "/Library/Developer/CommandLineTools/usr/include/c++/v1/limits" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 121 "/Library/Developer/CommandLineTools/usr/include/c++/v1/limits" 2 3
# 659 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iterator" 1 3
# 417 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iterator" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__functional_base" 1 3
# 23 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__functional_base" 3
# 312 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__functional_base" 3
# 341 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__functional_base" 3
# 372 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__functional_base" 3
# 510 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__functional_base" 3
# 418 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iterator" 2 3
# 429 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iterator" 3
# 758 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iterator" 3
# 1199 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iterator" 3
# 1296 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iterator" 3
# 1349 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iterator" 3
# 1499 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iterator" 3
# 1612 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iterator" 3
# 1830 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iterator" 3
# 660 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/tuple" 1 3
# 147 "/Library/Developer/CommandLineTools/usr/include/c++/v1/tuple" 3
# 738 "/Library/Developer/CommandLineTools/usr/include/c++/v1/tuple" 3
# 771 "/Library/Developer/CommandLineTools/usr/include/c++/v1/tuple" 3
# 1415 "/Library/Developer/CommandLineTools/usr/include/c++/v1/tuple" 3
# 663 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdexcept" 1 3
# 54 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdexcept" 3
# 664 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cassert" 1 3
# 21 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 2 3 4
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 22 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cassert" 2 3
# 25 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cassert" 3
# 666 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/atomic" 1 3
# 550 "/Library/Developer/CommandLineTools/usr/include/c++/v1/atomic" 3
# 582 "/Library/Developer/CommandLineTools/usr/include/c++/v1/atomic" 3
# 859 "/Library/Developer/CommandLineTools/usr/include/c++/v1/atomic" 3
# 893 "/Library/Developer/CommandLineTools/usr/include/c++/v1/atomic" 3
# 668 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 2 3
# 672 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 676 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 2 3
# 816 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 946 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 1153 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 1347 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 1380 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 1499 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 1592 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 1860 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 1956 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 2080 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 2224 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 2462 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 2551 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 2831 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 3055 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 3420 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 3644 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 3744 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 3783 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 3830 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 3952 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 4202 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 4464 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 4536 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 4589 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 4739 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 5489 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 5516 "/Library/Developer/CommandLineTools/usr/include/c++/v1/memory" 3
# 644 "/Library/Developer/CommandLineTools/usr/include/c++/v1/algorithm" 2 3
# 658 "/Library/Developer/CommandLineTools/usr/include/c++/v1/algorithm" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 662 "/Library/Developer/CommandLineTools/usr/include/c++/v1/algorithm" 2 3
# 790 "/Library/Developer/CommandLineTools/usr/include/c++/v1/algorithm" 3
# 804 "/Library/Developer/CommandLineTools/usr/include/c++/v1/algorithm" 3
# 839 "/Library/Developer/CommandLineTools/usr/include/c++/v1/algorithm" 3
# 856 "/Library/Developer/CommandLineTools/usr/include/c++/v1/algorithm" 3
# 889 "/Library/Developer/CommandLineTools/usr/include/c++/v1/algorithm" 3
# 1806 "/Library/Developer/CommandLineTools/usr/include/c++/v1/algorithm" 3
# 3209 "/Library/Developer/CommandLineTools/usr/include/c++/v1/algorithm" 3
# 4607 "/Library/Developer/CommandLineTools/usr/include/c++/v1/algorithm" 3
# 57 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__string" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstdio" 1 3
# 100 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstdio" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdio.h" 1 3
# 101 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstdio" 2 3
# 104 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cstdio" 3
# 58 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__string" 2 3
# 64 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__string" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 68 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__string" 2 3
# 262 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__string" 3
# 283 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__string" 3
# 352 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__string" 3
# 368 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__string" 3
# 389 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__string" 3
# 177 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string_view" 2 3
# 185 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string_view" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 189 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string_view" 2 3
# 601 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string_view" 3
# 478 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cwchar" 1 3
# 107 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cwchar" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cwctype" 1 3
# 54 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cwctype" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cctype" 1 3
# 43 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cctype" 3
# 104 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cctype" 3
# 55 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cwctype" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/wctype.h" 1 3
# 52 "/Library/Developer/CommandLineTools/usr/include/c++/v1/wctype.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wctype.h" 1 3 4
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wctype.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types/_wctrans_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types/_wctrans_t.h" 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wctype.h" 2 3 4
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wctype.h" 3 4
# 117 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/wctype.h" 3 4
# 55 "/Library/Developer/CommandLineTools/usr/include/c++/v1/wctype.h" 2 3
# 56 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cwctype" 2 3
# 59 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cwctype" 3
# 108 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cwchar" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/wchar.h" 1 3
# 109 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cwchar" 2 3
# 112 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cwchar" 3
# 482 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string" 2 3
# 498 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 502 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string" 2 3
# 599 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string" 3
# 636 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string" 3
# 703 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string" 3
# 856 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string" 3
# 1251 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string" 3
# 1266 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string" 3
# 1294 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string" 3
# 1522 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string" 3
# 4036 "/Library/Developer/CommandLineTools/usr/include/c++/v1/string" 3
# 16 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__locale" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/mutex" 1 3
# 191 "/Library/Developer/CommandLineTools/usr/include/c++/v1/mutex" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__mutex_base" 1 3
# 15 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__mutex_base" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/chrono" 1 3
# 303 "/Library/Developer/CommandLineTools/usr/include/c++/v1/chrono" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ctime" 1 3
# 52 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ctime" 3
# 304 "/Library/Developer/CommandLineTools/usr/include/c++/v1/chrono" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ratio" 1 3
# 83 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ratio" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/climits" 1 3
# 42 "/Library/Developer/CommandLineTools/usr/include/c++/v1/climits" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/limits.h" 1 3
# 45 "/Library/Developer/CommandLineTools/usr/include/c++/v1/limits.h" 3
# 58 "/Library/Developer/CommandLineTools/usr/include/c++/v1/limits.h" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/limits.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/limits.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/limits.h" 1 3 4
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/limits.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/machine/limits.h" 1 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/limits.h" 1 3 4
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/limits.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/_limits.h" 1 3 4
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/i386/limits.h" 2 3 4
# 7 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/machine/limits.h" 2 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/limits.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/syslimits.h" 1 3 4
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/limits.h" 2 3 4
# 38 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/limits.h" 2 3 4
# 59 "/Library/Developer/CommandLineTools/usr/include/c++/v1/limits.h" 2 3
# 43 "/Library/Developer/CommandLineTools/usr/include/c++/v1/climits" 2 3
# 46 "/Library/Developer/CommandLineTools/usr/include/c++/v1/climits" 3
# 84 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ratio" 2 3
# 88 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ratio" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 92 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ratio" 2 3
# 318 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ratio" 3
# 345 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ratio" 3
# 380 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ratio" 3
# 417 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ratio" 3
# 306 "/Library/Developer/CommandLineTools/usr/include/c++/v1/chrono" 2 3
# 310 "/Library/Developer/CommandLineTools/usr/include/c++/v1/chrono" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 314 "/Library/Developer/CommandLineTools/usr/include/c++/v1/chrono" 2 3
# 16 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__mutex_base" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/system_error" 1 3
# 229 "/Library/Developer/CommandLineTools/usr/include/c++/v1/system_error" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cerrno" 1 3
# 27 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cerrno" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/errno.h" 1 3
# 30 "/Library/Developer/CommandLineTools/usr/include/c++/v1/errno.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/errno.h" 1 3 4
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/errno.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/errno.h" 1 3 4
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/errno.h" 3 4
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/errno.h" 2 3 4
# 33 "/Library/Developer/CommandLineTools/usr/include/c++/v1/errno.h" 2 3
# 28 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cerrno" 2 3
# 31 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cerrno" 3
# 230 "/Library/Developer/CommandLineTools/usr/include/c++/v1/system_error" 2 3
# 237 "/Library/Developer/CommandLineTools/usr/include/c++/v1/system_error" 3
# 17 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__mutex_base" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__threading_support" 1 3
# 20 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__threading_support" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread.h" 1 3 4
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread/pthread_impl.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread/pthread_impl.h" 3 4
# 58 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread/sched.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread/sched.h" 3 4
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_cond_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_cond_t.h" 3 4
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_condattr_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_condattr_t.h" 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_key_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_key_t.h" 3 4
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h" 3 4
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h" 3 4
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_once_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_once_t.h" 3 4
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_rwlock_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_rwlock_t.h" 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_rwlockattr_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_rwlockattr_t.h" 3 4
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_pthread/_pthread_t.h" 3 4
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread/qos.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread/qos.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/qos.h" 1 3 4
# 128 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/qos.h" 3 4
# 157 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/qos.h" 3 4
# 168 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/qos.h" 3 4
# 190 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/qos.h" 3 4
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread/qos.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread/qos.h" 3 4
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread/qos.h" 3 4
# 153 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread/qos.h" 3 4
# 184 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread/qos.h" 3 4
# 211 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread/qos.h" 3 4
# 263 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread/qos.h" 3 4
# 291 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread/qos.h" 3 4
# 74 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_mach_port_t.h" 1 3 4
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_mach_port_t.h" 3 4
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread.h" 2 3 4
# 106 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread.h" 3 4
# 221 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/pthread.h" 3 4
# 28 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__threading_support" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 37 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__threading_support" 2 3
# 52 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__threading_support" 3
# 111 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__threading_support" 3
# 336 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__threading_support" 3
# 643 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__threading_support" 3
# 18 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__mutex_base" 2 3
# 22 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__mutex_base" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 26 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__mutex_base" 2 3
# 40 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__mutex_base" 3
# 85 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__mutex_base" 3
# 192 "/Library/Developer/CommandLineTools/usr/include/c++/v1/mutex" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/functional" 1 3
# 495 "/Library/Developer/CommandLineTools/usr/include/c++/v1/functional" 3
# 1254 "/Library/Developer/CommandLineTools/usr/include/c++/v1/functional" 3
# 1375 "/Library/Developer/CommandLineTools/usr/include/c++/v1/functional" 3
# 1648 "/Library/Developer/CommandLineTools/usr/include/c++/v1/functional" 3
# 1667 "/Library/Developer/CommandLineTools/usr/include/c++/v1/functional" 3
# 1719 "/Library/Developer/CommandLineTools/usr/include/c++/v1/functional" 3
# 1757 "/Library/Developer/CommandLineTools/usr/include/c++/v1/functional" 3
# 1809 "/Library/Developer/CommandLineTools/usr/include/c++/v1/functional" 3
# 1985 "/Library/Developer/CommandLineTools/usr/include/c++/v1/functional" 3
# 2020 "/Library/Developer/CommandLineTools/usr/include/c++/v1/functional" 3
# 193 "/Library/Developer/CommandLineTools/usr/include/c++/v1/mutex" 2 3
# 201 "/Library/Developer/CommandLineTools/usr/include/c++/v1/mutex" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 205 "/Library/Developer/CommandLineTools/usr/include/c++/v1/mutex" 2 3
# 572 "/Library/Developer/CommandLineTools/usr/include/c++/v1/mutex" 3
# 597 "/Library/Developer/CommandLineTools/usr/include/c++/v1/mutex" 3
# 644 "/Library/Developer/CommandLineTools/usr/include/c++/v1/mutex" 3
# 698 "/Library/Developer/CommandLineTools/usr/include/c++/v1/mutex" 3
# 19 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__locale" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/locale.h" 1 3
# 41 "/Library/Developer/CommandLineTools/usr/include/c++/v1/locale.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/locale.h" 1 3 4
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/locale.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_locale.h" 1 3 4
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_locale.h" 3 4
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/locale.h" 2 3 4
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/locale.h" 3 4
# 44 "/Library/Developer/CommandLineTools/usr/include/c++/v1/locale.h" 2 3
# 22 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__locale" 2 3
# 39 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__locale" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_xlocale.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_xlocale.h" 3 4
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale.h" 2 3 4
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale/_ctype.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale/_ctype.h" 3 4
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale/__wctype.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale/__wctype.h" 3 4
# 138 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale/__wctype.h" 3 4
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale.h" 2 3 4
# 92 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale/_stdio.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale/_stdio.h" 3 4
# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale/_stdlib.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale/_stdlib.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale/_stdlib.h" 2 3 4
# 96 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale/_string.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale/_string.h" 3 4
# 99 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale/_time.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale/_time.h" 3 4
# 102 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale/_wchar.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale/_wchar.h" 3 4
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale/_wchar.h" 3 4
# 118 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale/_wchar.h" 3 4
# 105 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale/_wctype.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale/_wctype.h" 3 4
# 90 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale/_wctype.h" 3 4
# 108 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/xlocale.h" 2 3 4
# 40 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__locale" 2 3
# 48 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__locale" 3
# 97 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__locale" 3
# 411 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__locale" 3
# 473 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__locale" 3
# 692 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__locale" 3
# 217 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ios" 2 3
# 225 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ios" 3
# 281 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ios" 3
# 582 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ios" 3
# 604 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ios" 3
# 39 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iostream" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/streambuf" 1 3
# 117 "/Library/Developer/CommandLineTools/usr/include/c++/v1/streambuf" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 121 "/Library/Developer/CommandLineTools/usr/include/c++/v1/streambuf" 2 3
# 40 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iostream" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/istream" 1 3
# 163 "/Library/Developer/CommandLineTools/usr/include/c++/v1/istream" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ostream" 1 3
# 140 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ostream" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/locale" 1 3
# 197 "/Library/Developer/CommandLineTools/usr/include/c++/v1/locale" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/nl_types.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/nl_types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 1 3 4
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_u_char.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_u_char.h" 3 4
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_u_short.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_u_short.h" 3 4
# 86 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_u_int.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_u_int.h" 3 4
# 87 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_caddr_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_caddr_t.h" 3 4
# 100 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_blkcnt_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_blkcnt_t.h" 3 4
# 108 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_blksize_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_blksize_t.h" 3 4
# 109 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_gid_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_gid_t.h" 3 4
# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_in_addr_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_in_addr_t.h" 3 4
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_in_port_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_in_port_t.h" 3 4
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_ino_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_ino_t.h" 3 4
# 113 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_ino64_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_ino64_t.h" 3 4
# 116 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_key_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_key_t.h" 3 4
# 119 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_nlink_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_nlink_t.h" 3 4
# 121 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 138 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 3 4
# 167 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_useconds_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_useconds_t.h" 3 4
# 168 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_suseconds_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_suseconds_t.h" 3 4
# 169 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_rsize_t.h" 1 3 4
# 172 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 181 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_fd_def.h" 1 3 4
# 48 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_fd_def.h" 3 4
# 182 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_fd_setsize.h" 1 3 4
# 195 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_fd_set.h" 1 3 4
# 196 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_fd_clr.h" 1 3 4
# 197 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_fd_zero.h" 1 3 4
# 198 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_fd_isset.h" 1 3 4
# 199 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_fd_copy.h" 1 3 4
# 202 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 229 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_fsblkcnt_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_fsblkcnt_t.h" 3 4
# 230 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_fsfilcnt_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_fsfilcnt_t.h" 3 4
# 231 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/types.h" 2 3 4
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/nl_types.h" 2 3 4
# 89 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/nl_types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types/_nl_item.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_types/_nl_item.h" 3 4
# 95 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/nl_types.h" 2 3 4
# 198 "/Library/Developer/CommandLineTools/usr/include/c++/v1/locale" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__bsd_locale_defaults.h" 1 3
# 20 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__bsd_locale_defaults.h" 3
# 206 "/Library/Developer/CommandLineTools/usr/include/c++/v1/locale" 2 3
# 212 "/Library/Developer/CommandLineTools/usr/include/c++/v1/locale" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 216 "/Library/Developer/CommandLineTools/usr/include/c++/v1/locale" 2 3
# 249 "/Library/Developer/CommandLineTools/usr/include/c++/v1/locale" 3
# 423 "/Library/Developer/CommandLineTools/usr/include/c++/v1/locale" 3
# 141 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ostream" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/bitset" 1 3
# 117 "/Library/Developer/CommandLineTools/usr/include/c++/v1/bitset" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__bit_reference" 1 3
# 19 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__bit_reference" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__bit_reference" 2 3
# 118 "/Library/Developer/CommandLineTools/usr/include/c++/v1/bitset" 2 3
# 127 "/Library/Developer/CommandLineTools/usr/include/c++/v1/bitset" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 131 "/Library/Developer/CommandLineTools/usr/include/c++/v1/bitset" 2 3
# 264 "/Library/Developer/CommandLineTools/usr/include/c++/v1/bitset" 3
# 279 "/Library/Developer/CommandLineTools/usr/include/c++/v1/bitset" 3
# 143 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ostream" 2 3
# 146 "/Library/Developer/CommandLineTools/usr/include/c++/v1/ostream" 3
# 164 "/Library/Developer/CommandLineTools/usr/include/c++/v1/istream" 2 3
# 167 "/Library/Developer/CommandLineTools/usr/include/c++/v1/istream" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 171 "/Library/Developer/CommandLineTools/usr/include/c++/v1/istream" 2 3
# 41 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iostream" 2 3
# 45 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iostream" 3
# 10 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iomanip" 1 3
# 52 "/Library/Developer/CommandLineTools/usr/include/c++/v1/iomanip" 3
# 11 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/cstdint.hpp" 1
# 36 "./boost/cstdint.hpp"
# 1 "./boost/config.hpp" 1
# 30 "./boost/config.hpp"
# 1 "./boost/config/user.hpp" 1
# 31 "./boost/config.hpp" 2
# 1 "./boost/config/detail/select_compiler_config.hpp" 1
# 36 "./boost/config.hpp" 2
# 1 "./boost/config/compiler/clang.hpp" 1
# 40 "./boost/config.hpp" 2
# 1 "./boost/config/detail/select_stdlib_config.hpp" 1
# 45 "./boost/config.hpp" 2
# 1 "./boost/config/stdlib/libcpp.hpp" 1
# 49 "./boost/config.hpp" 2
# 1 "./boost/config/detail/select_platform_config.hpp" 1
# 54 "./boost/config.hpp" 2
# 1 "./boost/config/platform/macos.hpp" 1
# 28 "./boost/config/platform/macos.hpp"
# 1 "./boost/config/detail/posix_features.hpp" 1
# 18 "./boost/config/detail/posix_features.hpp"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/unistd.h" 1 3 4
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/unistd.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/unistd.h" 1 3 4
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/unistd.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_posix_vdisable.h" 1 3 4
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/unistd.h" 2 3 4
# 122 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/unistd.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_seek_set.h" 1 3 4
# 123 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/unistd.h" 2 3 4
# 132 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/unistd.h" 3 4
# 185 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/unistd.h" 3 4
# 205 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/unistd.h" 3 4
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/unistd.h" 2 3 4
# 428 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/unistd.h" 3 4
# 505 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/unistd.h" 3 4
# 530 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/unistd.h" 3 4
# 623 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/unistd.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/select.h" 1 3 4
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/select.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_select.h" 1 3 4
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_select.h" 3 4
# 130 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/select.h" 2 3 4
# 639 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/unistd.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_uuid_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/sys/_types/_uuid_t.h" 3 4
# 643 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/unistd.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/gethostuuid.h" 1 3 4
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/gethostuuid.h" 3 4
# 659 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/unistd.h" 2 3 4
# 772 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/unistd.h" 3 4
# 19 "./boost/config/detail/posix_features.hpp" 2
# 29 "./boost/config/platform/macos.hpp" 2
# 58 "./boost/config.hpp" 2
# 1 "./boost/config/detail/suffix.hpp" 1
# 35 "./boost/config/detail/suffix.hpp" 3
# 484 "./boost/config/detail/suffix.hpp" 3
# 543 "./boost/config/detail/suffix.hpp" 3
# 1 "./boost/config/helper_macros.hpp" 1 3
# 544 "./boost/config/detail/suffix.hpp" 2 3
# 62 "./boost/config.hpp" 2
# 37 "./boost/cstdint.hpp" 2
# 47 "./boost/cstdint.hpp" 3
# 114 "./boost/cstdint.hpp" 3
# 387 "./boost/cstdint.hpp" 3
# 12 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/multiprecision/number.hpp" 1
# 1 "./boost/cstdint.hpp" 1
# 10 "./boost/multiprecision/number.hpp" 2
# 1 "./boost/mpl/max.hpp" 1
# 17 "./boost/mpl/max.hpp"
# 1 "./boost/mpl/min_max.hpp" 1
# 17 "./boost/mpl/min_max.hpp"
# 1 "./boost/mpl/less.hpp" 1
# 19 "./boost/mpl/less.hpp"
# 1 "./boost/mpl/aux_/comparison_op.hpp" 1
# 17 "./boost/mpl/aux_/comparison_op.hpp"
# 1 "./boost/mpl/bool.hpp" 1
# 17 "./boost/mpl/bool.hpp"
# 1 "./boost/mpl/bool_fwd.hpp" 1
# 17 "./boost/mpl/bool_fwd.hpp"
# 1 "./boost/mpl/aux_/adl_barrier.hpp" 1
# 17 "./boost/mpl/aux_/adl_barrier.hpp"
# 1 "./boost/mpl/aux_/config/adl.hpp" 1
# 17 "./boost/mpl/aux_/config/adl.hpp"
# 1 "./boost/mpl/aux_/config/msvc.hpp" 1
# 18 "./boost/mpl/aux_/config/adl.hpp" 2
# 1 "./boost/mpl/aux_/config/intel.hpp" 1
# 19 "./boost/mpl/aux_/config/adl.hpp" 2
# 1 "./boost/mpl/aux_/config/gcc.hpp" 1
# 20 "./boost/mpl/aux_/config/adl.hpp" 2
# 1 "./boost/mpl/aux_/config/workaround.hpp" 1
# 17 "./boost/mpl/aux_/config/workaround.hpp"
# 1 "./boost/detail/workaround.hpp" 1
# 1 "./boost/config/workaround.hpp" 1
# 9 "./boost/detail/workaround.hpp" 2
# 18 "./boost/mpl/aux_/config/workaround.hpp" 2
# 21 "./boost/mpl/aux_/config/adl.hpp" 2
# 18 "./boost/mpl/aux_/adl_barrier.hpp" 2
# 33 "./boost/mpl/aux_/adl_barrier.hpp"
# 18 "./boost/mpl/bool_fwd.hpp" 2
# 18 "./boost/mpl/bool.hpp" 2
# 1 "./boost/mpl/integral_c_tag.hpp" 1
# 19 "./boost/mpl/integral_c_tag.hpp"
# 1 "./boost/mpl/aux_/config/static_constant.hpp" 1
# 20 "./boost/mpl/integral_c_tag.hpp" 2
# 19 "./boost/mpl/bool.hpp" 2
# 18 "./boost/mpl/aux_/comparison_op.hpp" 2
# 1 "./boost/mpl/aux_/value_wknd.hpp" 1
# 17 "./boost/mpl/aux_/value_wknd.hpp"
# 1 "./boost/mpl/aux_/static_cast.hpp" 1
# 18 "./boost/mpl/aux_/value_wknd.hpp" 2
# 1 "./boost/mpl/aux_/config/integral.hpp" 1
# 19 "./boost/mpl/aux_/value_wknd.hpp" 2
# 1 "./boost/mpl/aux_/config/eti.hpp" 1
# 20 "./boost/mpl/aux_/value_wknd.hpp" 2
# 73 "./boost/mpl/aux_/value_wknd.hpp"
# 87 "./boost/mpl/aux_/value_wknd.hpp"
# 19 "./boost/mpl/aux_/comparison_op.hpp" 2
# 1 "./boost/mpl/aux_/numeric_op.hpp" 1
# 21 "./boost/mpl/aux_/numeric_op.hpp"
# 1 "./boost/mpl/numeric_cast.hpp" 1
# 30 "./boost/mpl/numeric_cast.hpp"
# 22 "./boost/mpl/aux_/numeric_op.hpp" 2
# 1 "./boost/mpl/apply_wrap.hpp" 1
# 22 "./boost/mpl/apply_wrap.hpp"
# 1 "./boost/mpl/aux_/arity.hpp" 1
# 17 "./boost/mpl/aux_/arity.hpp"
# 1 "./boost/mpl/aux_/config/dtp.hpp" 1
# 18 "./boost/mpl/aux_/arity.hpp" 2
# 23 "./boost/mpl/apply_wrap.hpp" 2
# 1 "./boost/mpl/aux_/has_apply.hpp" 1
# 17 "./boost/mpl/aux_/has_apply.hpp"
# 1 "./boost/mpl/has_xxx.hpp" 1
# 20 "./boost/mpl/has_xxx.hpp"
# 1 "./boost/mpl/aux_/na_spec.hpp" 1
# 18 "./boost/mpl/aux_/na_spec.hpp"
# 1 "./boost/mpl/lambda_fwd.hpp" 1
# 17 "./boost/mpl/lambda_fwd.hpp"
# 1 "./boost/mpl/void_fwd.hpp" 1
# 19 "./boost/mpl/void_fwd.hpp"
# 18 "./boost/mpl/lambda_fwd.hpp" 2
# 1 "./boost/mpl/aux_/na.hpp" 1
# 18 "./boost/mpl/aux_/na.hpp"
# 1 "./boost/mpl/aux_/na_fwd.hpp" 1
# 19 "./boost/mpl/aux_/na_fwd.hpp"
# 19 "./boost/mpl/aux_/na.hpp" 2
# 1 "./boost/mpl/aux_/config/ctps.hpp" 1
# 21 "./boost/mpl/aux_/na.hpp" 2
# 93 "./boost/mpl/aux_/na.hpp"
# 19 "./boost/mpl/lambda_fwd.hpp" 2
# 1 "./boost/mpl/aux_/config/lambda.hpp" 1
# 17 "./boost/mpl/aux_/config/lambda.hpp"
# 1 "./boost/mpl/aux_/config/ttp.hpp" 1
# 18 "./boost/mpl/aux_/config/lambda.hpp" 2
# 20 "./boost/mpl/lambda_fwd.hpp" 2
# 1 "./boost/mpl/int.hpp" 1
# 17 "./boost/mpl/int.hpp"
# 1 "./boost/mpl/int_fwd.hpp" 1
# 18 "./boost/mpl/int_fwd.hpp"
# 1 "./boost/mpl/aux_/nttp_decl.hpp" 1
# 17 "./boost/mpl/aux_/nttp_decl.hpp"
# 1 "./boost/mpl/aux_/config/nttp.hpp" 1
# 18 "./boost/mpl/aux_/nttp_decl.hpp" 2
# 19 "./boost/mpl/int_fwd.hpp" 2
# 18 "./boost/mpl/int.hpp" 2
# 1 "./boost/mpl/aux_/integral_wrapper.hpp" 1
# 22 "./boost/mpl/aux_/integral_wrapper.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 17 "./boost/preprocessor/cat.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 18 "./boost/preprocessor/cat.hpp" 2
# 23 "./boost/mpl/aux_/integral_wrapper.hpp" 2
# 40 "./boost/mpl/aux_/integral_wrapper.hpp"
# 72 "./boost/mpl/aux_/integral_wrapper.hpp"
# 21 "./boost/mpl/int.hpp" 2
# 24 "./boost/mpl/lambda_fwd.hpp" 2
# 1 "./boost/mpl/aux_/lambda_arity_param.hpp" 1
# 25 "./boost/mpl/lambda_fwd.hpp" 2
# 1 "./boost/mpl/aux_/template_arity_fwd.hpp" 1
# 17 "./boost/mpl/aux_/template_arity_fwd.hpp"
# 26 "./boost/mpl/lambda_fwd.hpp" 2
# 19 "./boost/mpl/aux_/na_spec.hpp" 2
# 1 "./boost/mpl/aux_/preprocessor/params.hpp" 1
# 17 "./boost/mpl/aux_/preprocessor/params.hpp"
# 1 "./boost/mpl/aux_/config/preprocessor.hpp" 1
# 18 "./boost/mpl/aux_/preprocessor/params.hpp" 2
# 45 "./boost/mpl/aux_/preprocessor/params.hpp"
# 1 "./boost/preprocessor/comma_if.hpp" 1
# 15 "./boost/preprocessor/comma_if.hpp"
# 1 "./boost/preprocessor/punctuation/comma_if.hpp" 1
# 17 "./boost/preprocessor/punctuation/comma_if.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 18 "./boost/preprocessor/punctuation/comma_if.hpp" 2
# 1 "./boost/preprocessor/control/if.hpp" 1
# 17 "./boost/preprocessor/control/if.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 18 "./boost/preprocessor/control/if.hpp" 2
# 1 "./boost/preprocessor/control/iif.hpp" 1
# 15 "./boost/preprocessor/control/iif.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 16 "./boost/preprocessor/control/iif.hpp" 2
# 19 "./boost/preprocessor/control/if.hpp" 2
# 1 "./boost/preprocessor/logical/bool.hpp" 1
# 17 "./boost/preprocessor/logical/bool.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 18 "./boost/preprocessor/logical/bool.hpp" 2
# 20 "./boost/preprocessor/control/if.hpp" 2
# 19 "./boost/preprocessor/punctuation/comma_if.hpp" 2
# 1 "./boost/preprocessor/facilities/empty.hpp" 1
# 17 "./boost/preprocessor/facilities/empty.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 18 "./boost/preprocessor/facilities/empty.hpp" 2
# 20 "./boost/preprocessor/punctuation/comma_if.hpp" 2
# 1 "./boost/preprocessor/punctuation/comma.hpp" 1
# 21 "./boost/preprocessor/punctuation/comma_if.hpp" 2
# 16 "./boost/preprocessor/comma_if.hpp" 2
# 46 "./boost/mpl/aux_/preprocessor/params.hpp" 2
# 1 "./boost/preprocessor/repeat.hpp" 1
# 15 "./boost/preprocessor/repeat.hpp"
# 1 "./boost/preprocessor/repetition/repeat.hpp" 1
# 17 "./boost/preprocessor/repetition/repeat.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 18 "./boost/preprocessor/repetition/repeat.hpp" 2
# 1 "./boost/preprocessor/config/config.hpp" 1
# 19 "./boost/preprocessor/repetition/repeat.hpp" 2
# 1 "./boost/preprocessor/debug/error.hpp" 1
# 15 "./boost/preprocessor/debug/error.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 16 "./boost/preprocessor/debug/error.hpp" 2
# 1 "./boost/preprocessor/config/config.hpp" 1
# 17 "./boost/preprocessor/debug/error.hpp" 2
# 20 "./boost/preprocessor/repetition/repeat.hpp" 2
# 1 "./boost/preprocessor/detail/auto_rec.hpp" 1
# 12 "./boost/preprocessor/detail/auto_rec.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 13 "./boost/preprocessor/detail/auto_rec.hpp" 2
# 1 "./boost/preprocessor/control/iif.hpp" 1
# 22 "./boost/preprocessor/detail/auto_rec.hpp" 2
# 21 "./boost/preprocessor/repetition/repeat.hpp" 2
# 1 "./boost/preprocessor/tuple/eat.hpp" 1
# 18 "./boost/preprocessor/tuple/eat.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 19 "./boost/preprocessor/tuple/eat.hpp" 2
# 22 "./boost/preprocessor/repetition/repeat.hpp" 2
# 16 "./boost/preprocessor/repeat.hpp" 2
# 47 "./boost/mpl/aux_/preprocessor/params.hpp" 2
# 1 "./boost/preprocessor/inc.hpp" 1
# 15 "./boost/preprocessor/inc.hpp"
# 1 "./boost/preprocessor/arithmetic/inc.hpp" 1
# 17 "./boost/preprocessor/arithmetic/inc.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 18 "./boost/preprocessor/arithmetic/inc.hpp" 2
# 16 "./boost/preprocessor/inc.hpp" 2
# 48 "./boost/mpl/aux_/preprocessor/params.hpp" 2
# 1 "./boost/preprocessor/cat.hpp" 1
# 49 "./boost/mpl/aux_/preprocessor/params.hpp" 2
# 27 "./boost/mpl/aux_/na_spec.hpp" 2
# 1 "./boost/mpl/aux_/preprocessor/enum.hpp" 1
# 45 "./boost/mpl/aux_/preprocessor/enum.hpp"
# 1 "./boost/preprocessor/comma_if.hpp" 1
# 46 "./boost/mpl/aux_/preprocessor/enum.hpp" 2
# 1 "./boost/preprocessor/repeat.hpp" 1
# 47 "./boost/mpl/aux_/preprocessor/enum.hpp" 2
# 28 "./boost/mpl/aux_/na_spec.hpp" 2
# 1 "./boost/mpl/aux_/preprocessor/def_params_tail.hpp" 1
# 17 "./boost/mpl/aux_/preprocessor/def_params_tail.hpp"
# 1 "./boost/mpl/limits/arity.hpp" 1
# 18 "./boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 1 "./boost/preprocessor/comma_if.hpp" 1
# 22 "./boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 1 "./boost/preprocessor/logical/and.hpp" 1
# 17 "./boost/preprocessor/logical/and.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 18 "./boost/preprocessor/logical/and.hpp" 2
# 1 "./boost/preprocessor/logical/bool.hpp" 1
# 19 "./boost/preprocessor/logical/and.hpp" 2
# 1 "./boost/preprocessor/logical/bitand.hpp" 1
# 15 "./boost/preprocessor/logical/bitand.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 16 "./boost/preprocessor/logical/bitand.hpp" 2
# 20 "./boost/preprocessor/logical/and.hpp" 2
# 23 "./boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 1 "./boost/preprocessor/identity.hpp" 1
# 15 "./boost/preprocessor/identity.hpp"
# 1 "./boost/preprocessor/facilities/identity.hpp" 1
# 18 "./boost/preprocessor/facilities/identity.hpp"
# 1 "./boost/preprocessor/facilities/empty.hpp" 1
# 19 "./boost/preprocessor/facilities/identity.hpp" 2
# 1 "./boost/preprocessor/tuple/eat.hpp" 1
# 20 "./boost/preprocessor/facilities/identity.hpp" 2
# 16 "./boost/preprocessor/identity.hpp" 2
# 24 "./boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 1 "./boost/preprocessor/empty.hpp" 1
# 15 "./boost/preprocessor/empty.hpp"
# 1 "./boost/preprocessor/facilities/empty.hpp" 1
# 16 "./boost/preprocessor/empty.hpp" 2
# 25 "./boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 66 "./boost/mpl/aux_/preprocessor/def_params_tail.hpp"
# 1 "./boost/preprocessor/arithmetic/add.hpp" 1
# 17 "./boost/preprocessor/arithmetic/add.hpp"
# 1 "./boost/preprocessor/arithmetic/dec.hpp" 1
# 17 "./boost/preprocessor/arithmetic/dec.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 18 "./boost/preprocessor/arithmetic/dec.hpp" 2
# 18 "./boost/preprocessor/arithmetic/add.hpp" 2
# 1 "./boost/preprocessor/arithmetic/inc.hpp" 1
# 19 "./boost/preprocessor/arithmetic/add.hpp" 2
# 1 "./boost/preprocessor/config/config.hpp" 1
# 20 "./boost/preprocessor/arithmetic/add.hpp" 2
# 1 "./boost/preprocessor/control/while.hpp" 1
# 17 "./boost/preprocessor/control/while.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 18 "./boost/preprocessor/control/while.hpp" 2
# 1 "./boost/preprocessor/config/config.hpp" 1
# 19 "./boost/preprocessor/control/while.hpp" 2
# 1 "./boost/preprocessor/debug/error.hpp" 1
# 20 "./boost/preprocessor/control/while.hpp" 2
# 1 "./boost/preprocessor/detail/auto_rec.hpp" 1
# 12 "./boost/preprocessor/detail/auto_rec.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 13 "./boost/preprocessor/detail/auto_rec.hpp" 2
# 21 "./boost/preprocessor/control/while.hpp" 2
# 1 "./boost/preprocessor/list/fold_left.hpp" 1
# 17 "./boost/preprocessor/list/fold_left.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 18 "./boost/preprocessor/list/fold_left.hpp" 2
# 1 "./boost/preprocessor/control/while.hpp" 1
# 19 "./boost/preprocessor/list/fold_left.hpp" 2
# 1 "./boost/preprocessor/debug/error.hpp" 1
# 20 "./boost/preprocessor/list/fold_left.hpp" 2
# 1 "./boost/preprocessor/detail/auto_rec.hpp" 1
# 12 "./boost/preprocessor/detail/auto_rec.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 13 "./boost/preprocessor/detail/auto_rec.hpp" 2
# 21 "./boost/preprocessor/list/fold_left.hpp" 2
# 41 "./boost/preprocessor/list/fold_left.hpp"
# 1 "./boost/preprocessor/list/detail/fold_left.hpp" 1
# 17 "./boost/preprocessor/list/detail/fold_left.hpp"
# 1 "./boost/preprocessor/control/expr_iif.hpp" 1
# 15 "./boost/preprocessor/control/expr_iif.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 16 "./boost/preprocessor/control/expr_iif.hpp" 2
# 18 "./boost/preprocessor/list/detail/fold_left.hpp" 2
# 1 "./boost/preprocessor/control/iif.hpp" 1
# 19 "./boost/preprocessor/list/detail/fold_left.hpp" 2
# 1 "./boost/preprocessor/list/adt.hpp" 1
# 17 "./boost/preprocessor/list/adt.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 18 "./boost/preprocessor/list/adt.hpp" 2
# 1 "./boost/preprocessor/detail/is_binary.hpp" 1
# 15 "./boost/preprocessor/detail/is_binary.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 16 "./boost/preprocessor/detail/is_binary.hpp" 2
# 1 "./boost/preprocessor/detail/check.hpp" 1
# 15 "./boost/preprocessor/detail/check.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 16 "./boost/preprocessor/detail/check.hpp" 2
# 1 "./boost/preprocessor/config/config.hpp" 1
# 17 "./boost/preprocessor/detail/check.hpp" 2
# 17 "./boost/preprocessor/detail/is_binary.hpp" 2
# 19 "./boost/preprocessor/list/adt.hpp" 2
# 1 "./boost/preprocessor/logical/compl.hpp" 1
# 15 "./boost/preprocessor/logical/compl.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 16 "./boost/preprocessor/logical/compl.hpp" 2
# 20 "./boost/preprocessor/list/adt.hpp" 2
# 1 "./boost/preprocessor/tuple/eat.hpp" 1
# 21 "./boost/preprocessor/list/adt.hpp" 2
# 20 "./boost/preprocessor/list/detail/fold_left.hpp" 2
# 1 "./boost/preprocessor/tuple/eat.hpp" 1
# 21 "./boost/preprocessor/list/detail/fold_left.hpp" 2
# 42 "./boost/preprocessor/list/fold_left.hpp" 2
# 22 "./boost/preprocessor/control/while.hpp" 2
# 1 "./boost/preprocessor/list/fold_right.hpp" 1
# 17 "./boost/preprocessor/list/fold_right.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 18 "./boost/preprocessor/list/fold_right.hpp" 2
# 1 "./boost/preprocessor/control/while.hpp" 1
# 19 "./boost/preprocessor/list/fold_right.hpp" 2
# 1 "./boost/preprocessor/debug/error.hpp" 1
# 20 "./boost/preprocessor/list/fold_right.hpp" 2
# 1 "./boost/preprocessor/detail/auto_rec.hpp" 1
# 12 "./boost/preprocessor/detail/auto_rec.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 13 "./boost/preprocessor/detail/auto_rec.hpp" 2
# 21 "./boost/preprocessor/list/fold_right.hpp" 2
# 37 "./boost/preprocessor/list/fold_right.hpp"
# 1 "./boost/preprocessor/list/detail/fold_right.hpp" 1
# 17 "./boost/preprocessor/list/detail/fold_right.hpp"
# 1 "./boost/preprocessor/list/fold_left.hpp" 1
# 18 "./boost/preprocessor/list/detail/fold_right.hpp" 2
# 1 "./boost/preprocessor/list/reverse.hpp" 1
# 17 "./boost/preprocessor/list/reverse.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 18 "./boost/preprocessor/list/reverse.hpp" 2
# 1 "./boost/preprocessor/list/fold_left.hpp" 1
# 19 "./boost/preprocessor/list/reverse.hpp" 2
# 19 "./boost/preprocessor/list/detail/fold_right.hpp" 2
# 38 "./boost/preprocessor/list/fold_right.hpp" 2
# 23 "./boost/preprocessor/control/while.hpp" 2
# 1 "./boost/preprocessor/logical/bitand.hpp" 1
# 24 "./boost/preprocessor/control/while.hpp" 2
# 48 "./boost/preprocessor/control/while.hpp"
# 1 "./boost/preprocessor/control/detail/while.hpp" 1
# 17 "./boost/preprocessor/control/detail/while.hpp"
# 1 "./boost/preprocessor/control/iif.hpp" 1
# 18 "./boost/preprocessor/control/detail/while.hpp" 2
# 1 "./boost/preprocessor/logical/bool.hpp" 1
# 19 "./boost/preprocessor/control/detail/while.hpp" 2
# 1 "./boost/preprocessor/tuple/eat.hpp" 1
# 20 "./boost/preprocessor/control/detail/while.hpp" 2
# 49 "./boost/preprocessor/control/while.hpp" 2
# 21 "./boost/preprocessor/arithmetic/add.hpp" 2
# 1 "./boost/preprocessor/tuple/elem.hpp" 1
# 18 "./boost/preprocessor/tuple/elem.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 19 "./boost/preprocessor/tuple/elem.hpp" 2
# 1 "./boost/preprocessor/config/config.hpp" 1
# 20 "./boost/preprocessor/tuple/elem.hpp" 2
# 1 "./boost/preprocessor/facilities/expand.hpp" 1
# 17 "./boost/preprocessor/facilities/expand.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 18 "./boost/preprocessor/facilities/expand.hpp" 2
# 21 "./boost/preprocessor/tuple/elem.hpp" 2
# 1 "./boost/preprocessor/facilities/overload.hpp" 1
# 16 "./boost/preprocessor/facilities/overload.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 17 "./boost/preprocessor/facilities/overload.hpp" 2
# 1 "./boost/preprocessor/variadic/size.hpp" 1
# 16 "./boost/preprocessor/variadic/size.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 17 "./boost/preprocessor/variadic/size.hpp" 2
# 1 "./boost/preprocessor/config/config.hpp" 1
# 18 "./boost/preprocessor/variadic/size.hpp" 2
# 18 "./boost/preprocessor/facilities/overload.hpp" 2
# 22 "./boost/preprocessor/tuple/elem.hpp" 2
# 1 "./boost/preprocessor/tuple/rem.hpp" 1
# 16 "./boost/preprocessor/tuple/rem.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 17 "./boost/preprocessor/tuple/rem.hpp" 2
# 1 "./boost/preprocessor/config/config.hpp" 1
# 18 "./boost/preprocessor/tuple/rem.hpp" 2
# 1 "./boost/preprocessor/facilities/expand.hpp" 1
# 19 "./boost/preprocessor/tuple/rem.hpp" 2
# 1 "./boost/preprocessor/facilities/overload.hpp" 1
# 20 "./boost/preprocessor/tuple/rem.hpp" 2
# 1 "./boost/preprocessor/tuple/detail/is_single_return.hpp" 1
# 15 "./boost/preprocessor/tuple/detail/is_single_return.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 16 "./boost/preprocessor/tuple/detail/is_single_return.hpp" 2
# 21 "./boost/preprocessor/tuple/rem.hpp" 2
# 23 "./boost/preprocessor/tuple/elem.hpp" 2
# 1 "./boost/preprocessor/variadic/elem.hpp" 1
# 16 "./boost/preprocessor/variadic/elem.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 17 "./boost/preprocessor/variadic/elem.hpp" 2
# 1 "./boost/preprocessor/config/config.hpp" 1
# 18 "./boost/preprocessor/variadic/elem.hpp" 2
# 24 "./boost/preprocessor/tuple/elem.hpp" 2
# 1 "./boost/preprocessor/tuple/detail/is_single_return.hpp" 1
# 25 "./boost/preprocessor/tuple/elem.hpp" 2
# 22 "./boost/preprocessor/arithmetic/add.hpp" 2
# 67 "./boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 1 "./boost/preprocessor/arithmetic/sub.hpp" 1
# 17 "./boost/preprocessor/arithmetic/sub.hpp"
# 1 "./boost/preprocessor/arithmetic/dec.hpp" 1
# 18 "./boost/preprocessor/arithmetic/sub.hpp" 2
# 1 "./boost/preprocessor/config/config.hpp" 1
# 19 "./boost/preprocessor/arithmetic/sub.hpp" 2
# 1 "./boost/preprocessor/control/while.hpp" 1
# 20 "./boost/preprocessor/arithmetic/sub.hpp" 2
# 1 "./boost/preprocessor/tuple/elem.hpp" 1
# 21 "./boost/preprocessor/arithmetic/sub.hpp" 2
# 68 "./boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 1 "./boost/preprocessor/inc.hpp" 1
# 69 "./boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 1 "./boost/preprocessor/tuple/elem.hpp" 1
# 70 "./boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 1 "./boost/preprocessor/repeat.hpp" 1
# 71 "./boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 1 "./boost/preprocessor/cat.hpp" 1
# 72 "./boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 29 "./boost/mpl/aux_/na_spec.hpp" 2
# 1 "./boost/mpl/aux_/config/overload_resolution.hpp" 1
# 36 "./boost/mpl/aux_/na_spec.hpp" 2
# 21 "./boost/mpl/has_xxx.hpp" 2
# 1 "./boost/mpl/aux_/type_wrapper.hpp" 1
# 20 "./boost/mpl/aux_/type_wrapper.hpp"
# 22 "./boost/mpl/has_xxx.hpp" 2
# 1 "./boost/mpl/aux_/yes_no.hpp" 1
# 18 "./boost/mpl/aux_/yes_no.hpp"
# 1 "./boost/mpl/aux_/config/arrays.hpp" 1
# 19 "./boost/mpl/aux_/yes_no.hpp" 2
# 56 "./boost/mpl/aux_/yes_no.hpp"
# 23 "./boost/mpl/has_xxx.hpp" 2
# 1 "./boost/mpl/aux_/config/has_xxx.hpp" 1
# 25 "./boost/mpl/has_xxx.hpp" 2
# 1 "./boost/mpl/aux_/config/msvc_typename.hpp" 1
# 26 "./boost/mpl/has_xxx.hpp" 2
# 1 "./boost/preprocessor/array/elem.hpp" 1
# 15 "./boost/preprocessor/array/elem.hpp"
# 1 "./boost/preprocessor/array/data.hpp" 1
# 15 "./boost/preprocessor/array/data.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 16 "./boost/preprocessor/array/data.hpp" 2
# 1 "./boost/preprocessor/tuple/elem.hpp" 1
# 17 "./boost/preprocessor/array/data.hpp" 2
# 16 "./boost/preprocessor/array/elem.hpp" 2
# 1 "./boost/preprocessor/array/size.hpp" 1
# 15 "./boost/preprocessor/array/size.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 16 "./boost/preprocessor/array/size.hpp" 2
# 1 "./boost/preprocessor/tuple/elem.hpp" 1
# 17 "./boost/preprocessor/array/size.hpp" 2
# 17 "./boost/preprocessor/array/elem.hpp" 2
# 1 "./boost/preprocessor/config/config.hpp" 1
# 18 "./boost/preprocessor/array/elem.hpp" 2
# 1 "./boost/preprocessor/tuple/elem.hpp" 1
# 19 "./boost/preprocessor/array/elem.hpp" 2
# 31 "./boost/mpl/has_xxx.hpp" 2
# 1 "./boost/preprocessor/cat.hpp" 1
# 32 "./boost/mpl/has_xxx.hpp" 2
# 1 "./boost/preprocessor/control/if.hpp" 1
# 33 "./boost/mpl/has_xxx.hpp" 2
# 1 "./boost/preprocessor/repetition/enum_params.hpp" 1
# 17 "./boost/preprocessor/repetition/enum_params.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 18 "./boost/preprocessor/repetition/enum_params.hpp" 2
# 1 "./boost/preprocessor/punctuation/comma_if.hpp" 1
# 19 "./boost/preprocessor/repetition/enum_params.hpp" 2
# 1 "./boost/preprocessor/repetition/repeat.hpp" 1
# 20 "./boost/preprocessor/repetition/enum_params.hpp" 2
# 34 "./boost/mpl/has_xxx.hpp" 2
# 1 "./boost/preprocessor/repetition/enum_trailing_params.hpp" 1
# 15 "./boost/preprocessor/repetition/enum_trailing_params.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 16 "./boost/preprocessor/repetition/enum_trailing_params.hpp" 2
# 1 "./boost/preprocessor/repetition/repeat.hpp" 1
# 17 "./boost/preprocessor/repetition/enum_trailing_params.hpp" 2
# 35 "./boost/mpl/has_xxx.hpp" 2
# 18 "./boost/mpl/aux_/has_apply.hpp" 2
# 1 "./boost/mpl/aux_/config/has_apply.hpp" 1
# 19 "./boost/mpl/aux_/has_apply.hpp" 2
# 24 "./boost/mpl/apply_wrap.hpp" 2
# 1 "./boost/mpl/aux_/msvc_never_true.hpp" 1
# 26 "./boost/mpl/apply_wrap.hpp" 2
# 1 "./boost/mpl/aux_/config/use_preprocessed.hpp" 1
# 29 "./boost/mpl/apply_wrap.hpp" 2
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 16 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/config/compiler.hpp" 1
# 17 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 17 "./boost/preprocessor/stringize.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 18 "./boost/preprocessor/stringize.hpp" 2
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 35 "./boost/mpl/apply_wrap.hpp" 2
# 23 "./boost/mpl/aux_/numeric_op.hpp" 2
# 1 "./boost/mpl/if.hpp" 1
# 20 "./boost/mpl/if.hpp"
# 1 "./boost/mpl/aux_/lambda_support.hpp" 1
# 21 "./boost/mpl/if.hpp" 2
# 131 "./boost/mpl/if.hpp"
# 24 "./boost/mpl/aux_/numeric_op.hpp" 2
# 1 "./boost/mpl/tag.hpp" 1
# 17 "./boost/mpl/tag.hpp"
# 1 "./boost/mpl/eval_if.hpp" 1
# 24 "./boost/mpl/eval_if.hpp"
# 18 "./boost/mpl/tag.hpp" 2
# 1 "./boost/mpl/void.hpp" 1
# 23 "./boost/mpl/void.hpp"
# 19 "./boost/mpl/tag.hpp" 2
# 1 "./boost/mpl/aux_/has_tag.hpp" 1
# 19 "./boost/mpl/aux_/has_tag.hpp"
# 20 "./boost/mpl/tag.hpp" 2
# 48 "./boost/mpl/tag.hpp"
# 25 "./boost/mpl/aux_/numeric_op.hpp" 2
# 1 "./boost/mpl/aux_/numeric_cast_utils.hpp" 1
# 18 "./boost/mpl/aux_/numeric_cast_utils.hpp"
# 1 "./boost/mpl/apply_wrap.hpp" 1
# 19 "./boost/mpl/aux_/numeric_cast_utils.hpp" 2
# 1 "./boost/mpl/aux_/config/forwarding.hpp" 1
# 20 "./boost/mpl/aux_/numeric_cast_utils.hpp" 2
# 46 "./boost/mpl/aux_/numeric_cast_utils.hpp"
# 72 "./boost/mpl/aux_/numeric_cast_utils.hpp"
# 26 "./boost/mpl/aux_/numeric_op.hpp" 2
# 1 "./boost/mpl/aux_/msvc_eti_base.hpp" 1
# 17 "./boost/mpl/aux_/msvc_eti_base.hpp"
# 1 "./boost/mpl/aux_/is_msvc_eti_arg.hpp" 1
# 21 "./boost/mpl/aux_/is_msvc_eti_arg.hpp"
# 62 "./boost/mpl/aux_/is_msvc_eti_arg.hpp"
# 18 "./boost/mpl/aux_/msvc_eti_base.hpp" 2
# 55 "./boost/mpl/aux_/msvc_eti_base.hpp"
# 30 "./boost/mpl/aux_/numeric_op.hpp" 2
# 28 "./boost/mpl/aux_/comparison_op.hpp" 2
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/less.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/less.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 36 "./boost/mpl/aux_/comparison_op.hpp" 2
# 20 "./boost/mpl/less.hpp" 2
# 18 "./boost/mpl/min_max.hpp" 2
# 18 "./boost/mpl/max.hpp" 2
# 11 "./boost/multiprecision/number.hpp" 2
# 1 "./boost/mpl/plus.hpp" 1
# 19 "./boost/mpl/plus.hpp"
# 1 "./boost/mpl/aux_/arithmetic_op.hpp" 1
# 17 "./boost/mpl/aux_/arithmetic_op.hpp"
# 1 "./boost/mpl/integral_c.hpp" 1
# 17 "./boost/mpl/integral_c.hpp"
# 1 "./boost/mpl/integral_c_fwd.hpp" 1
# 20 "./boost/mpl/integral_c_fwd.hpp"
# 18 "./boost/mpl/integral_c.hpp" 2
# 32 "./boost/mpl/integral_c.hpp"
# 1 "./boost/mpl/aux_/integral_wrapper.hpp" 1
# 22 "./boost/mpl/aux_/integral_wrapper.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 23 "./boost/mpl/aux_/integral_wrapper.hpp" 2
# 40 "./boost/mpl/aux_/integral_wrapper.hpp"
# 72 "./boost/mpl/aux_/integral_wrapper.hpp"
# 33 "./boost/mpl/integral_c.hpp" 2
# 18 "./boost/mpl/aux_/arithmetic_op.hpp" 2
# 1 "./boost/mpl/aux_/largest_int.hpp" 1
# 22 "./boost/mpl/aux_/largest_int.hpp"
# 19 "./boost/mpl/aux_/arithmetic_op.hpp" 2
# 1 "./boost/mpl/aux_/numeric_op.hpp" 1
# 22 "./boost/mpl/aux_/numeric_op.hpp"
# 1 "./boost/mpl/apply_wrap.hpp" 1
# 23 "./boost/mpl/aux_/numeric_op.hpp" 2
# 27 "./boost/mpl/aux_/arithmetic_op.hpp" 2
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/plus.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/plus.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 35 "./boost/mpl/aux_/arithmetic_op.hpp" 2
# 20 "./boost/mpl/plus.hpp" 2
# 12 "./boost/multiprecision/number.hpp" 2
# 1 "./boost/mpl/or.hpp" 1
# 23 "./boost/mpl/or.hpp"
# 1 "./boost/mpl/aux_/nested_type_wknd.hpp" 1
# 25 "./boost/mpl/aux_/nested_type_wknd.hpp"
# 24 "./boost/mpl/or.hpp" 2
# 43 "./boost/mpl/or.hpp"
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/or.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/or.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 44 "./boost/mpl/or.hpp" 2
# 13 "./boost/multiprecision/number.hpp" 2
# 1 "./boost/mpl/find_if.hpp" 1
# 17 "./boost/mpl/find_if.hpp"
# 1 "./boost/mpl/aux_/find_if_pred.hpp" 1
# 14 "./boost/mpl/aux_/find_if_pred.hpp"
# 1 "./boost/mpl/aux_/iter_apply.hpp" 1
# 17 "./boost/mpl/aux_/iter_apply.hpp"
# 1 "./boost/mpl/apply.hpp" 1
# 22 "./boost/mpl/apply.hpp"
# 1 "./boost/mpl/apply_fwd.hpp" 1
# 31 "./boost/mpl/apply_fwd.hpp"
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/apply_fwd.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/apply_fwd.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 32 "./boost/mpl/apply_fwd.hpp" 2
# 23 "./boost/mpl/apply.hpp" 2
# 1 "./boost/mpl/apply_wrap.hpp" 1
# 24 "./boost/mpl/apply.hpp" 2
# 1 "./boost/mpl/placeholders.hpp" 1
# 24 "./boost/mpl/placeholders.hpp"
# 1 "./boost/mpl/arg.hpp" 1
# 23 "./boost/mpl/arg.hpp"
# 1 "./boost/mpl/arg_fwd.hpp" 1
# 21 "./boost/mpl/arg_fwd.hpp"
# 24 "./boost/mpl/arg.hpp" 2
# 1 "./boost/mpl/aux_/na_assert.hpp" 1
# 23 "./boost/mpl/aux_/na_assert.hpp"
# 1 "./boost/mpl/assert.hpp" 1
# 17 "./boost/mpl/assert.hpp"
# 1 "./boost/mpl/not.hpp" 1
# 23 "./boost/mpl/not.hpp"
# 18 "./boost/mpl/assert.hpp" 2
# 28 "./boost/mpl/assert.hpp"
# 1 "./boost/mpl/aux_/config/gpu.hpp" 1
# 29 "./boost/mpl/assert.hpp" 2
# 1 "./boost/mpl/aux_/config/pp_counter.hpp" 1
# 31 "./boost/mpl/assert.hpp" 2
# 1 "./boost/preprocessor/cat.hpp" 1
# 34 "./boost/mpl/assert.hpp" 2
# 66 "./boost/mpl/assert.hpp"
# 79 "./boost/mpl/assert.hpp"
# 127 "./boost/mpl/assert.hpp"
# 171 "./boost/mpl/assert.hpp"
# 257 "./boost/mpl/assert.hpp"
# 24 "./boost/mpl/aux_/na_assert.hpp" 2
# 26 "./boost/mpl/arg.hpp" 2
# 1 "./boost/mpl/aux_/arity_spec.hpp" 1
# 27 "./boost/mpl/arg.hpp" 2
# 1 "./boost/mpl/aux_/arg_typedef.hpp" 1
# 28 "./boost/mpl/arg.hpp" 2
# 37 "./boost/mpl/arg.hpp"
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/arg.hpp" 1
# 13 "./boost/mpl/aux_/preprocessed/gcc/arg.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 38 "./boost/mpl/arg.hpp" 2
# 25 "./boost/mpl/placeholders.hpp" 2
# 43 "./boost/mpl/placeholders.hpp"
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/placeholders.hpp" 1
# 13 "./boost/mpl/aux_/preprocessed/gcc/placeholders.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 44 "./boost/mpl/placeholders.hpp" 2
# 25 "./boost/mpl/apply.hpp" 2
# 1 "./boost/mpl/lambda.hpp" 1
# 18 "./boost/mpl/lambda.hpp"
# 1 "./boost/mpl/bind.hpp" 1
# 23 "./boost/mpl/bind.hpp"
# 1 "./boost/mpl/bind_fwd.hpp" 1
# 25 "./boost/mpl/bind_fwd.hpp"
# 1 "./boost/mpl/aux_/config/bind.hpp" 1
# 26 "./boost/mpl/bind_fwd.hpp" 2
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/bind_fwd.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/bind_fwd.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 33 "./boost/mpl/bind_fwd.hpp" 2
# 24 "./boost/mpl/bind.hpp" 2
# 1 "./boost/mpl/placeholders.hpp" 1
# 25 "./boost/mpl/bind.hpp" 2
# 1 "./boost/mpl/next.hpp" 1
# 17 "./boost/mpl/next.hpp"
# 1 "./boost/mpl/next_prior.hpp" 1
# 17 "./boost/mpl/next_prior.hpp"
# 1 "./boost/mpl/aux_/common_name_wknd.hpp" 1
# 18 "./boost/mpl/next_prior.hpp" 2
# 18 "./boost/mpl/next.hpp" 2
# 26 "./boost/mpl/bind.hpp" 2
# 1 "./boost/mpl/protect.hpp" 1
# 23 "./boost/mpl/protect.hpp"
# 48 "./boost/mpl/protect.hpp"
# 27 "./boost/mpl/bind.hpp" 2
# 1 "./boost/mpl/apply_wrap.hpp" 1
# 28 "./boost/mpl/bind.hpp" 2
# 50 "./boost/mpl/bind.hpp"
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/bind.hpp" 1
# 13 "./boost/mpl/aux_/preprocessed/gcc/bind.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 51 "./boost/mpl/bind.hpp" 2
# 19 "./boost/mpl/lambda.hpp" 2
# 1 "./boost/mpl/aux_/full_lambda.hpp" 1
# 23 "./boost/mpl/aux_/full_lambda.hpp"
# 1 "./boost/mpl/bind_fwd.hpp" 1
# 24 "./boost/mpl/aux_/full_lambda.hpp" 2
# 1 "./boost/mpl/quote.hpp" 1
# 23 "./boost/mpl/quote.hpp"
# 1 "./boost/mpl/aux_/has_type.hpp" 1
# 19 "./boost/mpl/aux_/has_type.hpp"
# 24 "./boost/mpl/quote.hpp" 2
# 1 "./boost/mpl/aux_/config/bcc.hpp" 1
# 27 "./boost/mpl/quote.hpp" 2
# 45 "./boost/mpl/quote.hpp"
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/quote.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/quote.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 46 "./boost/mpl/quote.hpp" 2
# 26 "./boost/mpl/aux_/full_lambda.hpp" 2
# 1 "./boost/mpl/arg.hpp" 1
# 27 "./boost/mpl/aux_/full_lambda.hpp" 2
# 1 "./boost/mpl/aux_/template_arity.hpp" 1
# 43 "./boost/mpl/aux_/template_arity.hpp"
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/template_arity.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/template_arity.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 44 "./boost/mpl/aux_/template_arity.hpp" 2
# 30 "./boost/mpl/aux_/full_lambda.hpp" 2
# 44 "./boost/mpl/aux_/full_lambda.hpp"
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/full_lambda.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/full_lambda.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 45 "./boost/mpl/aux_/full_lambda.hpp" 2
# 23 "./boost/mpl/lambda.hpp" 2
# 26 "./boost/mpl/apply.hpp" 2
# 36 "./boost/mpl/apply.hpp"
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/apply.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/apply.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/apply.hpp" 2
# 18 "./boost/mpl/aux_/iter_apply.hpp" 2
# 1 "./boost/mpl/deref.hpp" 1
# 17 "./boost/mpl/deref.hpp"
# 1 "./boost/mpl/aux_/msvc_type.hpp" 1
# 20 "./boost/mpl/aux_/msvc_type.hpp"
# 48 "./boost/mpl/aux_/msvc_type.hpp"
# 18 "./boost/mpl/deref.hpp" 2
# 19 "./boost/mpl/aux_/iter_apply.hpp" 2
# 15 "./boost/mpl/aux_/find_if_pred.hpp" 2
# 18 "./boost/mpl/find_if.hpp" 2
# 1 "./boost/mpl/arg.hpp" 1
# 19 "./boost/mpl/find_if.hpp" 2
# 1 "./boost/mpl/iter_fold_if.hpp" 1
# 18 "./boost/mpl/iter_fold_if.hpp"
# 1 "./boost/mpl/begin_end.hpp" 1
# 17 "./boost/mpl/begin_end.hpp"
# 1 "./boost/mpl/begin_end_fwd.hpp" 1
# 17 "./boost/mpl/begin_end_fwd.hpp"
# 18 "./boost/mpl/begin_end.hpp" 2
# 1 "./boost/mpl/aux_/begin_end_impl.hpp" 1
# 18 "./boost/mpl/aux_/begin_end_impl.hpp"
# 1 "./boost/mpl/sequence_tag_fwd.hpp" 1
# 17 "./boost/mpl/sequence_tag_fwd.hpp"
# 19 "./boost/mpl/aux_/begin_end_impl.hpp" 2
# 1 "./boost/mpl/aux_/has_begin.hpp" 1
# 19 "./boost/mpl/aux_/has_begin.hpp"
# 22 "./boost/mpl/aux_/begin_end_impl.hpp" 2
# 1 "./boost/mpl/aux_/traits_lambda_spec.hpp" 1
# 24 "./boost/mpl/aux_/begin_end_impl.hpp" 2
# 82 "./boost/mpl/aux_/begin_end_impl.hpp"
# 19 "./boost/mpl/begin_end.hpp" 2
# 1 "./boost/mpl/sequence_tag.hpp" 1
# 26 "./boost/mpl/sequence_tag.hpp"
# 78 "./boost/mpl/sequence_tag.hpp"
# 98 "./boost/mpl/sequence_tag.hpp"
# 20 "./boost/mpl/begin_end.hpp" 2
# 19 "./boost/mpl/iter_fold_if.hpp" 2
# 1 "./boost/mpl/logical.hpp" 1
# 18 "./boost/mpl/logical.hpp"
# 1 "./boost/mpl/and.hpp" 1
# 42 "./boost/mpl/and.hpp"
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/and.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/and.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 43 "./boost/mpl/and.hpp" 2
# 19 "./boost/mpl/logical.hpp" 2
# 20 "./boost/mpl/iter_fold_if.hpp" 2
# 1 "./boost/mpl/always.hpp" 1
# 17 "./boost/mpl/always.hpp"
# 1 "./boost/mpl/aux_/preprocessor/default_params.hpp" 1
# 45 "./boost/mpl/aux_/preprocessor/default_params.hpp"
# 1 "./boost/preprocessor/tuple/elem.hpp" 1
# 46 "./boost/mpl/aux_/preprocessor/default_params.hpp" 2
# 1 "./boost/preprocessor/comma_if.hpp" 1
# 47 "./boost/mpl/aux_/preprocessor/default_params.hpp" 2
# 1 "./boost/preprocessor/repeat.hpp" 1
# 48 "./boost/mpl/aux_/preprocessor/default_params.hpp" 2
# 1 "./boost/preprocessor/inc.hpp" 1
# 49 "./boost/mpl/aux_/preprocessor/default_params.hpp" 2
# 1 "./boost/preprocessor/cat.hpp" 1
# 50 "./boost/mpl/aux_/preprocessor/default_params.hpp" 2
# 18 "./boost/mpl/always.hpp" 2
# 21 "./boost/mpl/iter_fold_if.hpp" 2
# 1 "./boost/mpl/pair.hpp" 1
# 22 "./boost/mpl/pair.hpp"
# 24 "./boost/mpl/iter_fold_if.hpp" 2
# 1 "./boost/mpl/apply.hpp" 1
# 25 "./boost/mpl/iter_fold_if.hpp" 2
# 1 "./boost/mpl/aux_/iter_fold_if_impl.hpp" 1
# 19 "./boost/mpl/aux_/iter_fold_if_impl.hpp"
# 1 "./boost/mpl/identity.hpp" 1
# 20 "./boost/mpl/identity.hpp"
# 20 "./boost/mpl/aux_/iter_fold_if_impl.hpp" 2
# 1 "./boost/mpl/apply.hpp" 1
# 23 "./boost/mpl/aux_/iter_fold_if_impl.hpp" 2
# 32 "./boost/mpl/aux_/iter_fold_if_impl.hpp"
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/iter_fold_if_impl.hpp" 1
# 13 "./boost/mpl/aux_/preprocessed/gcc/iter_fold_if_impl.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 33 "./boost/mpl/aux_/iter_fold_if_impl.hpp" 2
# 26 "./boost/mpl/iter_fold_if.hpp" 2
# 1 "./boost/type_traits/is_same.hpp" 1
# 24 "./boost/type_traits/is_same.hpp"
# 1 "./boost/type_traits/integral_constant.hpp" 1
# 31 "./boost/type_traits/integral_constant.hpp"
# 25 "./boost/type_traits/is_same.hpp" 2
# 32 "./boost/mpl/iter_fold_if.hpp" 2
# 20 "./boost/mpl/find_if.hpp" 2
# 14 "./boost/multiprecision/number.hpp" 2
# 1 "./boost/assert.hpp" 1
# 58 "./boost/assert.hpp"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 2 3 4
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 59 "./boost/assert.hpp" 2
# 15 "./boost/multiprecision/number.hpp" 2
# 1 "./boost/type_traits/remove_pointer.hpp" 1
# 20 "./boost/type_traits/remove_pointer.hpp"
# 68 "./boost/type_traits/remove_pointer.hpp"
# 16 "./boost/multiprecision/number.hpp" 2
# 1 "./boost/type_traits/is_signed.hpp" 1
# 13 "./boost/type_traits/is_signed.hpp"
# 1 "./boost/type_traits/is_integral.hpp" 1
# 15 "./boost/type_traits/is_integral.hpp"
# 67 "./boost/type_traits/is_integral.hpp"
# 14 "./boost/type_traits/is_signed.hpp" 2
# 1 "./boost/type_traits/remove_cv.hpp" 1
# 18 "./boost/type_traits/remove_cv.hpp"
# 15 "./boost/type_traits/is_signed.hpp" 2
# 1 "./boost/type_traits/is_enum.hpp" 1
# 14 "./boost/type_traits/is_enum.hpp"
# 1 "./boost/type_traits/intrinsics.hpp" 1
# 16 "./boost/type_traits/intrinsics.hpp"
# 1 "./boost/type_traits/detail/config.hpp" 1
# 15 "./boost/type_traits/detail/config.hpp"
# 1 "./boost/version.hpp" 1
# 16 "./boost/type_traits/detail/config.hpp" 2
# 17 "./boost/type_traits/intrinsics.hpp" 2
# 15 "./boost/type_traits/is_enum.hpp" 2
# 32 "./boost/type_traits/is_enum.hpp"
# 160 "./boost/type_traits/is_enum.hpp"
# 16 "./boost/type_traits/is_signed.hpp" 2
# 91 "./boost/type_traits/is_signed.hpp"
# 150 "./boost/type_traits/is_signed.hpp"
# 17 "./boost/multiprecision/number.hpp" 2
# 1 "./boost/type_traits/is_unsigned.hpp" 1
# 19 "./boost/type_traits/is_unsigned.hpp"
# 91 "./boost/type_traits/is_unsigned.hpp"
# 142 "./boost/type_traits/is_unsigned.hpp"
# 155 "./boost/type_traits/is_unsigned.hpp"
# 18 "./boost/multiprecision/number.hpp" 2
# 1 "./boost/type_traits/is_floating_point.hpp" 1
# 13 "./boost/type_traits/is_floating_point.hpp"
# 19 "./boost/multiprecision/number.hpp" 2
# 1 "./boost/type_traits/is_complex.hpp" 1
# 12 "./boost/type_traits/is_complex.hpp"
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/complex" 1 3
# 246 "/Library/Developer/CommandLineTools/usr/include/c++/v1/complex" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cmath" 1 3
# 305 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cmath" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/math.h" 1 3
# 299 "/Library/Developer/CommandLineTools/usr/include/c++/v1/math.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/math.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/math.h" 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/math.h" 3 4
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/math.h" 3 4
# 131 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/math.h" 3 4
# 174 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/math.h" 3 4
# 308 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/math.h" 3 4
# 551 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/math.h" 3 4
# 586 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/math.h" 3 4
# 603 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/math.h" 3 4
# 634 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/math.h" 3 4
# 740 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/math.h" 3 4
# 770 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/math.h" 3 4
# 302 "/Library/Developer/CommandLineTools/usr/include/c++/v1/math.h" 2 3
# 316 "/Library/Developer/CommandLineTools/usr/include/c++/v1/math.h" 3
# 378 "/Library/Developer/CommandLineTools/usr/include/c++/v1/math.h" 3
# 424 "/Library/Developer/CommandLineTools/usr/include/c++/v1/math.h" 3
# 306 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cmath" 2 3
# 309 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cmath" 3
# 247 "/Library/Developer/CommandLineTools/usr/include/c++/v1/complex" 2 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/sstream" 1 3
# 180 "/Library/Developer/CommandLineTools/usr/include/c++/v1/sstream" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 184 "/Library/Developer/CommandLineTools/usr/include/c++/v1/sstream" 2 3
# 248 "/Library/Developer/CommandLineTools/usr/include/c++/v1/complex" 2 3
# 251 "/Library/Developer/CommandLineTools/usr/include/c++/v1/complex" 3
# 13 "./boost/type_traits/is_complex.hpp" 2
# 21 "./boost/multiprecision/number.hpp" 2
# 1 "./boost/type_traits/make_unsigned.hpp" 1
# 12 "./boost/type_traits/make_unsigned.hpp"
# 1 "./boost/type_traits/conditional.hpp" 1
# 14 "./boost/type_traits/conditional.hpp"
# 13 "./boost/type_traits/make_unsigned.hpp" 2
# 1 "./boost/type_traits/is_const.hpp" 1
# 27 "./boost/type_traits/is_const.hpp"
# 36 "./boost/type_traits/is_const.hpp"
# 20 "./boost/type_traits/make_unsigned.hpp" 2
# 1 "./boost/type_traits/is_volatile.hpp" 1
# 27 "./boost/type_traits/is_volatile.hpp"
# 36 "./boost/type_traits/is_volatile.hpp"
# 21 "./boost/type_traits/make_unsigned.hpp" 2
# 1 "./boost/type_traits/add_const.hpp" 1
# 15 "./boost/type_traits/add_const.hpp"
# 30 "./boost/type_traits/add_const.hpp"
# 22 "./boost/type_traits/make_unsigned.hpp" 2
# 1 "./boost/type_traits/add_volatile.hpp" 1
# 15 "./boost/type_traits/add_volatile.hpp"
# 30 "./boost/type_traits/add_volatile.hpp"
# 23 "./boost/type_traits/make_unsigned.hpp" 2
# 1 "./boost/static_assert.hpp" 1
# 24 "./boost/type_traits/make_unsigned.hpp" 2
# 73 "./boost/type_traits/make_unsigned.hpp"
# 105 "./boost/type_traits/make_unsigned.hpp"
# 22 "./boost/multiprecision/number.hpp" 2
# 1 "./boost/throw_exception.hpp" 1
# 36 "./boost/throw_exception.hpp"
# 1 "./boost/exception/exception.hpp" 1
# 15 "./boost/exception/exception.hpp"
# 21 "./boost/exception/exception.hpp" 3
# 245 "./boost/exception/exception.hpp" 3
# 37 "./boost/throw_exception.hpp" 2
# 1 "./boost/current_function.hpp" 1
# 22 "./boost/current_function.hpp"
# 69 "./boost/current_function.hpp"
# 39 "./boost/throw_exception.hpp" 2
# 48 "./boost/throw_exception.hpp" 3
# 23 "./boost/multiprecision/number.hpp" 2
# 1 "./boost/multiprecision/detail/precision.hpp" 1
# 1 "./boost/multiprecision/traits/is_variable_precision.hpp" 1
# 10 "./boost/multiprecision/traits/is_variable_precision.hpp"
# 1 "./boost/multiprecision/detail/number_base.hpp" 1
# 10 "./boost/multiprecision/detail/number_base.hpp"
# 1 "./boost/utility/enable_if.hpp" 1
# 15 "./boost/utility/enable_if.hpp"
# 1 "./boost/core/enable_if.hpp" 1
# 24 "./boost/core/enable_if.hpp"
# 16 "./boost/utility/enable_if.hpp" 2
# 11 "./boost/multiprecision/detail/number_base.hpp" 2
# 1 "./boost/type_traits/is_convertible.hpp" 1
# 17 "./boost/type_traits/is_convertible.hpp"
# 1 "./boost/type_traits/is_complete.hpp" 1
# 12 "./boost/type_traits/is_complete.hpp"
# 1 "./boost/type_traits/declval.hpp" 1
# 15 "./boost/type_traits/declval.hpp"
# 1 "./boost/type_traits/add_rvalue_reference.hpp" 1
# 15 "./boost/type_traits/add_rvalue_reference.hpp"
# 1 "./boost/type_traits/is_void.hpp" 1
# 14 "./boost/type_traits/is_void.hpp"
# 16 "./boost/type_traits/add_rvalue_reference.hpp" 2
# 1 "./boost/type_traits/is_reference.hpp" 1
# 15 "./boost/type_traits/is_reference.hpp"
# 1 "./boost/type_traits/is_lvalue_reference.hpp" 1
# 26 "./boost/type_traits/is_lvalue_reference.hpp"
# 47 "./boost/type_traits/is_lvalue_reference.hpp"
# 16 "./boost/type_traits/is_reference.hpp" 2
# 1 "./boost/type_traits/is_rvalue_reference.hpp" 1
# 15 "./boost/type_traits/is_rvalue_reference.hpp"
# 17 "./boost/type_traits/is_reference.hpp" 2
# 17 "./boost/type_traits/add_rvalue_reference.hpp" 2
# 31 "./boost/type_traits/add_rvalue_reference.hpp"
# 16 "./boost/type_traits/declval.hpp" 2
# 37 "./boost/type_traits/declval.hpp"
# 13 "./boost/type_traits/is_complete.hpp" 2
# 1 "./boost/type_traits/remove_reference.hpp" 1
# 15 "./boost/type_traits/remove_reference.hpp"
# 53 "./boost/type_traits/remove_reference.hpp"
# 15 "./boost/type_traits/is_complete.hpp" 2
# 1 "./boost/type_traits/is_function.hpp" 1
# 19 "./boost/type_traits/is_function.hpp"
# 1 "./boost/type_traits/detail/is_function_cxx_11.hpp" 1
# 16 "./boost/type_traits/detail/is_function_cxx_11.hpp"
# 35 "./boost/type_traits/detail/is_function_cxx_11.hpp"
# 494 "./boost/type_traits/detail/is_function_cxx_11.hpp"
# 20 "./boost/type_traits/is_function.hpp" 2
# 16 "./boost/type_traits/is_complete.hpp" 2
# 1 "./boost/type_traits/detail/yes_no_type.hpp" 1
# 14 "./boost/type_traits/detail/yes_no_type.hpp"
# 17 "./boost/type_traits/is_complete.hpp" 2
# 31 "./boost/type_traits/is_complete.hpp"
# 41 "./boost/type_traits/is_complete.hpp"
# 90 "./boost/type_traits/is_complete.hpp"
# 18 "./boost/type_traits/is_convertible.hpp" 2
# 1 "./boost/type_traits/is_array.hpp" 1
# 20 "./boost/type_traits/is_array.hpp"
# 20 "./boost/type_traits/is_convertible.hpp" 2
# 45 "./boost/type_traits/is_convertible.hpp"
# 489 "./boost/type_traits/is_convertible.hpp"
# 12 "./boost/multiprecision/detail/number_base.hpp" 2
# 1 "./boost/type_traits/is_constructible.hpp" 1
# 17 "./boost/type_traits/is_constructible.hpp"
# 1 "./boost/type_traits/is_destructible.hpp" 1
# 23 "./boost/type_traits/is_destructible.hpp"
# 56 "./boost/type_traits/is_destructible.hpp"
# 18 "./boost/type_traits/is_constructible.hpp" 2
# 1 "./boost/type_traits/is_default_constructible.hpp" 1
# 29 "./boost/type_traits/is_default_constructible.hpp"
# 53 "./boost/type_traits/is_default_constructible.hpp"
# 96 "./boost/type_traits/is_default_constructible.hpp"
# 19 "./boost/type_traits/is_constructible.hpp" 2
# 88 "./boost/type_traits/is_constructible.hpp"
# 13 "./boost/multiprecision/detail/number_base.hpp" 2
# 1 "./boost/type_traits/decay.hpp" 1
# 14 "./boost/type_traits/decay.hpp"
# 1 "./boost/type_traits/remove_bounds.hpp" 1
# 12 "./boost/type_traits/remove_bounds.hpp"
# 1 "./boost/type_traits/remove_extent.hpp" 1
# 16 "./boost/type_traits/remove_extent.hpp"
# 13 "./boost/type_traits/remove_bounds.hpp" 2
# 15 "./boost/type_traits/decay.hpp" 2
# 1 "./boost/type_traits/add_pointer.hpp" 1
# 14 "./boost/type_traits/add_pointer.hpp"
# 50 "./boost/type_traits/add_pointer.hpp"
# 16 "./boost/type_traits/decay.hpp" 2
# 14 "./boost/multiprecision/detail/number_base.hpp" 2
# 1 "./boost/lexical_cast.hpp" 1
# 30 "./boost/lexical_cast.hpp"
# 1 "./boost/range/iterator_range_core.hpp" 1
# 25 "./boost/range/iterator_range_core.hpp"
# 1 "./boost/assert.hpp" 1
# 58 "./boost/assert.hpp"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 2 3 4
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 59 "./boost/assert.hpp" 2
# 26 "./boost/range/iterator_range_core.hpp" 2
# 1 "./boost/iterator/iterator_traits.hpp" 1
# 12 "./boost/iterator/iterator_traits.hpp"
# 27 "./boost/range/iterator_range_core.hpp" 2
# 1 "./boost/iterator/iterator_facade.hpp" 1
# 11 "./boost/iterator/iterator_facade.hpp"
# 1 "./boost/iterator/interoperable.hpp" 1
# 15 "./boost/iterator/interoperable.hpp"
# 1 "./boost/iterator/detail/config_def.hpp" 1
# 16 "./boost/iterator/interoperable.hpp" 2
# 34 "./boost/iterator/interoperable.hpp"
# 1 "./boost/iterator/detail/config_undef.hpp" 1
# 53 "./boost/iterator/interoperable.hpp" 2
# 12 "./boost/iterator/iterator_facade.hpp" 2
# 1 "./boost/iterator/iterator_categories.hpp" 1
# 10 "./boost/iterator/iterator_categories.hpp"
# 1 "./boost/iterator/detail/config_def.hpp" 1
# 11 "./boost/iterator/iterator_categories.hpp" 2
# 1 "./boost/mpl/placeholders.hpp" 1
# 17 "./boost/iterator/iterator_categories.hpp" 2
# 146 "./boost/iterator/iterator_categories.hpp"
# 194 "./boost/iterator/iterator_categories.hpp"
# 1 "./boost/iterator/detail/config_undef.hpp" 1
# 215 "./boost/iterator/iterator_categories.hpp" 2
# 14 "./boost/iterator/iterator_facade.hpp" 2
# 1 "./boost/iterator/detail/facade_iterator_category.hpp" 1
# 23 "./boost/iterator/detail/facade_iterator_category.hpp"
# 1 "./boost/iterator/detail/config_def.hpp" 1
# 24 "./boost/iterator/detail/facade_iterator_category.hpp" 2
# 1 "./boost/detail/indirect_traits.hpp" 1
# 10 "./boost/detail/indirect_traits.hpp"
# 1 "./boost/type_traits/is_pointer.hpp" 1
# 26 "./boost/type_traits/is_pointer.hpp"
# 45 "./boost/type_traits/is_pointer.hpp"
# 11 "./boost/detail/indirect_traits.hpp" 2
# 1 "./boost/type_traits/is_class.hpp" 1
# 31 "./boost/type_traits/is_class.hpp"
# 96 "./boost/type_traits/is_class.hpp"
# 12 "./boost/detail/indirect_traits.hpp" 2
# 1 "./boost/type_traits/is_member_function_pointer.hpp" 1
# 18 "./boost/type_traits/is_member_function_pointer.hpp"
# 1 "./boost/type_traits/detail/is_member_function_pointer_cxx_11.hpp" 1
# 16 "./boost/type_traits/detail/is_member_function_pointer_cxx_11.hpp"
# 25 "./boost/type_traits/detail/is_member_function_pointer_cxx_11.hpp"
# 47 "./boost/type_traits/detail/is_member_function_pointer_cxx_11.hpp"
# 555 "./boost/type_traits/detail/is_member_function_pointer_cxx_11.hpp"
# 19 "./boost/type_traits/is_member_function_pointer.hpp" 2
# 15 "./boost/detail/indirect_traits.hpp" 2
# 1 "./boost/type_traits/is_member_pointer.hpp" 1
# 27 "./boost/type_traits/is_member_pointer.hpp"
# 16 "./boost/detail/indirect_traits.hpp" 2
# 1 "./boost/detail/select_type.hpp" 1
# 16 "./boost/detail/select_type.hpp"
# 22 "./boost/detail/indirect_traits.hpp" 2
# 45 "./boost/detail/indirect_traits.hpp"
# 137 "./boost/detail/indirect_traits.hpp"
# 27 "./boost/iterator/detail/facade_iterator_category.hpp" 2
# 83 "./boost/iterator/detail/facade_iterator_category.hpp"
# 1 "./boost/iterator/detail/config_undef.hpp" 1
# 192 "./boost/iterator/detail/facade_iterator_category.hpp" 2
# 16 "./boost/iterator/iterator_facade.hpp" 2
# 1 "./boost/iterator/detail/enable_if.hpp" 1
# 13 "./boost/iterator/detail/enable_if.hpp"
# 1 "./boost/iterator/detail/config_def.hpp" 1
# 14 "./boost/iterator/detail/enable_if.hpp" 2
# 62 "./boost/iterator/detail/enable_if.hpp"
# 1 "./boost/iterator/detail/config_undef.hpp" 1
# 82 "./boost/iterator/detail/enable_if.hpp" 2
# 17 "./boost/iterator/iterator_facade.hpp" 2
# 1 "./boost/utility/addressof.hpp" 1
# 15 "./boost/utility/addressof.hpp"
# 1 "./boost/core/addressof.hpp" 1
# 34 "./boost/core/addressof.hpp"
# 266 "./boost/core/addressof.hpp"
# 16 "./boost/utility/addressof.hpp" 2
# 20 "./boost/iterator/iterator_facade.hpp" 2
# 1 "./boost/type_traits/add_lvalue_reference.hpp" 1
# 1 "./boost/type_traits/add_reference.hpp" 1
# 15 "./boost/type_traits/add_reference.hpp"
# 10 "./boost/type_traits/add_lvalue_reference.hpp" 2
# 25 "./boost/iterator/iterator_facade.hpp" 2
# 1 "./boost/type_traits/remove_const.hpp" 1
# 18 "./boost/type_traits/remove_const.hpp"
# 26 "./boost/iterator/iterator_facade.hpp" 2
# 1 "./boost/type_traits/is_pod.hpp" 1
# 15 "./boost/type_traits/is_pod.hpp"
# 1 "./boost/type_traits/is_scalar.hpp" 1
# 12 "./boost/type_traits/is_scalar.hpp"
# 1 "./boost/type_traits/is_arithmetic.hpp" 1
# 15 "./boost/type_traits/is_arithmetic.hpp"
# 13 "./boost/type_traits/is_scalar.hpp" 2
# 16 "./boost/type_traits/is_pod.hpp" 2
# 30 "./boost/type_traits/is_pod.hpp"
# 29 "./boost/iterator/iterator_facade.hpp" 2
# 1 "./boost/mpl/apply.hpp" 1
# 37 "./boost/iterator/iterator_facade.hpp" 2
# 1 "./boost/iterator/detail/config_def.hpp" 1
# 42 "./boost/iterator/iterator_facade.hpp" 2
# 145 "./boost/iterator/iterator_facade.hpp"
# 259 "./boost/iterator/iterator_facade.hpp"
# 284 "./boost/iterator/iterator_facade.hpp"
# 497 "./boost/iterator/iterator_facade.hpp"
# 900 "./boost/iterator/iterator_facade.hpp"
# 930 "./boost/iterator/iterator_facade.hpp"
# 955 "./boost/iterator/iterator_facade.hpp"
# 972 "./boost/iterator/iterator_facade.hpp"
# 1 "./boost/iterator/detail/config_undef.hpp" 1
# 980 "./boost/iterator/iterator_facade.hpp" 2
# 28 "./boost/range/iterator_range_core.hpp" 2
# 1 "./boost/type_traits/is_abstract.hpp" 1
# 63 "./boost/type_traits/is_abstract.hpp"
# 140 "./boost/type_traits/is_abstract.hpp"
# 32 "./boost/range/iterator_range_core.hpp" 2
# 1 "./boost/type_traits/is_base_and_derived.hpp" 1
# 24 "./boost/type_traits/is_base_and_derived.hpp"
# 220 "./boost/type_traits/is_base_and_derived.hpp"
# 34 "./boost/range/iterator_range_core.hpp" 2
# 1 "./boost/range/functions.hpp" 1
# 18 "./boost/range/functions.hpp"
# 1 "./boost/range/begin.hpp" 1
# 18 "./boost/range/begin.hpp"
# 1 "./boost/range/config.hpp" 1
# 19 "./boost/range/begin.hpp" 2
# 1 "./boost/range/iterator.hpp" 1
# 19 "./boost/range/iterator.hpp"
# 1 "./boost/range/range_fwd.hpp" 1
# 13 "./boost/range/range_fwd.hpp"
# 20 "./boost/range/iterator.hpp" 2
# 1 "./boost/range/mutable_iterator.hpp" 1
# 21 "./boost/range/mutable_iterator.hpp"
# 1 "./boost/range/detail/extract_optional_type.hpp" 1
# 18 "./boost/range/detail/extract_optional_type.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 19 "./boost/range/detail/extract_optional_type.hpp" 2
# 22 "./boost/range/mutable_iterator.hpp" 2
# 1 "./boost/range/detail/msvc_has_iterator_workaround.hpp" 1
# 78 "./boost/range/mutable_iterator.hpp" 2
# 21 "./boost/range/iterator.hpp" 2
# 1 "./boost/range/const_iterator.hpp" 1
# 27 "./boost/range/const_iterator.hpp"
# 22 "./boost/range/iterator.hpp" 2
# 60 "./boost/range/iterator.hpp"
# 25 "./boost/range/begin.hpp" 2
# 75 "./boost/range/begin.hpp"
# 19 "./boost/range/functions.hpp" 2
# 1 "./boost/range/end.hpp" 1
# 24 "./boost/range/end.hpp"
# 1 "./boost/range/detail/implementation_help.hpp" 1
# 15 "./boost/range/detail/implementation_help.hpp"
# 1 "./boost/range/detail/common.hpp" 1
# 19 "./boost/range/detail/common.hpp"
# 1 "./boost/range/detail/sfinae.hpp" 1
# 20 "./boost/range/detail/sfinae.hpp"
# 20 "./boost/range/detail/common.hpp" 2
# 29 "./boost/range/detail/common.hpp"
# 46 "./boost/range/detail/common.hpp"
# 16 "./boost/range/detail/implementation_help.hpp" 2
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/wchar.h" 1 3
# 22 "./boost/range/detail/implementation_help.hpp" 2
# 56 "./boost/range/detail/implementation_help.hpp"
# 25 "./boost/range/end.hpp" 2
# 20 "./boost/range/functions.hpp" 2
# 1 "./boost/range/size.hpp" 1
# 21 "./boost/range/size.hpp"
# 1 "./boost/range/size_type.hpp" 1
# 19 "./boost/range/size_type.hpp"
# 1 "./boost/range/difference_type.hpp" 1
# 21 "./boost/range/difference_type.hpp"
# 1 "./boost/range/has_range_iterator.hpp" 1
# 23 "./boost/range/has_range_iterator.hpp"
# 22 "./boost/range/difference_type.hpp" 2
# 20 "./boost/range/size_type.hpp" 2
# 1 "./boost/range/concepts.hpp" 1
# 19 "./boost/range/concepts.hpp"
# 1 "./boost/concept_check.hpp" 1
# 20 "./boost/concept_check.hpp"
# 1 "./boost/concept/assert.hpp" 1
# 35 "./boost/concept/assert.hpp"
# 1 "./boost/concept/detail/general.hpp" 1
# 1 "./boost/preprocessor/cat.hpp" 1
# 9 "./boost/concept/detail/general.hpp" 2
# 1 "./boost/concept/detail/backward_compatibility.hpp" 1
# 10 "./boost/concept/detail/general.hpp" 2
# 1 "./boost/concept/detail/has_constraints.hpp" 1
# 11 "./boost/concept/detail/has_constraints.hpp"
# 31 "./boost/concept/detail/has_constraints.hpp"
# 13 "./boost/concept/detail/general.hpp" 2
# 75 "./boost/concept/detail/general.hpp"
# 36 "./boost/concept/assert.hpp" 2
# 21 "./boost/concept_check.hpp" 2
# 1 "./boost/type_traits/conversion_traits.hpp" 1
# 24 "./boost/concept_check.hpp" 2
# 1 "./boost/concept/usage.hpp" 1
# 11 "./boost/concept/usage.hpp"
# 34 "./boost/concept/usage.hpp"
# 32 "./boost/concept_check.hpp" 2
# 1 "./boost/concept/detail/concept_def.hpp" 1
# 1 "./boost/preprocessor/seq/for_each_i.hpp" 1
# 15 "./boost/preprocessor/seq/for_each_i.hpp"
# 1 "./boost/preprocessor/arithmetic/dec.hpp" 1
# 16 "./boost/preprocessor/seq/for_each_i.hpp" 2
# 1 "./boost/preprocessor/arithmetic/inc.hpp" 1
# 17 "./boost/preprocessor/seq/for_each_i.hpp" 2
# 1 "./boost/preprocessor/config/config.hpp" 1
# 18 "./boost/preprocessor/seq/for_each_i.hpp" 2
# 1 "./boost/preprocessor/control/if.hpp" 1
# 19 "./boost/preprocessor/seq/for_each_i.hpp" 2
# 1 "./boost/preprocessor/control/iif.hpp" 1
# 20 "./boost/preprocessor/seq/for_each_i.hpp" 2
# 1 "./boost/preprocessor/repetition/for.hpp" 1
# 17 "./boost/preprocessor/repetition/for.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 18 "./boost/preprocessor/repetition/for.hpp" 2
# 1 "./boost/preprocessor/debug/error.hpp" 1
# 19 "./boost/preprocessor/repetition/for.hpp" 2
# 1 "./boost/preprocessor/facilities/empty.hpp" 1
# 20 "./boost/preprocessor/repetition/for.hpp" 2
# 1 "./boost/preprocessor/logical/bool.hpp" 1
# 21 "./boost/preprocessor/repetition/for.hpp" 2
# 1 "./boost/preprocessor/detail/auto_rec.hpp" 1
# 12 "./boost/preprocessor/detail/auto_rec.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 13 "./boost/preprocessor/detail/auto_rec.hpp" 2
# 22 "./boost/preprocessor/repetition/for.hpp" 2
# 44 "./boost/preprocessor/repetition/for.hpp"
# 1 "./boost/preprocessor/repetition/detail/for.hpp" 1
# 17 "./boost/preprocessor/repetition/detail/for.hpp"
# 1 "./boost/preprocessor/control/expr_iif.hpp" 1
# 18 "./boost/preprocessor/repetition/detail/for.hpp" 2
# 1 "./boost/preprocessor/control/iif.hpp" 1
# 19 "./boost/preprocessor/repetition/detail/for.hpp" 2
# 1 "./boost/preprocessor/logical/bool.hpp" 1
# 20 "./boost/preprocessor/repetition/detail/for.hpp" 2
# 1 "./boost/preprocessor/tuple/eat.hpp" 1
# 21 "./boost/preprocessor/repetition/detail/for.hpp" 2
# 45 "./boost/preprocessor/repetition/for.hpp" 2
# 21 "./boost/preprocessor/seq/for_each_i.hpp" 2
# 1 "./boost/preprocessor/seq/seq.hpp" 1
# 15 "./boost/preprocessor/seq/seq.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 16 "./boost/preprocessor/seq/seq.hpp" 2
# 1 "./boost/preprocessor/seq/elem.hpp" 1
# 15 "./boost/preprocessor/seq/elem.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 16 "./boost/preprocessor/seq/elem.hpp" 2
# 1 "./boost/preprocessor/config/config.hpp" 1
# 17 "./boost/preprocessor/seq/elem.hpp" 2
# 1 "./boost/preprocessor/facilities/empty.hpp" 1
# 18 "./boost/preprocessor/seq/elem.hpp" 2
# 17 "./boost/preprocessor/seq/seq.hpp" 2
# 22 "./boost/preprocessor/seq/for_each_i.hpp" 2
# 1 "./boost/preprocessor/seq/size.hpp" 1
# 15 "./boost/preprocessor/seq/size.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 16 "./boost/preprocessor/seq/size.hpp" 2
# 1 "./boost/preprocessor/config/config.hpp" 1
# 17 "./boost/preprocessor/seq/size.hpp" 2
# 23 "./boost/preprocessor/seq/for_each_i.hpp" 2
# 1 "./boost/preprocessor/seq/detail/is_empty.hpp" 1
# 15 "./boost/preprocessor/seq/detail/is_empty.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 16 "./boost/preprocessor/seq/detail/is_empty.hpp" 2
# 1 "./boost/preprocessor/arithmetic/dec.hpp" 1
# 17 "./boost/preprocessor/seq/detail/is_empty.hpp" 2
# 1 "./boost/preprocessor/logical/bool.hpp" 1
# 18 "./boost/preprocessor/seq/detail/is_empty.hpp" 2
# 1 "./boost/preprocessor/logical/compl.hpp" 1
# 19 "./boost/preprocessor/seq/detail/is_empty.hpp" 2
# 1 "./boost/preprocessor/seq/size.hpp" 1
# 20 "./boost/preprocessor/seq/detail/is_empty.hpp" 2
# 24 "./boost/preprocessor/seq/for_each_i.hpp" 2
# 1 "./boost/preprocessor/tuple/elem.hpp" 1
# 25 "./boost/preprocessor/seq/for_each_i.hpp" 2
# 1 "./boost/preprocessor/tuple/rem.hpp" 1
# 26 "./boost/preprocessor/seq/for_each_i.hpp" 2
# 7 "./boost/concept/detail/concept_def.hpp" 2
# 1 "./boost/preprocessor/seq/enum.hpp" 1
# 15 "./boost/preprocessor/seq/enum.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 16 "./boost/preprocessor/seq/enum.hpp" 2
# 1 "./boost/preprocessor/config/config.hpp" 1
# 17 "./boost/preprocessor/seq/enum.hpp" 2
# 1 "./boost/preprocessor/seq/size.hpp" 1
# 18 "./boost/preprocessor/seq/enum.hpp" 2
# 8 "./boost/concept/detail/concept_def.hpp" 2
# 1 "./boost/preprocessor/comma_if.hpp" 1
# 9 "./boost/concept/detail/concept_def.hpp" 2
# 1 "./boost/preprocessor/cat.hpp" 1
# 10 "./boost/concept/detail/concept_def.hpp" 2
# 33 "./boost/concept_check.hpp" 2
# 70 "./boost/concept_check.hpp"
# 225 "./boost/concept_check.hpp"
# 283 "./boost/concept_check.hpp"
# 1 "./boost/concept/detail/concept_undef.hpp" 1
# 1080 "./boost/concept_check.hpp" 2
# 20 "./boost/range/concepts.hpp" 2
# 1 "./boost/iterator/iterator_concepts.hpp" 1
# 23 "./boost/iterator/iterator_concepts.hpp"
# 1 "./boost/limits.hpp" 1
# 24 "./boost/iterator/iterator_concepts.hpp" 2
# 1 "./boost/concept/detail/concept_def.hpp" 1
# 30 "./boost/iterator/iterator_concepts.hpp" 2
# 1 "./boost/concept/detail/concept_undef.hpp" 1
# 272 "./boost/iterator/iterator_concepts.hpp" 2
# 21 "./boost/range/concepts.hpp" 2
# 1 "./boost/range/value_type.hpp" 1
# 23 "./boost/range/value_type.hpp"
# 25 "./boost/range/concepts.hpp" 2
# 1 "./boost/range/detail/misc_concept.hpp" 1
# 13 "./boost/range/detail/misc_concept.hpp"
# 26 "./boost/range/concepts.hpp" 2
# 62 "./boost/range/concepts.hpp"
# 124 "./boost/range/concepts.hpp"
# 21 "./boost/range/size_type.hpp" 2
# 22 "./boost/range/size.hpp" 2
# 1 "./boost/range/detail/has_member_size.hpp" 1
# 18 "./boost/range/detail/has_member_size.hpp"
# 1 "./boost/cstdint.hpp" 1
# 19 "./boost/range/detail/has_member_size.hpp" 2
# 23 "./boost/range/size.hpp" 2
# 1 "./boost/assert.hpp" 1
# 58 "./boost/assert.hpp"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 2 3 4
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 59 "./boost/assert.hpp" 2
# 24 "./boost/range/size.hpp" 2
# 1 "./boost/cstdint.hpp" 1
# 25 "./boost/range/size.hpp" 2
# 1 "./boost/utility.hpp" 1
# 15 "./boost/utility.hpp"
# 1 "./boost/utility/base_from_member.hpp" 1
# 14 "./boost/utility/base_from_member.hpp"
# 1 "./boost/preprocessor/arithmetic/inc.hpp" 1
# 15 "./boost/utility/base_from_member.hpp" 2
# 1 "./boost/preprocessor/repetition/enum_binary_params.hpp" 1
# 15 "./boost/preprocessor/repetition/enum_binary_params.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 16 "./boost/preprocessor/repetition/enum_binary_params.hpp" 2
# 1 "./boost/preprocessor/config/config.hpp" 1
# 17 "./boost/preprocessor/repetition/enum_binary_params.hpp" 2
# 1 "./boost/preprocessor/punctuation/comma_if.hpp" 1
# 18 "./boost/preprocessor/repetition/enum_binary_params.hpp" 2
# 1 "./boost/preprocessor/repetition/repeat.hpp" 1
# 19 "./boost/preprocessor/repetition/enum_binary_params.hpp" 2
# 1 "./boost/preprocessor/tuple/elem.hpp" 1
# 20 "./boost/preprocessor/repetition/enum_binary_params.hpp" 2
# 1 "./boost/preprocessor/tuple/rem.hpp" 1
# 21 "./boost/preprocessor/repetition/enum_binary_params.hpp" 2
# 16 "./boost/utility/base_from_member.hpp" 2
# 1 "./boost/preprocessor/repetition/enum_params.hpp" 1
# 17 "./boost/utility/base_from_member.hpp" 2
# 1 "./boost/preprocessor/repetition/repeat_from_to.hpp" 1
# 17 "./boost/preprocessor/repetition/repeat_from_to.hpp"
# 1 "./boost/preprocessor/arithmetic/add.hpp" 1
# 18 "./boost/preprocessor/repetition/repeat_from_to.hpp" 2
# 1 "./boost/preprocessor/arithmetic/sub.hpp" 1
# 19 "./boost/preprocessor/repetition/repeat_from_to.hpp" 2
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/preprocessor/repetition/repeat_from_to.hpp" 2
# 1 "./boost/preprocessor/config/config.hpp" 1
# 21 "./boost/preprocessor/repetition/repeat_from_to.hpp" 2
# 1 "./boost/preprocessor/control/while.hpp" 1
# 22 "./boost/preprocessor/repetition/repeat_from_to.hpp" 2
# 1 "./boost/preprocessor/debug/error.hpp" 1
# 23 "./boost/preprocessor/repetition/repeat_from_to.hpp" 2
# 1 "./boost/preprocessor/detail/auto_rec.hpp" 1
# 12 "./boost/preprocessor/detail/auto_rec.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 13 "./boost/preprocessor/detail/auto_rec.hpp" 2
# 24 "./boost/preprocessor/repetition/repeat_from_to.hpp" 2
# 1 "./boost/preprocessor/repetition/repeat.hpp" 1
# 25 "./boost/preprocessor/repetition/repeat_from_to.hpp" 2
# 1 "./boost/preprocessor/tuple/elem.hpp" 1
# 26 "./boost/preprocessor/repetition/repeat_from_to.hpp" 2
# 1 "./boost/preprocessor/tuple/rem.hpp" 1
# 27 "./boost/preprocessor/repetition/repeat_from_to.hpp" 2
# 18 "./boost/utility/base_from_member.hpp" 2
# 58 "./boost/utility/base_from_member.hpp"
# 72 "./boost/utility/base_from_member.hpp"
# 100 "./boost/utility/base_from_member.hpp"
# 123 "./boost/utility/base_from_member.hpp"
# 141 "./boost/utility/base_from_member.hpp"
# 16 "./boost/utility.hpp" 2
# 1 "./boost/utility/binary.hpp" 1
# 26 "./boost/utility/binary.hpp"
# 1 "./boost/preprocessor/control/deduce_d.hpp" 1
# 15 "./boost/preprocessor/control/deduce_d.hpp"
# 1 "./boost/preprocessor/control/while.hpp" 1
# 16 "./boost/preprocessor/control/deduce_d.hpp" 2
# 1 "./boost/preprocessor/detail/auto_rec.hpp" 1
# 12 "./boost/preprocessor/detail/auto_rec.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 13 "./boost/preprocessor/detail/auto_rec.hpp" 2
# 17 "./boost/preprocessor/control/deduce_d.hpp" 2
# 27 "./boost/utility/binary.hpp" 2
# 1 "./boost/preprocessor/facilities/identity.hpp" 1
# 28 "./boost/utility/binary.hpp" 2
# 1 "./boost/preprocessor/cat.hpp" 1
# 29 "./boost/utility/binary.hpp" 2
# 1 "./boost/preprocessor/seq/cat.hpp" 1
# 15 "./boost/preprocessor/seq/cat.hpp"
# 1 "./boost/preprocessor/arithmetic/dec.hpp" 1
# 16 "./boost/preprocessor/seq/cat.hpp" 2
# 1 "./boost/preprocessor/config/config.hpp" 1
# 17 "./boost/preprocessor/seq/cat.hpp" 2
# 1 "./boost/preprocessor/control/if.hpp" 1
# 18 "./boost/preprocessor/seq/cat.hpp" 2
# 1 "./boost/preprocessor/seq/fold_left.hpp" 1
# 15 "./boost/preprocessor/seq/fold_left.hpp"
# 1 "./boost/preprocessor/arithmetic/dec.hpp" 1
# 16 "./boost/preprocessor/seq/fold_left.hpp" 2
# 1 "./boost/preprocessor/cat.hpp" 1
# 17 "./boost/preprocessor/seq/fold_left.hpp" 2
# 1 "./boost/preprocessor/control/if.hpp" 1
# 18 "./boost/preprocessor/seq/fold_left.hpp" 2
# 1 "./boost/preprocessor/debug/error.hpp" 1
# 19 "./boost/preprocessor/seq/fold_left.hpp" 2
# 1 "./boost/preprocessor/detail/auto_rec.hpp" 1
# 12 "./boost/preprocessor/detail/auto_rec.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 13 "./boost/preprocessor/detail/auto_rec.hpp" 2
# 20 "./boost/preprocessor/seq/fold_left.hpp" 2
# 1 "./boost/preprocessor/seq/seq.hpp" 1
# 21 "./boost/preprocessor/seq/fold_left.hpp" 2
# 1 "./boost/preprocessor/seq/size.hpp" 1
# 22 "./boost/preprocessor/seq/fold_left.hpp" 2
# 19 "./boost/preprocessor/seq/cat.hpp" 2
# 1 "./boost/preprocessor/seq/seq.hpp" 1
# 20 "./boost/preprocessor/seq/cat.hpp" 2
# 1 "./boost/preprocessor/seq/size.hpp" 1
# 21 "./boost/preprocessor/seq/cat.hpp" 2
# 1 "./boost/preprocessor/tuple/eat.hpp" 1
# 22 "./boost/preprocessor/seq/cat.hpp" 2
# 30 "./boost/utility/binary.hpp" 2
# 1 "./boost/preprocessor/seq/transform.hpp" 1
# 15 "./boost/preprocessor/seq/transform.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 16 "./boost/preprocessor/seq/transform.hpp" 2
# 1 "./boost/preprocessor/seq/fold_left.hpp" 1
# 17 "./boost/preprocessor/seq/transform.hpp" 2
# 1 "./boost/preprocessor/seq/seq.hpp" 1
# 18 "./boost/preprocessor/seq/transform.hpp" 2
# 1 "./boost/preprocessor/tuple/elem.hpp" 1
# 19 "./boost/preprocessor/seq/transform.hpp" 2
# 1 "./boost/preprocessor/tuple/rem.hpp" 1
# 20 "./boost/preprocessor/seq/transform.hpp" 2
# 31 "./boost/utility/binary.hpp" 2
# 1 "./boost/preprocessor/arithmetic/mod.hpp" 1
# 17 "./boost/preprocessor/arithmetic/mod.hpp"
# 1 "./boost/preprocessor/arithmetic/detail/div_base.hpp" 1
# 17 "./boost/preprocessor/arithmetic/detail/div_base.hpp"
# 1 "./boost/preprocessor/arithmetic/inc.hpp" 1
# 18 "./boost/preprocessor/arithmetic/detail/div_base.hpp" 2
# 1 "./boost/preprocessor/arithmetic/sub.hpp" 1
# 19 "./boost/preprocessor/arithmetic/detail/div_base.hpp" 2
# 1 "./boost/preprocessor/comparison/less_equal.hpp" 1
# 17 "./boost/preprocessor/comparison/less_equal.hpp"
# 1 "./boost/preprocessor/arithmetic/sub.hpp" 1
# 18 "./boost/preprocessor/comparison/less_equal.hpp" 2
# 1 "./boost/preprocessor/config/config.hpp" 1
# 19 "./boost/preprocessor/comparison/less_equal.hpp" 2
# 1 "./boost/preprocessor/logical/not.hpp" 1
# 17 "./boost/preprocessor/logical/not.hpp"
# 1 "./boost/preprocessor/config/config.hpp" 1
# 18 "./boost/preprocessor/logical/not.hpp" 2
# 1 "./boost/preprocessor/logical/bool.hpp" 1
# 19 "./boost/preprocessor/logical/not.hpp" 2
# 1 "./boost/preprocessor/logical/compl.hpp" 1
# 20 "./boost/preprocessor/logical/not.hpp" 2
# 20 "./boost/preprocessor/comparison/less_equal.hpp" 2
# 20 "./boost/preprocessor/arithmetic/detail/div_base.hpp" 2
# 1 "./boost/preprocessor/config/config.hpp" 1
# 21 "./boost/preprocessor/arithmetic/detail/div_base.hpp" 2
# 1 "./boost/preprocessor/control/while.hpp" 1
# 22 "./boost/preprocessor/arithmetic/detail/div_base.hpp" 2
# 1 "./boost/preprocessor/tuple/elem.hpp" 1
# 23 "./boost/preprocessor/arithmetic/detail/div_base.hpp" 2
# 1 "./boost/preprocessor/tuple/rem.hpp" 1
# 24 "./boost/preprocessor/arithmetic/detail/div_base.hpp" 2
# 18 "./boost/preprocessor/arithmetic/mod.hpp" 2
# 1 "./boost/preprocessor/config/config.hpp" 1
# 19 "./boost/preprocessor/arithmetic/mod.hpp" 2
# 1 "./boost/preprocessor/tuple/elem.hpp" 1
# 20 "./boost/preprocessor/arithmetic/mod.hpp" 2
# 32 "./boost/utility/binary.hpp" 2
# 1 "./boost/preprocessor/seq/size.hpp" 1
# 33 "./boost/utility/binary.hpp" 2
# 1 "./boost/preprocessor/facilities/empty.hpp" 1
# 34 "./boost/utility/binary.hpp" 2
# 1 "./boost/preprocessor/control/while.hpp" 1
# 35 "./boost/utility/binary.hpp" 2
# 17 "./boost/utility.hpp" 2
# 1 "./boost/utility/identity_type.hpp" 1
# 16 "./boost/utility/identity_type.hpp"
# 1 "./boost/type_traits/function_traits.hpp" 1
# 16 "./boost/type_traits/function_traits.hpp"
# 17 "./boost/utility/identity_type.hpp" 2
# 18 "./boost/utility.hpp" 2
# 1 "./boost/core/checked_delete.hpp" 1
# 24 "./boost/core/checked_delete.hpp"
# 22 "./boost/utility.hpp" 2
# 1 "./boost/core/noncopyable.hpp" 1
# 14 "./boost/core/noncopyable.hpp"
# 34 "./boost/core/noncopyable.hpp"
# 23 "./boost/utility.hpp" 2
# 26 "./boost/range/size.hpp" 2
# 21 "./boost/range/functions.hpp" 2
# 1 "./boost/range/distance.hpp" 1
# 18 "./boost/range/distance.hpp"
# 1 "./boost/iterator/distance.hpp" 1
# 14 "./boost/iterator/distance.hpp"
# 19 "./boost/range/distance.hpp" 2
# 22 "./boost/range/functions.hpp" 2
# 1 "./boost/range/empty.hpp" 1
# 22 "./boost/range/empty.hpp"
# 23 "./boost/range/functions.hpp" 2
# 1 "./boost/range/rbegin.hpp" 1
# 19 "./boost/range/rbegin.hpp"
# 1 "./boost/range/reverse_iterator.hpp" 1
# 21 "./boost/range/reverse_iterator.hpp"
# 1 "./boost/iterator/reverse_iterator.hpp" 1
# 10 "./boost/iterator/reverse_iterator.hpp"
# 1 "./boost/iterator/iterator_adaptor.hpp" 1
# 28 "./boost/iterator/iterator_adaptor.hpp"
# 1 "./boost/iterator/detail/config_def.hpp" 1
# 29 "./boost/iterator/iterator_adaptor.hpp" 2
# 63 "./boost/iterator/iterator_adaptor.hpp"
# 130 "./boost/iterator/iterator_adaptor.hpp"
# 241 "./boost/iterator/iterator_adaptor.hpp"
# 1 "./boost/iterator/detail/config_undef.hpp" 1
# 357 "./boost/iterator/iterator_adaptor.hpp" 2
# 11 "./boost/iterator/reverse_iterator.hpp" 2
# 22 "./boost/range/reverse_iterator.hpp" 2
# 20 "./boost/range/rbegin.hpp" 2
# 35 "./boost/range/rbegin.hpp"
# 24 "./boost/range/functions.hpp" 2
# 1 "./boost/range/rend.hpp" 1
# 21 "./boost/range/rend.hpp"
# 35 "./boost/range/rend.hpp"
# 25 "./boost/range/functions.hpp" 2
# 39 "./boost/range/iterator_range_core.hpp" 2
# 1 "./boost/range/algorithm/equal.hpp" 1
# 17 "./boost/range/algorithm/equal.hpp"
# 171 "./boost/range/algorithm/equal.hpp"
# 43 "./boost/range/iterator_range_core.hpp" 2
# 1 "./boost/range/detail/safe_bool.hpp" 1
# 16 "./boost/range/detail/safe_bool.hpp"
# 56 "./boost/range/detail/safe_bool.hpp"
# 44 "./boost/range/iterator_range_core.hpp" 2
# 1 "./boost/next_prior.hpp" 1
# 21 "./boost/next_prior.hpp"
# 1 "./boost/type_traits/has_plus.hpp" 1
# 48 "./boost/type_traits/has_plus.hpp"
# 1 "./boost/type_traits/detail/has_binary_operator.hpp" 1
# 26 "./boost/type_traits/detail/has_binary_operator.hpp" 3
# 37 "./boost/type_traits/detail/has_binary_operator.hpp" 3
# 1 "./boost/type_traits/make_void.hpp" 1 3
# 15 "./boost/type_traits/make_void.hpp" 3
# 50 "./boost/type_traits/make_void.hpp" 3
# 38 "./boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 49 "./boost/type_traits/has_plus.hpp" 2
# 22 "./boost/next_prior.hpp" 2
# 1 "./boost/type_traits/has_plus_assign.hpp" 1
# 29 "./boost/type_traits/has_plus_assign.hpp" 3
# 52 "./boost/type_traits/has_plus_assign.hpp" 3
# 23 "./boost/next_prior.hpp" 2
# 1 "./boost/type_traits/has_minus.hpp" 1
# 29 "./boost/type_traits/has_minus.hpp" 3
# 48 "./boost/type_traits/has_minus.hpp" 3
# 24 "./boost/next_prior.hpp" 2
# 1 "./boost/type_traits/has_minus_assign.hpp" 1
# 29 "./boost/type_traits/has_minus_assign.hpp" 3
# 49 "./boost/type_traits/has_minus_assign.hpp" 3
# 25 "./boost/next_prior.hpp" 2
# 1 "./boost/iterator/advance.hpp" 1
# 13 "./boost/iterator/advance.hpp"
# 26 "./boost/next_prior.hpp" 2
# 40 "./boost/next_prior.hpp"
# 46 "./boost/range/iterator_range_core.hpp" 2
# 57 "./boost/range/iterator_range_core.hpp"
# 433 "./boost/range/iterator_range_core.hpp"
# 758 "./boost/range/iterator_range_core.hpp"
# 788 "./boost/range/iterator_range_core.hpp"
# 843 "./boost/range/iterator_range_core.hpp"
# 871 "./boost/range/iterator_range_core.hpp"
# 31 "./boost/lexical_cast.hpp" 2
# 1 "./boost/lexical_cast/bad_lexical_cast.hpp" 1
# 30 "./boost/lexical_cast/bad_lexical_cast.hpp"
# 32 "./boost/lexical_cast.hpp" 2
# 1 "./boost/lexical_cast/try_lexical_convert.hpp" 1
# 29 "./boost/lexical_cast/try_lexical_convert.hpp"
# 1 "./boost/type_traits/type_identity.hpp" 1
# 14 "./boost/type_traits/type_identity.hpp"
# 38 "./boost/lexical_cast/try_lexical_convert.hpp" 2
# 1 "./boost/lexical_cast/detail/is_character.hpp" 1
# 29 "./boost/lexical_cast/detail/is_character.hpp"
# 43 "./boost/lexical_cast/try_lexical_convert.hpp" 2
# 1 "./boost/lexical_cast/detail/converter_numeric.hpp" 1
# 33 "./boost/lexical_cast/detail/converter_numeric.hpp"
# 1 "./boost/type_traits/is_base_of.hpp" 1
# 16 "./boost/type_traits/is_base_of.hpp"
# 34 "./boost/lexical_cast/detail/converter_numeric.hpp" 2
# 1 "./boost/type_traits/is_float.hpp" 1
# 14 "./boost/type_traits/is_float.hpp"
# 35 "./boost/lexical_cast/detail/converter_numeric.hpp" 2
# 1 "./boost/numeric/conversion/cast.hpp" 1
# 32 "./boost/numeric/conversion/cast.hpp"
# 1 "./boost/type.hpp" 1
# 33 "./boost/numeric/conversion/cast.hpp" 2
# 1 "./boost/numeric/conversion/converter.hpp" 1
# 13 "./boost/numeric/conversion/converter.hpp"
# 1 "./boost/numeric/conversion/conversion_traits.hpp" 1
# 13 "./boost/numeric/conversion/conversion_traits.hpp"
# 1 "./boost/numeric/conversion/detail/conversion_traits.hpp" 1
# 17 "./boost/numeric/conversion/detail/conversion_traits.hpp"
# 1 "./boost/numeric/conversion/detail/meta.hpp" 1
# 17 "./boost/numeric/conversion/detail/meta.hpp"
# 1 "./boost/mpl/equal_to.hpp" 1
# 19 "./boost/mpl/equal_to.hpp"
# 1 "./boost/mpl/aux_/comparison_op.hpp" 1
# 27 "./boost/mpl/aux_/comparison_op.hpp"
# 1 "./boost/mpl/aux_/numeric_op.hpp" 1
# 22 "./boost/mpl/aux_/numeric_op.hpp"
# 1 "./boost/mpl/apply_wrap.hpp" 1
# 23 "./boost/mpl/aux_/numeric_op.hpp" 2
# 28 "./boost/mpl/aux_/comparison_op.hpp" 2
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/equal_to.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/equal_to.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 36 "./boost/mpl/aux_/comparison_op.hpp" 2
# 20 "./boost/mpl/equal_to.hpp" 2
# 18 "./boost/numeric/conversion/detail/meta.hpp" 2
# 48 "./boost/numeric/conversion/detail/meta.hpp"
# 59 "./boost/numeric/conversion/detail/meta.hpp"
# 97 "./boost/numeric/conversion/detail/meta.hpp"
# 18 "./boost/numeric/conversion/detail/conversion_traits.hpp" 2
# 1 "./boost/numeric/conversion/detail/int_float_mixture.hpp" 1
# 16 "./boost/numeric/conversion/detail/int_float_mixture.hpp"
# 1 "./boost/numeric/conversion/int_float_mixture_enum.hpp" 1
# 13 "./boost/numeric/conversion/int_float_mixture_enum.hpp"
# 17 "./boost/numeric/conversion/detail/int_float_mixture.hpp" 2
# 55 "./boost/numeric/conversion/detail/int_float_mixture.hpp"
# 19 "./boost/numeric/conversion/detail/conversion_traits.hpp" 2
# 1 "./boost/numeric/conversion/detail/sign_mixture.hpp" 1
# 16 "./boost/numeric/conversion/detail/sign_mixture.hpp"
# 1 "./boost/numeric/conversion/sign_mixture_enum.hpp" 1
# 13 "./boost/numeric/conversion/sign_mixture_enum.hpp"
# 17 "./boost/numeric/conversion/detail/sign_mixture.hpp" 2
# 55 "./boost/numeric/conversion/detail/sign_mixture.hpp"
# 20 "./boost/numeric/conversion/detail/conversion_traits.hpp" 2
# 1 "./boost/numeric/conversion/detail/udt_builtin_mixture.hpp" 1
# 15 "./boost/numeric/conversion/detail/udt_builtin_mixture.hpp"
# 1 "./boost/numeric/conversion/udt_builtin_mixture_enum.hpp" 1
# 13 "./boost/numeric/conversion/udt_builtin_mixture_enum.hpp"
# 16 "./boost/numeric/conversion/detail/udt_builtin_mixture.hpp" 2
# 37 "./boost/numeric/conversion/detail/udt_builtin_mixture.hpp"
# 21 "./boost/numeric/conversion/detail/conversion_traits.hpp" 2
# 1 "./boost/numeric/conversion/detail/is_subranged.hpp" 1
# 17 "./boost/numeric/conversion/detail/is_subranged.hpp"
# 1 "./boost/mpl/multiplies.hpp" 1
# 17 "./boost/mpl/multiplies.hpp"
# 1 "./boost/mpl/times.hpp" 1
# 19 "./boost/mpl/times.hpp"
# 1 "./boost/mpl/aux_/arithmetic_op.hpp" 1
# 26 "./boost/mpl/aux_/arithmetic_op.hpp"
# 1 "./boost/mpl/aux_/numeric_op.hpp" 1
# 22 "./boost/mpl/aux_/numeric_op.hpp"
# 1 "./boost/mpl/apply_wrap.hpp" 1
# 23 "./boost/mpl/aux_/numeric_op.hpp" 2
# 27 "./boost/mpl/aux_/arithmetic_op.hpp" 2
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/times.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/times.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 35 "./boost/mpl/aux_/arithmetic_op.hpp" 2
# 20 "./boost/mpl/times.hpp" 2
# 18 "./boost/mpl/multiplies.hpp" 2
# 18 "./boost/numeric/conversion/detail/is_subranged.hpp" 2
# 28 "./boost/numeric/conversion/detail/is_subranged.hpp"
# 62 "./boost/numeric/conversion/detail/is_subranged.hpp"
# 22 "./boost/numeric/conversion/detail/conversion_traits.hpp" 2
# 14 "./boost/numeric/conversion/conversion_traits.hpp" 2
# 14 "./boost/numeric/conversion/converter.hpp" 2
# 1 "./boost/numeric/conversion/converter_policies.hpp" 1
# 15 "./boost/numeric/conversion/converter_policies.hpp"
# 1 "./boost/config/no_tr1/cmath.hpp" 1
# 16 "./boost/numeric/conversion/converter_policies.hpp" 2
# 25 "./boost/numeric/conversion/converter_policies.hpp"
# 15 "./boost/numeric/conversion/converter.hpp" 2
# 1 "./boost/numeric/conversion/detail/converter.hpp" 1
# 17 "./boost/numeric/conversion/detail/converter.hpp"
# 1 "./boost/numeric/conversion/bounds.hpp" 1
# 13 "./boost/numeric/conversion/bounds.hpp"
# 1 "./boost/numeric/conversion/detail/bounds.hpp" 1
# 17 "./boost/numeric/conversion/detail/bounds.hpp"
# 14 "./boost/numeric/conversion/bounds.hpp" 2
# 18 "./boost/numeric/conversion/detail/converter.hpp" 2
# 40 "./boost/numeric/conversion/detail/converter.hpp"
# 81 "./boost/numeric/conversion/detail/converter.hpp"
# 96 "./boost/numeric/conversion/detail/converter.hpp"
# 215 "./boost/numeric/conversion/detail/converter.hpp"
# 262 "./boost/numeric/conversion/detail/converter.hpp"
# 279 "./boost/numeric/conversion/detail/converter.hpp"
# 305 "./boost/numeric/conversion/detail/converter.hpp"
# 452 "./boost/numeric/conversion/detail/converter.hpp"
# 528 "./boost/numeric/conversion/detail/converter.hpp"
# 574 "./boost/numeric/conversion/detail/converter.hpp"
# 17 "./boost/numeric/conversion/converter.hpp" 2
# 34 "./boost/numeric/conversion/cast.hpp" 2
# 1 "./boost/numeric/conversion/numeric_cast_traits.hpp" 1
# 14 "./boost/numeric/conversion/numeric_cast_traits.hpp"
# 1 "./boost/cstdint.hpp" 1
# 28 "./boost/numeric/conversion/numeric_cast_traits.hpp" 2
# 1 "./boost/numeric/conversion/detail/numeric_cast_traits.hpp" 1
# 12 "./boost/numeric/conversion/detail/numeric_cast_traits.hpp"
# 1 "./boost/numeric/conversion/detail/preprocessed/numeric_cast_traits_common.hpp" 1
# 12 "./boost/numeric/conversion/detail/preprocessed/numeric_cast_traits_common.hpp"
# 13 "./boost/numeric/conversion/detail/numeric_cast_traits.hpp" 2
# 1 "./boost/numeric/conversion/detail/preprocessed/numeric_cast_traits_long_long.hpp" 1
# 16 "./boost/numeric/conversion/detail/numeric_cast_traits.hpp" 2
# 29 "./boost/numeric/conversion/numeric_cast_traits.hpp" 2
# 35 "./boost/numeric/conversion/cast.hpp" 2
# 37 "./boost/lexical_cast/detail/converter_numeric.hpp" 2
# 152 "./boost/lexical_cast/detail/converter_numeric.hpp"
# 44 "./boost/lexical_cast/try_lexical_convert.hpp" 2
# 1 "./boost/lexical_cast/detail/converter_lexical.hpp" 1
# 38 "./boost/lexical_cast/detail/converter_lexical.hpp"
# 1 "./boost/type_traits/has_left_shift.hpp" 1
# 43 "./boost/type_traits/has_left_shift.hpp"
# 1 "./boost/type_traits/detail/has_binary_operator.hpp" 1
# 26 "./boost/type_traits/detail/has_binary_operator.hpp" 3
# 43 "./boost/type_traits/detail/has_binary_operator.hpp" 3
# 44 "./boost/type_traits/has_left_shift.hpp" 2
# 39 "./boost/lexical_cast/detail/converter_lexical.hpp" 2
# 1 "./boost/type_traits/has_right_shift.hpp" 1
# 43 "./boost/type_traits/has_right_shift.hpp"
# 1 "./boost/type_traits/detail/has_binary_operator.hpp" 1
# 26 "./boost/type_traits/detail/has_binary_operator.hpp" 3
# 43 "./boost/type_traits/detail/has_binary_operator.hpp" 3
# 44 "./boost/type_traits/has_right_shift.hpp" 2
# 40 "./boost/lexical_cast/detail/converter_lexical.hpp" 2
# 1 "./boost/detail/lcast_precision.hpp" 1
# 16 "./boost/detail/lcast_precision.hpp"
# 1 "./boost/integer_traits.hpp" 1
# 27 "./boost/integer_traits.hpp"
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/wchar.h" 1 3
# 28 "./boost/integer_traits.hpp" 2
# 40 "./boost/integer_traits.hpp" 3
# 121 "./boost/integer_traits.hpp" 3
# 251 "./boost/integer_traits.hpp" 3
# 17 "./boost/detail/lcast_precision.hpp" 2
# 36 "./boost/detail/lcast_precision.hpp"
# 166 "./boost/detail/lcast_precision.hpp"
# 42 "./boost/lexical_cast/detail/converter_lexical.hpp" 2
# 1 "./boost/lexical_cast/detail/widest_char.hpp" 1
# 29 "./boost/lexical_cast/detail/widest_char.hpp"
# 44 "./boost/lexical_cast/detail/converter_lexical.hpp" 2
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/array" 1 3
# 114 "/Library/Developer/CommandLineTools/usr/include/c++/v1/array" 3
# 48 "./boost/lexical_cast/detail/converter_lexical.hpp" 2
# 1 "./boost/array.hpp" 1
# 45 "./boost/array.hpp"
# 1 "./boost/assert.hpp" 1
# 58 "./boost/assert.hpp"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 2 3 4
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 59 "./boost/assert.hpp" 2
# 46 "./boost/array.hpp" 2
# 1 "./boost/swap.hpp" 1
# 15 "./boost/swap.hpp"
# 1 "./boost/core/swap.hpp" 1
# 30 "./boost/core/swap.hpp"
# 16 "./boost/swap.hpp" 2
# 48 "./boost/array.hpp" 2
# 1 "./boost/detail/iterator.hpp" 1
# 16 "./boost/detail/iterator.hpp"
# 35 "./boost/detail/iterator.hpp"
# 51 "./boost/array.hpp" 2
# 99 "./boost/array.hpp"
# 228 "./boost/array.hpp"
# 382 "./boost/array.hpp"
# 414 "./boost/array.hpp"
# 51 "./boost/lexical_cast/detail/converter_lexical.hpp" 2
# 1 "./boost/container/container_fwd.hpp" 1
# 61 "./boost/container/container_fwd.hpp"
# 1 "./boost/container/detail/std_fwd.hpp" 1
# 26 "./boost/container/detail/std_fwd.hpp"
# 1 "./boost/move/detail/std_ns_begin.hpp" 1
# 15 "./boost/move/detail/std_ns_begin.hpp"
# 27 "./boost/container/detail/std_fwd.hpp" 2
# 1 "./boost/move/detail/std_ns_end.hpp" 1
# 12 "./boost/move/detail/std_ns_end.hpp"
# 58 "./boost/container/detail/std_fwd.hpp" 2
# 62 "./boost/container/container_fwd.hpp" 2
# 88 "./boost/container/container_fwd.hpp"
# 53 "./boost/lexical_cast/detail/converter_lexical.hpp" 2
# 1 "./boost/lexical_cast/detail/converter_lexical_streams.hpp" 1
# 61 "./boost/lexical_cast/detail/converter_lexical_streams.hpp"
# 1 "./boost/lexical_cast/detail/lcast_char_constants.hpp" 1
# 26 "./boost/lexical_cast/detail/lcast_char_constants.hpp"
# 62 "./boost/lexical_cast/detail/converter_lexical_streams.hpp" 2
# 1 "./boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 1
# 53 "./boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
# 1 "./boost/noncopyable.hpp" 1
# 54 "./boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 2
# 239 "./boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
# 63 "./boost/lexical_cast/detail/converter_lexical_streams.hpp" 2
# 1 "./boost/lexical_cast/detail/inf_nan.hpp" 1
# 34 "./boost/lexical_cast/detail/inf_nan.hpp"
# 1 "./boost/math/special_functions/sign.hpp" 1
# 16 "./boost/math/special_functions/sign.hpp"
# 1 "./boost/math/tools/config.hpp" 1
# 14 "./boost/math/tools/config.hpp"
# 1 "./boost/predef.h" 1
# 13 "./boost/predef.h"
# 1 "./boost/predef/language.h" 1
# 13 "./boost/predef/language.h"
# 1 "./boost/predef/language/stdc.h" 1
# 11 "./boost/predef/language/stdc.h"
# 1 "./boost/predef/version_number.h" 1
# 12 "./boost/predef/language/stdc.h" 2
# 1 "./boost/predef/make.h" 1
# 1 "./boost/predef/detail/test.h" 1
# 8 "./boost/predef/make.h" 2
# 13 "./boost/predef/language/stdc.h" 2
# 14 "./boost/predef/language.h" 2
# 1 "./boost/predef/language/stdcpp.h" 1
# 12 "./boost/predef/language/stdcpp.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/language/stdcpp.h" 2
# 15 "./boost/predef/language.h" 2
# 1 "./boost/predef/language/objc.h" 1
# 12 "./boost/predef/language/objc.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/language/objc.h" 2
# 16 "./boost/predef/language.h" 2
# 1 "./boost/predef/language/cuda.h" 1
# 12 "./boost/predef/language/cuda.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/language/cuda.h" 2
# 17 "./boost/predef/language.h" 2
# 14 "./boost/predef.h" 2
# 1 "./boost/predef/architecture.h" 1
# 13 "./boost/predef/architecture.h"
# 1 "./boost/predef/architecture/alpha.h" 1
# 12 "./boost/predef/architecture/alpha.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/architecture/alpha.h" 2
# 14 "./boost/predef/architecture.h" 2
# 1 "./boost/predef/architecture/arm.h" 1
# 14 "./boost/predef/architecture/arm.h"
# 1 "./boost/predef/make.h" 1
# 15 "./boost/predef/architecture/arm.h" 2
# 15 "./boost/predef/architecture.h" 2
# 1 "./boost/predef/architecture/blackfin.h" 1
# 12 "./boost/predef/architecture/blackfin.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/architecture/blackfin.h" 2
# 16 "./boost/predef/architecture.h" 2
# 1 "./boost/predef/architecture/convex.h" 1
# 12 "./boost/predef/architecture/convex.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/architecture/convex.h" 2
# 17 "./boost/predef/architecture.h" 2
# 1 "./boost/predef/architecture/ia64.h" 1
# 12 "./boost/predef/architecture/ia64.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/architecture/ia64.h" 2
# 18 "./boost/predef/architecture.h" 2
# 1 "./boost/predef/architecture/m68k.h" 1
# 12 "./boost/predef/architecture/m68k.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/architecture/m68k.h" 2
# 19 "./boost/predef/architecture.h" 2
# 1 "./boost/predef/architecture/mips.h" 1
# 12 "./boost/predef/architecture/mips.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/architecture/mips.h" 2
# 20 "./boost/predef/architecture.h" 2
# 1 "./boost/predef/architecture/parisc.h" 1
# 12 "./boost/predef/architecture/parisc.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/architecture/parisc.h" 2
# 21 "./boost/predef/architecture.h" 2
# 1 "./boost/predef/architecture/ppc.h" 1
# 12 "./boost/predef/architecture/ppc.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/architecture/ppc.h" 2
# 22 "./boost/predef/architecture.h" 2
# 1 "./boost/predef/architecture/ptx.h" 1
# 12 "./boost/predef/architecture/ptx.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/architecture/ptx.h" 2
# 23 "./boost/predef/architecture.h" 2
# 1 "./boost/predef/architecture/pyramid.h" 1
# 12 "./boost/predef/architecture/pyramid.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/architecture/pyramid.h" 2
# 24 "./boost/predef/architecture.h" 2
# 1 "./boost/predef/architecture/rs6k.h" 1
# 12 "./boost/predef/architecture/rs6k.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/architecture/rs6k.h" 2
# 25 "./boost/predef/architecture.h" 2
# 1 "./boost/predef/architecture/sparc.h" 1
# 12 "./boost/predef/architecture/sparc.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/architecture/sparc.h" 2
# 26 "./boost/predef/architecture.h" 2
# 1 "./boost/predef/architecture/superh.h" 1
# 12 "./boost/predef/architecture/superh.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/architecture/superh.h" 2
# 27 "./boost/predef/architecture.h" 2
# 1 "./boost/predef/architecture/sys370.h" 1
# 12 "./boost/predef/architecture/sys370.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/architecture/sys370.h" 2
# 28 "./boost/predef/architecture.h" 2
# 1 "./boost/predef/architecture/sys390.h" 1
# 12 "./boost/predef/architecture/sys390.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/architecture/sys390.h" 2
# 29 "./boost/predef/architecture.h" 2
# 1 "./boost/predef/architecture/x86.h" 1
# 1 "./boost/predef/architecture/x86/32.h" 1
# 12 "./boost/predef/architecture/x86/32.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/architecture/x86/32.h" 2
# 82 "./boost/predef/architecture/x86/32.h"
# 1 "./boost/predef/architecture/x86.h" 1
# 1 "./boost/predef/architecture/x86/32.h" 1
# 9 "./boost/predef/architecture/x86.h" 2
# 1 "./boost/predef/architecture/x86/64.h" 1
# 12 "./boost/predef/architecture/x86/64.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/architecture/x86/64.h" 2
# 45 "./boost/predef/architecture/x86/64.h"
# 1 "./boost/predef/architecture/x86.h" 1
# 1 "./boost/predef/architecture/x86/32.h" 1
# 9 "./boost/predef/architecture/x86.h" 2
# 1 "./boost/predef/architecture/x86/64.h" 1
# 10 "./boost/predef/architecture/x86.h" 2
# 46 "./boost/predef/architecture/x86/64.h" 2
# 10 "./boost/predef/architecture/x86.h" 2
# 83 "./boost/predef/architecture/x86/32.h" 2
# 9 "./boost/predef/architecture/x86.h" 2
# 1 "./boost/predef/architecture/x86/64.h" 1
# 10 "./boost/predef/architecture/x86.h" 2
# 30 "./boost/predef/architecture.h" 2
# 1 "./boost/predef/architecture/z.h" 1
# 12 "./boost/predef/architecture/z.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/architecture/z.h" 2
# 31 "./boost/predef/architecture.h" 2
# 15 "./boost/predef.h" 2
# 1 "./boost/predef/compiler.h" 1
# 13 "./boost/predef/compiler.h"
# 1 "./boost/predef/compiler/borland.h" 1
# 12 "./boost/predef/compiler/borland.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/borland.h" 2
# 14 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/clang.h" 1
# 12 "./boost/predef/compiler/clang.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/clang.h" 2
# 43 "./boost/predef/compiler/clang.h"
# 1 "./boost/predef/detail/comp_detected.h" 1
# 44 "./boost/predef/compiler/clang.h" 2
# 15 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/comeau.h" 1
# 12 "./boost/predef/compiler/comeau.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/comeau.h" 2
# 16 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/compaq.h" 1
# 12 "./boost/predef/compiler/compaq.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/compaq.h" 2
# 17 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/diab.h" 1
# 12 "./boost/predef/compiler/diab.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/diab.h" 2
# 18 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/digitalmars.h" 1
# 12 "./boost/predef/compiler/digitalmars.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/digitalmars.h" 2
# 19 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/dignus.h" 1
# 12 "./boost/predef/compiler/dignus.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/dignus.h" 2
# 20 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/edg.h" 1
# 12 "./boost/predef/compiler/edg.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/edg.h" 2
# 21 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/ekopath.h" 1
# 12 "./boost/predef/compiler/ekopath.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/ekopath.h" 2
# 22 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/gcc_xml.h" 1
# 12 "./boost/predef/compiler/gcc_xml.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/gcc_xml.h" 2
# 23 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/gcc.h" 1
# 13 "./boost/predef/compiler/gcc.h"
# 1 "./boost/predef/compiler/clang.h" 1
# 14 "./boost/predef/compiler/gcc.h" 2
# 1 "./boost/predef/make.h" 1
# 17 "./boost/predef/compiler/gcc.h" 2
# 24 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/greenhills.h" 1
# 12 "./boost/predef/compiler/greenhills.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/greenhills.h" 2
# 25 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/hp_acc.h" 1
# 12 "./boost/predef/compiler/hp_acc.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/hp_acc.h" 2
# 26 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/iar.h" 1
# 12 "./boost/predef/compiler/iar.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/iar.h" 2
# 27 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/ibm.h" 1
# 12 "./boost/predef/compiler/ibm.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/ibm.h" 2
# 28 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/intel.h" 1
# 12 "./boost/predef/compiler/intel.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/intel.h" 2
# 29 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/kai.h" 1
# 12 "./boost/predef/compiler/kai.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/kai.h" 2
# 30 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/llvm.h" 1
# 13 "./boost/predef/compiler/llvm.h"
# 1 "./boost/predef/compiler/clang.h" 1
# 14 "./boost/predef/compiler/llvm.h" 2
# 1 "./boost/predef/make.h" 1
# 17 "./boost/predef/compiler/llvm.h" 2
# 31 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/metaware.h" 1
# 12 "./boost/predef/compiler/metaware.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/metaware.h" 2
# 32 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/metrowerks.h" 1
# 12 "./boost/predef/compiler/metrowerks.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/metrowerks.h" 2
# 33 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/microtec.h" 1
# 12 "./boost/predef/compiler/microtec.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/microtec.h" 2
# 34 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/mpw.h" 1
# 12 "./boost/predef/compiler/mpw.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/mpw.h" 2
# 35 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/nvcc.h" 1
# 12 "./boost/predef/compiler/nvcc.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/nvcc.h" 2
# 36 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/palm.h" 1
# 12 "./boost/predef/compiler/palm.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/palm.h" 2
# 37 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/pgi.h" 1
# 12 "./boost/predef/compiler/pgi.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/pgi.h" 2
# 38 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/sgi_mipspro.h" 1
# 12 "./boost/predef/compiler/sgi_mipspro.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/sgi_mipspro.h" 2
# 39 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/sunpro.h" 1
# 12 "./boost/predef/compiler/sunpro.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/sunpro.h" 2
# 40 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/tendra.h" 1
# 12 "./boost/predef/compiler/tendra.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/tendra.h" 2
# 41 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/visualc.h" 1
# 13 "./boost/predef/compiler/visualc.h"
# 1 "./boost/predef/compiler/clang.h" 1
# 14 "./boost/predef/compiler/visualc.h" 2
# 1 "./boost/predef/make.h" 1
# 17 "./boost/predef/compiler/visualc.h" 2
# 42 "./boost/predef/compiler.h" 2
# 1 "./boost/predef/compiler/watcom.h" 1
# 12 "./boost/predef/compiler/watcom.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/compiler/watcom.h" 2
# 43 "./boost/predef/compiler.h" 2
# 16 "./boost/predef.h" 2
# 1 "./boost/predef/library.h" 1
# 13 "./boost/predef/library.h"
# 1 "./boost/predef/library/c.h" 1
# 13 "./boost/predef/library/c.h"
# 1 "./boost/predef/library/c/_prefix.h" 1
# 11 "./boost/predef/library/c/_prefix.h"
# 1 "./boost/predef/detail/_cassert.h" 1
# 12 "./boost/predef/detail/_cassert.h"
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cassert" 1 3
# 21 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 2 3 4
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 22 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cassert" 2 3
# 25 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cassert" 3
# 13 "./boost/predef/detail/_cassert.h" 2
# 12 "./boost/predef/library/c/_prefix.h" 2
# 14 "./boost/predef/library/c.h" 2
# 1 "./boost/predef/library/c/cloudabi.h" 1
# 13 "./boost/predef/library/c/cloudabi.h"
# 1 "./boost/predef/make.h" 1
# 14 "./boost/predef/library/c/cloudabi.h" 2
# 16 "./boost/predef/library/c.h" 2
# 1 "./boost/predef/library/c/gnu.h" 1
# 12 "./boost/predef/library/c/gnu.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/library/c/gnu.h" 2
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stddef.h" 1 3
# 44 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stddef.h" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/stddef.h" 1 3 4
# 47 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stddef.h" 2 3
# 18 "./boost/predef/library/c/gnu.h" 2
# 17 "./boost/predef/library/c.h" 2
# 1 "./boost/predef/library/c/uc.h" 1
# 14 "./boost/predef/library/c/uc.h"
# 1 "./boost/predef/make.h" 1
# 15 "./boost/predef/library/c/uc.h" 2
# 18 "./boost/predef/library/c.h" 2
# 1 "./boost/predef/library/c/vms.h" 1
# 14 "./boost/predef/library/c/vms.h"
# 1 "./boost/predef/make.h" 1
# 15 "./boost/predef/library/c/vms.h" 2
# 19 "./boost/predef/library/c.h" 2
# 1 "./boost/predef/library/c/zos.h" 1
# 14 "./boost/predef/library/c/zos.h"
# 1 "./boost/predef/make.h" 1
# 15 "./boost/predef/library/c/zos.h" 2
# 20 "./boost/predef/library/c.h" 2
# 14 "./boost/predef/library.h" 2
# 1 "./boost/predef/library/std.h" 1
# 12 "./boost/predef/library/std.h"
# 1 "./boost/predef/library/std/_prefix.h" 1
# 21 "./boost/predef/library/std/_prefix.h"
# 1 "./boost/predef/detail/_exception.h" 1
# 22 "./boost/predef/library/std/_prefix.h" 2
# 13 "./boost/predef/library/std.h" 2
# 1 "./boost/predef/library/std/cxx.h" 1
# 14 "./boost/predef/library/std/cxx.h"
# 1 "./boost/predef/make.h" 1
# 15 "./boost/predef/library/std/cxx.h" 2
# 15 "./boost/predef/library/std.h" 2
# 1 "./boost/predef/library/std/dinkumware.h" 1
# 14 "./boost/predef/library/std/dinkumware.h"
# 1 "./boost/predef/make.h" 1
# 15 "./boost/predef/library/std/dinkumware.h" 2
# 16 "./boost/predef/library/std.h" 2
# 1 "./boost/predef/library/std/libcomo.h" 1
# 14 "./boost/predef/library/std/libcomo.h"
# 1 "./boost/predef/make.h" 1
# 15 "./boost/predef/library/std/libcomo.h" 2
# 17 "./boost/predef/library/std.h" 2
# 1 "./boost/predef/library/std/modena.h" 1
# 14 "./boost/predef/library/std/modena.h"
# 1 "./boost/predef/make.h" 1
# 15 "./boost/predef/library/std/modena.h" 2
# 18 "./boost/predef/library/std.h" 2
# 1 "./boost/predef/library/std/msl.h" 1
# 14 "./boost/predef/library/std/msl.h"
# 1 "./boost/predef/make.h" 1
# 15 "./boost/predef/library/std/msl.h" 2
# 19 "./boost/predef/library/std.h" 2
# 1 "./boost/predef/library/std/roguewave.h" 1
# 14 "./boost/predef/library/std/roguewave.h"
# 1 "./boost/predef/make.h" 1
# 15 "./boost/predef/library/std/roguewave.h" 2
# 20 "./boost/predef/library/std.h" 2
# 1 "./boost/predef/library/std/sgi.h" 1
# 14 "./boost/predef/library/std/sgi.h"
# 1 "./boost/predef/make.h" 1
# 15 "./boost/predef/library/std/sgi.h" 2
# 21 "./boost/predef/library/std.h" 2
# 1 "./boost/predef/library/std/stdcpp3.h" 1
# 14 "./boost/predef/library/std/stdcpp3.h"
# 1 "./boost/predef/make.h" 1
# 15 "./boost/predef/library/std/stdcpp3.h" 2
# 22 "./boost/predef/library/std.h" 2
# 1 "./boost/predef/library/std/stlport.h" 1
# 14 "./boost/predef/library/std/stlport.h"
# 1 "./boost/predef/make.h" 1
# 15 "./boost/predef/library/std/stlport.h" 2
# 23 "./boost/predef/library/std.h" 2
# 1 "./boost/predef/library/std/vacpp.h" 1
# 14 "./boost/predef/library/std/vacpp.h"
# 1 "./boost/predef/make.h" 1
# 15 "./boost/predef/library/std/vacpp.h" 2
# 24 "./boost/predef/library/std.h" 2
# 15 "./boost/predef/library.h" 2
# 17 "./boost/predef.h" 2
# 1 "./boost/predef/os.h" 1
# 14 "./boost/predef/os.h"
# 1 "./boost/predef/os/aix.h" 1
# 12 "./boost/predef/os/aix.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/os/aix.h" 2
# 15 "./boost/predef/os.h" 2
# 1 "./boost/predef/os/amigaos.h" 1
# 12 "./boost/predef/os/amigaos.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/os/amigaos.h" 2
# 16 "./boost/predef/os.h" 2
# 1 "./boost/predef/os/android.h" 1
# 12 "./boost/predef/os/android.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/os/android.h" 2
# 17 "./boost/predef/os.h" 2
# 1 "./boost/predef/os/beos.h" 1
# 12 "./boost/predef/os/beos.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/os/beos.h" 2
# 18 "./boost/predef/os.h" 2
# 1 "./boost/predef/os/bsd.h" 1
# 16 "./boost/predef/os/bsd.h"
# 1 "./boost/predef/os/macos.h" 1
# 17 "./boost/predef/os/macos.h"
# 1 "./boost/predef/os/ios.h" 1
# 13 "./boost/predef/os/ios.h"
# 1 "./boost/predef/make.h" 1
# 14 "./boost/predef/os/ios.h" 2
# 18 "./boost/predef/os/macos.h" 2
# 1 "./boost/predef/make.h" 1
# 21 "./boost/predef/os/macos.h" 2
# 57 "./boost/predef/os/macos.h"
# 1 "./boost/predef/detail/os_detected.h" 1
# 58 "./boost/predef/os/macos.h" 2
# 17 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/make.h" 1
# 20 "./boost/predef/os/bsd.h" 2
# 52 "./boost/predef/os/bsd.h"
# 1 "./boost/predef/os/bsd/bsdi.h" 1
# 11 "./boost/predef/os/bsd/bsdi.h"
# 1 "./boost/predef/os/bsd.h" 1
# 94 "./boost/predef/os/bsd.h"
# 1 "./boost/predef/os/bsd/bsdi.h" 1
# 95 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/dragonfly.h" 1
# 11 "./boost/predef/os/bsd/dragonfly.h"
# 1 "./boost/predef/os/bsd.h" 1
# 94 "./boost/predef/os/bsd.h"
# 1 "./boost/predef/os/bsd/bsdi.h" 1
# 95 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/dragonfly.h" 1
# 96 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/free.h" 1
# 11 "./boost/predef/os/bsd/free.h"
# 1 "./boost/predef/os/bsd.h" 1
# 94 "./boost/predef/os/bsd.h"
# 1 "./boost/predef/os/bsd/bsdi.h" 1
# 95 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/dragonfly.h" 1
# 96 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/free.h" 1
# 97 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/open.h" 1
# 11 "./boost/predef/os/bsd/open.h"
# 1 "./boost/predef/os/bsd.h" 1
# 94 "./boost/predef/os/bsd.h"
# 1 "./boost/predef/os/bsd/bsdi.h" 1
# 95 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/dragonfly.h" 1
# 96 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/free.h" 1
# 97 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/open.h" 1
# 98 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/net.h" 1
# 11 "./boost/predef/os/bsd/net.h"
# 1 "./boost/predef/os/bsd.h" 1
# 94 "./boost/predef/os/bsd.h"
# 1 "./boost/predef/os/bsd/bsdi.h" 1
# 95 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/dragonfly.h" 1
# 96 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/free.h" 1
# 97 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/open.h" 1
# 98 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/net.h" 1
# 99 "./boost/predef/os/bsd.h" 2
# 12 "./boost/predef/os/bsd/net.h" 2
# 99 "./boost/predef/os/bsd.h" 2
# 12 "./boost/predef/os/bsd/open.h" 2
# 98 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/net.h" 1
# 99 "./boost/predef/os/bsd.h" 2
# 12 "./boost/predef/os/bsd/free.h" 2
# 97 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/open.h" 1
# 98 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/net.h" 1
# 99 "./boost/predef/os/bsd.h" 2
# 12 "./boost/predef/os/bsd/dragonfly.h" 2
# 96 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/free.h" 1
# 97 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/open.h" 1
# 98 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/net.h" 1
# 99 "./boost/predef/os/bsd.h" 2
# 12 "./boost/predef/os/bsd/bsdi.h" 2
# 53 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/dragonfly.h" 1
# 54 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/free.h" 1
# 55 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/open.h" 1
# 56 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/net.h" 1
# 57 "./boost/predef/os/bsd.h" 2
# 19 "./boost/predef/os.h" 2
# 1 "./boost/predef/os/cygwin.h" 1
# 12 "./boost/predef/os/cygwin.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/os/cygwin.h" 2
# 20 "./boost/predef/os.h" 2
# 1 "./boost/predef/os/haiku.h" 1
# 13 "./boost/predef/os/haiku.h"
# 1 "./boost/predef/make.h" 1
# 14 "./boost/predef/os/haiku.h" 2
# 21 "./boost/predef/os.h" 2
# 1 "./boost/predef/os/hpux.h" 1
# 12 "./boost/predef/os/hpux.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/os/hpux.h" 2
# 22 "./boost/predef/os.h" 2
# 1 "./boost/predef/os/irix.h" 1
# 12 "./boost/predef/os/irix.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/os/irix.h" 2
# 23 "./boost/predef/os.h" 2
# 1 "./boost/predef/os/ios.h" 1
# 24 "./boost/predef/os.h" 2
# 1 "./boost/predef/os/linux.h" 1
# 12 "./boost/predef/os/linux.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/os/linux.h" 2
# 25 "./boost/predef/os.h" 2
# 1 "./boost/predef/os/macos.h" 1
# 26 "./boost/predef/os.h" 2
# 1 "./boost/predef/os/os400.h" 1
# 12 "./boost/predef/os/os400.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/os/os400.h" 2
# 27 "./boost/predef/os.h" 2
# 1 "./boost/predef/os/qnxnto.h" 1
# 12 "./boost/predef/os/qnxnto.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/os/qnxnto.h" 2
# 28 "./boost/predef/os.h" 2
# 1 "./boost/predef/os/solaris.h" 1
# 12 "./boost/predef/os/solaris.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/os/solaris.h" 2
# 29 "./boost/predef/os.h" 2
# 1 "./boost/predef/os/unix.h" 1
# 12 "./boost/predef/os/unix.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/os/unix.h" 2
# 30 "./boost/predef/os.h" 2
# 1 "./boost/predef/os/vms.h" 1
# 12 "./boost/predef/os/vms.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/os/vms.h" 2
# 31 "./boost/predef/os.h" 2
# 1 "./boost/predef/os/windows.h" 1
# 12 "./boost/predef/os/windows.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/os/windows.h" 2
# 32 "./boost/predef/os.h" 2
# 18 "./boost/predef.h" 2
# 1 "./boost/predef/other.h" 1
# 13 "./boost/predef/other.h"
# 1 "./boost/predef/other/endian.h" 1
# 12 "./boost/predef/other/endian.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/other/endian.h" 2
# 1 "./boost/predef/library/c/gnu.h" 1
# 14 "./boost/predef/other/endian.h" 2
# 1 "./boost/predef/os/macos.h" 1
# 15 "./boost/predef/other/endian.h" 2
# 1 "./boost/predef/os/bsd.h" 1
# 94 "./boost/predef/os/bsd.h"
# 1 "./boost/predef/os/bsd/bsdi.h" 1
# 95 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/dragonfly.h" 1
# 96 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/free.h" 1
# 97 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/open.h" 1
# 98 "./boost/predef/os/bsd.h" 2
# 1 "./boost/predef/os/bsd/net.h" 1
# 99 "./boost/predef/os/bsd.h" 2
# 16 "./boost/predef/other/endian.h" 2
# 1 "./boost/predef/os/android.h" 1
# 17 "./boost/predef/other/endian.h" 2
# 14 "./boost/predef/other.h" 2
# 19 "./boost/predef.h" 2
# 1 "./boost/predef/platform.h" 1
# 14 "./boost/predef/platform.h"
# 1 "./boost/predef/platform/cloudabi.h" 1
# 12 "./boost/predef/platform/cloudabi.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/platform/cloudabi.h" 2
# 15 "./boost/predef/platform.h" 2
# 1 "./boost/predef/platform/mingw.h" 1
# 12 "./boost/predef/platform/mingw.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/platform/mingw.h" 2
# 16 "./boost/predef/platform.h" 2
# 1 "./boost/predef/platform/mingw32.h" 1
# 12 "./boost/predef/platform/mingw32.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/platform/mingw32.h" 2
# 17 "./boost/predef/platform.h" 2
# 1 "./boost/predef/platform/mingw64.h" 1
# 12 "./boost/predef/platform/mingw64.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/platform/mingw64.h" 2
# 18 "./boost/predef/platform.h" 2
# 1 "./boost/predef/platform/windows_uwp.h" 1
# 11 "./boost/predef/platform/windows_uwp.h"
# 1 "./boost/predef/make.h" 1
# 12 "./boost/predef/platform/windows_uwp.h" 2
# 1 "./boost/predef/os/windows.h" 1
# 13 "./boost/predef/platform/windows_uwp.h" 2
# 19 "./boost/predef/platform.h" 2
# 1 "./boost/predef/platform/windows_desktop.h" 1
# 12 "./boost/predef/platform/windows_desktop.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/platform/windows_desktop.h" 2
# 1 "./boost/predef/os/windows.h" 1
# 14 "./boost/predef/platform/windows_desktop.h" 2
# 1 "./boost/predef/platform/windows_uwp.h" 1
# 15 "./boost/predef/platform/windows_desktop.h" 2
# 20 "./boost/predef/platform.h" 2
# 1 "./boost/predef/platform/windows_phone.h" 1
# 12 "./boost/predef/platform/windows_phone.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/platform/windows_phone.h" 2
# 1 "./boost/predef/os/windows.h" 1
# 14 "./boost/predef/platform/windows_phone.h" 2
# 1 "./boost/predef/platform/windows_uwp.h" 1
# 15 "./boost/predef/platform/windows_phone.h" 2
# 21 "./boost/predef/platform.h" 2
# 1 "./boost/predef/platform/windows_server.h" 1
# 11 "./boost/predef/platform/windows_server.h"
# 1 "./boost/predef/make.h" 1
# 12 "./boost/predef/platform/windows_server.h" 2
# 1 "./boost/predef/os/windows.h" 1
# 13 "./boost/predef/platform/windows_server.h" 2
# 1 "./boost/predef/platform/windows_uwp.h" 1
# 14 "./boost/predef/platform/windows_server.h" 2
# 22 "./boost/predef/platform.h" 2
# 1 "./boost/predef/platform/windows_store.h" 1
# 12 "./boost/predef/platform/windows_store.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/platform/windows_store.h" 2
# 1 "./boost/predef/os/windows.h" 1
# 14 "./boost/predef/platform/windows_store.h" 2
# 1 "./boost/predef/platform/windows_uwp.h" 1
# 15 "./boost/predef/platform/windows_store.h" 2
# 23 "./boost/predef/platform.h" 2
# 1 "./boost/predef/platform/windows_system.h" 1
# 11 "./boost/predef/platform/windows_system.h"
# 1 "./boost/predef/make.h" 1
# 12 "./boost/predef/platform/windows_system.h" 2
# 1 "./boost/predef/os/windows.h" 1
# 13 "./boost/predef/platform/windows_system.h" 2
# 1 "./boost/predef/platform/windows_uwp.h" 1
# 14 "./boost/predef/platform/windows_system.h" 2
# 24 "./boost/predef/platform.h" 2
# 1 "./boost/predef/platform/windows_runtime.h" 1
# 12 "./boost/predef/platform/windows_runtime.h"
# 1 "./boost/predef/make.h" 1
# 13 "./boost/predef/platform/windows_runtime.h" 2
# 1 "./boost/predef/os/windows.h" 1
# 14 "./boost/predef/platform/windows_runtime.h" 2
# 1 "./boost/predef/platform/windows_phone.h" 1
# 15 "./boost/predef/platform/windows_runtime.h" 2
# 1 "./boost/predef/platform/windows_store.h" 1
# 16 "./boost/predef/platform/windows_runtime.h" 2
# 25 "./boost/predef/platform.h" 2
# 1 "./boost/predef/platform/ios.h" 1
# 12 "./boost/predef/platform/ios.h"
# 1 "./boost/predef/os/ios.h" 1
# 13 "./boost/predef/platform/ios.h" 2
# 26 "./boost/predef/platform.h" 2
# 20 "./boost/predef.h" 2
# 1 "./boost/predef/hardware.h" 1
# 14 "./boost/predef/hardware.h"
# 1 "./boost/predef/hardware/simd.h" 1
# 1 "./boost/predef/hardware/simd/x86.h" 1
# 13 "./boost/predef/hardware/simd/x86.h"
# 1 "./boost/predef/hardware/simd/x86/versions.h" 1
# 14 "./boost/predef/hardware/simd/x86.h" 2
# 10 "./boost/predef/hardware/simd.h" 2
# 1 "./boost/predef/hardware/simd/x86_amd.h" 1
# 13 "./boost/predef/hardware/simd/x86_amd.h"
# 1 "./boost/predef/hardware/simd/x86_amd/versions.h" 1
# 14 "./boost/predef/hardware/simd/x86_amd.h" 2
# 11 "./boost/predef/hardware/simd.h" 2
# 1 "./boost/predef/hardware/simd/arm.h" 1
# 13 "./boost/predef/hardware/simd/arm.h"
# 1 "./boost/predef/hardware/simd/arm/versions.h" 1
# 14 "./boost/predef/hardware/simd/arm.h" 2
# 12 "./boost/predef/hardware/simd.h" 2
# 1 "./boost/predef/hardware/simd/ppc.h" 1
# 13 "./boost/predef/hardware/simd/ppc.h"
# 1 "./boost/predef/hardware/simd/ppc/versions.h" 1
# 14 "./boost/predef/hardware/simd/ppc.h" 2
# 13 "./boost/predef/hardware/simd.h" 2
# 15 "./boost/predef/hardware.h" 2
# 21 "./boost/predef.h" 2
# 1 "./boost/predef/version.h" 1
# 23 "./boost/predef.h" 2
# 15 "./boost/math/tools/config.hpp" 2
# 1 "./boost/cstdint.hpp" 1
# 16 "./boost/math/tools/config.hpp" 2
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cfloat" 1 3
# 64 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cfloat" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/float.h" 1 3
# 67 "/Library/Developer/CommandLineTools/usr/include/c++/v1/float.h" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/float.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/float.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/float.h" 1 3 4
# 46 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/float.h" 2 3 4
# 70 "/Library/Developer/CommandLineTools/usr/include/c++/v1/float.h" 2 3
# 65 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cfloat" 2 3
# 68 "/Library/Developer/CommandLineTools/usr/include/c++/v1/cfloat" 3
# 22 "./boost/math/tools/config.hpp" 2
# 1 "./boost/math/tools/user.hpp" 1
# 30 "./boost/math/tools/config.hpp" 2
# 335 "./boost/math/tools/config.hpp"
# 17 "./boost/math/special_functions/sign.hpp" 2
# 1 "./boost/math/special_functions/math_fwd.hpp" 1
# 26 "./boost/math/special_functions/math_fwd.hpp"
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/vector" 1 3
# 275 "/Library/Developer/CommandLineTools/usr/include/c++/v1/vector" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__split_buffer" 1 3
# 11 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__split_buffer" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 15 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__split_buffer" 2 3
# 276 "/Library/Developer/CommandLineTools/usr/include/c++/v1/vector" 2 3
# 282 "/Library/Developer/CommandLineTools/usr/include/c++/v1/vector" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 286 "/Library/Developer/CommandLineTools/usr/include/c++/v1/vector" 2 3
# 534 "/Library/Developer/CommandLineTools/usr/include/c++/v1/vector" 3
# 776 "/Library/Developer/CommandLineTools/usr/include/c++/v1/vector" 3
# 837 "/Library/Developer/CommandLineTools/usr/include/c++/v1/vector" 3
# 884 "/Library/Developer/CommandLineTools/usr/include/c++/v1/vector" 3
# 931 "/Library/Developer/CommandLineTools/usr/include/c++/v1/vector" 3
# 1704 "/Library/Developer/CommandLineTools/usr/include/c++/v1/vector" 3
# 2103 "/Library/Developer/CommandLineTools/usr/include/c++/v1/vector" 3
# 2131 "/Library/Developer/CommandLineTools/usr/include/c++/v1/vector" 3
# 2512 "/Library/Developer/CommandLineTools/usr/include/c++/v1/vector" 3
# 27 "./boost/math/special_functions/math_fwd.hpp" 2
# 1 "./boost/math/special_functions/detail/round_fwd.hpp" 1
# 12 "./boost/math/special_functions/detail/round_fwd.hpp"
# 1 "./boost/math/tools/promotion.hpp" 1
# 42 "./boost/math/tools/promotion.hpp"
# 68 "./boost/math/tools/promotion.hpp"
# 13 "./boost/math/special_functions/detail/round_fwd.hpp" 2
# 28 "./boost/math/special_functions/math_fwd.hpp" 2
# 1 "./boost/math/policies/policy.hpp" 1
# 1 "./boost/mpl/list.hpp" 1
# 18 "./boost/mpl/list.hpp"
# 1 "./boost/mpl/limits/list.hpp" 1
# 19 "./boost/mpl/list.hpp" 2
# 1 "./boost/preprocessor/inc.hpp" 1
# 23 "./boost/mpl/list.hpp" 2
# 1 "./boost/preprocessor/cat.hpp" 1
# 24 "./boost/mpl/list.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 25 "./boost/mpl/list.hpp" 2
# 36 "./boost/mpl/list.hpp"
# 1 "./boost/mpl/list/list20.hpp" 1
# 18 "./boost/mpl/list/list20.hpp"
# 1 "./boost/mpl/list/list10.hpp" 1
# 18 "./boost/mpl/list/list10.hpp"
# 1 "./boost/mpl/list/list0.hpp" 1
# 17 "./boost/mpl/list/list0.hpp"
# 1 "./boost/mpl/long.hpp" 1
# 17 "./boost/mpl/long.hpp"
# 1 "./boost/mpl/long_fwd.hpp" 1
# 20 "./boost/mpl/long_fwd.hpp"
# 18 "./boost/mpl/long.hpp" 2
# 1 "./boost/mpl/aux_/integral_wrapper.hpp" 1
# 22 "./boost/mpl/aux_/integral_wrapper.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 23 "./boost/mpl/aux_/integral_wrapper.hpp" 2
# 40 "./boost/mpl/aux_/integral_wrapper.hpp"
# 72 "./boost/mpl/aux_/integral_wrapper.hpp"
# 21 "./boost/mpl/long.hpp" 2
# 18 "./boost/mpl/list/list0.hpp" 2
# 1 "./boost/mpl/list/aux_/push_front.hpp" 1
# 17 "./boost/mpl/list/aux_/push_front.hpp"
# 1 "./boost/mpl/push_front_fwd.hpp" 1
# 17 "./boost/mpl/push_front_fwd.hpp"
# 18 "./boost/mpl/list/aux_/push_front.hpp" 2
# 1 "./boost/mpl/list/aux_/item.hpp" 1
# 18 "./boost/mpl/list/aux_/item.hpp"
# 1 "./boost/mpl/list/aux_/tag.hpp" 1
# 17 "./boost/mpl/list/aux_/tag.hpp"
# 19 "./boost/mpl/list/aux_/item.hpp" 2
# 20 "./boost/mpl/list/aux_/push_front.hpp" 2
# 20 "./boost/mpl/list/list0.hpp" 2
# 1 "./boost/mpl/list/aux_/pop_front.hpp" 1
# 17 "./boost/mpl/list/aux_/pop_front.hpp"
# 1 "./boost/mpl/pop_front_fwd.hpp" 1
# 17 "./boost/mpl/pop_front_fwd.hpp"
# 18 "./boost/mpl/list/aux_/pop_front.hpp" 2
# 21 "./boost/mpl/list/list0.hpp" 2
# 1 "./boost/mpl/list/aux_/push_back.hpp" 1
# 17 "./boost/mpl/list/aux_/push_back.hpp"
# 1 "./boost/mpl/push_back_fwd.hpp" 1
# 17 "./boost/mpl/push_back_fwd.hpp"
# 18 "./boost/mpl/list/aux_/push_back.hpp" 2
# 22 "./boost/mpl/list/list0.hpp" 2
# 1 "./boost/mpl/list/aux_/front.hpp" 1
# 17 "./boost/mpl/list/aux_/front.hpp"
# 1 "./boost/mpl/front_fwd.hpp" 1
# 17 "./boost/mpl/front_fwd.hpp"
# 18 "./boost/mpl/list/aux_/front.hpp" 2
# 23 "./boost/mpl/list/list0.hpp" 2
# 1 "./boost/mpl/list/aux_/clear.hpp" 1
# 17 "./boost/mpl/list/aux_/clear.hpp"
# 1 "./boost/mpl/clear_fwd.hpp" 1
# 17 "./boost/mpl/clear_fwd.hpp"
# 18 "./boost/mpl/list/aux_/clear.hpp" 2
# 24 "./boost/mpl/list/list0.hpp" 2
# 1 "./boost/mpl/list/aux_/O1_size.hpp" 1
# 17 "./boost/mpl/list/aux_/O1_size.hpp"
# 1 "./boost/mpl/O1_size_fwd.hpp" 1
# 17 "./boost/mpl/O1_size_fwd.hpp"
# 18 "./boost/mpl/list/aux_/O1_size.hpp" 2
# 25 "./boost/mpl/list/list0.hpp" 2
# 1 "./boost/mpl/list/aux_/size.hpp" 1
# 17 "./boost/mpl/list/aux_/size.hpp"
# 1 "./boost/mpl/size_fwd.hpp" 1
# 17 "./boost/mpl/size_fwd.hpp"
# 18 "./boost/mpl/list/aux_/size.hpp" 2
# 26 "./boost/mpl/list/list0.hpp" 2
# 1 "./boost/mpl/list/aux_/empty.hpp" 1
# 17 "./boost/mpl/list/aux_/empty.hpp"
# 1 "./boost/mpl/empty_fwd.hpp" 1
# 17 "./boost/mpl/empty_fwd.hpp"
# 18 "./boost/mpl/list/aux_/empty.hpp" 2
# 27 "./boost/mpl/list/list0.hpp" 2
# 1 "./boost/mpl/list/aux_/begin_end.hpp" 1
# 18 "./boost/mpl/list/aux_/begin_end.hpp"
# 1 "./boost/mpl/list/aux_/iterator.hpp" 1
# 17 "./boost/mpl/list/aux_/iterator.hpp"
# 1 "./boost/mpl/iterator_tags.hpp" 1
# 19 "./boost/mpl/iterator_tags.hpp"
# 18 "./boost/mpl/list/aux_/iterator.hpp" 2
# 1 "./boost/mpl/aux_/lambda_spec.hpp" 1
# 23 "./boost/mpl/list/aux_/iterator.hpp" 2
# 62 "./boost/mpl/list/aux_/iterator.hpp"
# 19 "./boost/mpl/list/aux_/begin_end.hpp" 2
# 28 "./boost/mpl/list/list0.hpp" 2
# 19 "./boost/mpl/list/list10.hpp" 2
# 1 "./boost/mpl/list/aux_/include_preprocessed.hpp" 1
# 18 "./boost/mpl/list/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 19 "./boost/mpl/list/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 20 "./boost/mpl/list/aux_/include_preprocessed.hpp" 2
# 30 "./boost/mpl/list/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/list/aux_/preprocessed/plain/list10.hpp" 1
# 12 "./boost/mpl/list/aux_/preprocessed/plain/list10.hpp"
# 31 "./boost/mpl/list/aux_/include_preprocessed.hpp" 2
# 28 "./boost/mpl/list/list10.hpp" 2
# 19 "./boost/mpl/list/list20.hpp" 2
# 1 "./boost/mpl/list/aux_/include_preprocessed.hpp" 1
# 18 "./boost/mpl/list/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 19 "./boost/mpl/list/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 20 "./boost/mpl/list/aux_/include_preprocessed.hpp" 2
# 30 "./boost/mpl/list/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/list/aux_/preprocessed/plain/list20.hpp" 1
# 12 "./boost/mpl/list/aux_/preprocessed/plain/list20.hpp"
# 31 "./boost/mpl/list/aux_/include_preprocessed.hpp" 2
# 28 "./boost/mpl/list/list20.hpp" 2
# 37 "./boost/mpl/list.hpp" 2
# 46 "./boost/mpl/list.hpp"
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/list.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/list.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 47 "./boost/mpl/list.hpp" 2
# 10 "./boost/math/policies/policy.hpp" 2
# 1 "./boost/mpl/contains.hpp" 1
# 18 "./boost/mpl/contains.hpp"
# 1 "./boost/mpl/contains_fwd.hpp" 1
# 18 "./boost/mpl/contains_fwd.hpp"
# 19 "./boost/mpl/contains.hpp" 2
# 1 "./boost/mpl/aux_/contains_impl.hpp" 1
# 20 "./boost/mpl/aux_/contains_impl.hpp"
# 1 "./boost/mpl/find.hpp" 1
# 18 "./boost/mpl/find.hpp"
# 1 "./boost/mpl/same_as.hpp" 1
# 23 "./boost/mpl/same_as.hpp"
# 19 "./boost/mpl/find.hpp" 2
# 21 "./boost/mpl/aux_/contains_impl.hpp" 2
# 54 "./boost/mpl/aux_/contains_impl.hpp"
# 21 "./boost/mpl/contains.hpp" 2
# 11 "./boost/math/policies/policy.hpp" 2
# 1 "./boost/mpl/remove_if.hpp" 1
# 18 "./boost/mpl/remove_if.hpp"
# 1 "./boost/mpl/fold.hpp" 1
# 19 "./boost/mpl/fold.hpp"
# 1 "./boost/mpl/O1_size.hpp" 1
# 19 "./boost/mpl/O1_size.hpp"
# 1 "./boost/mpl/aux_/O1_size_impl.hpp" 1
# 20 "./boost/mpl/aux_/O1_size_impl.hpp"
# 1 "./boost/mpl/aux_/has_size.hpp" 1
# 19 "./boost/mpl/aux_/has_size.hpp"
# 21 "./boost/mpl/aux_/O1_size_impl.hpp" 2
# 35 "./boost/mpl/aux_/O1_size_impl.hpp"
# 69 "./boost/mpl/aux_/O1_size_impl.hpp"
# 85 "./boost/mpl/aux_/O1_size_impl.hpp"
# 20 "./boost/mpl/O1_size.hpp" 2
# 20 "./boost/mpl/fold.hpp" 2
# 1 "./boost/mpl/aux_/fold_impl.hpp" 1
# 19 "./boost/mpl/aux_/fold_impl.hpp"
# 1 "./boost/mpl/apply.hpp" 1
# 20 "./boost/mpl/aux_/fold_impl.hpp" 2
# 34 "./boost/mpl/aux_/fold_impl.hpp"
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/fold_impl.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/fold_impl.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 35 "./boost/mpl/aux_/fold_impl.hpp" 2
# 21 "./boost/mpl/fold.hpp" 2
# 19 "./boost/mpl/remove_if.hpp" 2
# 1 "./boost/mpl/reverse_fold.hpp" 1
# 20 "./boost/mpl/reverse_fold.hpp"
# 1 "./boost/mpl/arg.hpp" 1
# 21 "./boost/mpl/reverse_fold.hpp" 2
# 1 "./boost/mpl/aux_/reverse_fold_impl.hpp" 1
# 20 "./boost/mpl/aux_/reverse_fold_impl.hpp"
# 1 "./boost/mpl/apply.hpp" 1
# 21 "./boost/mpl/aux_/reverse_fold_impl.hpp" 2
# 35 "./boost/mpl/aux_/reverse_fold_impl.hpp"
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/reverse_fold_impl.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/reverse_fold_impl.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 36 "./boost/mpl/aux_/reverse_fold_impl.hpp" 2
# 22 "./boost/mpl/reverse_fold.hpp" 2
# 20 "./boost/mpl/remove_if.hpp" 2
# 1 "./boost/mpl/apply.hpp" 1
# 25 "./boost/mpl/remove_if.hpp" 2
# 1 "./boost/mpl/aux_/inserter_algorithm.hpp" 1
# 18 "./boost/mpl/aux_/inserter_algorithm.hpp"
# 1 "./boost/mpl/back_inserter.hpp" 1
# 18 "./boost/mpl/back_inserter.hpp"
# 1 "./boost/mpl/push_back.hpp" 1
# 18 "./boost/mpl/push_back.hpp"
# 1 "./boost/mpl/aux_/push_back_impl.hpp" 1
# 26 "./boost/mpl/aux_/push_back_impl.hpp"
# 19 "./boost/mpl/push_back.hpp" 2
# 19 "./boost/mpl/back_inserter.hpp" 2
# 1 "./boost/mpl/inserter.hpp" 1
# 18 "./boost/mpl/inserter.hpp"
# 20 "./boost/mpl/back_inserter.hpp" 2
# 19 "./boost/mpl/aux_/inserter_algorithm.hpp" 2
# 1 "./boost/mpl/front_inserter.hpp" 1
# 18 "./boost/mpl/front_inserter.hpp"
# 1 "./boost/mpl/push_front.hpp" 1
# 18 "./boost/mpl/push_front.hpp"
# 1 "./boost/mpl/aux_/push_front_impl.hpp" 1
# 26 "./boost/mpl/aux_/push_front_impl.hpp"
# 19 "./boost/mpl/push_front.hpp" 2
# 19 "./boost/mpl/front_inserter.hpp" 2
# 20 "./boost/mpl/aux_/inserter_algorithm.hpp" 2
# 1 "./boost/mpl/clear.hpp" 1
# 18 "./boost/mpl/clear.hpp"
# 1 "./boost/mpl/aux_/clear_impl.hpp" 1
# 21 "./boost/mpl/aux_/clear_impl.hpp"
# 19 "./boost/mpl/clear.hpp" 2
# 25 "./boost/mpl/aux_/inserter_algorithm.hpp" 2
# 34 "./boost/mpl/aux_/inserter_algorithm.hpp"
# 1 "./boost/preprocessor/arithmetic/dec.hpp" 1
# 35 "./boost/mpl/aux_/inserter_algorithm.hpp" 2
# 26 "./boost/mpl/remove_if.hpp" 2
# 14 "./boost/math/policies/policy.hpp" 2
# 1 "./boost/mpl/vector.hpp" 1
# 18 "./boost/mpl/vector.hpp"
# 1 "./boost/mpl/limits/vector.hpp" 1
# 19 "./boost/mpl/vector.hpp" 2
# 1 "./boost/preprocessor/inc.hpp" 1
# 23 "./boost/mpl/vector.hpp" 2
# 1 "./boost/preprocessor/cat.hpp" 1
# 24 "./boost/mpl/vector.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 25 "./boost/mpl/vector.hpp" 2
# 36 "./boost/mpl/vector.hpp"
# 1 "./boost/mpl/vector/vector20.hpp" 1
# 18 "./boost/mpl/vector/vector20.hpp"
# 1 "./boost/mpl/vector/vector10.hpp" 1
# 18 "./boost/mpl/vector/vector10.hpp"
# 1 "./boost/mpl/vector/vector0.hpp" 1
# 17 "./boost/mpl/vector/vector0.hpp"
# 1 "./boost/mpl/vector/aux_/at.hpp" 1
# 17 "./boost/mpl/vector/aux_/at.hpp"
# 1 "./boost/mpl/at_fwd.hpp" 1
# 17 "./boost/mpl/at_fwd.hpp"
# 18 "./boost/mpl/vector/aux_/at.hpp" 2
# 1 "./boost/mpl/vector/aux_/tag.hpp" 1
# 17 "./boost/mpl/vector/aux_/tag.hpp"
# 1 "./boost/mpl/aux_/config/typeof.hpp" 1
# 18 "./boost/mpl/vector/aux_/tag.hpp" 2
# 19 "./boost/mpl/vector/aux_/at.hpp" 2
# 114 "./boost/mpl/vector/aux_/at.hpp"
# 18 "./boost/mpl/vector/vector0.hpp" 2
# 1 "./boost/mpl/vector/aux_/front.hpp" 1
# 24 "./boost/mpl/vector/aux_/front.hpp"
# 54 "./boost/mpl/vector/aux_/front.hpp"
# 19 "./boost/mpl/vector/vector0.hpp" 2
# 1 "./boost/mpl/vector/aux_/push_front.hpp" 1
# 22 "./boost/mpl/vector/aux_/push_front.hpp"
# 1 "./boost/mpl/vector/aux_/item.hpp" 1
# 24 "./boost/mpl/vector/aux_/item.hpp"
# 23 "./boost/mpl/vector/aux_/push_front.hpp" 2
# 20 "./boost/mpl/vector/vector0.hpp" 2
# 1 "./boost/mpl/vector/aux_/pop_front.hpp" 1
# 25 "./boost/mpl/vector/aux_/pop_front.hpp"
# 21 "./boost/mpl/vector/vector0.hpp" 2
# 1 "./boost/mpl/vector/aux_/push_back.hpp" 1
# 25 "./boost/mpl/vector/aux_/push_back.hpp"
# 22 "./boost/mpl/vector/vector0.hpp" 2
# 1 "./boost/mpl/vector/aux_/pop_back.hpp" 1
# 17 "./boost/mpl/vector/aux_/pop_back.hpp"
# 1 "./boost/mpl/pop_back_fwd.hpp" 1
# 17 "./boost/mpl/pop_back_fwd.hpp"
# 18 "./boost/mpl/vector/aux_/pop_back.hpp" 2
# 23 "./boost/mpl/vector/vector0.hpp" 2
# 1 "./boost/mpl/vector/aux_/back.hpp" 1
# 17 "./boost/mpl/vector/aux_/back.hpp"
# 1 "./boost/mpl/back_fwd.hpp" 1
# 17 "./boost/mpl/back_fwd.hpp"
# 18 "./boost/mpl/vector/aux_/back.hpp" 2
# 57 "./boost/mpl/vector/aux_/back.hpp"
# 24 "./boost/mpl/vector/vector0.hpp" 2
# 1 "./boost/mpl/vector/aux_/clear.hpp" 1
# 18 "./boost/mpl/vector/aux_/clear.hpp"
# 1 "./boost/mpl/vector/aux_/vector0.hpp" 1
# 22 "./boost/mpl/vector/aux_/vector0.hpp"
# 1 "./boost/mpl/vector/aux_/iterator.hpp" 1
# 20 "./boost/mpl/vector/aux_/iterator.hpp"
# 1 "./boost/mpl/minus.hpp" 1
# 19 "./boost/mpl/minus.hpp"
# 1 "./boost/mpl/aux_/arithmetic_op.hpp" 1
# 26 "./boost/mpl/aux_/arithmetic_op.hpp"
# 1 "./boost/mpl/aux_/numeric_op.hpp" 1
# 22 "./boost/mpl/aux_/numeric_op.hpp"
# 1 "./boost/mpl/apply_wrap.hpp" 1
# 23 "./boost/mpl/aux_/numeric_op.hpp" 2
# 27 "./boost/mpl/aux_/arithmetic_op.hpp" 2
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/minus.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/minus.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 35 "./boost/mpl/aux_/arithmetic_op.hpp" 2
# 20 "./boost/mpl/minus.hpp" 2
# 21 "./boost/mpl/vector/aux_/iterator.hpp" 2
# 1 "./boost/mpl/advance_fwd.hpp" 1
# 19 "./boost/mpl/advance_fwd.hpp"
# 22 "./boost/mpl/vector/aux_/iterator.hpp" 2
# 1 "./boost/mpl/distance_fwd.hpp" 1
# 19 "./boost/mpl/distance_fwd.hpp"
# 23 "./boost/mpl/vector/aux_/iterator.hpp" 2
# 1 "./boost/mpl/prior.hpp" 1
# 25 "./boost/mpl/vector/aux_/iterator.hpp" 2
# 56 "./boost/mpl/vector/aux_/iterator.hpp"
# 128 "./boost/mpl/vector/aux_/iterator.hpp"
# 23 "./boost/mpl/vector/aux_/vector0.hpp" 2
# 48 "./boost/mpl/vector/aux_/vector0.hpp"
# 19 "./boost/mpl/vector/aux_/clear.hpp" 2
# 53 "./boost/mpl/vector/aux_/clear.hpp"
# 25 "./boost/mpl/vector/vector0.hpp" 2
# 1 "./boost/mpl/vector/aux_/O1_size.hpp" 1
# 24 "./boost/mpl/vector/aux_/O1_size.hpp"
# 54 "./boost/mpl/vector/aux_/O1_size.hpp"
# 26 "./boost/mpl/vector/vector0.hpp" 2
# 1 "./boost/mpl/vector/aux_/size.hpp" 1
# 23 "./boost/mpl/vector/aux_/size.hpp"
# 47 "./boost/mpl/vector/aux_/size.hpp"
# 27 "./boost/mpl/vector/vector0.hpp" 2
# 1 "./boost/mpl/vector/aux_/empty.hpp" 1
# 24 "./boost/mpl/vector/aux_/empty.hpp"
# 66 "./boost/mpl/vector/aux_/empty.hpp"
# 28 "./boost/mpl/vector/vector0.hpp" 2
# 1 "./boost/mpl/vector/aux_/begin_end.hpp" 1
# 25 "./boost/mpl/vector/aux_/begin_end.hpp"
# 32 "./boost/mpl/vector/vector0.hpp" 2
# 19 "./boost/mpl/vector/vector10.hpp" 2
# 1 "./boost/mpl/vector/aux_/include_preprocessed.hpp" 1
# 21 "./boost/mpl/vector/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 22 "./boost/mpl/vector/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 23 "./boost/mpl/vector/aux_/include_preprocessed.hpp" 2
# 49 "./boost/mpl/vector/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/vector/aux_/preprocessed/typeof_based/vector10.hpp" 1
# 12 "./boost/mpl/vector/aux_/preprocessed/typeof_based/vector10.hpp"
# 50 "./boost/mpl/vector/aux_/include_preprocessed.hpp" 2
# 28 "./boost/mpl/vector/vector10.hpp" 2
# 19 "./boost/mpl/vector/vector20.hpp" 2
# 1 "./boost/mpl/vector/aux_/include_preprocessed.hpp" 1
# 21 "./boost/mpl/vector/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 22 "./boost/mpl/vector/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 23 "./boost/mpl/vector/aux_/include_preprocessed.hpp" 2
# 49 "./boost/mpl/vector/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/vector/aux_/preprocessed/typeof_based/vector20.hpp" 1
# 12 "./boost/mpl/vector/aux_/preprocessed/typeof_based/vector20.hpp"
# 50 "./boost/mpl/vector/aux_/include_preprocessed.hpp" 2
# 28 "./boost/mpl/vector/vector20.hpp" 2
# 37 "./boost/mpl/vector.hpp" 2
# 46 "./boost/mpl/vector.hpp"
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/vector.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/vector.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 47 "./boost/mpl/vector.hpp" 2
# 15 "./boost/math/policies/policy.hpp" 2
# 1 "./boost/mpl/at.hpp" 1
# 18 "./boost/mpl/at.hpp"
# 1 "./boost/mpl/aux_/at_impl.hpp" 1
# 18 "./boost/mpl/aux_/at_impl.hpp"
# 1 "./boost/mpl/advance.hpp" 1
# 19 "./boost/mpl/advance.hpp"
# 1 "./boost/mpl/negate.hpp" 1
# 25 "./boost/mpl/negate.hpp"
# 65 "./boost/mpl/negate.hpp"
# 20 "./boost/mpl/advance.hpp" 2
# 1 "./boost/mpl/apply_wrap.hpp" 1
# 24 "./boost/mpl/advance.hpp" 2
# 1 "./boost/mpl/aux_/advance_forward.hpp" 1
# 23 "./boost/mpl/aux_/advance_forward.hpp"
# 1 "./boost/mpl/apply_wrap.hpp" 1
# 24 "./boost/mpl/aux_/advance_forward.hpp" 2
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/advance_forward.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/advance_forward.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 33 "./boost/mpl/aux_/advance_forward.hpp" 2
# 25 "./boost/mpl/advance.hpp" 2
# 1 "./boost/mpl/aux_/advance_backward.hpp" 1
# 23 "./boost/mpl/aux_/advance_backward.hpp"
# 1 "./boost/mpl/apply_wrap.hpp" 1
# 24 "./boost/mpl/aux_/advance_backward.hpp" 2
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/advance_backward.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/advance_backward.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 33 "./boost/mpl/aux_/advance_backward.hpp" 2
# 26 "./boost/mpl/advance.hpp" 2
# 19 "./boost/mpl/aux_/at_impl.hpp" 2
# 19 "./boost/mpl/at.hpp" 2
# 17 "./boost/math/policies/policy.hpp" 2
# 1 "./boost/mpl/size.hpp" 1
# 19 "./boost/mpl/size.hpp"
# 1 "./boost/mpl/aux_/size_impl.hpp" 1
# 19 "./boost/mpl/aux_/size_impl.hpp"
# 1 "./boost/mpl/distance.hpp" 1
# 18 "./boost/mpl/distance.hpp"
# 1 "./boost/mpl/iter_fold.hpp" 1
# 21 "./boost/mpl/iter_fold.hpp"
# 1 "./boost/mpl/aux_/iter_fold_impl.hpp" 1
# 19 "./boost/mpl/aux_/iter_fold_impl.hpp"
# 1 "./boost/mpl/apply.hpp" 1
# 20 "./boost/mpl/aux_/iter_fold_impl.hpp" 2
# 33 "./boost/mpl/aux_/iter_fold_impl.hpp"
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/iter_fold_impl.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/iter_fold_impl.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 34 "./boost/mpl/aux_/iter_fold_impl.hpp" 2
# 22 "./boost/mpl/iter_fold.hpp" 2
# 19 "./boost/mpl/distance.hpp" 2
# 1 "./boost/mpl/iterator_range.hpp" 1
# 20 "./boost/mpl/iterator_range.hpp"
# 20 "./boost/mpl/distance.hpp" 2
# 1 "./boost/mpl/apply_wrap.hpp" 1
# 24 "./boost/mpl/distance.hpp" 2
# 60 "./boost/mpl/distance.hpp"
# 20 "./boost/mpl/aux_/size_impl.hpp" 2
# 20 "./boost/mpl/size.hpp" 2
# 18 "./boost/math/policies/policy.hpp" 2
# 1 "./boost/mpl/comparison.hpp" 1
# 18 "./boost/mpl/comparison.hpp"
# 1 "./boost/mpl/not_equal_to.hpp" 1
# 19 "./boost/mpl/not_equal_to.hpp"
# 1 "./boost/mpl/aux_/comparison_op.hpp" 1
# 27 "./boost/mpl/aux_/comparison_op.hpp"
# 1 "./boost/mpl/aux_/numeric_op.hpp" 1
# 22 "./boost/mpl/aux_/numeric_op.hpp"
# 1 "./boost/mpl/apply_wrap.hpp" 1
# 23 "./boost/mpl/aux_/numeric_op.hpp" 2
# 28 "./boost/mpl/aux_/comparison_op.hpp" 2
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/not_equal_to.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/not_equal_to.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 36 "./boost/mpl/aux_/comparison_op.hpp" 2
# 20 "./boost/mpl/not_equal_to.hpp" 2
# 19 "./boost/mpl/comparison.hpp" 2
# 1 "./boost/mpl/greater.hpp" 1
# 19 "./boost/mpl/greater.hpp"
# 1 "./boost/mpl/aux_/comparison_op.hpp" 1
# 27 "./boost/mpl/aux_/comparison_op.hpp"
# 1 "./boost/mpl/aux_/numeric_op.hpp" 1
# 22 "./boost/mpl/aux_/numeric_op.hpp"
# 1 "./boost/mpl/apply_wrap.hpp" 1
# 23 "./boost/mpl/aux_/numeric_op.hpp" 2
# 28 "./boost/mpl/aux_/comparison_op.hpp" 2
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/greater.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/greater.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 36 "./boost/mpl/aux_/comparison_op.hpp" 2
# 20 "./boost/mpl/greater.hpp" 2
# 21 "./boost/mpl/comparison.hpp" 2
# 1 "./boost/mpl/less_equal.hpp" 1
# 19 "./boost/mpl/less_equal.hpp"
# 1 "./boost/mpl/aux_/comparison_op.hpp" 1
# 27 "./boost/mpl/aux_/comparison_op.hpp"
# 1 "./boost/mpl/aux_/numeric_op.hpp" 1
# 22 "./boost/mpl/aux_/numeric_op.hpp"
# 1 "./boost/mpl/apply_wrap.hpp" 1
# 23 "./boost/mpl/aux_/numeric_op.hpp" 2
# 28 "./boost/mpl/aux_/comparison_op.hpp" 2
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/less_equal.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/less_equal.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 36 "./boost/mpl/aux_/comparison_op.hpp" 2
# 20 "./boost/mpl/less_equal.hpp" 2
# 22 "./boost/mpl/comparison.hpp" 2
# 1 "./boost/mpl/greater_equal.hpp" 1
# 19 "./boost/mpl/greater_equal.hpp"
# 1 "./boost/mpl/aux_/comparison_op.hpp" 1
# 27 "./boost/mpl/aux_/comparison_op.hpp"
# 1 "./boost/mpl/aux_/numeric_op.hpp" 1
# 22 "./boost/mpl/aux_/numeric_op.hpp"
# 1 "./boost/mpl/apply_wrap.hpp" 1
# 23 "./boost/mpl/aux_/numeric_op.hpp" 2
# 28 "./boost/mpl/aux_/comparison_op.hpp" 2
# 1 "./boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/preprocessor/cat.hpp" 1
# 20 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 1 "./boost/preprocessor/stringize.hpp" 1
# 21 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "./boost/mpl/aux_/include_preprocessed.hpp"
# 1 "./boost/mpl/aux_/preprocessed/gcc/greater_equal.hpp" 1
# 12 "./boost/mpl/aux_/preprocessed/gcc/greater_equal.hpp"
# 38 "./boost/mpl/aux_/include_preprocessed.hpp" 2
# 36 "./boost/mpl/aux_/comparison_op.hpp" 2
# 20 "./boost/mpl/greater_equal.hpp" 2
# 23 "./boost/mpl/comparison.hpp" 2
# 19 "./boost/math/policies/policy.hpp" 2
# 1 "./boost/assert.hpp" 1
# 58 "./boost/assert.hpp"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 2 3 4
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 59 "./boost/assert.hpp" 2
# 22 "./boost/math/policies/policy.hpp" 2
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdlib.h" 1 3
# 28 "./boost/math/policies/policy.hpp" 2
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stddef.h" 1 3
# 29 "./boost/math/policies/policy.hpp" 2
# 197 "./boost/math/policies/policy.hpp"
# 797 "./boost/math/policies/policy.hpp"
# 833 "./boost/math/policies/policy.hpp"
# 847 "./boost/math/policies/policy.hpp"
# 1035 "./boost/math/policies/policy.hpp"
# 30 "./boost/math/special_functions/math_fwd.hpp" 2
# 1 "./boost/config/no_tr1/complex.hpp" 1
# 33 "./boost/math/special_functions/math_fwd.hpp" 2
# 18 "./boost/math/special_functions/sign.hpp" 2
# 1 "./boost/math/special_functions/detail/fp_traits.hpp" 1
# 25 "./boost/math/special_functions/detail/fp_traits.hpp"
# 1 "./boost/assert.hpp" 1
# 58 "./boost/assert.hpp"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 2 3 4
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 59 "./boost/assert.hpp" 2
# 26 "./boost/math/special_functions/detail/fp_traits.hpp" 2
# 1 "./boost/cstdint.hpp" 1
# 27 "./boost/math/special_functions/detail/fp_traits.hpp" 2
# 1 "./boost/predef/other/endian.h" 1
# 28 "./boost/math/special_functions/detail/fp_traits.hpp" 2
# 81 "./boost/math/special_functions/detail/fp_traits.hpp"
# 92 "./boost/math/special_functions/detail/fp_traits.hpp"
# 125 "./boost/math/special_functions/detail/fp_traits.hpp"
# 177 "./boost/math/special_functions/detail/fp_traits.hpp"
# 232 "./boost/math/special_functions/detail/fp_traits.hpp"
# 292 "./boost/math/special_functions/detail/fp_traits.hpp"
# 318 "./boost/math/special_functions/detail/fp_traits.hpp"
# 490 "./boost/math/special_functions/detail/fp_traits.hpp"
# 564 "./boost/math/special_functions/detail/fp_traits.hpp"
# 19 "./boost/math/special_functions/sign.hpp" 2
# 67 "./boost/math/special_functions/sign.hpp"
# 126 "./boost/math/special_functions/sign.hpp"
# 35 "./boost/lexical_cast/detail/inf_nan.hpp" 2
# 1 "./boost/math/special_functions/fpclassify.hpp" 1
# 17 "./boost/math/special_functions/fpclassify.hpp"
# 1 "./boost/math/tools/real_cast.hpp" 1
# 15 "./boost/math/tools/real_cast.hpp"
# 18 "./boost/math/special_functions/fpclassify.hpp" 2
# 96 "./boost/math/special_functions/fpclassify.hpp"
# 145 "./boost/math/special_functions/fpclassify.hpp"
# 176 "./boost/math/special_functions/fpclassify.hpp"
# 206 "./boost/math/special_functions/fpclassify.hpp"
# 274 "./boost/math/special_functions/fpclassify.hpp"
# 308 "./boost/math/special_functions/fpclassify.hpp"
# 353 "./boost/math/special_functions/fpclassify.hpp"
# 379 "./boost/math/special_functions/fpclassify.hpp"
# 424 "./boost/math/special_functions/fpclassify.hpp"
# 450 "./boost/math/special_functions/fpclassify.hpp"
# 513 "./boost/math/special_functions/fpclassify.hpp"
# 546 "./boost/math/special_functions/fpclassify.hpp"
# 636 "./boost/math/special_functions/fpclassify.hpp"
# 36 "./boost/lexical_cast/detail/inf_nan.hpp" 2
# 64 "./boost/lexical_cast/detail/converter_lexical_streams.hpp" 2
# 77 "./boost/lexical_cast/detail/converter_lexical_streams.hpp"
# 1 "./boost/integer.hpp" 1
# 18 "./boost/integer.hpp"
# 1 "./boost/integer_fwd.hpp" 1
# 17 "./boost/integer_fwd.hpp"
# 1 "./boost/cstdint.hpp" 1
# 18 "./boost/integer_fwd.hpp" 2
# 42 "./boost/integer_fwd.hpp"
# 97 "./boost/integer_fwd.hpp"
# 19 "./boost/integer.hpp" 2
# 1 "./boost/cstdint.hpp" 1
# 23 "./boost/integer.hpp" 2
# 35 "./boost/integer.hpp" 3
# 109 "./boost/integer.hpp" 3
# 150 "./boost/integer.hpp" 3
# 243 "./boost/integer.hpp" 3
# 78 "./boost/lexical_cast/detail/converter_lexical_streams.hpp" 2
# 1 "./boost/detail/basic_pointerbuf.hpp" 1
# 24 "./boost/detail/basic_pointerbuf.hpp"
# 79 "./boost/lexical_cast/detail/converter_lexical_streams.hpp" 2
# 125 "./boost/lexical_cast/detail/converter_lexical_streams.hpp"
# 581 "./boost/lexical_cast/detail/converter_lexical_streams.hpp"
# 55 "./boost/lexical_cast/detail/converter_lexical.hpp" 2
# 181 "./boost/lexical_cast/detail/converter_lexical.hpp"
# 266 "./boost/lexical_cast/detail/converter_lexical.hpp"
# 350 "./boost/lexical_cast/detail/converter_lexical.hpp"
# 365 "./boost/lexical_cast/detail/converter_lexical.hpp"
# 377 "./boost/lexical_cast/detail/converter_lexical.hpp"
# 424 "./boost/lexical_cast/detail/converter_lexical.hpp"
# 45 "./boost/lexical_cast/try_lexical_convert.hpp" 2
# 33 "./boost/lexical_cast.hpp" 2
# 19 "./boost/multiprecision/detail/number_base.hpp" 2
# 55 "./boost/multiprecision/detail/number_base.hpp"
# 156 "./boost/multiprecision/detail/number_base.hpp"
# 204 "./boost/multiprecision/detail/number_base.hpp"
# 545 "./boost/multiprecision/detail/number_base.hpp"
# 571 "./boost/multiprecision/detail/number_base.hpp"
# 723 "./boost/multiprecision/detail/number_base.hpp"
# 748 "./boost/multiprecision/detail/number_base.hpp"
# 905 "./boost/multiprecision/detail/number_base.hpp"
# 930 "./boost/multiprecision/detail/number_base.hpp"
# 1098 "./boost/multiprecision/detail/number_base.hpp"
# 1123 "./boost/multiprecision/detail/number_base.hpp"
# 1300 "./boost/multiprecision/detail/number_base.hpp"
# 1325 "./boost/multiprecision/detail/number_base.hpp"
# 1368 "./boost/multiprecision/detail/number_base.hpp"
# 11 "./boost/multiprecision/traits/is_variable_precision.hpp" 2
# 10 "./boost/multiprecision/detail/precision.hpp" 2
# 135 "./boost/multiprecision/detail/precision.hpp"
# 24 "./boost/multiprecision/number.hpp" 2
# 1 "./boost/multiprecision/detail/generic_interconvert.hpp" 1
# 1 "./boost/multiprecision/detail/default_ops.hpp" 1
# 1 "./boost/math/policies/error_handling.hpp" 1
# 22 "./boost/math/policies/error_handling.hpp"
# 1 "./boost/math/tools/precision.hpp" 1
# 14 "./boost/math/tools/precision.hpp"
# 1 "./boost/assert.hpp" 1
# 58 "./boost/assert.hpp"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 2 3 4
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 59 "./boost/assert.hpp" 2
# 15 "./boost/math/tools/precision.hpp" 2
# 25 "./boost/math/tools/precision.hpp"
# 41 "./boost/math/tools/precision.hpp"
# 88 "./boost/math/tools/precision.hpp"
# 180 "./boost/math/tools/precision.hpp"
# 23 "./boost/math/policies/error_handling.hpp" 2
# 1 "./boost/cstdint.hpp" 1
# 25 "./boost/math/policies/error_handling.hpp" 2
# 37 "./boost/math/policies/error_handling.hpp"
# 123 "./boost/math/policies/error_handling.hpp"
# 10 "./boost/multiprecision/detail/default_ops.hpp" 2
# 1 "./boost/math/special_functions/next.hpp" 1
# 17 "./boost/math/special_functions/next.hpp"
# 1 "./boost/math/special_functions/trunc.hpp" 1
# 18 "./boost/math/special_functions/trunc.hpp"
# 57 "./boost/math/special_functions/trunc.hpp"
# 18 "./boost/math/special_functions/next.hpp" 2
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 1 3 4
# 27 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 1 3 4
# 27 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 44 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 61 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 78 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 94 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 110 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 140 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 170 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 200 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 227 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 250 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 271 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 298 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 321 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 342 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 363 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 384 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 405 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 427 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 450 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 472 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 494 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 515 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 536 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 557 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 580 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 603 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 627 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 651 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 678 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 699 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 720 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 743 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 765 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 788 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 810 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 830 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 850 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 874 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 897 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 921 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 944 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 967 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 989 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1012 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1034 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1054 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1075 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1093 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1114 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1132 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1150 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1172 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1194 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1216 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1238 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1260 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1282 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1295 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1316 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1339 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1370 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1390 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1408 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1426 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1447 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1470 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 1501 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mmintrin.h" 3 4
# 28 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mm_malloc.h" 1 3 4
# 27 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mm_malloc.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdlib.h" 1 3 4
# 28 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mm_malloc.h" 2 3 4
# 39 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/mm_malloc.h" 3 4
# 40 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 2 3 4
# 60 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 80 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 102 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 123 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 145 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 165 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 187 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 206 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 224 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 242 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 260 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 278 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 297 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 315 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 338 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 357 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 380 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 399 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 417 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 439 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 457 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 476 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 498 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 516 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 539 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 558 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 582 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 601 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 624 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 645 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 669 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 690 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 713 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 732 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 756 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 776 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 801 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 821 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 846 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 868 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 893 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 915 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 940 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 960 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 985 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1005 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1026 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1048 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1069 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1090 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1111 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1132 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1153 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1174 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1196 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1218 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1240 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1261 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1279 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1297 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1317 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1335 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1351 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1370 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1389 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1409 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1428 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1445 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1467 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1490 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1514 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1540 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1563 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1580 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1601 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1628 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1655 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1677 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1700 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1717 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1739 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1753 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1773 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1791 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1810 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1837 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1865 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1880 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1897 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1914 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1931 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1952 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1973 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1992 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2012 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2031 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2089 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2108 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2127 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2200 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2219 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2238 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2257 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2275 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2294 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2357 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2376 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2395 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2417 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2473 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2525 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2590 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2612 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2633 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2654 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2675 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2693 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2723 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2752 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2777 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2804 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2833 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2863 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2888 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 2969 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 1 3 4
# 27 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 1 3 4
# 28 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/f16cintrin.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/f16cintrin.h" 3 4
# 116 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/f16cintrin.h" 3 4
# 48 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 2 3 4
# 67 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 86 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 109 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 128 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 150 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 169 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 192 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 212 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 237 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 255 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 279 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 299 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 323 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 343 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 361 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 382 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 400 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 418 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 437 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 457 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 478 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 499 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 520 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 543 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 567 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 588 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 609 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 630 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 651 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 672 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 695 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 720 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 745 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 770 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 796 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 824 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 852 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 877 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 902 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 927 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 952 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 978 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1003 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1029 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1055 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1081 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1107 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1133 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1157 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1183 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1209 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1235 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1261 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1287 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1306 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1326 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1349 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1369 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1386 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1411 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1434 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1460 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1484 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1502 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1519 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1539 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1556 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1573 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1590 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1608 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1634 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1652 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1672 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1693 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1720 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1747 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1768 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1788 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1806 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1824 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1844 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1865 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1880 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1901 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1918 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1940 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1960 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1981 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 1999 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2022 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2040 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2060 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2085 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2107 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2129 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2147 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2169 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2190 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2212 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2233 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2254 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2274 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2298 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2328 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2348 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2368 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2388 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2408 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2428 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2448 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2468 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2487 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2506 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2528 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2546 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2564 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2582 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2601 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2619 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2640 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2661 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2681 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2701 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2719 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2739 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2756 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2774 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2834 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2853 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2872 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2891 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2910 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2929 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2949 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2969 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2989 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3009 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3069 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3088 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3107 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3126 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3145 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3164 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3183 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3202 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3221 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3241 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3264 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3285 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3306 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3327 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3348 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3372 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3390 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3408 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3424 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3440 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3457 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3473 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3490 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3508 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3527 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3544 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3560 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3581 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3599 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3621 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3643 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3671 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3711 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3759 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3778 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3797 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3816 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3835 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3854 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3874 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3897 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3928 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3975 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 3989 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4007 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4023 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4053 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4072 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4095 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4114 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4133 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4153 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4174 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4185 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4196 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4224 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4252 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4280 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4308 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4335 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4355 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4494 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4521 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4544 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4565 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4600 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4628 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4651 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4672 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4689 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4706 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4724 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4745 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4766 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4785 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4832 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4849 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4866 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4883 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4900 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4917 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 4934 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/emmintrin.h" 3 4
# 2970 "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include/xmmintrin.h" 2 3 4
# 24 "./boost/math/special_functions/next.hpp" 2
# 293 "./boost/math/special_functions/next.hpp"
# 425 "./boost/math/special_functions/next.hpp"
# 13 "./boost/multiprecision/detail/default_ops.hpp" 2
# 1 "./boost/math/special_functions/hypot.hpp" 1
# 24 "./boost/math/special_functions/hypot.hpp"
# 14 "./boost/multiprecision/detail/default_ops.hpp" 2
# 1 "./boost/mpl/front.hpp" 1
# 18 "./boost/mpl/front.hpp"
# 1 "./boost/mpl/aux_/front_impl.hpp" 1
# 22 "./boost/mpl/aux_/front_impl.hpp"
# 19 "./boost/mpl/front.hpp" 2
# 16 "./boost/multiprecision/detail/default_ops.hpp" 2
# 1 "./boost/cstdint.hpp" 1
# 18 "./boost/multiprecision/detail/default_ops.hpp" 2
# 33 "./boost/multiprecision/detail/default_ops.hpp"
# 72 "./boost/multiprecision/detail/default_ops.hpp"
# 1467 "./boost/multiprecision/detail/default_ops.hpp"
# 1 "./boost/multiprecision/detail/functions/constants.hpp" 1
# 50 "./boost/multiprecision/detail/functions/constants.hpp"
# 189 "./boost/multiprecision/detail/functions/constants.hpp"
# 254 "./boost/multiprecision/detail/functions/constants.hpp"
# 277 "./boost/multiprecision/detail/functions/constants.hpp"
# 300 "./boost/multiprecision/detail/functions/constants.hpp"
# 323 "./boost/multiprecision/detail/functions/constants.hpp"
# 1875 "./boost/multiprecision/detail/default_ops.hpp" 2
# 1 "./boost/multiprecision/detail/functions/pow.hpp" 1
# 20 "./boost/multiprecision/detail/functions/pow.hpp"
# 302 "./boost/multiprecision/detail/functions/pow.hpp"
# 436 "./boost/multiprecision/detail/functions/pow.hpp"
# 1876 "./boost/multiprecision/detail/default_ops.hpp" 2
# 1 "./boost/multiprecision/detail/functions/trig.hpp" 1
# 20 "./boost/multiprecision/detail/functions/trig.hpp"
# 1877 "./boost/multiprecision/detail/default_ops.hpp" 2
# 3494 "./boost/multiprecision/detail/default_ops.hpp"
# 1 "./boost/multiprecision/detail/no_et_ops.hpp" 1
# 14 "./boost/multiprecision/detail/no_et_ops.hpp"
# 654 "./boost/multiprecision/detail/no_et_ops.hpp"
# 3816 "./boost/multiprecision/detail/default_ops.hpp" 2
# 1 "./boost/multiprecision/detail/et_ops.hpp" 1
# 23 "./boost/multiprecision/detail/et_ops.hpp"
# 3817 "./boost/multiprecision/detail/default_ops.hpp" 2
# 1 "./boost/multiprecision/detail/min_max.hpp" 1
# 1 "./boost/multiprecision/traits/is_backend.hpp" 1
# 14 "./boost/multiprecision/traits/is_backend.hpp"
# 10 "./boost/multiprecision/detail/min_max.hpp" 2
# 28 "./boost/multiprecision/detail/min_max.hpp"
# 3821 "./boost/multiprecision/detail/default_ops.hpp" 2
# 10 "./boost/multiprecision/detail/generic_interconvert.hpp" 2
# 137 "./boost/multiprecision/detail/generic_interconvert.hpp"
# 25 "./boost/multiprecision/number.hpp" 2
# 1 "./boost/multiprecision/detail/number_compare.hpp" 1
# 15 "./boost/multiprecision/detail/number_compare.hpp"
# 26 "./boost/multiprecision/number.hpp" 2
# 1 "./boost/multiprecision/traits/is_restricted_conversion.hpp" 1
# 10 "./boost/multiprecision/traits/is_restricted_conversion.hpp"
# 1 "./boost/multiprecision/traits/explicit_conversion.hpp" 1
# 11 "./boost/multiprecision/traits/explicit_conversion.hpp"
# 1 "./boost/utility/declval.hpp" 1
# 12 "./boost/multiprecision/traits/explicit_conversion.hpp" 2
# 87 "./boost/multiprecision/traits/explicit_conversion.hpp"
# 11 "./boost/multiprecision/traits/is_restricted_conversion.hpp" 2
# 27 "./boost/multiprecision/number.hpp" 2
# 1 "./boost/container_hash/hash.hpp" 1
# 19 "./boost/container_hash/hash.hpp"
# 1 "./boost/container_hash/hash_fwd.hpp" 1
# 21 "./boost/container_hash/hash_fwd.hpp"
# 20 "./boost/container_hash/hash.hpp" 2
# 1 "./boost/container_hash/detail/hash_float.hpp" 1
# 14 "./boost/container_hash/detail/hash_float.hpp"
# 1 "./boost/container_hash/detail/float_functions.hpp" 1
# 76 "./boost/container_hash/detail/float_functions.hpp"
# 15 "./boost/container_hash/detail/hash_float.hpp" 2
# 1 "./boost/container_hash/detail/limits.hpp" 1
# 27 "./boost/container_hash/detail/limits.hpp"
# 59 "./boost/container_hash/detail/limits.hpp"
# 16 "./boost/container_hash/detail/hash_float.hpp" 2
# 1 "./boost/integer/static_log2.hpp" 1
# 21 "./boost/integer/static_log2.hpp"
# 44 "./boost/integer/static_log2.hpp"
# 84 "./boost/integer/static_log2.hpp"
# 18 "./boost/container_hash/detail/hash_float.hpp" 2
# 1 "./boost/cstdint.hpp" 1
# 19 "./boost/container_hash/detail/hash_float.hpp" 2
# 1 "./boost/assert.hpp" 1
# 58 "./boost/assert.hpp"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 2 3 4
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 59 "./boost/assert.hpp" 2
# 20 "./boost/container_hash/detail/hash_float.hpp" 2
# 51 "./boost/container_hash/detail/hash_float.hpp"
# 237 "./boost/container_hash/detail/hash_float.hpp"
# 22 "./boost/container_hash/hash.hpp" 2
# 1 "./boost/cstdint.hpp" 1
# 28 "./boost/container_hash/hash.hpp" 2
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/typeindex" 1 3
# 54 "/Library/Developer/CommandLineTools/usr/include/c++/v1/typeindex" 3
# 35 "./boost/container_hash/hash.hpp" 2
# 110 "./boost/container_hash/hash.hpp"
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/optional" 1 3
# 158 "/Library/Developer/CommandLineTools/usr/include/c++/v1/optional" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 162 "/Library/Developer/CommandLineTools/usr/include/c++/v1/optional" 2 3
# 111 "./boost/container_hash/hash.hpp" 2
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/variant" 1 3
# 214 "/Library/Developer/CommandLineTools/usr/include/c++/v1/variant" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 218 "/Library/Developer/CommandLineTools/usr/include/c++/v1/variant" 2 3
# 667 "/Library/Developer/CommandLineTools/usr/include/c++/v1/variant" 3
# 748 "/Library/Developer/CommandLineTools/usr/include/c++/v1/variant" 3
# 768 "/Library/Developer/CommandLineTools/usr/include/c++/v1/variant" 3
# 832 "/Library/Developer/CommandLineTools/usr/include/c++/v1/variant" 3
# 872 "/Library/Developer/CommandLineTools/usr/include/c++/v1/variant" 3
# 971 "/Library/Developer/CommandLineTools/usr/include/c++/v1/variant" 3
# 984 "/Library/Developer/CommandLineTools/usr/include/c++/v1/variant" 3
# 1012 "/Library/Developer/CommandLineTools/usr/include/c++/v1/variant" 3
# 115 "./boost/container_hash/hash.hpp" 2
# 129 "./boost/container_hash/hash.hpp"
# 411 "./boost/container_hash/hash.hpp"
# 471 "./boost/container_hash/hash.hpp"
# 603 "./boost/container_hash/hash.hpp"
# 673 "./boost/container_hash/hash.hpp"
# 684 "./boost/container_hash/hash.hpp"
# 743 "./boost/container_hash/hash.hpp"
# 760 "./boost/container_hash/hash.hpp"
# 1 "./boost/container_hash/extensions.hpp" 1
# 21 "./boost/container_hash/extensions.hpp"
# 1 "./boost/container_hash/hash.hpp" 1
# 22 "./boost/container_hash/extensions.hpp" 2
# 1 "./boost/detail/container_fwd.hpp" 1
# 91 "./boost/detail/container_fwd.hpp"
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/deque" 1 3
# 163 "/Library/Developer/CommandLineTools/usr/include/c++/v1/deque" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 167 "/Library/Developer/CommandLineTools/usr/include/c++/v1/deque" 2 3
# 92 "./boost/detail/container_fwd.hpp" 2
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/list" 1 3
# 184 "/Library/Developer/CommandLineTools/usr/include/c++/v1/list" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 188 "/Library/Developer/CommandLineTools/usr/include/c++/v1/list" 2 3
# 291 "/Library/Developer/CommandLineTools/usr/include/c++/v1/list" 3
# 343 "/Library/Developer/CommandLineTools/usr/include/c++/v1/list" 3
# 414 "/Library/Developer/CommandLineTools/usr/include/c++/v1/list" 3
# 470 "/Library/Developer/CommandLineTools/usr/include/c++/v1/list" 3
# 802 "/Library/Developer/CommandLineTools/usr/include/c++/v1/list" 3
# 1093 "/Library/Developer/CommandLineTools/usr/include/c++/v1/list" 3
# 1718 "/Library/Developer/CommandLineTools/usr/include/c++/v1/list" 3
# 1747 "/Library/Developer/CommandLineTools/usr/include/c++/v1/list" 3
# 1783 "/Library/Developer/CommandLineTools/usr/include/c++/v1/list" 3
# 1805 "/Library/Developer/CommandLineTools/usr/include/c++/v1/list" 3
# 1829 "/Library/Developer/CommandLineTools/usr/include/c++/v1/list" 3
# 1993 "/Library/Developer/CommandLineTools/usr/include/c++/v1/list" 3
# 2011 "/Library/Developer/CommandLineTools/usr/include/c++/v1/list" 3
# 2036 "/Library/Developer/CommandLineTools/usr/include/c++/v1/list" 3
# 2059 "/Library/Developer/CommandLineTools/usr/include/c++/v1/list" 3
# 2094 "/Library/Developer/CommandLineTools/usr/include/c++/v1/list" 3
# 2222 "/Library/Developer/CommandLineTools/usr/include/c++/v1/list" 3
# 2360 "/Library/Developer/CommandLineTools/usr/include/c++/v1/list" 3
# 93 "./boost/detail/container_fwd.hpp" 2
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/map" 1 3
# 442 "/Library/Developer/CommandLineTools/usr/include/c++/v1/map" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__tree" 1 3
# 22 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__tree" 3
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__undef_macros" 1 3
# 26 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__tree" 2 3
# 79 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__tree" 3
# 279 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__tree" 3
# 349 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__tree" 3
# 416 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__tree" 3
# 1271 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__tree" 3
# 2045 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__tree" 3
# 2300 "/Library/Developer/CommandLineTools/usr/include/c++/v1/__tree" 3
# 443 "/Library/Developer/CommandLineTools/usr/include/c++/v1/map" 2 3
# 452 "/Library/Developer/CommandLineTools/usr/include/c++/v1/map" 3
# 672 "/Library/Developer/CommandLineTools/usr/include/c++/v1/map" 3
# 921 "/Library/Developer/CommandLineTools/usr/include/c++/v1/map" 3
# 1368 "/Library/Developer/CommandLineTools/usr/include/c++/v1/map" 3
# 1579 "/Library/Developer/CommandLineTools/usr/include/c++/v1/map" 3
# 95 "./boost/detail/container_fwd.hpp" 2
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/set" 1 3
# 394 "/Library/Developer/CommandLineTools/usr/include/c++/v1/set" 3
# 96 "./boost/detail/container_fwd.hpp" 2
# 23 "./boost/container_hash/extensions.hpp" 2
# 43 "./boost/container_hash/extensions.hpp"
# 288 "./boost/container_hash/extensions.hpp"
# 352 "./boost/container_hash/extensions.hpp"
# 412 "./boost/container_hash/extensions.hpp"
# 761 "./boost/container_hash/hash.hpp" 2
# 28 "./boost/multiprecision/number.hpp" 2
# 44 "./boost/multiprecision/number.hpp"
# 226 "./boost/multiprecision/number.hpp"
# 249 "./boost/multiprecision/number.hpp"
# 307 "./boost/multiprecision/number.hpp"
# 330 "./boost/multiprecision/number.hpp"
# 353 "./boost/multiprecision/number.hpp"
# 385 "./boost/multiprecision/number.hpp"
# 426 "./boost/multiprecision/number.hpp"
# 461 "./boost/multiprecision/number.hpp"
# 510 "./boost/multiprecision/number.hpp"
# 537 "./boost/multiprecision/number.hpp"
# 587 "./boost/multiprecision/number.hpp"
# 631 "./boost/multiprecision/number.hpp"
# 691 "./boost/multiprecision/number.hpp"
# 910 "./boost/multiprecision/number.hpp"
# 935 "./boost/multiprecision/number.hpp"
# 2077 "./boost/multiprecision/number.hpp"
# 1 "./boost/multiprecision/detail/ublas_interop.hpp" 1
# 2277 "./boost/multiprecision/number.hpp" 2
# 13 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/multiprecision/detail/integer_ops.hpp" 1
# 11 "./boost/multiprecision/detail/integer_ops.hpp"
# 14 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/multiprecision/detail/rebind.hpp" 1
# 11 "./boost/multiprecision/detail/rebind.hpp"
# 15 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/core/empty_value.hpp" 1
# 28 "./boost/core/empty_value.hpp"
# 76 "./boost/core/empty_value.hpp"
# 120 "./boost/core/empty_value.hpp"
# 16 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/multiprecision/cpp_int/cpp_int_config.hpp" 1
# 14 "./boost/multiprecision/cpp_int/cpp_int_config.hpp"
# 1 "./boost/assert.hpp" 1
# 58 "./boost/assert.hpp"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 2 3 4
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 59 "./boost/assert.hpp" 2
# 15 "./boost/multiprecision/cpp_int/cpp_int_config.hpp" 2
# 28 "./boost/multiprecision/cpp_int/cpp_int_config.hpp"
# 121 "./boost/multiprecision/cpp_int/cpp_int_config.hpp"
# 20 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/multiprecision/rational_adaptor.hpp" 1
# 12 "./boost/multiprecision/rational_adaptor.hpp"
# 1 "./boost/cstdint.hpp" 1
# 13 "./boost/multiprecision/rational_adaptor.hpp" 2
# 1 "./boost/functional/hash_fwd.hpp" 1
# 14 "./boost/multiprecision/rational_adaptor.hpp" 2
# 1 "./boost/rational.hpp" 1
# 77 "./boost/rational.hpp"
# 1 "./boost/operators.hpp" 1
# 116 "./boost/operators.hpp"
# 259 "./boost/operators.hpp"
# 357 "./boost/operators.hpp"
# 662 "./boost/operators.hpp"
# 679 "./boost/operators.hpp"
# 757 "./boost/operators.hpp"
# 78 "./boost/rational.hpp" 2
# 1 "./boost/call_traits.hpp" 1
# 18 "./boost/call_traits.hpp"
# 1 "./boost/detail/call_traits.hpp" 1
# 31 "./boost/detail/call_traits.hpp"
# 143 "./boost/detail/call_traits.hpp"
# 19 "./boost/call_traits.hpp" 2
# 80 "./boost/rational.hpp" 2
# 1 "./boost/assert.hpp" 1
# 58 "./boost/assert.hpp"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 2 3 4
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 59 "./boost/assert.hpp" 2
# 82 "./boost/rational.hpp" 2
# 1 "./boost/integer/common_factor_rt.hpp" 1
# 10 "./boost/integer/common_factor_rt.hpp"
# 1 "./boost/assert.hpp" 1
# 58 "./boost/assert.hpp"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 2 3 4
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/assert.h" 3 4
# 59 "./boost/assert.hpp" 2
# 11 "./boost/integer/common_factor_rt.hpp" 2
# 42 "./boost/integer/common_factor_rt.hpp"
# 86 "./boost/integer/common_factor_rt.hpp"
# 240 "./boost/integer/common_factor_rt.hpp"
# 504 "./boost/integer/common_factor_rt.hpp"
# 83 "./boost/rational.hpp" 2
# 96 "./boost/rational.hpp"
# 203 "./boost/rational.hpp"
# 339 "./boost/rational.hpp"
# 512 "./boost/rational.hpp"
# 604 "./boost/rational.hpp"
# 835 "./boost/rational.hpp"
# 20 "./boost/multiprecision/rational_adaptor.hpp" 2
# 331 "./boost/multiprecision/rational_adaptor.hpp"
# 21 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/multiprecision/traits/is_byte_container.hpp" 1
# 12 "./boost/multiprecision/traits/is_byte_container.hpp"
# 22 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/predef/other/endian.h" 1
# 23 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/integer/static_min_max.hpp" 1
# 15 "./boost/integer/static_min_max.hpp"
# 24 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/type_traits/common_type.hpp" 1
# 26 "./boost/type_traits/common_type.hpp"
# 1 "./boost/type_traits/detail/mp_defer.hpp" 1
# 15 "./boost/type_traits/detail/mp_defer.hpp"
# 27 "./boost/type_traits/common_type.hpp" 2
# 80 "./boost/type_traits/common_type.hpp"
# 100 "./boost/type_traits/common_type.hpp"
# 134 "./boost/type_traits/common_type.hpp"
# 25 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/type_traits/make_signed.hpp" 1
# 25 "./boost/type_traits/make_signed.hpp"
# 74 "./boost/type_traits/make_signed.hpp"
# 106 "./boost/type_traits/make_signed.hpp"
# 26 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/multiprecision/cpp_int/checked.hpp" 1
# 27 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/multiprecision/cpp_int/value_pack.hpp" 1
# 29 "./boost/multiprecision/cpp_int.hpp" 2
# 45 "./boost/multiprecision/cpp_int.hpp"
# 943 "./boost/multiprecision/cpp_int.hpp"
# 1968 "./boost/multiprecision/cpp_int.hpp"
# 1 "./boost/multiprecision/cpp_int/comparison.hpp" 1
# 13 "./boost/multiprecision/cpp_int/comparison.hpp"
# 23 "./boost/multiprecision/cpp_int/comparison.hpp"
# 1974 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/multiprecision/cpp_int/add.hpp" 1
# 11 "./boost/multiprecision/cpp_int/add.hpp"
# 21 "./boost/multiprecision/cpp_int/add.hpp"
# 1975 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/multiprecision/cpp_int/multiply.hpp" 1
# 11 "./boost/multiprecision/cpp_int/multiply.hpp"
# 392 "./boost/multiprecision/cpp_int/multiply.hpp"
# 440 "./boost/multiprecision/cpp_int/multiply.hpp"
# 1976 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/multiprecision/cpp_int/divide.hpp" 1
# 11 "./boost/multiprecision/cpp_int/divide.hpp"
# 52 "./boost/multiprecision/cpp_int/divide.hpp"
# 1977 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/multiprecision/cpp_int/bitwise.hpp" 1
# 16 "./boost/multiprecision/cpp_int/bitwise.hpp"
# 67 "./boost/multiprecision/cpp_int/bitwise.hpp"
# 450 "./boost/multiprecision/cpp_int/bitwise.hpp"
# 573 "./boost/multiprecision/cpp_int/bitwise.hpp"
# 606 "./boost/multiprecision/cpp_int/bitwise.hpp"
# 1978 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/multiprecision/cpp_int/misc.hpp" 1
# 11 "./boost/multiprecision/cpp_int/misc.hpp"
# 1 "./boost/multiprecision/detail/bitscan.hpp" 1
# 11 "./boost/multiprecision/detail/bitscan.hpp"
# 1 "./boost/predef/other/endian.h" 1
# 12 "./boost/multiprecision/detail/bitscan.hpp" 2
# 1 "./boost/cstdint.hpp" 1
# 13 "./boost/multiprecision/detail/bitscan.hpp" 2
# 122 "./boost/multiprecision/detail/bitscan.hpp"
# 262 "./boost/multiprecision/detail/bitscan.hpp"
# 12 "./boost/multiprecision/cpp_int/misc.hpp" 2
# 1 "./boost/functional/hash_fwd.hpp" 1
# 14 "./boost/multiprecision/cpp_int/misc.hpp" 2
# 23 "./boost/multiprecision/cpp_int/misc.hpp"
# 1979 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/multiprecision/cpp_int/limits.hpp" 1
# 11 "./boost/multiprecision/cpp_int/limits.hpp"
# 1980 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/multiprecision/cpp_int/literals.hpp" 1
# 11 "./boost/multiprecision/cpp_int/literals.hpp"
# 180 "./boost/multiprecision/cpp_int/literals.hpp"
# 1982 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/multiprecision/cpp_int/serialize.hpp" 1
# 1984 "./boost/multiprecision/cpp_int.hpp" 2
# 1 "./boost/multiprecision/cpp_int/import_export.hpp" 1
# 10 "./boost/multiprecision/cpp_int/import_export.hpp"
# 1985 "./boost/multiprecision/cpp_int.hpp" 2
# 2 "main.cpp" 2

































namespace boost{

   __extension__ typedef long long long_long_type;
   __extension__ typedef unsigned long long ulong_long_type;




}



namespace boost{

   __extension__ typedef __int128 int128_type;
   __extension__ typedef unsigned __int128 uint128_type;




}
namespace boost
{

  using ::int8_t;
  using ::int_least8_t;
  using ::int_fast8_t;
  using ::uint8_t;
  using ::uint_least8_t;
  using ::uint_fast8_t;

  using ::int16_t;
  using ::int_least16_t;
  using ::int_fast16_t;
  using ::uint16_t;
  using ::uint_least16_t;
  using ::uint_fast16_t;

  using ::int32_t;
  using ::int_least32_t;
  using ::int_fast32_t;
  using ::uint32_t;
  using ::uint_least32_t;
  using ::uint_fast32_t;



  using ::int64_t;
  using ::int_least64_t;
  using ::int_fast64_t;
  using ::uint64_t;
  using ::uint_least64_t;
  using ::uint_fast64_t;



  using ::intmax_t;
  using ::uintmax_t;

}
namespace boost {
    using ::intptr_t;
    using ::uintptr_t;
}















namespace mpl_ { namespace aux {} }
namespace boost { namespace mpl { using namespace mpl_;
namespace aux { using namespace mpl_::aux; }
}}

namespace mpl_ {

template< bool C_ > struct bool_;


typedef bool_<true> true_;
typedef bool_<false> false_;

}

namespace boost { namespace mpl { using ::mpl_::bool_; } }
namespace boost { namespace mpl { using ::mpl_::true_; } }
namespace boost { namespace mpl { using ::mpl_::false_; } }

namespace mpl_ {
struct integral_c_tag { static const int value = 0; };
}
namespace boost { namespace mpl { using ::mpl_::integral_c_tag; } }


namespace mpl_ {

template< bool C_ > struct bool_
{
    static const bool value = C_;
    typedef integral_c_tag tag;
    typedef bool_ type;
    typedef bool value_type;
    constexpr operator bool() const { return this->value; }
};


template< bool C_ >
bool const bool_<C_>::value;


}
namespace boost { namespace mpl { namespace aux {

template< typename T > struct value_type_wknd
{
    typedef typename T::value_type type;
};
}}}








namespace boost { namespace mpl {



template< typename SourceTag, typename TargetTag > struct numeric_cast
{
    template< typename N > struct apply;
};

}}
namespace mpl_ {

struct void_;

}
namespace boost { namespace mpl { using ::mpl_::void_; } }
namespace mpl_ {


struct na
{
    typedef na type;
    enum { value = 0 };
};

}
namespace boost { namespace mpl { using ::mpl_::na; } }


namespace boost { namespace mpl {

template< typename T >
struct is_na
    : false_
{



};

template<>
struct is_na<na>
    : true_
{



};

template< typename T >
struct is_not_na
    : true_
{



};

template<>
struct is_not_na<na>
    : false_
{



};


template< typename T, typename U > struct if_na
{
    typedef T type;
};

template< typename U > struct if_na<na,U>
{
    typedef U type;
};
}}




namespace mpl_ {

template< int N > struct int_;

}
namespace boost { namespace mpl { using ::mpl_::int_; } }


namespace mpl_ {

template< int N >
struct int_
{
    static const int value = N;





    typedef int_ type;

    typedef int value_type;
    typedef integral_c_tag tag;
    typedef mpl_::int_< static_cast<int>((value + 1)) > next;
    typedef mpl_::int_< static_cast<int>((value - 1)) > prior;






    constexpr operator int() const { return static_cast<int>(this->value); }
};


template< int N >
int const mpl_::int_< N >::value;


}
namespace boost { namespace mpl { namespace aux {

template< typename F > struct template_arity;

}}}

namespace boost { namespace mpl {

template<
      typename T = na
    , typename Tag = void_
    , typename Arity = int_< aux::template_arity<T>::value >


    >
struct lambda;

}}
























namespace boost { namespace mpl { namespace aux {

template< typename T > struct type_wrapper
{
    typedef T type;
};






template< typename T > struct wrapped_type;

template< typename T > struct wrapped_type< type_wrapper<T> >
{
    typedef T type;
};







}}}




namespace boost { namespace mpl { namespace aux {

typedef char (&no_tag)[1];
typedef char (&yes_tag)[2];

template< bool C_ > struct yes_no_tag
{
    typedef no_tag type;
};

template<> struct yes_no_tag<true>
{
    typedef yes_tag type;
};


template< long n > struct weighted_tag
{

    typedef char (&type)[n];




};
}}}






namespace boost { namespace mpl { namespace aux {

template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_apply { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::apply>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };







}}}










namespace boost { namespace mpl {

template<
      typename F

    , typename has_apply_ = typename aux::has_apply<F>::type

    >
struct apply_wrap0

    : F::template apply< >
{
};

template< typename F >
struct apply_wrap0< F,true_ >
    : F::apply
{
};

template<
      typename F, typename T1

    >
struct apply_wrap1

    : F::template apply<T1>
{
};

template<
      typename F, typename T1, typename T2

    >
struct apply_wrap2

    : F::template apply< T1,T2 >
{
};

template<
      typename F, typename T1, typename T2, typename T3

    >
struct apply_wrap3

    : F::template apply< T1,T2,T3 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4

    >
struct apply_wrap4

    : F::template apply< T1,T2,T3,T4 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5

    >
struct apply_wrap5

    : F::template apply< T1,T2,T3,T4,T5 >
{
};

}}




namespace boost { namespace mpl {



template<
      bool C
    , typename T1
    , typename T2
    >
struct if_c
{
    typedef T1 type;
};

template<
      typename T1
    , typename T2
    >
struct if_c<false,T1,T2>
{
    typedef T2 type;
};



template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = na
    >
struct if_
{
 private:

    typedef if_c<



          static_cast<bool>(T1::value)

        , T2
        , T3
        > almost_type_;

 public:
    typedef typename almost_type_::type type;


};
template<> struct if_< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : if_< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< if_< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef if_< na , na , na > result_; typedef if_< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< if_< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< if_< na , na , na > > : int_<-1> { }; }

}}
namespace boost { namespace mpl {

template<
      typename C = na
    , typename F1 = na
    , typename F2 = na
    >
struct eval_if




{
    typedef typename if_<C,F1,F2>::type f_;
    typedef typename f_::type type;





};



template<
      bool C
    , typename F1
    , typename F2
    >
struct eval_if_c




{
    typedef typename if_c<C,F1,F2>::type f_;
    typedef typename f_::type type;




};

template<> struct eval_if< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : eval_if< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< eval_if< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef eval_if< na , na , na > result_; typedef eval_if< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< eval_if< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< eval_if< na , na , na > > : int_<-1> { }; }

}}
namespace mpl_ {





struct void_ { typedef void_ type; };

}

namespace boost { namespace mpl {

template< typename T >
struct is_void_
    : false_
{



};

template<>
struct is_void_<void_>
    : true_
{



};

template< typename T >
struct is_not_void_
    : true_
{



};

template<>
struct is_not_void_<void_>
    : false_
{



};

template<> struct is_void_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_void_< T1 > { }; }; template< typename Tag > struct lambda< is_void_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_void_< na > result_; typedef is_void_< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_void_< T1 > > : int_<1> { }; template<> struct template_arity< is_void_< na > > : int_<-1> { }; }
template<> struct is_not_void_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_not_void_< T1 > { }; }; template< typename Tag > struct lambda< is_not_void_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_not_void_< na > result_; typedef is_not_void_< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_not_void_< T1 > > : int_<1> { }; template<> struct template_arity< is_not_void_< na > > : int_<-1> { }; }

}}
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_tag { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::tag>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}


namespace boost { namespace mpl {

namespace aux {
template< typename T > struct tag_impl
{
    typedef typename T::tag type;
};
}

template< typename T, typename Default = void_ > struct tag

    : if_<
          aux::has_tag<T>
        , aux::tag_impl<T>
        , Default
        >::type
{
};

}}

namespace boost { namespace mpl { namespace aux {

template<
      typename F
    , typename Tag1
    , typename Tag2
    >
struct cast1st_impl
{
    template< typename N1, typename N2 > struct apply

        : apply_wrap2<
              F
            , typename apply_wrap1< numeric_cast<Tag1,Tag2>,N1 >::type
            , N2
            >
    {
    };
};

template<
      typename F
    , typename Tag1
    , typename Tag2
    >
struct cast2nd_impl
{
    template< typename N1, typename N2 > struct apply

        : apply_wrap2<
              F
            , N1
            , typename apply_wrap1< numeric_cast<Tag2,Tag1>,N2 >::type
            >
    {
    };
};

}}}



namespace boost { namespace mpl { namespace aux {
}}}




namespace boost { namespace mpl { namespace aux {
template< typename T > struct msvc_eti_base
    : T
{

    msvc_eti_base();

    typedef T type;
};



template<> struct msvc_eti_base<int>
{
    typedef msvc_eti_base type;
    typedef msvc_eti_base first;
    typedef msvc_eti_base second;
    typedef msvc_eti_base tag;
    enum { value = 0 };
};

}}}







namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct less_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< less_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< less_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct less_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct less_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct less_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct less_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct less

    : less_impl<
          typename less_tag<N1>::type
        , typename less_tag<N2>::type
        >::template apply< N1,N2 >::type
{


};

template<> struct less< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : less< T1 , T2 > { }; }; template< typename Tag > struct lambda< less< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef less< na , na > result_; typedef less< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< less< T1 , T2 > > : int_<2> { }; template<> struct template_arity< less< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct less_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N2::value > N1::value ) >
    {
    };
};

}}



namespace boost { namespace mpl {

template<
      typename N1 = na
    , typename N2 = na
    >
struct min
    : if_< less<N1,N2>,N1,N2 >
{
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct max
    : if_< less<N1,N2>,N2,N1 >
{
};

template<> struct min< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : min< T1 , T2 > { }; }; template< typename Tag > struct lambda< min< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef min< na , na > result_; typedef min< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< min< T1 , T2 > > : int_<2> { }; template<> struct template_arity< min< na , na > > : int_<-1> { }; }
template<> struct max< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : max< T1 , T2 > { }; }; template< typename Tag > struct lambda< max< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef max< na , na > result_; typedef max< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< max< T1 , T2 > > : int_<2> { }; template<> struct template_arity< max< na , na > > : int_<-1> { }; }

}}
namespace mpl_ {





template< typename T, T N > struct integral_c;


}
namespace boost { namespace mpl { using ::mpl_::integral_c; } }
namespace mpl_ {

template< typename T, T N >
struct integral_c
{
    static const T value = N;





    typedef integral_c type;

    typedef T value_type;
    typedef integral_c_tag tag;
    typedef integral_c< T, static_cast<T>((value + 1)) > next;
    typedef integral_c< T, static_cast<T>((value - 1)) > prior;






    constexpr operator T() const { return static_cast<T>(this->value); }
};


template< typename T, T N >
T const integral_c< T, N >::value;


}




namespace mpl_ {

template< bool C >
struct integral_c<bool, C>
{
    static const bool value = C;
    typedef integral_c_tag tag;
    typedef integral_c type;
    typedef bool value_type;
    operator bool() const { return this->value; }
};
}
namespace boost { namespace mpl { namespace aux {

template< typename T > struct integral_rank;

template<> struct integral_rank<bool> : int_<1> {};
template<> struct integral_rank<signed char> : int_<2> {};
template<> struct integral_rank<char> : int_<3> {};
template<> struct integral_rank<unsigned char> : int_<4> {};

template<> struct integral_rank<wchar_t> : int_<5> {};

template<> struct integral_rank<short> : int_<6> {};
template<> struct integral_rank<unsigned short> : int_<7> {};
template<> struct integral_rank<int> : int_<8> {};
template<> struct integral_rank<unsigned int> : int_<9> {};
template<> struct integral_rank<long> : int_<10> {};
template<> struct integral_rank<unsigned long> : int_<11> {};


template<> struct integral_rank<long_long_type> : int_<12> {};
template<> struct integral_rank<ulong_long_type>: int_<13> {};


template< typename T1, typename T2 > struct largest_int

    : if_c<
          ( integral_rank<T1>::value >= integral_rank<T2>::value )
        , T1
        , T2
        >
{






};

}}}














namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct plus_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< plus_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< plus_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct plus_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct plus_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct plus_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct plus_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    , typename N3 = na, typename N4 = na, typename N5 = na
    >
struct plus
    : plus< plus< plus< plus< N1,N2 >, N3>, N4>, N5>
{





};

template<
      typename N1, typename N2, typename N3, typename N4
    >
struct plus< N1,N2,N3,N4,na >

    : plus< plus< plus< N1,N2 >, N3>, N4>
{





};

template<
      typename N1, typename N2, typename N3
    >
struct plus< N1,N2,N3,na,na >

    : plus< plus< N1,N2 >, N3>
{





};

template<
      typename N1, typename N2
    >
struct plus< N1,N2,na,na,na >
    : plus_impl<
          typename plus_tag<N1>::type
        , typename plus_tag<N2>::type
        >::template apply< N1,N2 >::type
{






};

template<> struct plus< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : plus< T1 , T2 > { }; }; template< typename Tag > struct lambda< plus< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef plus< na , na > result_; typedef plus< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< plus< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< plus< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {
template<>
struct plus_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : integral_c<
              typename aux::largest_int<
                  typename N1::value_type
                , typename N2::value_type
                >::type
            , ( N1::value
                  + N2::value
                )
            >
    {
    };
};

}}
namespace boost { namespace mpl { namespace aux {
template< typename T > struct nested_type_wknd
    : T::type
{
};
}}}
namespace boost { namespace mpl {

namespace aux {

template< bool C_, typename T1, typename T2, typename T3, typename T4 >
struct or_impl
    : true_
{
};

template< typename T1, typename T2, typename T3, typename T4 >
struct or_impl< false,T1,T2,T3,T4 >
    : or_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4
        , false_
        >
{
};

template<>
struct or_impl<
          false
        , false_, false_, false_, false_
        >
    : false_
{
};

}

template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = false_, typename T4 = false_, typename T5 = false_
    >
struct or_

    : aux::or_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4, T5
        >

{





};

template<> struct or_< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : or_< T1 , T2 > { }; }; template< typename Tag > struct lambda< or_< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef or_< na , na > result_; typedef or_< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< or_< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< or_< na , na > > : int_<-1> { }; }





}}
namespace boost { namespace mpl {

template<
      typename F, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na
    >
struct apply;

template<
      typename F
    >
struct apply0;

template<
      typename F, typename T1
    >
struct apply1;

template<
      typename F, typename T1, typename T2
    >
struct apply2;

template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply3;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply4;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply5;

}}
namespace mpl_ {

template< int N > struct arg;

}
namespace boost { namespace mpl { using ::mpl_::arg; } }

namespace boost { namespace mpl {

namespace aux {

template< long C_ >
struct not_impl
    : bool_<!C_>
{
};

}


template<
      typename T = na
    >
struct not_
    : aux::not_impl<
          ::boost::mpl::aux::nested_type_wknd<T>::value
        >
{

};

template<> struct not_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : not_< T1 > { }; }; template< typename Tag > struct lambda< not_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef not_< na > result_; typedef not_< na > type; }; namespace aux { template< typename T1 > struct template_arity< not_< T1 > > : int_<1> { }; template<> struct template_arity< not_< na > > : int_<-1> { }; }

}}



namespace mpl_ {

struct failed {};
template< bool C > struct assert { typedef void* type; };
template<> struct assert<false> { typedef assert type; };

template< bool C >
int assertion_failed( typename assert<C>::type );

template< bool C >
struct assertion
{
    static int failed( assert<false> );
};

template<>
struct assertion<true>
{
    static int failed( void* );
};

struct assert_
{

    template< typename T1, typename T2 = na, typename T3 = na, typename T4 = na > struct types {};

    static assert_ const arg;
    enum relations { equal = 1, not_equal, greater, greater_equal, less, less_equal };
};
boost::mpl::aux::weighted_tag<1>::type operator==( assert_, assert_ );
boost::mpl::aux::weighted_tag<2>::type operator!=( assert_, assert_ );
boost::mpl::aux::weighted_tag<3>::type operator>( assert_, assert_ );
boost::mpl::aux::weighted_tag<4>::type operator>=( assert_, assert_ );
boost::mpl::aux::weighted_tag<5>::type operator<( assert_, assert_ );
boost::mpl::aux::weighted_tag<6>::type operator<=( assert_, assert_ );

template< assert_::relations r, long x, long y > struct assert_relation {};
template< bool > struct assert_arg_pred_impl { typedef int type; };
template<> struct assert_arg_pred_impl<true> { typedef void* type; };

template< typename P > struct assert_arg_pred
{
    typedef typename P::type p_type;
    typedef typename assert_arg_pred_impl< p_type::value >::type type;
};

template< typename P > struct assert_arg_pred_not
{
    typedef typename P::type p_type;
    enum { p = !p_type::value };
    typedef typename assert_arg_pred_impl<p>::type type;
};







template< typename Pred >
failed ************ (Pred::************
      assert_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type )
    );

template< typename Pred >
failed ************ (boost::mpl::not_<Pred>::************
      assert_not_arg( void (*)(Pred), typename assert_arg_pred_not<Pred>::type )
    );






template< typename Pred >
assert<false>
assert_arg( void (*)(Pred), typename assert_arg_pred_not<Pred>::type );

template< typename Pred >
assert<false>
assert_not_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type );
}
namespace mpl_ {
template<> struct arg< -1 >
{
    static const int value = -1;



    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U1 type;
        enum { mpl_assertion_in_line_27 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<1>
{
    static const int value = 1;
    typedef arg<2> next;



    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U1 type;
        enum { mpl_assertion_in_line_45 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<2>
{
    static const int value = 2;
    typedef arg<3> next;



    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U2 type;
        enum { mpl_assertion_in_line_63 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<3>
{
    static const int value = 3;
    typedef arg<4> next;



    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U3 type;
        enum { mpl_assertion_in_line_81 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<4>
{
    static const int value = 4;
    typedef arg<5> next;



    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U4 type;
        enum { mpl_assertion_in_line_99 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<5>
{
    static const int value = 5;
    typedef arg<6> next;



    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U5 type;
        enum { mpl_assertion_in_line_117 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};



}
namespace mpl_ {
typedef arg< -1 > _;
}
namespace boost { namespace mpl {

using ::mpl_::_;

namespace placeholders {
using mpl_::_;
}

}}



namespace mpl_ {
typedef arg<1> _1;

}
namespace boost { namespace mpl {

using ::mpl_::_1;

namespace placeholders {
using mpl_::_1;
}

}}
namespace mpl_ {
typedef arg<2> _2;

}
namespace boost { namespace mpl {

using ::mpl_::_2;

namespace placeholders {
using mpl_::_2;
}

}}
namespace mpl_ {
typedef arg<3> _3;

}
namespace boost { namespace mpl {

using ::mpl_::_3;

namespace placeholders {
using mpl_::_3;
}

}}
namespace mpl_ {
typedef arg<4> _4;

}
namespace boost { namespace mpl {

using ::mpl_::_4;

namespace placeholders {
using mpl_::_4;
}

}}
namespace mpl_ {
typedef arg<5> _5;

}
namespace boost { namespace mpl {

using ::mpl_::_5;

namespace placeholders {
using mpl_::_5;
}

}}
namespace mpl_ {
typedef arg<6> _6;

}
namespace boost { namespace mpl {

using ::mpl_::_6;

namespace placeholders {
using mpl_::_6;
}

}}






namespace boost { namespace mpl {

template<
      typename F, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na
    >
struct bind;

template<
      typename F
    >
struct bind0;

template<
      typename F, typename T1
    >
struct bind1;

template<
      typename F, typename T1, typename T2
    >
struct bind2;

template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind3;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind4;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind5;

}}



namespace boost { namespace mpl {




template<
      typename T = na
    >
struct next
{
    typedef typename T::next type;

};

template<
      typename T = na
    >
struct prior
{
    typedef typename T::prior type;

};

template<> struct next< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : next< T1 > { }; }; template< typename Tag > struct lambda< next< na > , Tag , int_<-1> > { typedef false_ is_le; typedef next< na > result_; typedef next< na > type; }; namespace aux { template< typename T1 > struct template_arity< next< T1 > > : int_<1> { }; template<> struct template_arity< next< na > > : int_<-1> { }; }
template<> struct prior< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : prior< T1 > { }; }; template< typename Tag > struct lambda< prior< na > , Tag , int_<-1> > { typedef false_ is_le; typedef prior< na > result_; typedef prior< na > type; }; namespace aux { template< typename T1 > struct template_arity< prior< T1 > > : int_<1> { }; template<> struct template_arity< prior< na > > : int_<-1> { }; }

}}
namespace boost { namespace mpl {

template<
      typename T = na
    , int not_le_ = 0
    >
struct protect : T
{



    typedef protect type;

};
template<> struct protect< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : protect< T1 > { }; };

namespace aux { template< typename T1 > struct template_arity< protect< T1 > > : int_<1> { }; template<> struct template_arity< protect< na > > : int_<-1> { }; }


}}
namespace boost { namespace mpl {

namespace aux {

template<
      typename T, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg
{
    typedef T type;
};

template<
      typename T
    , typename Arg
    >
struct replace_unnamed_arg
{
    typedef Arg next;
    typedef T type;
};

template<
      typename Arg
    >
struct replace_unnamed_arg< arg< -1 >, Arg >
{
    typedef typename Arg::next next;
    typedef Arg type;
};

template<
      int N, typename U1, typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg< arg<N>, U1, U2, U3, U4, U5 >
{
    typedef typename apply_wrap5<mpl::arg<N>, U1, U2, U3, U4, U5>::type type;
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg< bind< F,T1,T2,T3,T4,T5 >, U1, U2, U3, U4, U5 >
{
    typedef bind< F,T1,T2,T3,T4,T5 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}

template<
      typename F
    >
struct bind0
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

     public:
        typedef typename apply_wrap0<
              f_
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg<
      bind0<F>, U1, U2, U3, U4, U5
    >
{
    typedef bind0<F> f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 > struct template_arity< bind0< T1> > : int_<1> { }; }

template<
      typename F
    >
struct bind< F,na,na,na,na,na >
    : bind0<F>
{
};

template<
      typename F, typename T1
    >
struct bind1
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

     public:
        typedef typename apply_wrap1<
              f_
            , typename t1::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename U1, typename U2, typename U3
    , typename U4, typename U5
    >
struct resolve_bind_arg<
      bind1< F,T1 >, U1, U2, U3, U4, U5
    >
{
    typedef bind1< F,T1 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 > struct template_arity< bind1< T1 , T2> > : int_<2> { }; }

template<
      typename F, typename T1
    >
struct bind< F,T1,na,na,na,na >
    : bind1< F,T1 >
{
};

template<
      typename F, typename T1, typename T2
    >
struct bind2
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

     public:
        typedef typename apply_wrap2<
              f_
            , typename t1::type, typename t2::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename U1, typename U2
    , typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind2< F,T1,T2 >, U1, U2, U3, U4, U5
    >
{
    typedef bind2< F,T1,T2 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< bind2< T1 , T2 , T3> > : int_<3> { }; }

template<
      typename F, typename T1, typename T2
    >
struct bind< F,T1,T2,na,na,na >
    : bind2< F,T1,T2 >
{
};

template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind3
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

     public:
        typedef typename apply_wrap3<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename T3, typename U1
    , typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind3< F,T1,T2,T3 >, U1, U2, U3, U4, U5
    >
{
    typedef bind3< F,T1,T2,T3 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 > struct template_arity< bind3< T1 , T2 , T3 , T4> > : int_<4> { }; }

template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind< F,T1,T2,T3,na,na >
    : bind3< F,T1,T2,T3 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind4
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef aux::replace_unnamed_arg< T4,n4 > r4;
        typedef typename r4::type a4;
        typedef typename r4::next n5;
        typedef aux::resolve_bind_arg< a4,U1,U2,U3,U4,U5 > t4;

     public:
        typedef typename apply_wrap4<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            , typename t4::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename U1, typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind4< F,T1,T2,T3,T4 >, U1, U2, U3, U4, U5
    >
{
    typedef bind4< F,T1,T2,T3,T4 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< bind4< T1 , T2 , T3 , T4 , T5> > : int_<5> { }; }

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind< F,T1,T2,T3,T4,na >
    : bind4< F,T1,T2,T3,T4 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind5
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef aux::replace_unnamed_arg< T4,n4 > r4;
        typedef typename r4::type a4;
        typedef typename r4::next n5;
        typedef aux::resolve_bind_arg< a4,U1,U2,U3,U4,U5 > t4;

        typedef aux::replace_unnamed_arg< T5,n5 > r5;
        typedef typename r5::type a5;
        typedef typename r5::next n6;
        typedef aux::resolve_bind_arg< a5,U1,U2,U3,U4,U5 > t5;

     public:
        typedef typename apply_wrap5<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            , typename t4::type, typename t5::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg<
      bind5< F,T1,T2,T3,T4,T5 >, U1, U2, U3, U4, U5
    >
{
    typedef bind5< F,T1,T2,T3,T4,T5 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > struct template_arity< bind5< T1 , T2 , T3 , T4 , T5 , T6> > : int_<6> { }; }



template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind
    : bind5< F,T1,T2,T3,T4,T5 >
{
};


template< template< typename T1, typename T2, typename T3 > class F, typename Tag >
struct quote3;

template< typename T1, typename T2, typename T3 > struct if_;

template<
      typename Tag, typename T1, typename T2, typename T3
    >
struct bind3<
      quote3< if_,Tag >
    , T1, T2, T3
    >
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef mpl::arg<1> n1;
        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef typename if_<
              typename t1::type
            , t2, t3
            >::type f_;

     public:
        typedef typename f_::type type;
    };
};

template<
      template< typename T1, typename T2, typename T3 > class F, typename Tag
    >
struct quote3;

template< typename T1, typename T2, typename T3 > struct eval_if;

template<
      typename Tag, typename T1, typename T2, typename T3
    >
struct bind3<
      quote3< eval_if,Tag >
    , T1, T2, T3
    >
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef mpl::arg<1> n1;
        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef typename eval_if<
              typename t1::type
            , t2, t3
            >::type f_;

     public:
        typedef typename f_::type type;
    };
};

}}




namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<true> > struct has_type { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::type>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}


namespace boost { namespace mpl {

template< typename T, bool has_type_ >
struct quote_impl
{
    typedef typename T::type type;
};

template< typename T >
struct quote_impl< T,false >
{
    typedef T type;
};

template<
      template< typename P1 > class F
    , typename Tag = void_
    >
struct quote1
{
    template< typename U1 > struct apply

        : quote_impl<
              F<U1>
            , aux::has_type< F<U1> >::value
            >

    {
    };
};

template<
      template< typename P1, typename P2 > class F
    , typename Tag = void_
    >
struct quote2
{
    template< typename U1, typename U2 > struct apply

        : quote_impl<
              F< U1,U2 >
            , aux::has_type< F< U1,U2 > >::value
            >

    {
    };
};

template<
      template< typename P1, typename P2, typename P3 > class F
    , typename Tag = void_
    >
struct quote3
{
    template< typename U1, typename U2, typename U3 > struct apply

        : quote_impl<
              F< U1,U2,U3 >
            , aux::has_type< F< U1,U2,U3 > >::value
            >

    {
    };
};

template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename Tag = void_
    >
struct quote4
{
    template<
          typename U1, typename U2, typename U3, typename U4
        >
    struct apply

        : quote_impl<
              F< U1,U2,U3,U4 >
            , aux::has_type< F< U1,U2,U3,U4 > >::value
            >

    {
    };
};

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename Tag = void_
    >
struct quote5
{
    template<
          typename U1, typename U2, typename U3, typename U4
        , typename U5
        >
    struct apply

        : quote_impl<
              F< U1,U2,U3,U4,U5 >
            , aux::has_type< F< U1,U2,U3,U4,U5 > >::value
            >

    {
    };
};

}}


namespace boost { namespace mpl { namespace aux {
template< int N > struct arity_tag
{
    typedef char (&type)[N + 1];
};

template<
      int C1, int C2, int C3, int C4, int C5, int C6
    >
struct max_arity
{
    static const int value = ( C6 > 0 ? C6 : ( C5 > 0 ? C5 : ( C4 > 0 ? C4 : ( C3 > 0 ? C3 : ( C2 > 0 ? C2 : ( C1 > 0 ? C1 : -1 ) ) ) ) ) );


};

arity_tag<0>::type arity_helper(...);

template<
      template< typename P1 > class F
    , typename T1
    >
typename arity_tag<1>::type
arity_helper(type_wrapper< F<T1> >, arity_tag<1>);

template<
      template< typename P1, typename P2 > class F
    , typename T1, typename T2
    >
typename arity_tag<2>::type
arity_helper(type_wrapper< F< T1,T2 > >, arity_tag<2>);

template<
      template< typename P1, typename P2, typename P3 > class F
    , typename T1, typename T2, typename T3
    >
typename arity_tag<3>::type
arity_helper(type_wrapper< F< T1,T2,T3 > >, arity_tag<3>);

template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename T1, typename T2, typename T3, typename T4
    >
typename arity_tag<4>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4 > >, arity_tag<4>);

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    >
typename arity_tag<5>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4,T5 > >, arity_tag<5>);

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5, typename P6
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    , typename T6
    >
typename arity_tag<6>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4,T5,T6 > >, arity_tag<6>);
template< typename F, int N >
struct template_arity_impl
{
    static const int value = sizeof(::boost::mpl::aux::arity_helper(type_wrapper<F>(), arity_tag<N>())) - 1;


};

template< typename F >
struct template_arity
{
    static const int value = ( max_arity< template_arity_impl< F,1 >::value, template_arity_impl< F,2 >::value, template_arity_impl< F,3 >::value, template_arity_impl< F,4 >::value, template_arity_impl< F,5 >::value, template_arity_impl< F,6 >::value >::value );


    typedef mpl::int_<value> type;
};

}}}
namespace boost { namespace mpl {

namespace aux {

template<
      bool C1 = false, bool C2 = false, bool C3 = false, bool C4 = false
    , bool C5 = false
    >
struct lambda_or
    : true_
{
};

template<>
struct lambda_or< false,false,false,false,false >
    : false_
{
};

}

template<
      typename T
    , typename Tag
    , typename Arity
    >
struct lambda
{
    typedef false_ is_le;
    typedef T result_;
    typedef T type;
};

template<
      typename T
    >
struct is_lambda_expression
    : lambda<T>::is_le
{
};

template< int N, typename Tag >
struct lambda< arg<N>,Tag, int_< -1 > >
{
    typedef true_ is_le;
    typedef mpl::arg<N> result_;
    typedef mpl::protect<result_> type;
};

template<
      typename F
    , typename Tag
    >
struct lambda<
          bind0<F>
        , Tag
        , int_<1>
        >
{
    typedef false_ is_le;
    typedef bind0<
          F
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1 > class F
    , typename L1
    >
struct le_result1
{
    typedef F<
          typename L1::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1 > class F
    , typename L1
    >
struct le_result1< true_,Tag,F,L1 >
{
    typedef bind1<
          quote1< F,Tag >
        , typename L1::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1 > class F
    , typename T1
    , typename Tag
    >
struct lambda<
          F<T1>
        , Tag
        , int_<1>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef typename l1::is_le is_le1;
    typedef typename aux::lambda_or<
          is_le1::value
        >::type is_le;

    typedef aux::le_result1<
          is_le, Tag, F, l1
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1
    , typename Tag
    >
struct lambda<
          bind1< F,T1 >
        , Tag
        , int_<2>
        >
{
    typedef false_ is_le;
    typedef bind1<
          F
        , T1
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2 > class F
    , typename L1, typename L2
    >
struct le_result2
{
    typedef F<
          typename L1::type, typename L2::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2 > class F
    , typename L1, typename L2
    >
struct le_result2< true_,Tag,F,L1,L2 >
{
    typedef bind2<
          quote2< F,Tag >
        , typename L1::result_, typename L2::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1, typename P2 > class F
    , typename T1, typename T2
    , typename Tag
    >
struct lambda<
          F< T1,T2 >
        , Tag
        , int_<2>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value
        >::type is_le;

    typedef aux::le_result2<
          is_le, Tag, F, l1, l2
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2
    , typename Tag
    >
struct lambda<
          bind2< F,T1,T2 >
        , Tag
        , int_<3>
        >
{
    typedef false_ is_le;
    typedef bind2<
          F
        , T1, T2
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3 > class F
    , typename L1, typename L2, typename L3
    >
struct le_result3
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2, typename P3 > class F
    , typename L1, typename L2, typename L3
    >
struct le_result3< true_,Tag,F,L1,L2,L3 >
{
    typedef bind3<
          quote3< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1, typename P2, typename P3 > class F
    , typename T1, typename T2, typename T3
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3 >
        , Tag
        , int_<3>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value
        >::type is_le;

    typedef aux::le_result3<
          is_le, Tag, F, l1, l2, l3
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2, typename T3
    , typename Tag
    >
struct lambda<
          bind3< F,T1,T2,T3 >
        , Tag
        , int_<4>
        >
{
    typedef false_ is_le;
    typedef bind3<
          F
        , T1, T2, T3
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename L1, typename L2, typename L3, typename L4
    >
struct le_result4
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        , typename L4::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename L1, typename L2, typename L3, typename L4
    >
struct le_result4< true_,Tag,F,L1,L2,L3,L4 >
{
    typedef bind4<
          quote4< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        , typename L4::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename T1, typename T2, typename T3, typename T4
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3,T4 >
        , Tag
        , int_<4>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;
    typedef lambda< T4,Tag > l4;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;
    typedef typename l4::is_le is_le4;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value, is_le4::value
        >::type is_le;

    typedef aux::le_result4<
          is_le, Tag, F, l1, l2, l3, l4
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename Tag
    >
struct lambda<
          bind4< F,T1,T2,T3,T4 >
        , Tag
        , int_<5>
        >
{
    typedef false_ is_le;
    typedef bind4<
          F
        , T1, T2, T3, T4
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3, typename P4, typename P5 > class F
    , typename L1, typename L2, typename L3, typename L4, typename L5
    >
struct le_result5
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        , typename L4::type, typename L5::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2, typename P3, typename P4, typename P5 > class F
    , typename L1, typename L2, typename L3, typename L4, typename L5
    >
struct le_result5< true_,Tag,F,L1,L2,L3,L4,L5 >
{
    typedef bind5<
          quote5< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        , typename L4::result_, typename L5::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3,T4,T5 >
        , Tag
        , int_<5>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;
    typedef lambda< T4,Tag > l4;
    typedef lambda< T5,Tag > l5;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;
    typedef typename l4::is_le is_le4;
    typedef typename l5::is_le is_le5;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value, is_le4::value
        , is_le5::value
        >::type is_le;

    typedef aux::le_result5<
          is_le, Tag, F, l1, l2, l3, l4, l5
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    , typename Tag
    >
struct lambda<
          bind5< F,T1,T2,T3,T4,T5 >
        , Tag
        , int_<6>
        >
{
    typedef false_ is_le;
    typedef bind5<
          F
        , T1, T2, T3, T4, T5
        > result_;

    typedef result_ type;
};


template< typename T, typename Tag >
struct lambda< mpl::protect<T>,Tag, int_<1> >
{
    typedef false_ is_le;
    typedef mpl::protect<T> result_;
    typedef result_ type;
};



template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    , typename Tag
    >
struct lambda<
          bind< F,T1,T2,T3,T4,T5 >
        , Tag
        , int_<6>
        >
{
    typedef false_ is_le;
    typedef bind< F,T1,T2,T3,T4,T5 > result_;
    typedef result_ type;
};

template<
      typename F
    , typename Tag1
    , typename Tag2
    , typename Arity
    >
struct lambda<
          lambda< F,Tag1,Arity >
        , Tag2
        , int_<3>
        >
{
    typedef lambda< F,Tag2 > l1;
    typedef lambda< Tag1,Tag2 > l2;
    typedef typename l1::is_le is_le;
    typedef bind1< quote1<aux::template_arity>, typename l1::result_ > arity_;
    typedef lambda< typename if_< is_le,arity_,Arity >::type, Tag2 > l3;
    typedef aux::le_result3<is_le, Tag2, mpl::lambda, l1, l2, l3> le_result_;
    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<> struct lambda< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : lambda< T1 , T2 > { }; }; template< typename Tag > struct lambda< lambda< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef lambda< na , na > result_; typedef lambda< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< lambda< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< lambda< na , na > > : int_<-1> { }; }

}}
namespace boost { namespace mpl {

template<
      typename F
    >
struct apply0

    : apply_wrap0<
          typename lambda<F>::type

        >
{





};

template<
      typename F
    >
struct apply< F,na,na,na,na,na >
    : apply0<F>
{
};

template<
      typename F, typename T1
    >
struct apply1

    : apply_wrap1<
          typename lambda<F>::type
        , T1
        >
{





};

template<
      typename F, typename T1
    >
struct apply< F,T1,na,na,na,na >
    : apply1< F,T1 >
{
};

template<
      typename F, typename T1, typename T2
    >
struct apply2

    : apply_wrap2<
          typename lambda<F>::type
        , T1, T2
        >
{





};

template<
      typename F, typename T1, typename T2
    >
struct apply< F,T1,T2,na,na,na >
    : apply2< F,T1,T2 >
{
};

template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply3

    : apply_wrap3<
          typename lambda<F>::type
        , T1, T2, T3
        >
{





};

template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply< F,T1,T2,T3,na,na >
    : apply3< F,T1,T2,T3 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply4

    : apply_wrap4<
          typename lambda<F>::type
        , T1, T2, T3, T4
        >
{





};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply< F,T1,T2,T3,T4,na >
    : apply4< F,T1,T2,T3,T4 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply5

    : apply_wrap5<
          typename lambda<F>::type
        , T1, T2, T3, T4, T5
        >
{





};



template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply
    : apply5< F,T1,T2,T3,T4,T5 >
{
};

}}
namespace boost { namespace mpl { namespace aux {
template< typename T > struct msvc_type
{
    typedef typename T::type type;
};

template<> struct msvc_type<int>
{
    typedef int type;
};



}}}




namespace boost { namespace mpl {

template<
      typename Iterator = na
    >
struct deref
{

    typedef typename Iterator::type type;




};

template<> struct deref< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : deref< T1 > { }; }; template< typename Tag > struct lambda< deref< na > , Tag , int_<-1> > { typedef false_ is_le; typedef deref< na > result_; typedef deref< na > type; }; namespace aux { template< typename T1 > struct template_arity< deref< T1 > > : int_<1> { }; template<> struct template_arity< deref< na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl { namespace aux {

template<
      typename F
    , typename Iterator
    >
struct iter_apply1
    : apply1< F,typename deref<Iterator>::type >
{
};

template<
      typename F
    , typename Iterator1
    , typename Iterator2
    >
struct iter_apply2
    : apply2<
          F
        , typename deref<Iterator1>::type
        , typename deref<Iterator2>::type
        >
{
};

}}}


namespace boost { namespace mpl { namespace aux {

template< typename Predicate >
struct find_if_pred
{
    template< typename Iterator >
    struct apply
    {
        typedef not_< aux::iter_apply1<Predicate,Iterator> > type;
    };
};

}}}
namespace boost { namespace mpl {

template< typename Tag > struct begin_impl;
template< typename Tag > struct end_impl;

template< typename Sequence > struct begin;
template< typename Sequence > struct end;

}}
namespace boost { namespace mpl {

struct nested_begin_end_tag;
struct non_sequence_tag;

template< typename Sequence > struct sequence_tag;

}}


namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<true> > struct has_begin { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::begin>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}



namespace boost { namespace mpl {


namespace aux {

template< typename Sequence >
struct begin_type
{
    typedef typename Sequence::begin type;
};
template< typename Sequence >
struct end_type
{
    typedef typename Sequence::end type;
};

}





template< typename Tag >
struct begin_impl
{
    template< typename Sequence > struct apply
    {
        typedef typename eval_if<aux::has_begin<Sequence, true_>,
                                 aux::begin_type<Sequence>, void_>::type type;
    };
};

template< typename Tag >
struct end_impl
{
    template< typename Sequence > struct apply
    {
        typedef typename eval_if<aux::has_begin<Sequence, true_>,
                                 aux::end_type<Sequence>, void_>::type type;
    };
};
template<> struct begin_impl<nested_begin_end_tag> { template< typename Sequence > struct apply { typedef typename Sequence::begin type; }; };
template<> struct end_impl<nested_begin_end_tag> { template< typename Sequence > struct apply { typedef typename Sequence::end type; }; };




template<> struct begin_impl<non_sequence_tag> { template< typename Sequence > struct apply { typedef void_ type; }; };
template<> struct end_impl<non_sequence_tag> { template< typename Sequence > struct apply { typedef void_ type; }; };
template<> struct begin_impl<na> { template< typename Sequence > struct apply { typedef void_ type; }; };
template<> struct end_impl<na> { template< typename Sequence > struct apply { typedef void_ type; }; };







}}
namespace boost { namespace mpl {
namespace aux {

template< bool has_tag_, bool has_begin_ >
struct sequence_tag_impl
{


    template< typename Sequence > struct result2_;
};
template<> struct sequence_tag_impl<true,true> { template< typename Sequence > struct result2_ { typedef typename Sequence::tag type; }; };
template<> struct sequence_tag_impl<true,false> { template< typename Sequence > struct result2_ { typedef typename Sequence::tag type; }; };
template<> struct sequence_tag_impl<false,true> { template< typename Sequence > struct result2_ { typedef nested_begin_end_tag type; }; };
template<> struct sequence_tag_impl<false,false> { template< typename Sequence > struct result2_ { typedef non_sequence_tag type; }; };



}

template<
      typename Sequence = na
    >
struct sequence_tag
    : aux::sequence_tag_impl<
          ::boost::mpl::aux::has_tag<Sequence>::value
        , ::boost::mpl::aux::has_begin<Sequence>::value
        >::template result2_<Sequence>
{
};



template<> struct sequence_tag< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : sequence_tag< T1 > { }; }; template< typename Tag > struct lambda< sequence_tag< na > , Tag , int_<-1> > { typedef false_ is_le; typedef sequence_tag< na > result_; typedef sequence_tag< na > type; }; namespace aux { template< typename T1 > struct template_arity< sequence_tag< T1 > > : int_<1> { }; template<> struct template_arity< sequence_tag< na > > : int_<-1> { }; }

}}



namespace boost { namespace mpl {




template<
      typename Sequence = na
    >
struct begin
{
    typedef typename sequence_tag<Sequence>::type tag_;
    typedef typename begin_impl< tag_ >
        ::template apply< Sequence >::type type;


};

template<
      typename Sequence = na
    >
struct end
{
    typedef typename sequence_tag<Sequence>::type tag_;
    typedef typename end_impl< tag_ >
        ::template apply< Sequence >::type type;


};

template<> struct begin< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : begin< T1 > { }; }; template< typename Tag > struct lambda< begin< na > , Tag , int_<-1> > { typedef false_ is_le; typedef begin< na > result_; typedef begin< na > type; }; namespace aux { template< typename T1 > struct template_arity< begin< T1 > > : int_<1> { }; template<> struct template_arity< begin< na > > : int_<-1> { }; }
template<> struct end< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : end< T1 > { }; }; template< typename Tag > struct lambda< end< na > , Tag , int_<-1> > { typedef false_ is_le; typedef end< na > result_; typedef end< na > type; }; namespace aux { template< typename T1 > struct template_arity< end< T1 > > : int_<1> { }; template<> struct template_arity< end< na > > : int_<-1> { }; }

}}
namespace boost { namespace mpl {

namespace aux {

template< bool C_, typename T1, typename T2, typename T3, typename T4 >
struct and_impl
    : false_
{
};

template< typename T1, typename T2, typename T3, typename T4 >
struct and_impl< true,T1,T2,T3,T4 >
    : and_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4
        , true_
        >
{
};

template<>
struct and_impl<
          true
        , true_, true_, true_, true_
        >
    : true_
{
};

}

template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = true_, typename T4 = true_, typename T5 = true_
    >
struct and_

    : aux::and_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4, T5
        >

{





};

template<> struct and_< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : and_< T1 , T2 > { }; }; template< typename Tag > struct lambda< and_< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef and_< na , na > result_; typedef and_< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< and_< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< and_< na , na > > : int_<-1> { }; }





}}



namespace boost { namespace mpl {

template< typename Value > struct always
{
    template<
        typename T1 = na , typename T2 = na , typename T3 = na , typename T4 = na , typename T5 = na
        >
    struct apply
    {
        typedef Value type;
    };
};



}}


namespace boost { namespace mpl {

template<
      typename T1 = na
    , typename T2 = na
    >
struct pair
{
    typedef pair type;
    typedef T1 first;
    typedef T2 second;


};

template<
      typename P = na
    >
struct first
{

    typedef typename P::first type;




};

template<
      typename P = na
    >
struct second
{

    typedef typename P::second type;




};


template<> struct pair< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : pair< T1 , T2 > { }; }; template< typename Tag > struct lambda< pair< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef pair< na , na > result_; typedef pair< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< pair< T1 , T2 > > : int_<2> { }; template<> struct template_arity< pair< na , na > > : int_<-1> { }; }
template<> struct first< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : first< T1 > { }; }; template< typename Tag > struct lambda< first< na > , Tag , int_<-1> > { typedef false_ is_le; typedef first< na > result_; typedef first< na > type; }; namespace aux { template< typename T1 > struct template_arity< first< T1 > > : int_<1> { }; template<> struct template_arity< first< na > > : int_<-1> { }; }
template<> struct second< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : second< T1 > { }; }; template< typename Tag > struct lambda< second< na > , Tag , int_<-1> > { typedef false_ is_le; typedef second< na > result_; typedef second< na > type; }; namespace aux { template< typename T1 > struct template_arity< second< T1 > > : int_<1> { }; template<> struct template_arity< second< na > > : int_<-1> { }; }

}}
namespace boost { namespace mpl {

template<
      typename T = na
    >
struct identity
{
    typedef T type;

};

template<
      typename T = na
    >
struct make_identity
{
    typedef identity<T> type;

};

template<> struct identity< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : identity< T1 > { }; }; template< typename Tag > struct lambda< identity< na > , Tag , int_<-1> > { typedef false_ is_le; typedef identity< na > result_; typedef identity< na > type; }; namespace aux { template< typename T1 > struct template_arity< identity< T1 > > : int_<1> { }; template<> struct template_arity< identity< na > > : int_<-1> { }; }
template<> struct make_identity< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : make_identity< T1 > { }; }; template< typename Tag > struct lambda< make_identity< na > , Tag , int_<-1> > { typedef false_ is_le; typedef make_identity< na > result_; typedef make_identity< na > type; }; namespace aux { template< typename T1 > struct template_arity< make_identity< T1 > > : int_<1> { }; template<> struct template_arity< make_identity< na > > : int_<-1> { }; }

}}


namespace boost { namespace mpl { namespace aux {

template< typename Iterator, typename State >
struct iter_fold_if_null_step
{
    typedef State state;
    typedef Iterator iterator;
};

template< bool >
struct iter_fold_if_step_impl
{
    template<
          typename Iterator
        , typename State
        , typename StateOp
        , typename IteratorOp
        >
    struct result_
    {
        typedef typename apply2< StateOp,State,Iterator >::type state;
        typedef typename IteratorOp::type iterator;
    };
};

template<>
struct iter_fold_if_step_impl<false>
{
    template<
          typename Iterator
        , typename State
        , typename StateOp
        , typename IteratorOp
        >
    struct result_
    {
        typedef State state;
        typedef Iterator iterator;
    };
};

template<
      typename Iterator
    , typename State
    , typename ForwardOp
    , typename Predicate
    >
struct iter_fold_if_forward_step
{
    typedef typename apply2< Predicate,State,Iterator >::type not_last;
    typedef typename iter_fold_if_step_impl<
          not_last::value
        >::template result_< Iterator,State,ForwardOp, mpl::next<Iterator> > impl_;

    typedef typename impl_::state state;
    typedef typename impl_::iterator iterator;
};

template<
      typename Iterator
    , typename State
    , typename BackwardOp
    , typename Predicate
    >
struct iter_fold_if_backward_step
{
    typedef typename apply2< Predicate,State,Iterator >::type not_last;
    typedef typename iter_fold_if_step_impl<
          not_last::value
        >::template result_< Iterator,State,BackwardOp, identity<Iterator> > impl_;

    typedef typename impl_::state state;
    typedef typename impl_::iterator iterator;
};

template<
      typename Iterator
    , typename State
    , typename ForwardOp
    , typename ForwardPredicate
    , typename BackwardOp
    , typename BackwardPredicate
    >
struct iter_fold_if_impl
{
 private:
    typedef iter_fold_if_null_step< Iterator,State > forward_step0;
    typedef iter_fold_if_forward_step< typename forward_step0::iterator, typename forward_step0::state, ForwardOp, ForwardPredicate > forward_step1;
    typedef iter_fold_if_forward_step< typename forward_step1::iterator, typename forward_step1::state, ForwardOp, ForwardPredicate > forward_step2;
    typedef iter_fold_if_forward_step< typename forward_step2::iterator, typename forward_step2::state, ForwardOp, ForwardPredicate > forward_step3;
    typedef iter_fold_if_forward_step< typename forward_step3::iterator, typename forward_step3::state, ForwardOp, ForwardPredicate > forward_step4;


    typedef typename if_<
          typename forward_step4::not_last
        , iter_fold_if_impl<
              typename forward_step4::iterator
            , typename forward_step4::state
            , ForwardOp
            , ForwardPredicate
            , BackwardOp
            , BackwardPredicate
            >
        , iter_fold_if_null_step<
              typename forward_step4::iterator
            , typename forward_step4::state
            >
        >::type backward_step4;

    typedef iter_fold_if_backward_step< typename forward_step3::iterator, typename backward_step4::state, BackwardOp, BackwardPredicate > backward_step3;
    typedef iter_fold_if_backward_step< typename forward_step2::iterator, typename backward_step3::state, BackwardOp, BackwardPredicate > backward_step2;
    typedef iter_fold_if_backward_step< typename forward_step1::iterator, typename backward_step2::state, BackwardOp, BackwardPredicate > backward_step1;
    typedef iter_fold_if_backward_step< typename forward_step0::iterator, typename backward_step1::state, BackwardOp, BackwardPredicate > backward_step0;


 public:
    typedef typename backward_step0::state state;
    typedef typename backward_step4::iterator iterator;
};

}}}





namespace mpl_{

   template <bool B> struct bool_;
   template <class I, I val> struct integral_c;
   struct integral_c_tag;
}

namespace boost
{
   namespace mpl
   {
      using ::mpl_::bool_;
      using ::mpl_::integral_c;
      using ::mpl_::integral_c_tag;
   }
}



namespace boost{

   template <class T, T val>
   struct integral_constant
   {
      typedef mpl::integral_c_tag tag;
      typedef T value_type;
      typedef integral_constant<T, val> type;
      static const T value = val;

      operator const mpl::integral_c<T, val>& ()const
      {
         static const char data[sizeof(long)] = { 0 };
         static const void* pdata = data;
         return *(reinterpret_cast<const mpl::integral_c<T, val>*>(pdata));
      }
      constexpr operator T()const { return val; }
   };

   template <class T, T val>
   T const integral_constant<T, val>::value;

   template <bool val>
   struct integral_constant<bool, val>
   {
      typedef mpl::integral_c_tag tag;
      typedef bool value_type;
      typedef integral_constant<bool, val> type;
      static const bool value = val;

      operator const mpl::bool_<val>& ()const
      {
         static const char data[sizeof(long)] = { 0 };
         static const void* pdata = data;
         return *(reinterpret_cast<const mpl::bool_<val>*>(pdata));
      }
      constexpr operator bool()const { return val; }
   };

   template <bool val>
   bool const integral_constant<bool, val>::value;

   typedef integral_constant<bool, true> true_type;
   typedef integral_constant<bool, false> false_type;

}

namespace boost {


   template <class T, class U> struct is_same : public false_type {};
   template <class T> struct is_same<T,T> : public true_type {};







}

namespace boost { namespace mpl {

namespace aux {

template< typename Predicate, typename LastIterator >
struct iter_fold_if_pred
{
    template< typename State, typename Iterator > struct apply

        : and_<
              not_< is_same<Iterator,LastIterator> >
            , apply1<Predicate,Iterator>
            >
    {







    };
};

}

template<
      typename Sequence = na
    , typename State = na
    , typename ForwardOp = na
    , typename ForwardPredicate = na
    , typename BackwardOp = na
    , typename BackwardPredicate = na
    >
struct iter_fold_if
{

    typedef typename begin<Sequence>::type first_;
    typedef typename end<Sequence>::type last_;

    typedef typename eval_if<
          is_na<BackwardPredicate>
        , if_< is_na<BackwardOp>, always<false_>, always<true_> >
        , identity<BackwardPredicate>
        >::type backward_pred_;



    struct result_ :



        aux::iter_fold_if_impl<
          first_
        , State
        , ForwardOp
        , protect< aux::iter_fold_if_pred< ForwardPredicate,last_ > >
        , BackwardOp
        , backward_pred_
        >

    { };




public:

    typedef pair<
          typename result_::state
        , typename result_::iterator
        > type;






};

template<> struct iter_fold_if< na , na , na , na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > struct apply : iter_fold_if< T1 , T2 , T3 , T4 , T5 , T6 > { }; }; template< typename Tag > struct lambda< iter_fold_if< na , na , na , na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef iter_fold_if< na , na , na , na , na , na > result_; typedef iter_fold_if< na , na , na , na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > struct template_arity< iter_fold_if< T1 , T2 , T3 , T4 , T5 , T6 > > : int_<6> { }; template<> struct template_arity< iter_fold_if< na , na , na , na , na , na > > : int_<-1> { }; }

}}




namespace boost { namespace mpl {



template<
      typename Sequence = na
    , typename Predicate = na
    >
struct find_if
{
    typedef typename iter_fold_if<
          Sequence
        , void
        , mpl::arg<1>
        , protect< aux::find_if_pred<Predicate> >
        >::type result_;

    typedef typename second<result_>::type type;


};

template<> struct find_if< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : find_if< T1 , T2 > { }; }; template< typename Tag > struct lambda< find_if< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef find_if< na , na > result_; typedef find_if< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< find_if< T1 , T2 > > : int_<2> { }; template<> struct template_arity< find_if< na , na > > : int_<-1> { }; }

}}
namespace boost {
template <class T> struct remove_pointer{ typedef T type; };
template <class T> struct remove_pointer<T*>{ typedef T type; };
template <class T> struct remove_pointer<T*const>{ typedef T type; };
template <class T> struct remove_pointer<T*volatile>{ typedef T type; };
template <class T> struct remove_pointer<T*const volatile>{ typedef T type; };





   template <class T> using remove_pointer_t = typename remove_pointer<T>::type;



}
namespace boost {






template <class T> struct is_integral : public false_type {};
template <class T> struct is_integral<const T> : public is_integral<T> {};
template <class T> struct is_integral<volatile const T> : public is_integral<T>{};
template <class T> struct is_integral<volatile T> : public is_integral<T>{};




template<> struct is_integral<unsigned char> : public true_type {};
template<> struct is_integral<unsigned short> : public true_type{};
template<> struct is_integral<unsigned int> : public true_type{};
template<> struct is_integral<unsigned long> : public true_type{};

template<> struct is_integral<signed char> : public true_type{};
template<> struct is_integral<short> : public true_type{};
template<> struct is_integral<int> : public true_type{};
template<> struct is_integral<long> : public true_type{};

template<> struct is_integral<char> : public true_type{};
template<> struct is_integral<bool> : public true_type{};





template<> struct is_integral<wchar_t> : public true_type{};
template<> struct is_integral< ::boost::ulong_long_type> : public true_type{};
template<> struct is_integral< ::boost::long_long_type> : public true_type{};






template<> struct is_integral<boost::int128_type> : public true_type{};
template<> struct is_integral<boost::uint128_type> : public true_type{};


template<> struct is_integral<char16_t> : public true_type{};


template<> struct is_integral<char32_t> : public true_type{};




}
namespace boost {


template <class T> struct remove_cv{ typedef T type; };
template <class T> struct remove_cv<T const>{ typedef T type; };
template <class T> struct remove_cv<T volatile>{ typedef T type; };
template <class T> struct remove_cv<T const volatile>{ typedef T type; };


template <class T, std::size_t N> struct remove_cv<T const[N]>{ typedef T type[N]; };
template <class T, std::size_t N> struct remove_cv<T const volatile[N]>{ typedef T type[N]; };
template <class T, std::size_t N> struct remove_cv<T volatile[N]>{ typedef T type[N]; };

template <class T> struct remove_cv<T const[]>{ typedef T type[]; };
template <class T> struct remove_cv<T const volatile[]>{ typedef T type[]; };
template <class T> struct remove_cv<T volatile[]>{ typedef T type[]; };





   template <class T> using remove_cv_t = typename remove_cv<T>::type;



}
namespace boost {
template <class T> struct is_enum : public integral_constant<bool, __is_enum(T)> {};



}


namespace boost {







namespace detail{

template <class T>
struct is_signed_values
{





   typedef typename remove_cv<T>::type no_cv_t;
   static const no_cv_t minus_one = (static_cast<no_cv_t>(-1));
   static const no_cv_t zero = (static_cast<no_cv_t>(0));
};

template <class T>
struct is_signed_helper
{
   typedef typename remove_cv<T>::type no_cv_t;
   static const bool value = (!(::boost::detail::is_signed_values<T>::minus_one > boost::detail::is_signed_values<T>::zero));
};

template <bool integral_type>
struct is_signed_select_helper
{
   template <class T>
   struct rebind
   {
      typedef is_signed_helper<T> type;
   };
};

template <>
struct is_signed_select_helper<false>
{
   template <class T>
   struct rebind
   {
      typedef false_type type;
   };
};

template <class T>
struct is_signed_impl
{
   typedef ::boost::detail::is_signed_select_helper< ::boost::is_integral<T>::value || ::boost::is_enum<T>::value> selector;
   typedef typename selector::template rebind<T> binder;
   typedef typename binder::type type;
   static const bool value = type::value;
};

}

template <class T> struct is_signed : public integral_constant<bool, boost::detail::is_signed_impl<T>::value> {};
template <> struct is_signed<signed char> : public true_type{};
template <> struct is_signed<const signed char> : public true_type{};
template <> struct is_signed<volatile signed char> : public true_type{};
template <> struct is_signed<const volatile signed char> : public true_type{};
template <> struct is_signed<short> : public true_type{};
template <> struct is_signed<const short> : public true_type{};
template <> struct is_signed<volatile short> : public true_type{};
template <> struct is_signed<const volatile short> : public true_type{};
template <> struct is_signed<int> : public true_type{};
template <> struct is_signed<const int> : public true_type{};
template <> struct is_signed<volatile int> : public true_type{};
template <> struct is_signed<const volatile int> : public true_type{};
template <> struct is_signed<long> : public true_type{};
template <> struct is_signed<const long> : public true_type{};
template <> struct is_signed<volatile long> : public true_type{};
template <> struct is_signed<const volatile long> : public true_type{};

template <> struct is_signed<unsigned char> : public false_type{};
template <> struct is_signed<const unsigned char> : public false_type{};
template <> struct is_signed<volatile unsigned char> : public false_type{};
template <> struct is_signed<const volatile unsigned char> : public false_type{};
template <> struct is_signed<unsigned short> : public false_type{};
template <> struct is_signed<const unsigned short> : public false_type{};
template <> struct is_signed<volatile unsigned short> : public false_type{};
template <> struct is_signed<const volatile unsigned short> : public false_type{};
template <> struct is_signed<unsigned int> : public false_type{};
template <> struct is_signed<const unsigned int> : public false_type{};
template <> struct is_signed<volatile unsigned int> : public false_type{};
template <> struct is_signed<const volatile unsigned int> : public false_type{};
template <> struct is_signed<unsigned long> : public false_type{};
template <> struct is_signed<const unsigned long> : public false_type{};
template <> struct is_signed<volatile unsigned long> : public false_type{};
template <> struct is_signed<const volatile unsigned long> : public false_type{};

template <> struct is_signed< ::boost::long_long_type> : public true_type{};
template <> struct is_signed<const ::boost::long_long_type> : public true_type{};
template <> struct is_signed<volatile ::boost::long_long_type> : public true_type{};
template <> struct is_signed<const volatile ::boost::long_long_type> : public true_type{};

template <> struct is_signed< ::boost::ulong_long_type> : public false_type{};
template <> struct is_signed<const ::boost::ulong_long_type> : public false_type{};
template <> struct is_signed<volatile ::boost::ulong_long_type> : public false_type{};
template <> struct is_signed<const volatile ::boost::ulong_long_type> : public false_type{};



template <> struct is_signed<char> : public true_type{};
template <> struct is_signed<const char> : public true_type{};
template <> struct is_signed<volatile char> : public true_type{};
template <> struct is_signed<const volatile char> : public true_type{};
template <> struct is_signed<wchar_t> : public true_type{};
template <> struct is_signed<const wchar_t> : public true_type{};
template <> struct is_signed<volatile wchar_t> : public true_type{};
template <> struct is_signed<const volatile wchar_t> : public true_type{};







}
namespace boost {







namespace detail{

template <class T>
struct is_unsigned_values
{





   typedef typename remove_cv<T>::type no_cv_t;
   static const no_cv_t minus_one = (static_cast<no_cv_t>(-1));
   static const no_cv_t zero = (static_cast<no_cv_t>(0));
};

template <class T>
struct is_ununsigned_helper
{
   static const bool value = (::boost::detail::is_unsigned_values<T>::minus_one > ::boost::detail::is_unsigned_values<T>::zero);
};

template <bool integral_type>
struct is_unsigned_select_helper
{
   template <class T>
   struct rebind
   {
      typedef is_ununsigned_helper<T> type;
   };
};

template <>
struct is_unsigned_select_helper<false>
{
   template <class T>
   struct rebind
   {
      typedef false_type type;
   };
};

template <class T>
struct is_unsigned
{
   typedef ::boost::detail::is_unsigned_select_helper< ::boost::is_integral<T>::value || ::boost::is_enum<T>::value > selector;
   typedef typename selector::template rebind<T> binder;
   typedef typename binder::type type;
   static const bool value = type::value;
};

}

template <class T> struct is_unsigned : public integral_constant<bool, boost::detail::is_unsigned<T>::value> {};
template <> struct is_unsigned<unsigned char> : public true_type{};
template <> struct is_unsigned<const unsigned char> : public true_type{};
template <> struct is_unsigned<volatile unsigned char> : public true_type{};
template <> struct is_unsigned<const volatile unsigned char> : public true_type{};
template <> struct is_unsigned<unsigned short> : public true_type{};
template <> struct is_unsigned<const unsigned short> : public true_type{};
template <> struct is_unsigned<volatile unsigned short> : public true_type{};
template <> struct is_unsigned<const volatile unsigned short> : public true_type{};
template <> struct is_unsigned<unsigned int> : public true_type{};
template <> struct is_unsigned<const unsigned int> : public true_type{};
template <> struct is_unsigned<volatile unsigned int> : public true_type{};
template <> struct is_unsigned<const volatile unsigned int> : public true_type{};
template <> struct is_unsigned<unsigned long> : public true_type{};
template <> struct is_unsigned<const unsigned long> : public true_type{};
template <> struct is_unsigned<volatile unsigned long> : public true_type{};
template <> struct is_unsigned<const volatile unsigned long> : public true_type{};

template <> struct is_unsigned<signed char> : public false_type{};
template <> struct is_unsigned<const signed char> : public false_type{};
template <> struct is_unsigned<volatile signed char> : public false_type{};
template <> struct is_unsigned<const volatile signed char> : public false_type{};
template <> struct is_unsigned< short> : public false_type{};
template <> struct is_unsigned<const short> : public false_type{};
template <> struct is_unsigned<volatile short> : public false_type{};
template <> struct is_unsigned<const volatile short> : public false_type{};
template <> struct is_unsigned< int> : public false_type{};
template <> struct is_unsigned<const int> : public false_type{};
template <> struct is_unsigned<volatile int> : public false_type{};
template <> struct is_unsigned<const volatile int> : public false_type{};
template <> struct is_unsigned< long> : public false_type{};
template <> struct is_unsigned<const long> : public false_type{};
template <> struct is_unsigned<volatile long> : public false_type{};
template <> struct is_unsigned<const volatile long> : public false_type{};

template <> struct is_unsigned< ::boost::ulong_long_type> : public true_type{};
template <> struct is_unsigned<const ::boost::ulong_long_type> : public true_type{};
template <> struct is_unsigned<volatile ::boost::ulong_long_type> : public true_type{};
template <> struct is_unsigned<const volatile ::boost::ulong_long_type> : public true_type{};

template <> struct is_unsigned< ::boost::long_long_type> : public false_type{};
template <> struct is_unsigned<const ::boost::long_long_type> : public false_type{};
template <> struct is_unsigned<volatile ::boost::long_long_type> : public false_type{};
template <> struct is_unsigned<const volatile ::boost::long_long_type> : public false_type{};
template <> struct is_unsigned<char> : public false_type{};
template <> struct is_unsigned<const char> : public false_type{};
template <> struct is_unsigned<volatile char> : public false_type{};
template <> struct is_unsigned<const volatile char> : public false_type{};
template <> struct is_unsigned<wchar_t> : public false_type{};
template <> struct is_unsigned<const wchar_t> : public false_type{};
template <> struct is_unsigned<volatile wchar_t> : public false_type{};
template <> struct is_unsigned<const volatile wchar_t> : public false_type{};


}
namespace boost {


   template <class T> struct is_floating_point : public false_type{};
   template <class T> struct is_floating_point<const T> : public is_floating_point<T>{};
   template <class T> struct is_floating_point<volatile const T> : public is_floating_point<T>{};
   template <class T> struct is_floating_point<volatile T> : public is_floating_point<T>{};
   template<> struct is_floating_point<float> : public true_type{};
   template<> struct is_floating_point<double> : public true_type{};
   template<> struct is_floating_point<long double> : public true_type{};





}



namespace boost {

   template <class T> struct is_complex : public false_type {};
   template <class T> struct is_complex<const T > : public is_complex<T>{};
   template <class T> struct is_complex<volatile const T > : public is_complex<T>{};
   template <class T> struct is_complex<volatile T > : public is_complex<T>{};
   template <class T> struct is_complex<std::complex<T> > : public true_type{};

}
namespace boost {

template <bool b, class T, class U> struct conditional { typedef T type; };
template <class T, class U> struct conditional<false, T, U> { typedef U type; };



   template <bool b, class T, class U> using conditional_t = typename conditional<b, T, U>::type;



}






namespace boost {
   template <class T>
   struct is_const : public false_type {};
   template <class T> struct is_const<T const> : public true_type{};
   template <class T, std::size_t N> struct is_const<T const[N]> : public true_type{};
   template <class T> struct is_const<T const[]> : public true_type{};



}
namespace boost {
   template <class T>
   struct is_volatile : public false_type {};
   template <class T> struct is_volatile<T volatile> : public true_type{};
   template <class T, std::size_t N> struct is_volatile<T volatile[N]> : public true_type{};
   template <class T> struct is_volatile<T volatile[]> : public true_type{};



}
namespace boost {
   template <class T> struct add_const
   {
      typedef T const type;
   };





   template <class T> struct add_const<T&>
   {
      typedef T& type;
   };



   template <class T> using add_const_t = typename add_const<T>::type;



}
namespace boost {
template <class T> struct add_volatile{ typedef T volatile type; };





template <class T> struct add_volatile<T&>{ typedef T& type; };



   template <class T> using add_volatile_t = typename add_volatile<T>::type;



}

namespace boost {

template <class T>
struct make_unsigned
{
private:
   static_assert((::boost::is_integral<T>::value || ::boost::is_enum<T>::value), "The template argument to make_unsigned must be an integer or enum type.");
   static_assert((! ::boost::is_same<typename remove_cv<T>::type, bool>::value), "The template argument to make_unsigned must not be the type bool");

   typedef typename remove_cv<T>::type t_no_cv;
   typedef typename conditional<
      (::boost::is_unsigned<T>::value && ::boost::is_integral<T>::value
      && ! ::boost::is_same<t_no_cv, char>::value
      && ! ::boost::is_same<t_no_cv, wchar_t>::value
      && ! ::boost::is_same<t_no_cv, bool>::value),
      T,
      typename conditional<
         (::boost::is_integral<T>::value
         && ! ::boost::is_same<t_no_cv, char>::value
         && ! ::boost::is_same<t_no_cv, wchar_t>::value
         && ! ::boost::is_same<t_no_cv, bool>::value),
         typename conditional<
            is_same<t_no_cv, signed char>::value,
            unsigned char,
            typename conditional<
               is_same<t_no_cv, short>::value,
               unsigned short,
               typename conditional<
                  is_same<t_no_cv, int>::value,
                  unsigned int,
                  typename conditional<
                     is_same<t_no_cv, long>::value,
                     unsigned long,


                     typename conditional<
                        sizeof(t_no_cv) == sizeof(boost::ulong_long_type),
                        boost::ulong_long_type,
                        boost::uint128_type
                     >::type
                  >::type
               >::type
            >::type
         >::type,

         typename conditional<
            sizeof(t_no_cv) == sizeof(unsigned char),
            unsigned char,
            typename conditional<
               sizeof(t_no_cv) == sizeof(unsigned short),
               unsigned short,
               typename conditional<
                  sizeof(t_no_cv) == sizeof(unsigned int),
                  unsigned int,
                  typename conditional<
                     sizeof(t_no_cv) == sizeof(unsigned long),
                     unsigned long,


                     typename conditional<
                        sizeof(t_no_cv) == sizeof(boost::ulong_long_type),
                        boost::ulong_long_type,
                        boost::uint128_type
                     >::type
                  >::type
               >::type
            >::type
         >::type
      >::type
   >::type base_integer_type;


   typedef typename conditional<
      is_const<T>::value,
      typename add_const<base_integer_type>::type,
      base_integer_type
   >::type const_base_integer_type;
public:

   typedef typename conditional<
      is_volatile<T>::value,
      typename add_volatile<const_base_integer_type>::type,
      const_base_integer_type
   >::type type;
};



   template <class T> using make_unsigned_t = typename make_unsigned<T>::type;



}
namespace boost { template <class T> class shared_ptr; }
namespace boost { namespace exception_detail { using boost::shared_ptr; } }





namespace
boost
    {
    namespace
    exception_detail
        {
        template <class T>
        class
        refcount_ptr
            {
            public:

            refcount_ptr():
                px_(0)
                {
                }

            ~refcount_ptr()
                {
                release();
                }

            refcount_ptr( refcount_ptr const & x ):
                px_(x.px_)
                {
                add_ref();
                }

            refcount_ptr &
            operator=( refcount_ptr const & x )
                {
                adopt(x.px_);
                return *this;
                }

            void
            adopt( T * px )
                {
                release();
                px_=px;
                add_ref();
                }

            T *
            get() const
                {
                return px_;
                }

            private:

            T * px_;

            void
            add_ref()
                {
                if( px_ )
                    px_->add_ref();
                }

            void
            release()
                {
                if( px_ && px_->release() )
                    px_=0;
                }
            };
        }



    template <class Tag,class T>
    class error_info;

    typedef error_info<struct throw_function_,char const *> throw_function;
    typedef error_info<struct throw_file_,char const *> throw_file;
    typedef error_info<struct throw_line_,int> throw_line;

    template <>
    class
    error_info<throw_function_,char const *>
        {
        public:
        typedef char const * value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };

    template <>
    class
    error_info<throw_file_,char const *>
        {
        public:
        typedef char const * value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };

    template <>
    class
    error_info<throw_line_,int>
        {
        public:
        typedef int value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };

    class
    __attribute__((__visibility__("default")))
    exception;

    namespace
    exception_detail
        {
        class error_info_base;
        struct type_info_;

        struct
        error_info_container
            {
            virtual char const * diagnostic_information( char const * ) const = 0;
            virtual shared_ptr<error_info_base> get( type_info_ const & ) const = 0;
            virtual void set( shared_ptr<error_info_base> const &, type_info_ const & ) = 0;
            virtual void add_ref() const = 0;
            virtual bool release() const = 0;
            virtual refcount_ptr<exception_detail::error_info_container> clone() const = 0;

            protected:

            ~error_info_container() throw()
                {
                }
            };

        template <class>
        struct get_info;

        template <>
        struct get_info<throw_function>;

        template <>
        struct get_info<throw_file>;

        template <>
        struct get_info<throw_line>;

        template <class>
        struct set_info_rv;

        template <>
        struct set_info_rv<throw_function>;

        template <>
        struct set_info_rv<throw_file>;

        template <>
        struct set_info_rv<throw_line>;

        char const * get_diagnostic_information( exception const &, char const * );

        void copy_boost_exception( exception *, exception const * );

        template <class E,class Tag,class T>
        E const & set_info( E const &, error_info<Tag,T> const & );

        template <class E>
        E const & set_info( E const &, throw_function const & );

        template <class E>
        E const & set_info( E const &, throw_file const & );

        template <class E>
        E const & set_info( E const &, throw_line const & );
        }

    class
    __attribute__((__visibility__("default")))
    exception
        {

        public:
        template <class Tag> void set( typename Tag::type const & );
        template <class Tag> typename Tag::type const * get() const;


        protected:

        exception():
            throw_function_(0),
            throw_file_(0),
            throw_line_(-1)
            {
            }
        virtual ~exception() throw()

            = 0

            ;




        private:

        template <class E>
        friend E const & exception_detail::set_info( E const &, throw_function const & );

        template <class E>
        friend E const & exception_detail::set_info( E const &, throw_file const & );

        template <class E>
        friend E const & exception_detail::set_info( E const &, throw_line const & );

        template <class E,class Tag,class T>
        friend E const & exception_detail::set_info( E const &, error_info<Tag,T> const & );

        friend char const * exception_detail::get_diagnostic_information( exception const &, char const * );

        template <class>
        friend struct exception_detail::get_info;
        friend struct exception_detail::get_info<throw_function>;
        friend struct exception_detail::get_info<throw_file>;
        friend struct exception_detail::get_info<throw_line>;
        template <class>
        friend struct exception_detail::set_info_rv;
        friend struct exception_detail::set_info_rv<throw_function>;
        friend struct exception_detail::set_info_rv<throw_file>;
        friend struct exception_detail::set_info_rv<throw_line>;
        friend void exception_detail::copy_boost_exception( exception *, exception const * );

        mutable exception_detail::refcount_ptr<exception_detail::error_info_container> data_;
        mutable char const * throw_function_;
        mutable char const * throw_file_;
        mutable int throw_line_;
        };

    inline
    exception::
    ~exception() throw()
        {
        }

    namespace
    exception_detail
        {
        template <class E>
        E const &
        set_info( E const & x, throw_function const & y )
            {
            x.throw_function_=y.v_;
            return x;
            }

        template <class E>
        E const &
        set_info( E const & x, throw_file const & y )
            {
            x.throw_file_=y.v_;
            return x;
            }

        template <class E>
        E const &
        set_info( E const & x, throw_line const & y )
            {
            x.throw_line_=y.v_;
            return x;
            }
        }



    namespace
    exception_detail
        {
        template <class T>
        struct
        __attribute__((__visibility__("default")))
        error_info_injector:
            public T,
            public exception
            {
            explicit
            error_info_injector( T const & x ):
                T(x)
                {
                }

            ~error_info_injector() throw()
                {
                }
            };

        struct large_size { char c[256]; };
        large_size dispatch_boost_exception( exception const * );

        struct small_size { };
        small_size dispatch_boost_exception( void const * );

        template <class,int>
        struct enable_error_info_helper;

        template <class T>
        struct
        enable_error_info_helper<T,sizeof(large_size)>
            {
            typedef T type;
            };

        template <class T>
        struct
        enable_error_info_helper<T,sizeof(small_size)>
            {
            typedef error_info_injector<T> type;
            };

        template <class T>
        struct
        enable_error_info_return_type
            {
            typedef typename enable_error_info_helper<T,sizeof(exception_detail::dispatch_boost_exception(static_cast<T *>(0)))>::type type;
            };
        }

    template <class T>
    inline
    typename
    exception_detail::enable_error_info_return_type<T>::type
    enable_error_info( T const & x )
        {
        typedef typename exception_detail::enable_error_info_return_type<T>::type rt;
        return rt(x);
        }



    namespace
    exception_detail
        {
        class
        __attribute__((__visibility__("default")))
        clone_base
            {
            public:

            virtual clone_base const * clone() const = 0;
            virtual void rethrow() const = 0;

            virtual
            ~clone_base() throw()
                {
                }
            };

        inline
        void
        copy_boost_exception( exception * a, exception const * b )
            {
            refcount_ptr<error_info_container> data;
            if( error_info_container * d=b->data_.get() )
                data = d->clone();
            a->throw_file_ = b->throw_file_;
            a->throw_line_ = b->throw_line_;
            a->throw_function_ = b->throw_function_;
            a->data_ = data;
            }

        inline
        void
        copy_boost_exception( void *, void const * )
            {
            }

        template <class T>
        class
        __attribute__((__visibility__("default")))
        clone_impl:
            public T,
            public virtual clone_base
            {
            struct clone_tag { };
            clone_impl( clone_impl const & x, clone_tag ):
                T(x)
                {
                copy_boost_exception(this,&x);
                }

            public:

            explicit
            clone_impl( T const & x ):
                T(x)
                {
                copy_boost_exception(this,&x);
                }

            ~clone_impl() throw()
                {
                }

            private:

            clone_base const *
            clone() const
                {
                return new clone_impl(*this,clone_tag());
                }

            void
            rethrow() const
                {
                throw*this;
                }
            };
        }

    template <class T>
    inline
    exception_detail::clone_impl<T>
    enable_current_exception( T const & x )
        {
        return exception_detail::clone_impl<T>(x);
        }

    template <class T>
    struct
    __attribute__((__visibility__("default")))
    wrapexcept:
        public exception_detail::clone_impl<typename exception_detail::enable_error_info_return_type<T>::type>
        {
        typedef exception_detail::clone_impl<typename exception_detail::enable_error_info_return_type<T>::type> base_type;
        public:
        explicit
        wrapexcept( typename exception_detail::enable_error_info_return_type<T>::type const & x ):
            base_type( x )
            {
            }

        ~wrapexcept() throw()
            {
            }
        };

    namespace
    exception_detail
        {
        template <class T>
        struct
        remove_error_info_injector
            {
            typedef T type;
            };

        template <class T>
        struct
        remove_error_info_injector< error_info_injector<T> >
            {
            typedef T type;
            };

        template <class T>
        inline
        wrapexcept<typename remove_error_info_injector<T>::type>
        enable_both( T const & x )
            {
            return wrapexcept<typename remove_error_info_injector<T>::type>( enable_error_info( x ) );
            }
        }
    }

namespace boost
{

namespace detail
{

inline void current_function_helper()
{
}

}

}





namespace boost
{






inline void throw_exception_assert_compatibility( std::exception const & ) { }

template<class E> __attribute__ ((__noreturn__)) inline void throw_exception( E const & e )
{


    throw_exception_assert_compatibility(e);


    throw exception_detail::enable_both( e );



}




    namespace
    exception_detail
    {
        template <class E>
        __attribute__ ((__noreturn__))
        void
        throw_exception_( E const & x, char const * current_function, char const * file, int line )
        {
            boost::throw_exception(
                set_info(
                    set_info(
                        set_info(
                            enable_error_info(x),
                            throw_function(current_function)),
                        throw_file(file)),
                    throw_line(line)));
        }
    }

}








namespace boost
{
  template<typename T, typename R=void>
  struct enable_if_has_type
  {
    typedef R type;
  };

  template <bool B, class T = void>
  struct enable_if_c {
    typedef T type;
  };

  template <class T>
  struct enable_if_c<false, T> {};

  template <class Cond, class T = void>
  struct enable_if : public enable_if_c<Cond::value, T> {};

  template <bool B, class T>
  struct lazy_enable_if_c {
    typedef typename T::type type;
  };

  template <class T>
  struct lazy_enable_if_c<false, T> {};

  template <class Cond, class T>
  struct lazy_enable_if : public lazy_enable_if_c<Cond::value, T> {};


  template <bool B, class T = void>
  struct disable_if_c {
    typedef T type;
  };

  template <class T>
  struct disable_if_c<true, T> {};

  template <class Cond, class T = void>
  struct disable_if : public disable_if_c<Cond::value, T> {};

  template <bool B, class T>
  struct lazy_disable_if_c {
    typedef typename T::type type;
  };

  template <class T>
  struct lazy_disable_if_c<true, T> {};

  template <class Cond, class T>
  struct lazy_disable_if : public lazy_disable_if_c<Cond::value, T> {};

}
namespace boost {

template <class T>
struct is_void : public false_type {};

template<> struct is_void<void> : public true_type {};
template<> struct is_void<const void> : public true_type{};
template<> struct is_void<const volatile void> : public true_type{};
template<> struct is_void<volatile void> : public true_type{};

}
namespace boost {





   template <class T> struct is_lvalue_reference : public false_type{};
   template <class T> struct is_lvalue_reference<T&> : public true_type{};
}
namespace boost {

template <class T> struct is_rvalue_reference : public false_type {};

template <class T> struct is_rvalue_reference<T&&> : public true_type {};


}

namespace boost {

template <class T> struct is_reference
   : public
   integral_constant<
      bool,
      ::boost::is_lvalue_reference<T>::value || ::boost::is_rvalue_reference<T>::value>
{};

}
namespace boost {

namespace type_traits_detail {

    template <typename T, bool b>
    struct add_rvalue_reference_helper
    { typedef T type; };


    template <typename T>
    struct add_rvalue_reference_helper<T, true>
    {
        typedef T&& type;
    };


    template <typename T>
    struct add_rvalue_reference_imp
    {
       typedef typename boost::type_traits_detail::add_rvalue_reference_helper
                  <T, (is_void<T>::value == false && is_reference<T>::value == false) >::type type;
    };

}

template <class T> struct add_rvalue_reference
{
   typedef typename boost::type_traits_detail::add_rvalue_reference_imp<T>::type type;
};



   template <class T> using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;



}
namespace boost {

    template <typename T>
    typename add_rvalue_reference<T>::type declval() noexcept;

}

namespace boost {


namespace detail{




template <class T>
struct remove_rvalue_ref
{
   typedef T type;
};

template <class T>
struct remove_rvalue_ref<T&&>
{
   typedef T type;
};


}

template <class T> struct remove_reference{ typedef typename boost::detail::remove_rvalue_ref<T>::type type; };
template <class T> struct remove_reference<T&>{ typedef T type; };
   template <class T> using remove_reference_t = typename remove_reference<T>::type;



}
namespace boost {

   template <class T>
   struct is_function : public false_type {};
   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)noexcept(NE)> : public true_type {};

   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)const noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)const noexcept(NE)> : public true_type {};

   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)volatile noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)volatile noexcept(NE)> : public true_type {};

   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)const volatile noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)const volatile noexcept(NE)> : public true_type {};



   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)& noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)& noexcept(NE)> : public true_type {};

   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)const & noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)const & noexcept(NE)> : public true_type {};

   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)volatile & noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)volatile & noexcept(NE)> : public true_type {};

   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)const volatile & noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)const volatile & noexcept(NE)> : public true_type {};



   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)&& noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)&& noexcept(NE)> : public true_type {};

   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)const && noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)const && noexcept(NE)> : public true_type {};

   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)volatile && noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)volatile && noexcept(NE)> : public true_type {};

   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)const volatile && noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)const volatile && noexcept(NE)> : public true_type {};
}
namespace boost {
namespace type_traits {

typedef char yes_type;
struct no_type
{
   char padding[8];
};

}
}
namespace boost {
   namespace detail{

      template <unsigned N>
      struct ok_tag { double d; char c[N]; };

      template <class T>
      ok_tag<sizeof(T)> check_is_complete(int);
      template <class T>
      char check_is_complete(...);
   }

   template <class T> struct is_complete
      : public integral_constant<bool, ::boost::is_function<typename boost::remove_reference<T>::type>::value || (sizeof(detail::check_is_complete<T>(0)) != sizeof(char))> {};
}

namespace boost {




   template <class T> struct is_array : public false_type {};

   template <class T, std::size_t N> struct is_array<T[N]> : public true_type {};
   template <class T, std::size_t N> struct is_array<T const[N]> : public true_type{};
   template <class T, std::size_t N> struct is_array<T volatile[N]> : public true_type{};
   template <class T, std::size_t N> struct is_array<T const volatile[N]> : public true_type{};

   template <class T> struct is_array<T[]> : public true_type{};
   template <class T> struct is_array<T const[]> : public true_type{};
   template <class T> struct is_array<T const volatile[]> : public true_type{};
   template <class T> struct is_array<T volatile[]> : public true_type{};





}
namespace boost {
template <class From, class To>
struct is_convertible : public integral_constant<bool, __is_convertible_to(From,To)>
{





   static_assert(boost::is_complete<To>::value || boost::is_void<To>::value || boost::is_array<To>::value, "Destination argument type to is_convertible must be a complete type");
   static_assert(boost::is_complete<From>::value || boost::is_void<From>::value || boost::is_array<From>::value, "From argument type to is_convertible must be a complete type");

};



}
namespace boost{

   namespace detail{

      struct is_destructible_imp
      {
         template<typename T, typename = decltype(boost::declval<T&>().~T())>
         static boost::type_traits::yes_type test(int);
         template<typename>
         static boost::type_traits::no_type test(...);
      };

   }

   template <class T> struct is_destructible : public integral_constant<bool, sizeof(detail::is_destructible_imp::test<T>(0)) == sizeof(boost::type_traits::yes_type)>
   {
      static_assert(boost::is_complete<T>::value, "Arguments to is_destructible must be complete types");
   };
   template <> struct is_destructible<void> : public false_type{};
   template <> struct is_destructible<void const> : public false_type{};
   template <> struct is_destructible<void volatile> : public false_type{};
   template <> struct is_destructible<void const volatile> : public false_type{};
   template <class T> struct is_destructible<T&> : public is_destructible<T>{};

   template <class T> struct is_destructible<T&&> : public is_destructible<T>{};

   template <class T, std::size_t N> struct is_destructible<T[N]> : public is_destructible<T>{};
   template <class T> struct is_destructible<T[]> : public is_destructible<T>{};

}
namespace boost{

   namespace detail{

      struct is_default_constructible_imp
      {
         template<typename _Tp, typename = decltype(_Tp())>
         static boost::type_traits::yes_type test(int);

         template<typename>
         static boost::type_traits::no_type test(...);
      };
   }







   template <class T> struct is_default_constructible : public integral_constant<bool, sizeof(detail::is_default_constructible_imp::test<T>(0)) == sizeof(boost::type_traits::yes_type)>
   {
      static_assert(boost::is_complete<T>::value, "Arguments to is_default_constructible must be complete types");
   };

   template <class T, std::size_t N> struct is_default_constructible<T[N]> : public is_default_constructible<T>{};
   template <class T> struct is_default_constructible<T[]> : public is_default_constructible<T>{};
   template <class T> struct is_default_constructible<T&> : public integral_constant<bool, false>{};

   template <class T, class U> struct is_default_constructible<std::pair<T,U> > : public integral_constant<bool, is_default_constructible<T>::value && is_default_constructible<U>::value>{};


   template <class T> struct is_default_constructible<T&&> : public integral_constant<bool, false>{};

   template <> struct is_default_constructible<void> : public integral_constant<bool, false>{};
   template <> struct is_default_constructible<void const> : public integral_constant<bool, false>{};
   template <> struct is_default_constructible<void volatile> : public integral_constant<bool, false>{};
   template <> struct is_default_constructible<void const volatile> : public integral_constant<bool, false>{};
}







namespace boost{

   namespace detail{

      struct is_constructible_imp
      {
         template<typename T, typename ...TheArgs, typename = decltype(T(boost::declval<TheArgs>()...))>
         static boost::type_traits::yes_type test(int);
         template<typename, typename...>
         static boost::type_traits::no_type test(...);

         template<typename T, typename Arg, typename = decltype(::new T(boost::declval<Arg>()))>
         static boost::type_traits::yes_type test1(int);
         template<typename, typename>
         static boost::type_traits::no_type test1(...);

         template <typename T>
         static boost::type_traits::yes_type ref_test(T);
         template <typename T>
         static boost::type_traits::no_type ref_test(...);
      };

   }

   template <class T, class ...Args> struct is_constructible : public integral_constant<bool, sizeof(detail::is_constructible_imp::test<T, Args...>(0)) == sizeof(boost::type_traits::yes_type)>
   {
      static_assert(::boost::is_complete<T>::value, "The target type must be complete in order to test for constructibility");
   };
   template <class T, class Arg> struct is_constructible<T, Arg> : public integral_constant<bool, is_destructible<T>::value && sizeof(detail::is_constructible_imp::test1<T, Arg>(0)) == sizeof(boost::type_traits::yes_type)>
   {
      static_assert(::boost::is_complete<T>::value, "The target type must be complete in order to test for constructibility");
   };
   template <class Ref, class Arg> struct is_constructible<Ref&, Arg> : public integral_constant<bool, sizeof(detail::is_constructible_imp::ref_test<Ref&>(boost::declval<Arg>())) == sizeof(boost::type_traits::yes_type)>{};
   template <class Ref, class Arg> struct is_constructible<Ref&&, Arg> : public integral_constant<bool, sizeof(detail::is_constructible_imp::ref_test<Ref&&>(boost::declval<Arg>())) == sizeof(boost::type_traits::yes_type)>{};

   template <> struct is_constructible<void> : public false_type{};
   template <> struct is_constructible<void const> : public false_type{};
   template <> struct is_constructible<void const volatile> : public false_type{};
   template <> struct is_constructible<void volatile> : public false_type{};

   template <class T> struct is_constructible<T> : public is_default_constructible<T>{};
}
namespace boost {

template <class T> struct remove_extent{ typedef T type; };


template <typename T, std::size_t N> struct remove_extent<T[N]> { typedef T type; };
template <typename T, std::size_t N> struct remove_extent<T const[N]> { typedef T const type; };
template <typename T, std::size_t N> struct remove_extent<T volatile [N]> { typedef T volatile type; };
template <typename T, std::size_t N> struct remove_extent<T const volatile [N]> { typedef T const volatile type; };

template <typename T> struct remove_extent<T[]> { typedef T type; };
template <typename T> struct remove_extent<T const[]> { typedef T const type; };
template <typename T> struct remove_extent<T volatile[]> { typedef T volatile type; };
template <typename T> struct remove_extent<T const volatile[]> { typedef T const volatile type; };





   template <class T> using remove_extent_t = typename remove_extent<T>::type;



}

namespace boost
{

template <class T> struct remove_bounds : public remove_extent<T> {};



template <class T> using remove_bounds_t = typename remove_bounds<T>::type;




}
namespace boost {
template <typename T>
struct add_pointer
{
    typedef typename remove_reference<T>::type no_ref_type;
    typedef no_ref_type* type;
};





   template <class T> using add_pointer_t = typename add_pointer<T>::type;



}



namespace boost
{

   namespace detail
   {

      template <class T, bool Array, bool Function> struct decay_imp { typedef typename remove_cv<T>::type type; };
      template <class T> struct decay_imp<T, true, false> { typedef typename remove_bounds<T>::type* type; };
      template <class T> struct decay_imp<T, false, true> { typedef T* type; };

   }

    template< class T >
    struct decay
    {
    private:
        typedef typename remove_reference<T>::type Ty;
    public:
       typedef typename boost::detail::decay_imp<Ty, boost::is_array<Ty>::value, boost::is_function<Ty>::value>::type type;
    };



   template <class T> using decay_t = typename decay<T>::type;



}




namespace boost {
namespace iterators {






template <class Iterator>
struct iterator_value
{
    typedef typename std::iterator_traits<Iterator>::value_type type;
};

template <class Iterator>
struct iterator_reference
{
    typedef typename std::iterator_traits<Iterator>::reference type;
};


template <class Iterator>
struct iterator_pointer
{
    typedef typename std::iterator_traits<Iterator>::pointer type;
};

template <class Iterator>
struct iterator_difference
{
    typedef typename std::iterator_traits<Iterator>::difference_type type;
};

template <class Iterator>
struct iterator_category
{
    typedef typename std::iterator_traits<Iterator>::iterator_category type;
};

}

using iterators::iterator_value;
using iterators::iterator_reference;
using iterators::iterator_pointer;
using iterators::iterator_difference;
using iterators::iterator_category;

}

namespace boost {
namespace iterators {
  template <typename A, typename B>
  struct is_interoperable



    : mpl::or_<
          is_convertible< A, B >
        , is_convertible< B, A > >

  {
  };

}

using iterators::is_interoperable;

}
















namespace boost {
namespace iterators {





struct no_traversal_tag {};

struct incrementable_traversal_tag
  : no_traversal_tag
{


};

struct single_pass_traversal_tag
  : incrementable_traversal_tag
{


};

struct forward_traversal_tag
  : single_pass_traversal_tag
{


};

struct bidirectional_traversal_tag
  : forward_traversal_tag
{


};

struct random_access_traversal_tag
  : bidirectional_traversal_tag
{


};

namespace detail
{






  template <class Cat>
  struct old_category_to_traversal
    : mpl::eval_if<
          is_convertible<Cat,std::random_access_iterator_tag>
        , mpl::identity<random_access_traversal_tag>
        , mpl::eval_if<
              is_convertible<Cat,std::bidirectional_iterator_tag>
            , mpl::identity<bidirectional_traversal_tag>
            , mpl::eval_if<
                  is_convertible<Cat,std::forward_iterator_tag>
                , mpl::identity<forward_traversal_tag>
                , mpl::eval_if<
                      is_convertible<Cat,std::input_iterator_tag>
                    , mpl::identity<single_pass_traversal_tag>
                    , mpl::eval_if<
                          is_convertible<Cat,std::output_iterator_tag>
                        , mpl::identity<incrementable_traversal_tag>
                        , void
                      >
                  >
              >
          >
      >
  {};

}




template <class Cat>
struct iterator_category_to_traversal
  : mpl::eval_if<
        is_convertible<Cat,incrementable_traversal_tag>
      , mpl::identity<Cat>
      , boost::iterators::detail::old_category_to_traversal<Cat>
    >
{};


template <class Iterator = mpl::_1>
struct iterator_traversal
  : iterator_category_to_traversal<
        typename std::iterator_traits<Iterator>::iterator_category
    >
{};
template <class Traversal>
struct pure_traversal_tag
  : mpl::eval_if<
        is_convertible<Traversal,random_access_traversal_tag>
      , mpl::identity<random_access_traversal_tag>
      , mpl::eval_if<
            is_convertible<Traversal,bidirectional_traversal_tag>
          , mpl::identity<bidirectional_traversal_tag>
          , mpl::eval_if<
                is_convertible<Traversal,forward_traversal_tag>
              , mpl::identity<forward_traversal_tag>
              , mpl::eval_if<
                    is_convertible<Traversal,single_pass_traversal_tag>
                  , mpl::identity<single_pass_traversal_tag>
                  , mpl::eval_if<
                        is_convertible<Traversal,incrementable_traversal_tag>
                      , mpl::identity<incrementable_traversal_tag>
                      , void
                    >
                >
            >
        >
    >
{
};




template <class Iterator = mpl::_1>
struct pure_iterator_traversal
  : pure_traversal_tag<typename iterator_traversal<Iterator>::type>
{};
}

using iterators::no_traversal_tag;
using iterators::incrementable_traversal_tag;
using iterators::single_pass_traversal_tag;
using iterators::forward_traversal_tag;
using iterators::bidirectional_traversal_tag;
using iterators::random_access_traversal_tag;
using iterators::iterator_category_to_traversal;
using iterators::iterator_traversal;




namespace detail {
using iterators::pure_traversal_tag;
}

}





namespace boost {




template <class T> struct is_pointer : public false_type{};
template <class T> struct is_pointer<T*> : public true_type{};
template <class T> struct is_pointer<T*const> : public true_type{};
template <class T> struct is_pointer<T*const volatile> : public true_type{};
template <class T> struct is_pointer<T*volatile> : public true_type{};
}
namespace boost {

namespace detail {
template <typename T>
struct is_class_impl
{
    static const bool value = __is_class(T);
};


}

template <class T> struct is_class : public integral_constant<bool, ::boost::detail::is_class_impl<T>::value> {};






}


namespace boost {
   template <class T>
   struct is_member_function_pointer : public false_type {};
   template <class T>
   struct is_member_function_pointer<T const> : public is_member_function_pointer<T> {};
   template <class T>
   struct is_member_function_pointer<T volatile> : public is_member_function_pointer<T> {};
   template <class T>
   struct is_member_function_pointer<T const volatile> : public is_member_function_pointer<T> {};
   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret (C::*)(Args..., ...)noexcept(NE)> : public true_type {};

   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)const noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)const noexcept(NE)> : public true_type {};

   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)volatile noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)volatile noexcept(NE)> : public true_type {};

   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)const volatile noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)const volatile noexcept(NE)> : public true_type {};



   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)& noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)& noexcept(NE)> : public true_type {};

   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)const & noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)const & noexcept(NE)> : public true_type {};

   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)volatile & noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)volatile & noexcept(NE)> : public true_type {};

   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)const volatile & noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)const volatile & noexcept(NE)> : public true_type {};



   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...) && noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...) && noexcept(NE)> : public true_type {};

   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)const && noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)const && noexcept(NE)> : public true_type {};

   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)volatile && noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)volatile && noexcept(NE)> : public true_type {};

   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)const volatile && noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)const volatile && noexcept(NE)> : public true_type {};
}
namespace boost {




template <class T> struct is_member_pointer : public integral_constant<bool, ::boost::is_member_function_pointer<T>::value>{};
template <class T, class U> struct is_member_pointer<U T::* > : public true_type{};


template <class T, class U> struct is_member_pointer<U T::*const> : public true_type{};
template <class T, class U> struct is_member_pointer<U T::*const volatile> : public true_type{};
template <class T, class U> struct is_member_pointer<U T::*volatile> : public true_type{};




}





namespace boost { namespace detail {






  template <bool b> struct if_true
  {
      template <class T, class F>
      struct then { typedef T type; };
  };

  template <>
  struct if_true<false>
  {
      template <class T, class F>
      struct then { typedef F type; };
  };
}}


namespace boost { namespace detail {

namespace indirect_traits {

template <class T>
struct is_reference_to_const : boost::false_type
{
};

template <class T>
struct is_reference_to_const<T const&> : boost::true_type
{
};
template <class T>
struct is_reference_to_function : boost::false_type
{
};

template <class T>
struct is_reference_to_function<T&> : is_function<T>
{
};

template <class T>
struct is_pointer_to_function : boost::false_type
{
};



template <class T>
struct is_pointer_to_function<T*> : is_function<T>
{
};

template <class T>
struct is_reference_to_member_function_pointer_impl : boost::false_type
{
};

template <class T>
struct is_reference_to_member_function_pointer_impl<T&>
    : is_member_function_pointer<typename remove_cv<T>::type>
{
};


template <class T>
struct is_reference_to_member_function_pointer
    : is_reference_to_member_function_pointer_impl<T>
{
};

template <class T>
struct is_reference_to_function_pointer_aux
    : boost::integral_constant<bool,
          is_reference<T>::value &&
          is_pointer_to_function<
              typename remove_cv<
                  typename remove_reference<T>::type
              >::type
          >::value
      >
{

};

template <class T>
struct is_reference_to_function_pointer
    : boost::detail::if_true<
          is_reference_to_function<T>::value
      >::template then<
          boost::false_type
        , is_reference_to_function_pointer_aux<T>
      >::type
{
};

template <class T>
struct is_reference_to_non_const
    : boost::integral_constant<bool,
          is_reference<T>::value &&
          !is_reference_to_const<T>::value
      >
{
};

template <class T>
struct is_reference_to_volatile : boost::false_type
{
};

template <class T>
struct is_reference_to_volatile<T volatile&> : boost::true_type
{
};
template <class T>
struct is_reference_to_pointer : boost::false_type
{
};

template <class T>
struct is_reference_to_pointer<T*&> : boost::true_type
{
};

template <class T>
struct is_reference_to_pointer<T* const&> : boost::true_type
{
};

template <class T>
struct is_reference_to_pointer<T* volatile&> : boost::true_type
{
};

template <class T>
struct is_reference_to_pointer<T* const volatile&> : boost::true_type
{
};

template <class T>
struct is_reference_to_class
    : boost::integral_constant<bool,
          is_reference<T>::value &&
          is_class<
              typename remove_cv<
                  typename remove_reference<T>::type
              >::type
          >::value
      >
{
};

template <class T>
struct is_pointer_to_class
    : boost::integral_constant<bool,
          is_pointer<T>::value &&
          is_class<
              typename remove_cv<
                  typename remove_pointer<T>::type
              >::type
          >::value
      >
{
};


}

using namespace indirect_traits;

}}






namespace boost {
namespace iterators {


struct use_default;

namespace detail {

struct input_output_iterator_tag
  : std::input_iterator_tag
{






    operator std::output_iterator_tag() const
    {
        return std::output_iterator_tag();
    }
};






template <class ValueParam, class Reference>
struct iterator_writability_disabled

  : mpl::or_<
        is_const<Reference>
      , boost::detail::indirect_traits::is_reference_to_const<Reference>
      , is_const<ValueParam>
    >



{};
template <class Traversal, class ValueParam, class Reference>
struct iterator_facade_default_category
  : mpl::eval_if<
        mpl::and_<
            is_reference<Reference>
          , is_convertible<Traversal,forward_traversal_tag>
        >
      , mpl::eval_if<
            is_convertible<Traversal,random_access_traversal_tag>
          , mpl::identity<std::random_access_iterator_tag>
          , mpl::if_<
                is_convertible<Traversal,bidirectional_traversal_tag>
              , std::bidirectional_iterator_tag
              , std::forward_iterator_tag
            >
        >
      , typename mpl::eval_if<
            mpl::and_<
                is_convertible<Traversal, single_pass_traversal_tag>


              , is_convertible<Reference, ValueParam>
            >
          , mpl::identity<std::input_iterator_tag>
          , mpl::identity<Traversal>
        >
    >
{
};


template <class T>
struct is_iterator_category
  : mpl::or_<
        is_convertible<T,std::input_iterator_tag>
      , is_convertible<T,std::output_iterator_tag>
    >
{
};

template <class T>
struct is_iterator_traversal
  : is_convertible<T,incrementable_traversal_tag>
{};







template <class Category, class Traversal>
struct iterator_category_with_traversal
  : Category, Traversal
{



    enum { mpl_assertion_in_line_145 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) ( is_convertible< typename iterator_category_to_traversal<Category>::type , Traversal >))0, 1 ) ) ) };





    enum { mpl_assertion_in_line_147 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (is_iterator_category<Category>))0, 1 ) ) ) };
    enum { mpl_assertion_in_line_148 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (is_iterator_category<Traversal>))0, 1 ) ) ) };
    enum { mpl_assertion_in_line_149 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (is_iterator_traversal<Category>))0, 1 ) ) ) };

    enum { mpl_assertion_in_line_151 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (is_iterator_traversal<Traversal>))0, 1 ) ) ) };

};



template <class Traversal, class ValueParam, class Reference>
struct facade_iterator_category_impl
{
    enum { mpl_assertion_in_line_160 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (is_iterator_category<Traversal>))0, 1 ) ) ) };

    typedef typename iterator_facade_default_category<
        Traversal,ValueParam,Reference
    >::type category;

    typedef typename mpl::if_<
        is_same<
            Traversal
          , typename iterator_category_to_traversal<category>::type
        >
      , category
      , iterator_category_with_traversal<category,Traversal>
    >::type type;
};




template <class CategoryOrTraversal, class ValueParam, class Reference>
struct facade_iterator_category
  : mpl::eval_if<
        is_iterator_category<CategoryOrTraversal>
      , mpl::identity<CategoryOrTraversal>
      , facade_iterator_category_impl<CategoryOrTraversal,ValueParam,Reference>
    >
{
};

}}}









namespace boost
{

  namespace iterators
  {



    template<bool>
    struct enabled
    {
      template<typename T>
      struct base
      {
        typedef T type;
      };
    };






    template<>
    struct enabled<false>
    {
      template<typename T>
      struct base
      {
      };
    };


    template <class Cond,
              class Return>
    struct enable_if

      : enabled<(Cond::value)>::template base<Return>



    {
    };

  }

}




namespace boost {

template<class T>
constexpr inline T*
addressof(T& o) noexcept
{
    return __builtin_addressof(o);
}

}
namespace boost {

template<class T>
const T* addressof(const T&&) = delete;

}












namespace boost {

namespace detail {






template <typename T>
struct add_reference_impl
{
    typedef T& type;
};


template <typename T>
struct add_reference_impl<T&&>
{
    typedef T&& type;
};


}

template <class T> struct add_reference
{
   typedef typename boost::detail::add_reference_impl<T>::type type;
};
template <class T> struct add_reference<T&>
{
   typedef T& type;
};


template <> struct add_reference<void> { typedef void type; };

template <> struct add_reference<const void> { typedef const void type; };
template <> struct add_reference<const volatile void> { typedef const volatile void type; };
template <> struct add_reference<volatile void> { typedef volatile void type; };




template <class T> using add_reference_t = typename add_reference<T>::type;




}

namespace boost{

template <class T> struct add_lvalue_reference
{
   typedef typename boost::add_reference<T>::type type;
};


template <class T> struct add_lvalue_reference<T&&>
{
   typedef T& type;
};




   template <class T> using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;



}
namespace boost {


   template <class T> struct remove_const{ typedef T type; };
   template <class T> struct remove_const<T const>{ typedef T type; };


   template <class T, std::size_t N> struct remove_const<T const[N]>{ typedef T type[N]; };

   template <class T> struct remove_const<T const[]>{ typedef T type[]; };





   template <class T> using remove_const_t = typename remove_const<T>::type;



}


namespace boost {

template <class T>
struct is_arithmetic : public integral_constant<bool, is_integral<T>::value || is_floating_point<T>::value> {};

}





namespace boost {

template <typename T>
struct is_scalar
   : public integral_constant<bool, ::boost::is_arithmetic<T>::value || ::boost::is_enum<T>::value || ::boost::is_pointer<T>::value || ::boost::is_member_pointer<T>::value>
{};

}
namespace boost {


template< typename T > struct is_POD;

template <typename T> struct is_pod
: public integral_constant<bool, ::boost::is_scalar<T>::value || ::boost::is_void<T>::value || __is_pod(T)>
{};


template <typename T, std::size_t sz> struct is_pod<T[sz]> : public is_pod<T>{};




template<> struct is_pod<void> : public true_type{};


template<> struct is_pod<void const> : public true_type{};
template<> struct is_pod<void const volatile> : public true_type{};
template<> struct is_pod<void volatile> : public true_type{};


template<class T> struct is_POD : public is_pod<T>{};

}












namespace boost {
namespace iterators {



  template <class I, class V, class TC, class R, class D> class iterator_facade;

  namespace detail
  {



    struct always_bool2
    {
        template <class T, class U>
        struct apply
        {
            typedef bool type;
        };
    };


    template< typename CategoryOrTraversal, typename Required >
    struct is_traversal_at_least :
        public boost::is_convertible< typename iterator_category_to_traversal< CategoryOrTraversal >::type, Required >
    {};




    template <
        class Facade1
      , class Facade2
      , class Return
    >
    struct enable_if_interoperable :
        public boost::iterators::enable_if<
            is_interoperable< Facade1, Facade2 >
          , Return
        >
    {};




    template <
        class Facade1
      , class Facade2
      , class Return
    >
    struct enable_if_interoperable_and_random_access_traversal :
        public boost::iterators::enable_if<
            mpl::and_<
                is_interoperable< Facade1, Facade2 >
              , is_traversal_at_least< typename iterator_category< Facade1 >::type, random_access_traversal_tag >
              , is_traversal_at_least< typename iterator_category< Facade2 >::type, random_access_traversal_tag >
            >
          , Return
        >
    {};





    template <
        class ValueParam
      , class CategoryOrTraversal
      , class Reference
      , class Difference
    >
    struct iterator_facade_types
    {
        typedef typename facade_iterator_category<
            CategoryOrTraversal, ValueParam, Reference
        >::type iterator_category;

        typedef typename remove_const<ValueParam>::type value_type;


        typedef typename mpl::eval_if<
            boost::iterators::detail::iterator_writability_disabled<ValueParam,Reference>
          , add_pointer<const value_type>
          , add_pointer<value_type>
        >::type pointer;
    };







    template <class Iterator>
    class postfix_increment_proxy
    {
        typedef typename iterator_value<Iterator>::type value_type;
     public:
        explicit postfix_increment_proxy(Iterator const& x)
          : stored_value(*x)
        {}





        value_type&
        operator*() const
        {
            return this->stored_value;
        }
     private:
        mutable value_type stored_value;
    };





    template <class Iterator>
    class writable_postfix_increment_proxy
    {
        typedef typename iterator_value<Iterator>::type value_type;
     public:
        explicit writable_postfix_increment_proxy(Iterator const& x)
          : stored_value(*x)
          , stored_iterator(x)
        {}





        writable_postfix_increment_proxy const&
        operator*() const
        {
            return *this;
        }


        operator value_type&() const
        {
            return stored_value;
        }


        template <class T>
        T const& operator=(T const& x) const
        {
            *this->stored_iterator = x;
            return x;
        }


        template <class T>
        T& operator=(T& x) const
        {
            *this->stored_iterator = x;
            return x;
        }


        operator Iterator const&() const
        {
            return stored_iterator;
        }

     private:
        mutable value_type stored_value;
        Iterator stored_iterator;
    };
    template <class Reference, class Value>
    struct is_non_proxy_reference
      : is_convertible<
            typename remove_reference<Reference>::type
            const volatile*
          , Value const volatile*
        >
    {};
    template <class Iterator, class Value, class Reference, class CategoryOrTraversal>
    struct postfix_increment_result
      : mpl::eval_if<
            mpl::and_<

                is_convertible<
                    Reference





                  , typename add_lvalue_reference<Value const>::type
                >



              , mpl::not_<
                    is_convertible<
                        typename iterator_category_to_traversal<CategoryOrTraversal>::type
                      , forward_traversal_tag
                    >
                >
            >
          , mpl::if_<
                is_non_proxy_reference<Reference,Value>
              , postfix_increment_proxy<Iterator>
              , writable_postfix_increment_proxy<Iterator>
            >
          , mpl::identity<Iterator>
        >
    {};





    template <class Reference, class Pointer>
    struct operator_arrow_dispatch
    {
        struct proxy
        {
            explicit proxy(Reference const & x) : m_ref(x) {}
            Reference* operator->() { return boost::addressof(m_ref); }


            operator Reference*() { return boost::addressof(m_ref); }
            Reference m_ref;
        };
        typedef proxy result_type;
        static result_type apply(Reference const & x)
        {
            return result_type(x);
        }
    };

    template <class T, class Pointer>
    struct operator_arrow_dispatch<T&, Pointer>
    {
        typedef Pointer result_type;
        static result_type apply(T& x)
        {
            return boost::addressof(x);
        }
    };




    template <class Iterator>
    class operator_brackets_proxy
    {


        typedef typename Iterator::reference reference;
        typedef typename Iterator::value_type value_type;

     public:
        operator_brackets_proxy(Iterator const& iter)
          : m_iter(iter)
        {}

        operator reference() const
        {
            return *m_iter;
        }

        operator_brackets_proxy& operator=(value_type const& val)
        {
            *m_iter = val;
            return *this;
        }

     private:
        Iterator m_iter;
    };



    template <class ValueType, class Reference>
    struct use_operator_brackets_proxy
      : mpl::not_<
            mpl::and_<


                boost::is_POD<ValueType>
              , iterator_writability_disabled<ValueType,Reference>
            >
        >
    {};

    template <class Iterator, class Value, class Reference>
    struct operator_brackets_result
    {
        typedef typename mpl::if_<
            use_operator_brackets_proxy<Value,Reference>
          , operator_brackets_proxy<Iterator>
          , Value
        >::type type;
    };

    template <class Iterator>
    operator_brackets_proxy<Iterator> make_operator_brackets_result(Iterator const& iter, mpl::true_)
    {
        return operator_brackets_proxy<Iterator>(iter);
    }

    template <class Iterator>
    typename Iterator::value_type make_operator_brackets_result(Iterator const& iter, mpl::false_)
    {
      return *iter;
    }

    struct choose_difference_type
    {
        template <class I1, class I2>
        struct apply
          :



          mpl::eval_if<
              is_convertible<I2,I1>
            , iterator_difference<I1>
            , iterator_difference<I2>
          >

        {};

    };

    template <
        class Derived
      , class Value
      , class CategoryOrTraversal
      , class Reference
      , class Difference
      , bool IsBidirectionalTraversal
      , bool IsRandomAccessTraversal
    >
    class iterator_facade_base;

  }
  class iterator_core_access
  {






      template <class I, class V, class TC, class R, class D> friend class iterator_facade;
      template <class I, class V, class TC, class R, class D, bool IsBidirectionalTraversal, bool IsRandomAccessTraversal>
      friend class detail::iterator_facade_base;




      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::iterators::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator ==( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::iterators::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator !=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);






      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator <( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator >( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator <=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator >=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);



      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::choose_difference_type,Derived1,Derived2>::type >::type operator -( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs)

      ;

      template <class Derived, class V, class TC, class R, class D> friend inline typename boost::iterators::enable_if< boost::iterators::detail::is_traversal_at_least< TC, boost::iterators::random_access_traversal_tag >, Derived >::type operator+ (iterator_facade<Derived, V, TC, R, D> const& , typename Derived::difference_type)




      ;

      template <class Derived, class V, class TC, class R, class D> friend inline typename boost::iterators::enable_if< boost::iterators::detail::is_traversal_at_least< TC, boost::iterators::random_access_traversal_tag >, Derived >::type operator+ (typename Derived::difference_type , iterator_facade<Derived, V, TC, R, D> const&)




      ;



      template <class Facade>
      static typename Facade::reference dereference(Facade const& f)
      {
          return f.dereference();
      }

      template <class Facade>
      static void increment(Facade& f)
      {
          f.increment();
      }

      template <class Facade>
      static void decrement(Facade& f)
      {
          f.decrement();
      }

      template <class Facade1, class Facade2>
      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::true_)
      {
          return f1.equal(f2);
      }

      template <class Facade1, class Facade2>
      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::false_)
      {
          return f2.equal(f1);
      }

      template <class Facade>
      static void advance(Facade& f, typename Facade::difference_type n)
      {
          f.advance(n);
      }

      template <class Facade1, class Facade2>
      static typename Facade1::difference_type distance_from(
          Facade1 const& f1, Facade2 const& f2, mpl::true_)
      {
          return -f1.distance_to(f2);
      }

      template <class Facade1, class Facade2>
      static typename Facade2::difference_type distance_from(
          Facade1 const& f1, Facade2 const& f2, mpl::false_)
      {
          return f2.distance_to(f1);
      }




      template <class I, class V, class TC, class R, class D>
      static I& derived(iterator_facade<I,V,TC,R,D>& facade)
      {
          return *static_cast<I*>(&facade);
      }

      template <class I, class V, class TC, class R, class D>
      static I const& derived(iterator_facade<I,V,TC,R,D> const& facade)
      {
          return *static_cast<I const*>(&facade);
      }


      iterator_core_access() = delete;
  };

  namespace detail {


    template <
        class Derived
      , class Value
      , class CategoryOrTraversal
      , class Reference
      , class Difference
    >
    class iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, false, false >






    {
    private:
        typedef boost::iterators::detail::iterator_facade_types<
            Value, CategoryOrTraversal, Reference, Difference
        > associated_types;

        typedef boost::iterators::detail::operator_arrow_dispatch<
            Reference
          , typename associated_types::pointer
        > operator_arrow_dispatch_;

    public:
        typedef typename associated_types::value_type value_type;
        typedef Reference reference;
        typedef Difference difference_type;

        typedef typename operator_arrow_dispatch_::result_type pointer;

        typedef typename associated_types::iterator_category iterator_category;

    public:
        reference operator*() const
        {
            return iterator_core_access::dereference(this->derived());
        }

        pointer operator->() const
        {
            return operator_arrow_dispatch_::apply(*this->derived());
        }

        Derived& operator++()
        {
            iterator_core_access::increment(this->derived());
            return this->derived();
        }

    protected:



        Derived& derived()
        {
            return *static_cast<Derived*>(this);
        }

        Derived const& derived() const
        {
            return *static_cast<Derived const*>(this);
        }
    };


    template <
        class Derived
      , class Value
      , class CategoryOrTraversal
      , class Reference
      , class Difference
    >
    class iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, true, false > :
        public iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, false, false >
    {
    public:
        Derived& operator--()
        {
            iterator_core_access::decrement(this->derived());
            return this->derived();
        }

        Derived operator--(int)
        {
            Derived tmp(this->derived());
            --*this;
            return tmp;
        }
    };


    template <
        class Derived
      , class Value
      , class CategoryOrTraversal
      , class Reference
      , class Difference
    >
    class iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, true, true > :
        public iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, true, false >
    {
    private:
        typedef iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, true, false > base_type;

    public:
        typedef typename base_type::reference reference;
        typedef typename base_type::difference_type difference_type;

    public:
        typename boost::iterators::detail::operator_brackets_result<Derived, Value, reference>::type
        operator[](difference_type n) const
        {
            typedef boost::iterators::detail::use_operator_brackets_proxy<Value, Reference> use_proxy;

            return boost::iterators::detail::make_operator_brackets_result<Derived>(
                this->derived() + n
              , use_proxy()
            );
        }

        Derived& operator+=(difference_type n)
        {
            iterator_core_access::advance(this->derived(), n);
            return this->derived();
        }

        Derived& operator-=(difference_type n)
        {
            iterator_core_access::advance(this->derived(), -n);
            return this->derived();
        }

        Derived operator-(difference_type x) const
        {
            Derived result(this->derived());
            return result -= x;
        }
    };

  }





  template <
      class Derived
    , class Value
    , class CategoryOrTraversal
    , class Reference = Value&
    , class Difference = std::ptrdiff_t
  >
  class iterator_facade :
      public detail::iterator_facade_base<
          Derived,
          Value,
          CategoryOrTraversal,
          Reference,
          Difference,
          detail::is_traversal_at_least< CategoryOrTraversal, bidirectional_traversal_tag >::value,
          detail::is_traversal_at_least< CategoryOrTraversal, random_access_traversal_tag >::value
      >
  {
  protected:

      typedef iterator_facade<Derived,Value,CategoryOrTraversal,Reference,Difference> iterator_facade_;
  };

  template <class I, class V, class TC, class R, class D>
  inline typename boost::iterators::detail::postfix_increment_result<I,V,R,TC>::type
  operator++(
      iterator_facade<I,V,TC,R,D>& i
    , int
  )
  {
      typename boost::iterators::detail::postfix_increment_result<I,V,R,TC>::type
          tmp(*static_cast<I*>(&i));

      ++i;

      return tmp;
  }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::iterators::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator ==( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value ), "( is_interoperable< Derived1, Derived2 >::value )"); return iterator_core_access::equal( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::iterators::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator !=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value ), "( is_interoperable< Derived1, Derived2 >::value )"); return ! iterator_core_access::equal( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator <( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value ), "( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value )"); return 0 > iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator >( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value ), "( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value )"); return 0 < iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator <=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value ), "( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value )"); return 0 >= iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator >=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value ), "( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value )"); return 0 <= iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }




  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::choose_difference_type,Derived1,Derived2>::type >::type operator -( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value ), "( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value )"); return iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template <class Derived, class V, class TC, class R, class D> inline typename boost::iterators::enable_if< boost::iterators::detail::is_traversal_at_least< TC, boost::iterators::random_access_traversal_tag >, Derived >::type operator+ ( iterator_facade<Derived, V, TC, R, D> const& i , typename Derived::difference_type n ) { Derived tmp(static_cast<Derived const&>(i)); return tmp += n; }




  template <class Derived, class V, class TC, class R, class D> inline typename boost::iterators::enable_if< boost::iterators::detail::is_traversal_at_least< TC, boost::iterators::random_access_traversal_tag >, Derived >::type operator+ ( typename Derived::difference_type n , iterator_facade<Derived, V, TC, R, D> const& i ) { Derived tmp(static_cast<Derived const&>(i)); return tmp += n; }
}

using iterators::iterator_core_access;
using iterators::iterator_facade;

}





namespace boost {

namespace detail{


template <class T>
struct is_abstract_imp
{
   static const bool value = __is_abstract(T);
};
}


template <class T> struct is_abstract : public integral_constant<bool, ::boost::detail::is_abstract_imp<T>::value> {};




}

namespace boost {

namespace detail {
template <typename B, typename D>
struct is_base_and_derived_impl
{
    typedef typename remove_cv<B>::type ncvB;
    typedef typename remove_cv<D>::type ncvD;

    static const bool value = ((__is_base_of(B,D) && !is_same<B,D>::value) && ! ::boost::is_same<ncvB,ncvD>::value);
};

}

template <class Base, class Derived> struct is_base_and_derived
   : public integral_constant<bool, (::boost::detail::is_base_and_derived_impl<Base, Derived>::value)> {};

template <class Base, class Derived> struct is_base_and_derived<Base&, Derived> : public false_type{};
template <class Base, class Derived> struct is_base_and_derived<Base, Derived&> : public false_type{};
template <class Base, class Derived> struct is_base_and_derived<Base&, Derived&> : public false_type{};





}









namespace boost
{


    template<typename C, typename Enabler>
    struct range_iterator;

    template<typename C, typename Enabler>
    struct range_mutable_iterator;

    template<typename C, typename Enabler>
    struct range_const_iterator;


    template<typename IteratorT>
    class iterator_range;

    template<typename ForwardRange>
    class sub_range;


    template<typename T>
    struct range_category;

    template<typename T>
    struct range_difference;

    template<typename T>
    struct range_pointer;

    template<typename T>
    struct range_reference;

    template<typename T>
    struct range_reverse_iterator;

    template<typename T>
    struct range_size;

    template<typename T>
    struct range_value;

    template<typename T>
    struct has_range_iterator;

    template<typename T>
    struct has_range_const_iterator;

}





namespace boost
{





    namespace range_detail
    {

template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_iterator { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::iterator>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; }; template< typename C, bool B = has_iterator<C>::value > struct extract_iterator {}; template< typename C > struct extract_iterator< C, true > { typedef typename C::iterator type; };

template< typename C >
struct range_mutable_iterator
        : range_detail::extract_iterator<
            typename remove_reference<C>::type>
{};





template< typename Iterator >
struct range_mutable_iterator< std::pair<Iterator,Iterator> >
{
    typedef Iterator type;
};





template< typename T, std::size_t sz >
struct range_mutable_iterator< T[sz] >
{
    typedef T* type;
};

    }

template<typename C, typename Enabler=void>
struct range_mutable_iterator
        : range_detail::range_mutable_iterator<
            typename remove_reference<C>::type
        >
{
};

}


namespace boost
{




    namespace range_detail
    {

template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_const_iterator { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::const_iterator>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; }; template< typename C, bool B = has_const_iterator<C>::value > struct extract_const_iterator {}; template< typename C > struct extract_const_iterator< C, true > { typedef typename C::const_iterator type; };

template< typename C >
struct range_const_iterator_helper
        : extract_const_iterator<C>
{};





template< typename Iterator >
struct range_const_iterator_helper<std::pair<Iterator,Iterator> >
{
    typedef Iterator type;
};





template< typename T, std::size_t sz >
struct range_const_iterator_helper< T[sz] >
{
    typedef const T* type;
};

    }

template<typename C, typename Enabler=void>
struct range_const_iterator
        : range_detail::range_const_iterator_helper<
            typename remove_reference<C>::type
        >
{
};

}




namespace boost
{
    template< typename C, typename Enabler=void >
    struct range_iterator
      : mpl::if_c<
            is_const<typename remove_reference<C>::type>::value,
            range_const_iterator<typename remove_const<typename remove_reference<C>::type>::type>,
            range_mutable_iterator<typename remove_reference<C>::type>
        >::type
    {
    };



}



namespace boost
{


namespace range_detail
{






    template< typename C >
    constexpr inline typename range_iterator<C>::type
    range_begin( C& c )
    {





        return c.begin();
    }





    template< typename Iterator >
    constexpr inline Iterator range_begin( const std::pair<Iterator,Iterator>& p )
    {
        return p.first;
    }

    template< typename Iterator >
    constexpr inline Iterator range_begin( std::pair<Iterator,Iterator>& p )
    {
        return p.first;
    }
    template< typename T, std::size_t sz >
    constexpr inline const T* range_begin( const T (&a)[sz] ) noexcept
    {
        return a;
    }

    template< typename T, std::size_t sz >
    constexpr inline T* range_begin( T (&a)[sz] ) noexcept
    {
        return a;
    }



}





namespace range_adl_barrier
{

template< class T >

constexpr

inline typename range_iterator<T>::type begin( T& r )
{

    using namespace range_detail;

    return range_begin( r );
}

template< class T >

constexpr

inline typename range_iterator<const T>::type begin( const T& r )
{

    using namespace range_detail;

    return range_begin( r );
}

    }
}



namespace boost
{
    namespace range_adl_barrier
    {
        template< class T >
        inline typename range_iterator<const T>::type
        const_begin( const T& r )
        {
            return boost::range_adl_barrier::begin( r );
        }
    }

    using namespace range_adl_barrier;
}
namespace boost
{
    namespace range_detail
    {
        using type_traits::yes_type;
        using type_traits::no_type;





        yes_type is_string_impl( const char* const );
        yes_type is_string_impl( const wchar_t* const );
        no_type is_string_impl( ... );

        template< std::size_t sz >
        yes_type is_char_array_impl( char (&boost_range_array)[sz] );
        template< std::size_t sz >
        yes_type is_char_array_impl( const char (&boost_range_array)[sz] );
        no_type is_char_array_impl( ... );

        template< std::size_t sz >
        yes_type is_wchar_t_array_impl( wchar_t (&boost_range_array)[sz] );
        template< std::size_t sz >
        yes_type is_wchar_t_array_impl( const wchar_t (&boost_range_array)[sz] );
        no_type is_wchar_t_array_impl( ... );

        yes_type is_char_ptr_impl( char* const );
        no_type is_char_ptr_impl( ... );

        yes_type is_const_char_ptr_impl( const char* const );
        no_type is_const_char_ptr_impl( ... );

        yes_type is_wchar_t_ptr_impl( wchar_t* const );
        no_type is_wchar_t_ptr_impl( ... );

        yes_type is_const_wchar_t_ptr_impl( const wchar_t* const );
        no_type is_const_wchar_t_ptr_impl( ... );





        template< typename Iterator >
        yes_type is_pair_impl( const std::pair<Iterator,Iterator>* );
        no_type is_pair_impl( ... );





        struct char_or_wchar_t_array_tag {};

    }

}
namespace boost
{
    namespace range_detail
    {
        typedef mpl::int_<1>::type std_container_;
        typedef mpl::int_<2>::type std_pair_;
        typedef mpl::int_<3>::type const_std_pair_;
        typedef mpl::int_<4>::type array_;
        typedef mpl::int_<5>::type const_array_;
        typedef mpl::int_<6>::type char_array_;
        typedef mpl::int_<7>::type wchar_t_array_;
        typedef mpl::int_<8>::type char_ptr_;
        typedef mpl::int_<9>::type const_char_ptr_;
        typedef mpl::int_<10>::type wchar_t_ptr_;
        typedef mpl::int_<11>::type const_wchar_t_ptr_;
        typedef mpl::int_<12>::type string_;

        template< typename C >
        struct range_helper
        {
            static C* c;
            static C ptr;

            static const bool is_pair_ = sizeof( boost::range_detail::is_pair_impl( c ) ) == sizeof( yes_type );
            static const bool is_char_ptr_ = sizeof( boost::range_detail::is_char_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_const_char_ptr_ = sizeof( boost::range_detail::is_const_char_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_wchar_t_ptr_ = sizeof( boost::range_detail::is_wchar_t_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_const_wchar_t_ptr_ = sizeof( boost::range_detail::is_const_wchar_t_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_char_array_ = sizeof( boost::range_detail::is_char_array_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_wchar_t_array_ = sizeof( boost::range_detail::is_wchar_t_array_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_string_ = (is_const_char_ptr_ || is_const_wchar_t_ptr_);
            static const bool is_array_ = boost::is_array<C>::value;

        };

        template< typename C >
        class range
        {
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_pair_,
                                                                  boost::range_detail::std_pair_,
                                                                  void >::type pair_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_array_,
                                                                    boost::range_detail::array_,
                                                                    pair_t >::type array_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_string_,
                                                                    boost::range_detail::string_,
                                                                    array_t >::type string_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_const_char_ptr_,
                                                                    boost::range_detail::const_char_ptr_,
                                                                    string_t >::type const_char_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_char_ptr_,
                                                                    boost::range_detail::char_ptr_,
                                                                    const_char_ptr_t >::type char_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_const_wchar_t_ptr_,
                                                                    boost::range_detail::const_wchar_t_ptr_,
                                                                    char_ptr_t >::type const_wchar_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_wchar_t_ptr_,
                                                                    boost::range_detail::wchar_t_ptr_,
                                                                    const_wchar_ptr_t >::type wchar_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_wchar_t_array_,
                                                                    boost::range_detail::wchar_t_array_,
                                                                    wchar_ptr_t >::type wchar_array_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_char_array_,
                                                                    boost::range_detail::char_array_,
                                                                    wchar_array_t >::type char_array_t;
        public:
            typedef typename boost::mpl::if_c< ::boost::is_void<char_array_t>::value,
                                                                    boost::range_detail::std_container_,
                                                                    char_array_t >::type type;
        };
    }
}







namespace boost
{
    namespace range_detail
    {
        template <typename T>
        inline void boost_range_silence_warning( const T& ) { }





        inline const char* str_end( const char* s, const char* )
        {
            return s + strlen( s );
        }


        inline const wchar_t* str_end( const wchar_t* s, const wchar_t* )
        {
            return s + wcslen( s );
        }
        template< class Char >
        inline Char* str_end( Char* s )
        {
            return const_cast<Char*>( str_end( s, s ) );
        }

        template< class T, std::size_t sz >
        constexpr inline T* array_end( T (&boost_range_array)[sz] ) noexcept
        {
            return boost_range_array + sz;
        }

        template< class T, std::size_t sz >
        constexpr inline const T* array_end( const T (&boost_range_array)[sz] ) noexcept
        {
            return boost_range_array + sz;
        }





        template< class Char >
        inline std::size_t str_size( const Char* const& s )
        {
            return str_end( s ) - s;
        }

        template< class T, std::size_t sz >
        inline std::size_t array_size( T (&boost_range_array)[sz] )
        {
            boost_range_silence_warning( boost_range_array );
            return sz;
        }

        template< class T, std::size_t sz >
        inline std::size_t array_size( const T (&boost_range_array)[sz] )
        {
            boost_range_silence_warning( boost_range_array );
            return sz;
        }

        inline bool is_same_address(const void* l, const void* r)
        {
            return l == r;
        }

        template<class T1, class T2>
        inline bool is_same_object(const T1& l, const T2& r)
        {
            return range_detail::is_same_address(&l, &r);
        }

    }

}





namespace boost
{


namespace range_detail
{





        template< typename C >
        constexpr inline typename range_iterator<C>::type
        range_end( C& c )
        {





            return c.end();
        }





        template< typename Iterator >
        constexpr inline Iterator range_end( const std::pair<Iterator,Iterator>& p )
        {
            return p.second;
        }

        template< typename Iterator >
        constexpr inline Iterator range_end( std::pair<Iterator,Iterator>& p )
        {
            return p.second;
        }





        template< typename T, std::size_t sz >
        constexpr inline const T* range_end( const T (&a)[sz] ) noexcept
        {
            return range_detail::array_end<T,sz>( a );
        }

        template< typename T, std::size_t sz >
        constexpr inline T* range_end( T (&a)[sz] ) noexcept
        {
            return range_detail::array_end<T,sz>( a );
        }


}


namespace range_adl_barrier
{

template< class T >

constexpr

inline typename range_iterator<T>::type end( T& r )
{

    using namespace range_detail;

    return range_end( r );
}

template< class T >

constexpr

inline typename range_iterator<const T>::type end( const T& r )
{

    using namespace range_detail;

    return range_end( r );
}

    }
}



namespace boost
{
    namespace range_adl_barrier
    {
        template< class T >
        constexpr inline typename range_iterator<const T>::type
        const_end( const T& r )
        {
            return boost::range_adl_barrier::end( r );
        }
    }
    using namespace range_adl_barrier;
}
namespace boost
{
    namespace range_detail
    {
        template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_type { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::type>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };

        template<class T, class Enabler = void>
        struct has_range_iterator_impl
            : boost::mpl::false_
        {
        };

        template<class T>
        struct has_range_iterator_impl<
            T,
            typename ::boost::enable_if<
                typename mpl::eval_if<is_const<T>,
                    has_type<boost::range_const_iterator<
                                typename remove_const<T>::type> >,
                    has_type<boost::range_mutable_iterator<T> >
                >::type
            >::type
        >
            : boost::mpl::true_
        {
        };

        template<class T, class Enabler = void>
        struct has_range_const_iterator_impl
            : boost::mpl::false_
        {
        };

        template<class T>
        struct has_range_const_iterator_impl<
            T,
            typename ::boost::enable_if<
                has_type<boost::range_const_iterator<T> >
            >::type
        >
            : boost::mpl::true_
        {
        };

    }

    template<class T>
    struct has_range_iterator
        : range_detail::has_range_iterator_impl<
            typename remove_reference<T>::type>
    {};

    template<class T>
    struct has_range_const_iterator
        : range_detail::has_range_const_iterator_impl<
            typename remove_reference<T>::type>
    {};
}



namespace boost
{
    namespace range_detail
    {
        template< class T, bool B = has_type<range_iterator<T> >::value >
        struct range_difference
        { };

        template< class T >
        struct range_difference<T, true>
          : iterator_difference<
                typename range_iterator<T>::type
            >
        { };
    }

    template< class T >
    struct range_difference
      : range_detail::range_difference<typename remove_reference<T>::type>
    { };
}













namespace boost
{
  namespace concepts {}




}


namespace boost { namespace concepts {

namespace detail
{



  typedef char yes;
  typedef char (&no)[2];

  template <class Model, void (Model::*)()>
  struct wrap_constraints {};
  template <class Model>
  inline yes has_constraints_(Model*, wrap_constraints<Model,&Model::constraints>* = 0);
  inline no has_constraints_(...);

}



template <class Model>
struct not_satisfied
{
    static const bool value = sizeof( detail::has_constraints_((Model*)0) ) == sizeof(detail::yes);


    typedef boost::integral_constant<bool, value> type;
};

}}





namespace boost { namespace concepts {

template <class ModelFn>
struct requirement_;

namespace detail
{
  template <void(*)()> struct instantiate {};
}

template <class Model>
struct requirement
{
    static void failed() { ((Model*)0)->~Model(); }
};

struct failed {};

template <class Model>
struct requirement<failed ************ Model::************>
{
    static void failed() { ((Model*)0)->~Model(); }
};



template <class Model>
struct constraint
{
    static void failed() { ((Model*)0)->constraints(); }
};

template <class Model>
struct requirement_<void(*)(Model)>
  : boost::conditional<
        concepts::not_satisfied<Model>::value
      , constraint<Model>
      , requirement<failed ************ Model::************>
    >::type
{};
}}









namespace boost { namespace concepts {

template <class Model>
struct usage_requirements
{
    ~usage_requirements() { ((Model*)0)->~Model(); }
};
}}












namespace boost
{





  template <class Model>
  inline void function_requires(Model* = 0)
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Model)>::failed> boost_concept_check50 __attribute__((__unused__));
  }
  template <class T> inline void ignore_unused_variable_warning(T const&) {}
  template < typename T > struct Integer; template < typename T > struct IntegerConcept : Integer< T > { }; template < typename T > struct Integer
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Integer>)>::failed> boost_concept_check72 __attribute__((__unused__)); ~Integer()
        {
            x.error_type_must_be_an_integer_type();
        }
   private:
      T x;
  };

  template <> struct Integer<char> {};
  template <> struct Integer<signed char> {};
  template <> struct Integer<unsigned char> {};
  template <> struct Integer<short> {};
  template <> struct Integer<unsigned short> {};
  template <> struct Integer<int> {};
  template <> struct Integer<unsigned int> {};
  template <> struct Integer<long> {};
  template <> struct Integer<unsigned long> {};

  template <> struct Integer< ::boost::long_long_type> {};
  template <> struct Integer< ::boost::ulong_long_type> {};





  template < typename T > struct SignedInteger; template < typename T > struct SignedIntegerConcept : SignedInteger< T > { }; template < typename T > struct SignedInteger {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SignedInteger>)>::failed> boost_concept_check98 __attribute__((__unused__)); ~SignedInteger() {
      x.error_type_must_be_a_signed_integer_type();
    }
   private:
    T x;
  };
  template <> struct SignedInteger<signed char> { };
  template <> struct SignedInteger<short> {};
  template <> struct SignedInteger<int> {};
  template <> struct SignedInteger<long> {};

  template <> struct SignedInteger< ::boost::long_long_type> {};




  template < typename T > struct UnsignedInteger; template < typename T > struct UnsignedIntegerConcept : UnsignedInteger< T > { }; template < typename T > struct UnsignedInteger {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UnsignedInteger>)>::failed> boost_concept_check115 __attribute__((__unused__)); ~UnsignedInteger() {
      x.error_type_must_be_an_unsigned_integer_type();
    }
   private:
    T x;
  };

  template <> struct UnsignedInteger<unsigned char> {};
  template <> struct UnsignedInteger<unsigned short> {};
  template <> struct UnsignedInteger<unsigned int> {};
  template <> struct UnsignedInteger<unsigned long> {};

  template <> struct UnsignedInteger< ::boost::ulong_long_type> {};







  template < typename TT > struct DefaultConstructible; template < typename TT > struct DefaultConstructibleConcept : DefaultConstructible< TT > { }; template < typename TT > struct DefaultConstructible
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<DefaultConstructible>)>::failed> boost_concept_check137 __attribute__((__unused__)); ~DefaultConstructible() {
      TT a;
      ignore_unused_variable_warning(a);
    }
  };

  template < typename TT > struct Assignable; template < typename TT > struct AssignableConcept : Assignable< TT > { }; template < typename TT > struct Assignable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Assignable>)>::failed> boost_concept_check145 __attribute__((__unused__)); ~Assignable() {

      a = b;

      const_constraints(b);
    }
   private:
    void const_constraints(const TT& x) {

      a = x;



    }
   private:
    TT a;
    TT b;
  };


  template < typename TT > struct CopyConstructible; template < typename TT > struct CopyConstructibleConcept : CopyConstructible< TT > { }; template < typename TT > struct CopyConstructible
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<CopyConstructible>)>::failed> boost_concept_check167 __attribute__((__unused__)); ~CopyConstructible() {
      TT a(b);
      TT* ptr = &a;
      const_constraints(a);
      ignore_unused_variable_warning(ptr);
    }
   private:
    void const_constraints(const TT& a) {
      TT c(a);
      const TT* ptr = &a;
      ignore_unused_variable_warning(c);
      ignore_unused_variable_warning(ptr);
    }
    TT b;
  };


  template < typename TT > struct SGIAssignable; template < typename TT > struct SGIAssignableConcept : SGIAssignable< TT > { }; template < typename TT > struct SGIAssignable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SGIAssignable>)>::failed> boost_concept_check186 __attribute__((__unused__)); ~SGIAssignable() {
      TT c(a);

      a = b;

      const_constraints(b);
      ignore_unused_variable_warning(c);
    }
   private:
    void const_constraints(const TT& x) {
      TT c(x);

      a = x;

      ignore_unused_variable_warning(c);
    }
    TT a;
    TT b;
  };

  template < typename X , typename Y > struct Convertible; template < typename X , typename Y > struct ConvertibleConcept : Convertible< X, Y > { }; template < typename X , typename Y > struct Convertible
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Convertible>)>::failed> boost_concept_check208 __attribute__((__unused__)); ~Convertible() {
      Y y = x;
      ignore_unused_variable_warning(y);
    }
   private:
    X x;
  };
  template <class TT>
  void require_boolean_expr(const TT& t) {
    bool x = t;
    ignore_unused_variable_warning(x);
  }

  template < typename TT > struct EqualityComparable; template < typename TT > struct EqualityComparableConcept : EqualityComparable< TT > { }; template < typename TT > struct EqualityComparable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<EqualityComparable>)>::failed> boost_concept_check233 __attribute__((__unused__)); ~EqualityComparable() {
      require_boolean_expr(a == b);
      require_boolean_expr(a != b);
    }
   private:
    TT a, b;
  };

  template < typename TT > struct LessThanComparable; template < typename TT > struct LessThanComparableConcept : LessThanComparable< TT > { }; template < typename TT > struct LessThanComparable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LessThanComparable>)>::failed> boost_concept_check243 __attribute__((__unused__)); ~LessThanComparable() {
      require_boolean_expr(a < b);
    }
   private:
    TT a, b;
  };


  template < typename TT > struct Comparable; template < typename TT > struct ComparableConcept : Comparable< TT > { }; template < typename TT > struct Comparable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Comparable>)>::failed> boost_concept_check253 __attribute__((__unused__)); ~Comparable() {
      require_boolean_expr(a < b);
      require_boolean_expr(a > b);
      require_boolean_expr(a <= b);
      require_boolean_expr(a >= b);
    }
   private:
    TT a, b;
  };
  template < typename First , typename Second > struct EqualOp; template < typename First , typename Second > struct EqualOpConcept : EqualOp< First, Second > { }; template < typename First , typename Second > struct EqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<EqualOp>)>::failed> boost_concept_check283 __attribute__((__unused__)); ~EqualOp() { (void)constraints_(); } private: bool constraints_() { return a == b; } First a; Second b; };
  template < typename First , typename Second > struct NotEqualOp; template < typename First , typename Second > struct NotEqualOpConcept : NotEqualOp< First, Second > { }; template < typename First , typename Second > struct NotEqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<NotEqualOp>)>::failed> boost_concept_check284 __attribute__((__unused__)); ~NotEqualOp() { (void)constraints_(); } private: bool constraints_() { return a != b; } First a; Second b; };
  template < typename First , typename Second > struct LessThanOp; template < typename First , typename Second > struct LessThanOpConcept : LessThanOp< First, Second > { }; template < typename First , typename Second > struct LessThanOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LessThanOp>)>::failed> boost_concept_check285 __attribute__((__unused__)); ~LessThanOp() { (void)constraints_(); } private: bool constraints_() { return a < b; } First a; Second b; };
  template < typename First , typename Second > struct LessEqualOp; template < typename First , typename Second > struct LessEqualOpConcept : LessEqualOp< First, Second > { }; template < typename First , typename Second > struct LessEqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LessEqualOp>)>::failed> boost_concept_check286 __attribute__((__unused__)); ~LessEqualOp() { (void)constraints_(); } private: bool constraints_() { return a <= b; } First a; Second b; };
  template < typename First , typename Second > struct GreaterThanOp; template < typename First , typename Second > struct GreaterThanOpConcept : GreaterThanOp< First, Second > { }; template < typename First , typename Second > struct GreaterThanOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<GreaterThanOp>)>::failed> boost_concept_check287 __attribute__((__unused__)); ~GreaterThanOp() { (void)constraints_(); } private: bool constraints_() { return a > b; } First a; Second b; };
  template < typename First , typename Second > struct GreaterEqualOp; template < typename First , typename Second > struct GreaterEqualOpConcept : GreaterEqualOp< First, Second > { }; template < typename First , typename Second > struct GreaterEqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<GreaterEqualOp>)>::failed> boost_concept_check288 __attribute__((__unused__)); ~GreaterEqualOp() { (void)constraints_(); } private: bool constraints_() { return a >= b; } First a; Second b; };

  template < typename Ret , typename First , typename Second > struct PlusOp; template < typename Ret , typename First , typename Second > struct PlusOpConcept : PlusOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct PlusOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<PlusOp>)>::failed> boost_concept_check290 __attribute__((__unused__)); ~PlusOp() { (void)constraints_(); } private: Ret constraints_() { return a + b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct TimesOp; template < typename Ret , typename First , typename Second > struct TimesOpConcept : TimesOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct TimesOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<TimesOp>)>::failed> boost_concept_check291 __attribute__((__unused__)); ~TimesOp() { (void)constraints_(); } private: Ret constraints_() { return a * b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct DivideOp; template < typename Ret , typename First , typename Second > struct DivideOpConcept : DivideOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct DivideOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<DivideOp>)>::failed> boost_concept_check292 __attribute__((__unused__)); ~DivideOp() { (void)constraints_(); } private: Ret constraints_() { return a / b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct SubtractOp; template < typename Ret , typename First , typename Second > struct SubtractOpConcept : SubtractOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct SubtractOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SubtractOp>)>::failed> boost_concept_check293 __attribute__((__unused__)); ~SubtractOp() { (void)constraints_(); } private: Ret constraints_() { return a - b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct ModOp; template < typename Ret , typename First , typename Second > struct ModOpConcept : ModOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct ModOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ModOp>)>::failed> boost_concept_check294 __attribute__((__unused__)); ~ModOp() { (void)constraints_(); } private: Ret constraints_() { return a % b; } First a; Second b; };




  template < typename Func , typename Return > struct Generator; template < typename Func , typename Return > struct GeneratorConcept : Generator< Func, Return > { }; template < typename Func , typename Return > struct Generator
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Generator>)>::failed> boost_concept_check301 __attribute__((__unused__)); ~Generator() { test(is_void<Return>()); }

   private:
      void test(boost::false_type)
      {

          const Return& r = f();
          ignore_unused_variable_warning(r);
      }

      void test(boost::true_type)
      {
          f();
      }

      Func f;
  };

  template < typename Func , typename Return , typename Arg > struct UnaryFunction; template < typename Func , typename Return , typename Arg > struct UnaryFunctionConcept : UnaryFunction< Func, Return, Arg > { }; template < typename Func , typename Return , typename Arg > struct UnaryFunction
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UnaryFunction>)>::failed> boost_concept_check321 __attribute__((__unused__)); ~UnaryFunction() { test(is_void<Return>()); }

   private:
      void test(boost::false_type)
      {
          f(arg);
          Return r = f(arg);
          ignore_unused_variable_warning(r);
      }

      void test(boost::true_type)
      {
          f(arg);
      }







      UnaryFunction();


      Func f;
      Arg arg;
  };

  template < typename Func , typename Return , typename First , typename Second > struct BinaryFunction; template < typename Func , typename Return , typename First , typename Second > struct BinaryFunctionConcept : BinaryFunction< Func, Return, First, Second > { }; template < typename Func , typename Return , typename First , typename Second > struct BinaryFunction
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BinaryFunction>)>::failed> boost_concept_check351 __attribute__((__unused__)); ~BinaryFunction() { test(is_void<Return>()); }
   private:
      void test(boost::false_type)
      {
          f(first,second);
          Return r = f(first, second);
          (void)r;
      }

      void test(boost::true_type)
      {
          f(first,second);
      }







      BinaryFunction();


      Func f;
      First first;
      Second second;
  };

  template < typename Func , typename Arg > struct UnaryPredicate; template < typename Func , typename Arg > struct UnaryPredicateConcept : UnaryPredicate< Func, Arg > { }; template < typename Func , typename Arg > struct UnaryPredicate
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UnaryPredicate>)>::failed> boost_concept_check381 __attribute__((__unused__)); ~UnaryPredicate() {
      require_boolean_expr(f(arg));
    }
   private:






      UnaryPredicate();


    Func f;
    Arg arg;
  };

  template < typename Func , typename First , typename Second > struct BinaryPredicate; template < typename Func , typename First , typename Second > struct BinaryPredicateConcept : BinaryPredicate< Func, First, Second > { }; template < typename Func , typename First , typename Second > struct BinaryPredicate
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BinaryPredicate>)>::failed> boost_concept_check400 __attribute__((__unused__)); ~BinaryPredicate() {
      require_boolean_expr(f(a, b));
    }
   private:






      BinaryPredicate();

    Func f;
    First a;
    Second b;
  };


  template < typename Func , typename First , typename Second > struct Const_BinaryPredicate; template < typename Func , typename First , typename Second > struct Const_BinaryPredicateConcept : Const_BinaryPredicate< Func, First, Second > { }; template < typename Func , typename First , typename Second > struct Const_BinaryPredicate
    : BinaryPredicate<Func, First, Second>
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Const_BinaryPredicate>)>::failed> boost_concept_check421 __attribute__((__unused__)); ~Const_BinaryPredicate() {
      const_constraints(f);
    }
   private:
    void const_constraints(const Func& fun) {

      require_boolean_expr(fun(a, b));
    }






      Const_BinaryPredicate();


    Func f;
    First a;
    Second b;
  };

  template < typename Func , typename Return > struct AdaptableGenerator; template < typename Func , typename Return > struct AdaptableGeneratorConcept : AdaptableGenerator< Func, Return > { }; template < typename Func , typename Return > struct AdaptableGenerator
    : Generator<Func, typename Func::result_type>
  {
      typedef typename Func::result_type result_type;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<AdaptableGenerator>)>::failed> boost_concept_check448 __attribute__((__unused__)); ~AdaptableGenerator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<result_type, Return>)>::failed> boost_concept_check450 __attribute__((__unused__));
      }
  };

  template < typename Func , typename Return , typename Arg > struct AdaptableUnaryFunction; template < typename Func , typename Return , typename Arg > struct AdaptableUnaryFunctionConcept : AdaptableUnaryFunction< Func, Return, Arg > { }; template < typename Func , typename Return , typename Arg > struct AdaptableUnaryFunction
    : UnaryFunction<Func, typename Func::result_type, typename Func::argument_type>
  {
      typedef typename Func::argument_type argument_type;
      typedef typename Func::result_type result_type;

      ~AdaptableUnaryFunction()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<result_type, Return>)>::failed> boost_concept_check462 __attribute__((__unused__));
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<Arg, argument_type>)>::failed> boost_concept_check463 __attribute__((__unused__));
      }
  };

  template < typename Func , typename Return , typename First , typename Second > struct AdaptableBinaryFunction; template < typename Func , typename Return , typename First , typename Second > struct AdaptableBinaryFunctionConcept : AdaptableBinaryFunction< Func, Return, First, Second > { }; template < typename Func , typename Return , typename First , typename Second > struct AdaptableBinaryFunction
    : BinaryFunction<
          Func
        , typename Func::result_type
        , typename Func::first_argument_type
        , typename Func::second_argument_type
      >
  {
      typedef typename Func::first_argument_type first_argument_type;
      typedef typename Func::second_argument_type second_argument_type;
      typedef typename Func::result_type result_type;

      ~AdaptableBinaryFunction()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<result_type, Return>)>::failed> boost_concept_check481 __attribute__((__unused__));
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<First, first_argument_type>)>::failed> boost_concept_check482 __attribute__((__unused__));
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<Second, second_argument_type>)>::failed> boost_concept_check483 __attribute__((__unused__));
      }
  };

  template < typename Func , typename Arg > struct AdaptablePredicate; template < typename Func , typename Arg > struct AdaptablePredicateConcept : AdaptablePredicate< Func, Arg > { }; template < typename Func , typename Arg > struct AdaptablePredicate
    : UnaryPredicate<Func, Arg>
    , AdaptableUnaryFunction<Func, bool, Arg>
  {
  };

  template < typename Func , typename First , typename Second > struct AdaptableBinaryPredicate; template < typename Func , typename First , typename Second > struct AdaptableBinaryPredicateConcept : AdaptableBinaryPredicate< Func, First, Second > { }; template < typename Func , typename First , typename Second > struct AdaptableBinaryPredicate
    : BinaryPredicate<Func, First, Second>
    , AdaptableBinaryFunction<Func, bool, First, Second>
  {
  };




  template < typename TT > struct InputIterator; template < typename TT > struct InputIteratorConcept : InputIterator< TT > { }; template < typename TT > struct InputIterator
    : Assignable<TT>
    , EqualityComparable<TT>
  {
      typedef typename std::iterator_traits<TT>::value_type value_type;
      typedef typename std::iterator_traits<TT>::difference_type difference_type;
      typedef typename std::iterator_traits<TT>::reference reference;
      typedef typename std::iterator_traits<TT>::pointer pointer;
      typedef typename std::iterator_traits<TT>::iterator_category iterator_category;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<InputIterator>)>::failed> boost_concept_check512 __attribute__((__unused__)); ~InputIterator()
      {
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(SignedInteger<difference_type>)>::failed> boost_concept_check514 __attribute__((__unused__));
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<iterator_category, std::input_iterator_tag>)>::failed> boost_concept_check515 __attribute__((__unused__));

        TT j(i);
        (void)*i;
        ++j;
        i++;
      }
   private:
    TT i;
  };

  template < typename TT , typename ValueT > struct OutputIterator; template < typename TT , typename ValueT > struct OutputIteratorConcept : OutputIterator< TT, ValueT > { }; template < typename TT , typename ValueT > struct OutputIterator
    : Assignable<TT>
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<OutputIterator>)>::failed> boost_concept_check529 __attribute__((__unused__)); ~OutputIterator() {

      ++i;
      i++;
      *i++ = t;
    }
   private:
    TT i, j;
    ValueT t;
  };

  template < typename TT > struct ForwardIterator; template < typename TT > struct ForwardIteratorConcept : ForwardIterator< TT > { }; template < typename TT > struct ForwardIterator
    : InputIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ForwardIterator>)>::failed> boost_concept_check543 __attribute__((__unused__)); ~ForwardIterator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible< typename ForwardIterator::iterator_category , std::forward_iterator_tag >)>::failed> boost_concept_check548 __attribute__((__unused__));




          typename InputIterator<TT>::reference r = *i;
          ignore_unused_variable_warning(r);
      }

   private:
      TT i;
  };

  template < typename TT > struct Mutable_ForwardIterator; template < typename TT > struct Mutable_ForwardIteratorConcept : Mutable_ForwardIterator< TT > { }; template < typename TT > struct Mutable_ForwardIterator
    : ForwardIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_ForwardIterator>)>::failed> boost_concept_check561 __attribute__((__unused__)); ~Mutable_ForwardIterator() {
        *i++ = *j;
      }
   private:
      TT i, j;
  };

  template < typename TT > struct BidirectionalIterator; template < typename TT > struct BidirectionalIteratorConcept : BidirectionalIterator< TT > { }; template < typename TT > struct BidirectionalIterator
    : ForwardIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BidirectionalIterator>)>::failed> boost_concept_check571 __attribute__((__unused__)); ~BidirectionalIterator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible< typename BidirectionalIterator::iterator_category , std::bidirectional_iterator_tag >)>::failed> boost_concept_check576 __attribute__((__unused__));




          --i;
          i--;
      }
   private:
      TT i;
  };

  template < typename TT > struct Mutable_BidirectionalIterator; template < typename TT > struct Mutable_BidirectionalIteratorConcept : Mutable_BidirectionalIterator< TT > { }; template < typename TT > struct Mutable_BidirectionalIterator
    : BidirectionalIterator<TT>
    , Mutable_ForwardIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_BidirectionalIterator>)>::failed> boost_concept_check589 __attribute__((__unused__)); ~Mutable_BidirectionalIterator()
      {
          *i-- = *j;
      }
   private:
      TT i, j;
  };

  template < typename TT > struct RandomAccessIterator; template < typename TT > struct RandomAccessIteratorConcept : RandomAccessIterator< TT > { }; template < typename TT > struct RandomAccessIterator
    : BidirectionalIterator<TT>
    , Comparable<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessIterator>)>::failed> boost_concept_check601 __attribute__((__unused__)); ~RandomAccessIterator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible< typename BidirectionalIterator<TT>::iterator_category , std::random_access_iterator_tag >)>::failed> boost_concept_check606 __attribute__((__unused__));




          i += n;
          i = i + n; i = n + i;
          i -= n;
          i = i - n;
          n = i - j;
          (void)i[n];
      }

   private:
    TT a, b;
    TT i, j;
      typename std::iterator_traits<TT>::difference_type n;
  };

  template < typename TT > struct Mutable_RandomAccessIterator; template < typename TT > struct Mutable_RandomAccessIteratorConcept : Mutable_RandomAccessIterator< TT > { }; template < typename TT > struct Mutable_RandomAccessIterator
    : RandomAccessIterator<TT>
    , Mutable_BidirectionalIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_RandomAccessIterator>)>::failed> boost_concept_check626 __attribute__((__unused__)); ~Mutable_RandomAccessIterator()
      {
          i[n] = *i;
      }
   private:
    TT i;
    typename std::iterator_traits<TT>::difference_type n;
  };




  template < typename C > struct Container; template < typename C > struct ContainerConcept : Container< C > { }; template < typename C > struct Container
    : Assignable<C>
  {
    typedef typename C::value_type value_type;
    typedef typename C::difference_type difference_type;
    typedef typename C::size_type size_type;
    typedef typename C::const_reference const_reference;
    typedef typename C::const_pointer const_pointer;
    typedef typename C::const_iterator const_iterator;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Container>)>::failed> boost_concept_check648 __attribute__((__unused__)); ~Container()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(InputIterator<const_iterator>)>::failed> boost_concept_check650 __attribute__((__unused__));
          const_constraints(c);
      }

   private:
      void const_constraints(const C& cc) {
          i = cc.begin();
          i = cc.end();
          n = cc.size();
          n = cc.max_size();
          b = cc.empty();
      }
      C c;
      bool b;
      const_iterator i;
      size_type n;
  };

  template < typename C > struct Mutable_Container; template < typename C > struct Mutable_ContainerConcept : Mutable_Container< C > { }; template < typename C > struct Mutable_Container
    : Container<C>
  {
      typedef typename C::reference reference;
      typedef typename C::iterator iterator;
      typedef typename C::pointer pointer;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_Container>)>::failed> boost_concept_check675 __attribute__((__unused__)); ~Mutable_Container()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Assignable<typename Mutable_Container::value_type>)>::failed> boost_concept_check678 __attribute__((__unused__));


          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(InputIterator<iterator>)>::failed> boost_concept_check680 __attribute__((__unused__));

          i = c.begin();
          i = c.end();
          c.swap(c2);
      }

   private:
      iterator i;
      C c, c2;
  };

  template < typename C > struct ForwardContainer; template < typename C > struct ForwardContainerConcept : ForwardContainer< C > { }; template < typename C > struct ForwardContainer
    : Container<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ForwardContainer>)>::failed> boost_concept_check695 __attribute__((__unused__)); ~ForwardContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( ForwardIterator< typename ForwardContainer::const_iterator >)>::failed> boost_concept_check700 __attribute__((__unused__));



      }
  };

  template < typename C > struct Mutable_ForwardContainer; template < typename C > struct Mutable_ForwardContainerConcept : Mutable_ForwardContainer< C > { }; template < typename C > struct Mutable_ForwardContainer
    : ForwardContainer<C>
    , Mutable_Container<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_ForwardContainer>)>::failed> boost_concept_check708 __attribute__((__unused__)); ~Mutable_ForwardContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Mutable_ForwardIterator< typename Mutable_ForwardContainer::iterator >)>::failed> boost_concept_check713 __attribute__((__unused__));



      }
  };

  template < typename C > struct ReversibleContainer; template < typename C > struct ReversibleContainerConcept : ReversibleContainer< C > { }; template < typename C > struct ReversibleContainer
    : ForwardContainer<C>
  {
      typedef typename
        C::const_reverse_iterator
      const_reverse_iterator;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ReversibleContainer>)>::failed> boost_concept_check724 __attribute__((__unused__)); ~ReversibleContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( BidirectionalIterator< typename ReversibleContainer::const_iterator>)>::failed> boost_concept_check728 __attribute__((__unused__));



          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BidirectionalIterator<const_reverse_iterator>)>::failed> boost_concept_check730 __attribute__((__unused__));

          const_constraints(c);
      }
   private:
      void const_constraints(const C& cc)
      {
          const_reverse_iterator _i = cc.rbegin();
          _i = cc.rend();
      }
      C c;
  };

  template < typename C > struct Mutable_ReversibleContainer; template < typename C > struct Mutable_ReversibleContainerConcept : Mutable_ReversibleContainer< C > { }; template < typename C > struct Mutable_ReversibleContainer
    : Mutable_ForwardContainer<C>
    , ReversibleContainer<C>
  {
      typedef typename C::reverse_iterator reverse_iterator;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_ReversibleContainer>)>::failed> boost_concept_check749 __attribute__((__unused__)); ~Mutable_ReversibleContainer()
      {
          typedef typename Mutable_ForwardContainer<C>::iterator iterator;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_BidirectionalIterator<iterator>)>::failed> boost_concept_check752 __attribute__((__unused__));
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_BidirectionalIterator<reverse_iterator>)>::failed> boost_concept_check753 __attribute__((__unused__));

          reverse_iterator i = c.rbegin();
          i = c.rend();
      }
   private:
      C c;
  };

  template < typename C > struct RandomAccessContainer; template < typename C > struct RandomAccessContainerConcept : RandomAccessContainer< C > { }; template < typename C > struct RandomAccessContainer
    : ReversibleContainer<C>
  {
      typedef typename C::size_type size_type;
      typedef typename C::const_reference const_reference;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessContainer>)>::failed> boost_concept_check768 __attribute__((__unused__)); ~RandomAccessContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( RandomAccessIterator< typename RandomAccessContainer::const_iterator >)>::failed> boost_concept_check773 __attribute__((__unused__));




          const_constraints(c);
      }
   private:
      void const_constraints(const C& cc)
      {
          const_reference r = cc[n];
          ignore_unused_variable_warning(r);
      }

      C c;
      size_type n;
  };

  template < typename C > struct Mutable_RandomAccessContainer; template < typename C > struct Mutable_RandomAccessContainerConcept : Mutable_RandomAccessContainer< C > { }; template < typename C > struct Mutable_RandomAccessContainer
    : Mutable_ReversibleContainer<C>
    , RandomAccessContainer<C>
  {
   private:
      typedef Mutable_RandomAccessContainer self;
   public:
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_RandomAccessContainer>)>::failed> boost_concept_check795 __attribute__((__unused__)); ~Mutable_RandomAccessContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_RandomAccessIterator<typename self::iterator>)>::failed> boost_concept_check797 __attribute__((__unused__));
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_RandomAccessIterator<typename self::reverse_iterator>)>::failed> boost_concept_check798 __attribute__((__unused__));

          typename self::reference r = c[i];
          ignore_unused_variable_warning(r);
      }

   private:
      typename Mutable_ReversibleContainer<C>::size_type i;
      C c;
  };


  template < typename S > struct Sequence; template < typename S > struct SequenceConcept : Sequence< S > { }; template < typename S > struct Sequence
    : Mutable_ForwardContainer<S>



    , DefaultConstructible<S>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Sequence>)>::failed> boost_concept_check817 __attribute__((__unused__)); ~Sequence()
      {
          S
              c(n, t),
              c2(first, last);

          c.insert(p, t);
          c.insert(p, n, t);
          c.insert(p, first, last);

          c.erase(p);
          c.erase(p, q);

          typename Sequence::reference r = c.front();

          ignore_unused_variable_warning(c);
          ignore_unused_variable_warning(c2);
          ignore_unused_variable_warning(r);
          const_constraints(c);
      }
   private:
      void const_constraints(const S& c) {
          typename Sequence::const_reference r = c.front();
          ignore_unused_variable_warning(r);
      }

      typename S::value_type t;
      typename S::size_type n;
      typename S::value_type* first, *last;
      typename S::iterator p, q;
  };

  template < typename S > struct FrontInsertionSequence; template < typename S > struct FrontInsertionSequenceConcept : FrontInsertionSequence< S > { }; template < typename S > struct FrontInsertionSequence
    : Sequence<S>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<FrontInsertionSequence>)>::failed> boost_concept_check852 __attribute__((__unused__)); ~FrontInsertionSequence()
      {
          c.push_front(t);
          c.pop_front();
      }
   private:
      S c;
      typename S::value_type t;
  };

  template < typename S > struct BackInsertionSequence; template < typename S > struct BackInsertionSequenceConcept : BackInsertionSequence< S > { }; template < typename S > struct BackInsertionSequence
    : Sequence<S>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BackInsertionSequence>)>::failed> boost_concept_check865 __attribute__((__unused__)); ~BackInsertionSequence()
      {
          c.push_back(t);
          c.pop_back();
          typename BackInsertionSequence::reference r = c.back();
          ignore_unused_variable_warning(r);
          const_constraints(c);
      }
   private:
      void const_constraints(const S& cc) {
          typename BackInsertionSequence::const_reference
              r = cc.back();
          ignore_unused_variable_warning(r);
      }
      S c;
      typename S::value_type t;
  };

  template < typename C > struct AssociativeContainer; template < typename C > struct AssociativeContainerConcept : AssociativeContainer< C > { }; template < typename C > struct AssociativeContainer
    : ForwardContainer<C>
    , DefaultConstructible<C>
  {
      typedef typename C::key_type key_type;
      typedef typename C::key_compare key_compare;
      typedef typename C::value_compare value_compare;
      typedef typename C::iterator iterator;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<AssociativeContainer>)>::failed> boost_concept_check892 __attribute__((__unused__)); ~AssociativeContainer()
      {
          i = c.find(k);
          r = c.equal_range(k);
          c.erase(k);
          c.erase(i);
          c.erase(r.first, r.second);
          const_constraints(c);
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BinaryPredicate<key_compare,key_type,key_type>)>::failed> boost_concept_check900 __attribute__((__unused__));

          typedef typename AssociativeContainer::value_type value_type_;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BinaryPredicate<value_compare,value_type_,value_type_>)>::failed> boost_concept_check903 __attribute__((__unused__));
      }


      typedef typename C::const_iterator const_iterator;
   private:
      void const_constraints(const C& cc)
      {
          ci = cc.find(k);
          n = cc.count(k);
          cr = cc.equal_range(k);
      }

      C c;
      iterator i;
      std::pair<iterator,iterator> r;
      const_iterator ci;
      std::pair<const_iterator,const_iterator> cr;
      typename C::key_type k;
      typename C::size_type n;
  };

  template < typename C > struct UniqueAssociativeContainer; template < typename C > struct UniqueAssociativeContainerConcept : UniqueAssociativeContainer< C > { }; template < typename C > struct UniqueAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UniqueAssociativeContainer>)>::failed> boost_concept_check928 __attribute__((__unused__)); ~UniqueAssociativeContainer()
      {
          C c(first, last);

          pos_flag = c.insert(t);
          c.insert(first, last);

          ignore_unused_variable_warning(c);
      }
   private:
      std::pair<typename C::iterator, bool> pos_flag;
      typename C::value_type t;
      typename C::value_type* first, *last;
  };

  template < typename C > struct MultipleAssociativeContainer; template < typename C > struct MultipleAssociativeContainerConcept : MultipleAssociativeContainer< C > { }; template < typename C > struct MultipleAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<MultipleAssociativeContainer>)>::failed> boost_concept_check946 __attribute__((__unused__)); ~MultipleAssociativeContainer()
      {
          C c(first, last);

          pos = c.insert(t);
          c.insert(first, last);

          ignore_unused_variable_warning(c);
          ignore_unused_variable_warning(pos);
      }
   private:
      typename C::iterator pos;
      typename C::value_type t;
      typename C::value_type* first, *last;
  };

  template < typename C > struct SimpleAssociativeContainer; template < typename C > struct SimpleAssociativeContainerConcept : SimpleAssociativeContainer< C > { }; template < typename C > struct SimpleAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SimpleAssociativeContainer>)>::failed> boost_concept_check965 __attribute__((__unused__)); ~SimpleAssociativeContainer()
      {
          typedef typename C::key_type key_type;
          typedef typename C::value_type value_type;
          static_assert((boost::is_same<key_type,value_type>::value), "(boost::is_same<key_type,value_type>::value)");
      }
  };

  template < typename C > struct PairAssociativeContainer; template < typename C > struct PairAssociativeContainerConcept : PairAssociativeContainer< C > { }; template < typename C > struct PairAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<PairAssociativeContainer>)>::failed> boost_concept_check976 __attribute__((__unused__)); ~PairAssociativeContainer()
      {
          typedef typename C::key_type key_type;
          typedef typename C::value_type value_type;
          typedef typename C::mapped_type mapped_type;
          typedef std::pair<const key_type, mapped_type> required_value_type;
          static_assert((boost::is_same<value_type,required_value_type>::value), "(boost::is_same<value_type,required_value_type>::value)");
      }
  };

  template < typename C > struct SortedAssociativeContainer; template < typename C > struct SortedAssociativeContainerConcept : SortedAssociativeContainer< C > { }; template < typename C > struct SortedAssociativeContainer
    : AssociativeContainer<C>
    , ReversibleContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SortedAssociativeContainer>)>::failed> boost_concept_check990 __attribute__((__unused__)); ~SortedAssociativeContainer()
      {
          C
              c(kc),
              c2(first, last),
              c3(first, last, kc);

          p = c.upper_bound(k);
          p = c.lower_bound(k);
          r = c.equal_range(k);

          c.insert(p, t);

          ignore_unused_variable_warning(c);
          ignore_unused_variable_warning(c2);
          ignore_unused_variable_warning(c3);
          const_constraints(c);
      }

      void const_constraints(const C& c)
      {
          kc = c.key_comp();
          vc = c.value_comp();

          cp = c.upper_bound(k);
          cp = c.lower_bound(k);
          cr = c.equal_range(k);
      }

   private:
      typename C::key_compare kc;
      typename C::value_compare vc;
      typename C::value_type t;
      typename C::key_type k;
      typedef typename C::iterator iterator;
      typedef typename C::const_iterator const_iterator;

      typedef SortedAssociativeContainer self;
      iterator p;
      const_iterator cp;
      std::pair<typename self::iterator,typename self::iterator> r;
      std::pair<typename self::const_iterator,typename self::const_iterator> cr;
      typename C::value_type* first, *last;
  };



  template < typename C > struct Collection; template < typename C > struct CollectionConcept : Collection< C > { }; template < typename C > struct Collection
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Collection>)>::failed> boost_concept_check1039 __attribute__((__unused__)); ~Collection()
      {
        boost::function_requires<boost::InputIteratorConcept<iterator> >();
        boost::function_requires<boost::InputIteratorConcept<const_iterator> >();
        boost::function_requires<boost::CopyConstructibleConcept<value_type> >();
        const_constraints(c);
        i = c.begin();
        i = c.end();
        c.swap(c);
      }

      void const_constraints(const C& cc) {
        ci = cc.begin();
        ci = cc.end();
        n = cc.size();
        b = cc.empty();
      }

    private:
      typedef typename C::value_type value_type;
      typedef typename C::iterator iterator;
      typedef typename C::const_iterator const_iterator;
      typedef typename C::reference reference;
      typedef typename C::const_reference const_reference;

      typedef typename C::difference_type difference_type;
      typedef typename C::size_type size_type;

      C c;
      bool b;
      iterator i;
      const_iterator ci;
      size_type n;
  };
}












namespace boost_concepts
{







  template < typename Iterator > struct ReadableIterator; template < typename Iterator > struct ReadableIteratorConcept : ReadableIterator< Iterator > { }; template < typename Iterator > struct ReadableIterator
    : boost::Assignable<Iterator>
    , boost::CopyConstructible<Iterator>

  {
      typedef typename std::iterator_traits<Iterator>::value_type value_type;
      typedef typename std::iterator_traits<Iterator>::reference reference;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ReadableIterator>)>::failed> boost_concept_check48 __attribute__((__unused__)); ~ReadableIterator()
      {

          value_type v = *i;
          boost::ignore_unused_variable_warning(v);
      }
  private:
      Iterator i;
  };

  template <
      typename Iterator
    , typename ValueType = typename std::iterator_traits<Iterator>::value_type
  >
  struct WritableIterator
    : boost::CopyConstructible<Iterator>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<WritableIterator>)>::failed> boost_concept_check65 __attribute__((__unused__)); ~WritableIterator()
      {
          *i = v;
      }
  private:
      ValueType v;
      Iterator i;
  };

  template <
      typename Iterator
    , typename ValueType = typename std::iterator_traits<Iterator>::value_type
  >
  struct WritableIteratorConcept : WritableIterator<Iterator,ValueType> {};

  template < typename Iterator > struct SwappableIterator; template < typename Iterator > struct SwappableIteratorConcept : SwappableIterator< Iterator > { }; template < typename Iterator > struct SwappableIterator
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SwappableIterator>)>::failed> boost_concept_check82 __attribute__((__unused__)); ~SwappableIterator()
      {
          std::iter_swap(i1, i2);
      }
  private:
      Iterator i1;
      Iterator i2;
  };

  template < typename Iterator > struct LvalueIterator; template < typename Iterator > struct LvalueIteratorConcept : LvalueIterator< Iterator > { }; template < typename Iterator > struct LvalueIterator
  {
      typedef typename std::iterator_traits<Iterator>::value_type value_type;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LvalueIterator>)>::failed> boost_concept_check95 __attribute__((__unused__)); ~LvalueIterator()
      {
        value_type& r = const_cast<value_type&>(*i);
        boost::ignore_unused_variable_warning(r);
      }
  private:
      Iterator i;
  };





  template < typename Iterator > struct IncrementableIterator; template < typename Iterator > struct IncrementableIteratorConcept : IncrementableIterator< Iterator > { }; template < typename Iterator > struct IncrementableIterator
    : boost::Assignable<Iterator>
    , boost::CopyConstructible<Iterator>
  {
      typedef typename boost::iterator_traversal<Iterator>::type traversal_category;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< traversal_category , boost::incrementable_traversal_tag >)>::failed> boost_concept_check118 __attribute__((__unused__));





      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<IncrementableIterator>)>::failed> boost_concept_check120 __attribute__((__unused__)); ~IncrementableIterator()
      {
          ++i;
          (void)i++;
      }
  private:
      Iterator i;
  };

  template < typename Iterator > struct SinglePassIterator; template < typename Iterator > struct SinglePassIteratorConcept : SinglePassIterator< Iterator > { }; template < typename Iterator > struct SinglePassIterator
    : IncrementableIterator<Iterator>
    , boost::EqualityComparable<Iterator>

  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< typename SinglePassIterator::traversal_category , boost::single_pass_traversal_tag > )>::failed> boost_concept_check138 __attribute__((__unused__));




  };

  template < typename Iterator > struct ForwardTraversal; template < typename Iterator > struct ForwardTraversalConcept : ForwardTraversal< Iterator > { }; template < typename Iterator > struct ForwardTraversal
    : SinglePassIterator<Iterator>
    , boost::DefaultConstructible<Iterator>
  {
      typedef typename std::iterator_traits<Iterator>::difference_type difference_type;

      enum { mpl_assertion_in_line_147 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (boost::is_integral<difference_type>))0, 1 ) ) ) };
      enum { mpl_assert_rel_value148 = (std::numeric_limits<difference_type>::is_signed == true) }; enum { mpl_assertion_in_line_148 = sizeof( boost::mpl::assertion_failed<mpl_assert_rel_value148>( (boost::mpl::failed ************ ( boost::mpl::assert_relation< boost::mpl::assert_::relations( sizeof( boost::mpl::assert_::arg == boost::mpl::assert_::arg ) ) , std::numeric_limits<difference_type>::is_signed , true >::************)) 0 ) ) };

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< typename ForwardTraversal::traversal_category , boost::forward_traversal_tag > )>::failed> boost_concept_check154 __attribute__((__unused__));




  };

  template < typename Iterator > struct BidirectionalTraversal; template < typename Iterator > struct BidirectionalTraversalConcept : BidirectionalTraversal< Iterator > { }; template < typename Iterator > struct BidirectionalTraversal
    : ForwardTraversal<Iterator>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< typename BidirectionalTraversal::traversal_category , boost::bidirectional_traversal_tag > )>::failed> boost_concept_check164 __attribute__((__unused__));





      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BidirectionalTraversal>)>::failed> boost_concept_check166 __attribute__((__unused__)); ~BidirectionalTraversal()
      {
          --i;
          (void)i--;
      }
   private:
      Iterator i;
  };

  template < typename Iterator > struct RandomAccessTraversal; template < typename Iterator > struct RandomAccessTraversalConcept : RandomAccessTraversal< Iterator > { }; template < typename Iterator > struct RandomAccessTraversal
    : BidirectionalTraversal<Iterator>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< typename RandomAccessTraversal::traversal_category , boost::random_access_traversal_tag > )>::failed> boost_concept_check182 __attribute__((__unused__));





      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessTraversal>)>::failed> boost_concept_check184 __attribute__((__unused__)); ~RandomAccessTraversal()
      {
          i += n;
          i = i + n;
          i = n + i;
          i -= n;
          i = i - n;
          n = i - j;
      }

   private:
      typename BidirectionalTraversal<Iterator>::difference_type n;
      Iterator i, j;
  };




  namespace detail
  {
    template <typename Iterator1, typename Iterator2>
    void interop_single_pass_constraints(Iterator1 const& i1, Iterator2 const& i2)
    {
        bool b;
        b = i1 == i2;
        b = i1 != i2;

        b = i2 == i1;
        b = i2 != i1;
        boost::ignore_unused_variable_warning(b);
    }

    template <typename Iterator1, typename Iterator2>
    void interop_rand_access_constraints(
        Iterator1 const& i1, Iterator2 const& i2,
        boost::random_access_traversal_tag, boost::random_access_traversal_tag)
    {
        bool b;
        typename std::iterator_traits<Iterator2>::difference_type n;
        b = i1 < i2;
        b = i1 <= i2;
        b = i1 > i2;
        b = i1 >= i2;
        n = i1 - i2;

        b = i2 < i1;
        b = i2 <= i1;
        b = i2 > i1;
        b = i2 >= i1;
        n = i2 - i1;
        boost::ignore_unused_variable_warning(b);
        boost::ignore_unused_variable_warning(n);
    }

    template <typename Iterator1, typename Iterator2>
    void interop_rand_access_constraints(
        Iterator1 const&, Iterator2 const&,
        boost::single_pass_traversal_tag, boost::single_pass_traversal_tag)
    { }

  }

  template < typename Iterator , typename ConstIterator > struct InteroperableIterator; template < typename Iterator , typename ConstIterator > struct InteroperableIteratorConcept : InteroperableIterator< Iterator, ConstIterator > { }; template < typename Iterator , typename ConstIterator > struct InteroperableIterator
  {
   private:
      typedef typename boost::iterators::pure_iterator_traversal<Iterator>::type traversal_category;
      typedef typename boost::iterators::pure_iterator_traversal<ConstIterator>::type const_traversal_category;

   public:
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(SinglePassIterator<Iterator>)>::failed> boost_concept_check253 __attribute__((__unused__));
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(SinglePassIterator<ConstIterator>)>::failed> boost_concept_check254 __attribute__((__unused__));

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<InteroperableIterator>)>::failed> boost_concept_check256 __attribute__((__unused__)); ~InteroperableIterator()
      {
          detail::interop_single_pass_constraints(i, ci);
          detail::interop_rand_access_constraints(i, ci, traversal_category(), const_traversal_category());

          ci = i;
      }

   private:
      Iterator i;
      ConstIterator ci;
  };

}





namespace boost
{
    template< class T >
    struct range_value : iterator_value< typename range_iterator<T>::type >
    { };
}
namespace boost
{
    namespace range_detail
    {
        template<typename T1, typename T2>
        class SameTypeConcept
        {
        public:
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SameTypeConcept>)>::failed> boost_concept_check21 __attribute__((__unused__)); ~SameTypeConcept()
            {
                same_type(a,b);
            }
        private:
            template<typename T> void same_type(T,T) {}
            T1 a;
            T2 b;
        };
    }
}
namespace boost {

    namespace range_detail {
        template<class Iterator>
        struct IncrementableIteratorConcept : CopyConstructible<Iterator>
        {

            typedef typename iterator_traversal<Iterator>::type traversal_category;

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< traversal_category, incrementable_traversal_tag >)>::failed> boost_concept_check134 __attribute__((__unused__));





            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<IncrementableIteratorConcept>)>::failed> boost_concept_check136 __attribute__((__unused__)); ~IncrementableIteratorConcept()
            {
                ++i;
                (void)i++;
            }
        private:
            Iterator i;

        };

        template<class Iterator>
        struct SinglePassIteratorConcept
            : IncrementableIteratorConcept<Iterator>
            , EqualityComparable<Iterator>
        {

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< typename SinglePassIteratorConcept::traversal_category, single_pass_traversal_tag >)>::failed> boost_concept_check156 __attribute__((__unused__));





            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SinglePassIteratorConcept>)>::failed> boost_concept_check158 __attribute__((__unused__)); ~SinglePassIteratorConcept()
            {
                Iterator i2(++i);
                boost::ignore_unused_variable_warning(i2);





                (void)(i++);

                typename std::iterator_traits<Iterator>::reference r1(*i);
                boost::ignore_unused_variable_warning(r1);

                typename std::iterator_traits<Iterator>::reference r2(*(++i));
                boost::ignore_unused_variable_warning(r2);
            }
        private:
            Iterator i;

        };

        template<class Iterator>
        struct ForwardIteratorConcept
            : SinglePassIteratorConcept<Iterator>
            , DefaultConstructible<Iterator>
        {

            typedef typename std::iterator_traits<Iterator>::difference_type difference_type;

            enum { mpl_assertion_in_line_188 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (is_integral<difference_type>))0, 1 ) ) ) };
            enum { mpl_assert_rel_value189 = (std::numeric_limits<difference_type>::is_signed == true) }; enum { mpl_assertion_in_line_189 = sizeof( boost::mpl::assertion_failed<mpl_assert_rel_value189>( (boost::mpl::failed ************ ( boost::mpl::assert_relation< boost::mpl::assert_::relations( sizeof( boost::mpl::assert_::arg == boost::mpl::assert_::arg ) ) , std::numeric_limits<difference_type>::is_signed , true >::************)) 0 ) ) };

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< typename ForwardIteratorConcept::traversal_category, forward_traversal_tag >)>::failed> boost_concept_check195 __attribute__((__unused__));





            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ForwardIteratorConcept>)>::failed> boost_concept_check197 __attribute__((__unused__)); ~ForwardIteratorConcept()
            {




                Iterator i2(i++);
                boost::ignore_unused_variable_warning(i2);
                typename std::iterator_traits<Iterator>::reference r(*(i++));
                boost::ignore_unused_variable_warning(r);
            }
        private:
            Iterator i;

         };

         template<class Iterator>
         struct BidirectionalIteratorConcept
             : ForwardIteratorConcept<Iterator>
         {

             typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< typename BidirectionalIteratorConcept::traversal_category, bidirectional_traversal_tag >)>::failed> boost_concept_check222 __attribute__((__unused__));





             typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BidirectionalIteratorConcept>)>::failed> boost_concept_check224 __attribute__((__unused__)); ~BidirectionalIteratorConcept()
             {
                 --i;
                 (void)i--;
             }
         private:
             Iterator i;

         };

         template<class Iterator>
         struct RandomAccessIteratorConcept
             : BidirectionalIteratorConcept<Iterator>
         {

             typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< typename RandomAccessIteratorConcept::traversal_category, random_access_traversal_tag >)>::failed> boost_concept_check243 __attribute__((__unused__));





             typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessIteratorConcept>)>::failed> boost_concept_check245 __attribute__((__unused__)); ~RandomAccessIteratorConcept()
             {
                 i += n;
                 i = i + n;
                 i = n + i;
                 i -= n;
                 i = i - n;
                 n = i - j;
             }
         private:
             typename BidirectionalIteratorConcept<Iterator>::difference_type n;
             Iterator i;
             Iterator j;

         };

    }


    template<class T>
    struct SinglePassRangeConcept
    {



        typedef typename remove_reference<T>::type Rng;

        typedef typename range_iterator<
            Rng const
        >::type const_iterator;

        typedef typename range_iterator<Rng>::type iterator;

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( range_detail::SinglePassIteratorConcept<iterator>)>::failed> boost_concept_check279 __attribute__((__unused__));


        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( range_detail::SinglePassIteratorConcept<const_iterator>)>::failed> boost_concept_check282 __attribute__((__unused__));


        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SinglePassRangeConcept>)>::failed> boost_concept_check284 __attribute__((__unused__)); ~SinglePassRangeConcept()
        {



            iterator i1 = boost::begin(*m_range);
            iterator i2 = boost::end(*m_range);

            boost::ignore_unused_variable_warning(i1);
            boost::ignore_unused_variable_warning(i2);

            const_constraints(*m_range);
        }

    private:
        void const_constraints(const Rng& const_range)
        {
            const_iterator ci1 = boost::begin(const_range);
            const_iterator ci2 = boost::end(const_range);

            boost::ignore_unused_variable_warning(ci1);
            boost::ignore_unused_variable_warning(ci2);
        }





       Rng* m_range;

    };


    template<class T>
    struct ForwardRangeConcept : SinglePassRangeConcept<T>
    {

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::ForwardIteratorConcept<typename ForwardRangeConcept::iterator>)>::failed> boost_concept_check321 __attribute__((__unused__));
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::ForwardIteratorConcept<typename ForwardRangeConcept::const_iterator>)>::failed> boost_concept_check322 __attribute__((__unused__));

    };

    template<class T>
    struct WriteableRangeConcept
    {

        typedef typename range_iterator<T>::type iterator;

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<WriteableRangeConcept>)>::failed> boost_concept_check332 __attribute__((__unused__)); ~WriteableRangeConcept()
        {
            *i = v;
        }
    private:
        iterator i;
        typename range_value<T>::type v;

    };


    template<class T>
    struct WriteableForwardRangeConcept
        : ForwardRangeConcept<T>
        , WriteableRangeConcept<T>
    {
    };


    template<class T>
    struct BidirectionalRangeConcept : ForwardRangeConcept<T>
    {

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::BidirectionalIteratorConcept<typename BidirectionalRangeConcept::iterator>)>::failed> boost_concept_check355 __attribute__((__unused__));
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::BidirectionalIteratorConcept<typename BidirectionalRangeConcept::const_iterator>)>::failed> boost_concept_check356 __attribute__((__unused__));

    };


    template<class T>
    struct WriteableBidirectionalRangeConcept
        : BidirectionalRangeConcept<T>
        , WriteableRangeConcept<T>
    {
    };


    template<class T>
    struct RandomAccessRangeConcept : BidirectionalRangeConcept<T>
    {

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::RandomAccessIteratorConcept<typename RandomAccessRangeConcept::iterator>)>::failed> boost_concept_check373 __attribute__((__unused__));
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::RandomAccessIteratorConcept<typename RandomAccessRangeConcept::const_iterator>)>::failed> boost_concept_check374 __attribute__((__unused__));

    };


    template<class T>
    struct WriteableRandomAccessRangeConcept
        : RandomAccessRangeConcept<T>
        , WriteableRangeConcept<T>
    {
    };

}








namespace boost
{
    namespace detail
    {





        template<typename T>
        class has_size_type
        {
            typedef char no_type;
            struct yes_type { char dummy[2]; };

            template<typename C>
            static yes_type test(typename C::size_type x);

            template<typename C>
            static no_type test(...);

        public:
            static const bool value = sizeof(test<T>(0)) == sizeof(yes_type);
        };

        template<typename C, typename Enabler=void>
        struct range_size_
        {
            typedef typename make_unsigned<
                typename range_difference<C>::type
            >::type type;
        };

        template<typename C>
        struct range_size_<
            C,
            typename ::boost::enable_if<has_size_type<C>, void>::type
        >
        {
            typedef typename C::size_type type;
        };

        template<typename C, bool B = range_detail::has_type< range_iterator<C> >::value>
        struct range_size
        { };

        template<typename C>
        struct range_size<C, true>
          : range_size_<C>
        { };
    }

    template< class T >
    struct range_size :
        detail::range_size<T>
    { };

}

namespace boost
{
    namespace range_detail
    {

template<class T>
class has_member_size_impl
{
private:
    template<class U, U>
    class check
    {
    };

    template<class C>
    static boost::uint8_t f(check<std::size_t(C::*)(void) const, &C::size>*);

    template<class C>
    static boost::uint16_t f(...);

public:
    static const bool value =
        (sizeof(f<T>(0)) == sizeof(boost::uint8_t));

    typedef typename mpl::if_c<
        (sizeof(f<T>(0)) == sizeof(boost::uint8_t)),
        mpl::true_,
        mpl::false_
    >::type type;
};

template<class T>
struct has_member_size
{
    typedef typename mpl::and_<
        typename is_class<T>::type,
        typename has_member_size_impl<const T>::type
    >::type type;

    static const bool value =
        is_class<T>::value && has_member_size_impl<const T>::value;
};

    }
}
namespace boost
{

namespace detail
{
template < typename T >
struct remove_cv_ref
{
    typedef typename ::boost::remove_cv<typename
     ::boost::remove_reference<T>::type>::type type;

};







template < typename T, typename U >
struct is_related
    : public ::boost::is_same<
     typename ::boost::detail::remove_cv_ref<T>::type,
     typename ::boost::detail::remove_cv_ref<U>::type >
{};
template<typename ...T>
struct enable_if_unrelated
    : public ::boost::enable_if_c<true>
{};

template<typename T, typename U, typename ...U2>
struct enable_if_unrelated<T, U, U2...>
    : public ::boost::disable_if< ::boost::detail::is_related<T, U> >
{};


}
template < typename MemberType, int UniqueID = 0 >
class base_from_member
{
protected:
    MemberType member;
    base_from_member()
        : member()
        {}

    template < typename T0 > explicit base_from_member( T0 x0 ) : member( x0 ) {}
    template < typename T0 , typename T1 > base_from_member( T0 x0 , T1 x1 ) : member( x0 , x1 ) {} template < typename T0 , typename T1 , typename T2 > base_from_member( T0 x0 , T1 x1 , T2 x2 ) : member( x0 , x1 , x2 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 > base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 ) : member( x0 , x1 , x2 , x3 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 ) : member( x0 , x1 , x2 , x3 , x4 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 ) : member( x0 , x1 , x2 , x3 , x4 , x5 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 , T7 x7 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 , T7 x7 , T8 x8 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 , x8 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 , T7 x7 , T8 x8 , T9 x9 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 , x8 , x9 ) {}



};

template < typename MemberType, int UniqueID >
class base_from_member<MemberType&, UniqueID>
{
protected:
    MemberType& member;

    explicit constexpr base_from_member( MemberType& x )
        noexcept
        : member( x )
        {}

};

}
namespace boost {

namespace detail {

template<typename Function> struct function_traits_helper;

template<typename R>
struct function_traits_helper<R (*)(void)>
{
  static const unsigned arity = 0;
  typedef R result_type;
};

template<typename R, typename T1>
struct function_traits_helper<R (*)(T1)>
{
  static const unsigned arity = 1;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T1 argument_type;
};

template<typename R, typename T1, typename T2>
struct function_traits_helper<R (*)(T1, T2)>
{
  static const unsigned arity = 2;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T1 first_argument_type;
  typedef T2 second_argument_type;
};

template<typename R, typename T1, typename T2, typename T3>
struct function_traits_helper<R (*)(T1, T2, T3)>
{
  static const unsigned arity = 3;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4>
struct function_traits_helper<R (*)(T1, T2, T3, T4)>
{
  static const unsigned arity = 4;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5)>
{
  static const unsigned arity = 5;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6)>
{
  static const unsigned arity = 6;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7)>
{
  static const unsigned arity = 7;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8)>
{
  static const unsigned arity = 8;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8, typename T9>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8, T9)>
{
  static const unsigned arity = 9;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
  typedef T9 arg9_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8, typename T9,
         typename T10>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
{
  static const unsigned arity = 10;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
  typedef T9 arg9_type;
  typedef T10 arg10_type;
};

}

template<typename Function>
struct function_traits :
  public boost::detail::function_traits_helper<typename boost::add_pointer<Function>::type>
{
};

}



namespace boost
{



template<class T> inline void checked_delete(T * x)
{

    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
    (void) sizeof(type_must_be_complete);
    delete x;
}

template<class T> inline void checked_array_delete(T * x)
{
    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
    (void) sizeof(type_must_be_complete);
    delete [] x;
}

template<class T> struct checked_deleter
{
    typedef void result_type;
    typedef T * argument_type;

    void operator()(T * x) const
    {

        boost::checked_delete(x);
    }
};

template<class T> struct checked_array_deleter
{
    typedef void result_type;
    typedef T * argument_type;

    void operator()(T * x) const
    {
        boost::checked_array_delete(x);
    }
};

}
namespace boost {






namespace noncopyable_
{
  struct base_token {};



  class noncopyable: base_token
  {
  protected:

      constexpr noncopyable() = default;
      ~noncopyable() = default;





      noncopyable( const noncopyable& ) = delete;
      noncopyable& operator=( const noncopyable& ) = delete;





  };
}

typedef noncopyable_::noncopyable noncopyable;

}

namespace boost
{
    namespace range_detail
    {

        template<class SinglePassRange>
        inline typename ::boost::enable_if<
            has_member_size<SinglePassRange>,
            typename range_size<const SinglePassRange>::type
        >::type
        range_calculate_size(const SinglePassRange& rng)
        {
            return rng.size();
        }

        template<class SinglePassRange>
        inline typename disable_if<
            has_member_size<SinglePassRange>,
            typename range_size<const SinglePassRange>::type
        >::type
        range_calculate_size(const SinglePassRange& rng)
        {
            return std::distance(boost::begin(rng), boost::end(rng));
        }
    }

    template<class SinglePassRange>
    inline typename range_size<const SinglePassRange>::type
    size(const SinglePassRange& rng)
    {





        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::SinglePassRangeConcept<SinglePassRange>)>::failed> boost_concept_check62 __attribute__((__unused__));





        using namespace range_detail;


        return range_calculate_size(rng);
    }

}
namespace boost {
namespace iterators {

    namespace detail {
        template <typename SinglePassIterator>
        inline constexpr typename iterator_difference<SinglePassIterator>::type
        distance_impl(
            SinglePassIterator first
          , SinglePassIterator last
          , single_pass_traversal_tag
        )
        {
            typename iterator_difference<SinglePassIterator>::type n = 0;
            while (first != last) {
                ++first;
                ++n;
            }
            return n;
        }

        template <typename RandomAccessIterator>
        inline constexpr typename iterator_difference<RandomAccessIterator>::type
        distance_impl(
            RandomAccessIterator first
          , RandomAccessIterator last
          , random_access_traversal_tag
        )
        {
            return last - first;
        }
    }

    namespace distance_adl_barrier {
        template <typename SinglePassIterator>
        inline constexpr typename iterator_difference<SinglePassIterator>::type
        distance(SinglePassIterator first, SinglePassIterator last)
        {
            return detail::distance_impl(
                first, last, typename iterator_traversal<SinglePassIterator>::type()
            );
        }
    }

    using namespace distance_adl_barrier;

}

using namespace iterators::distance_adl_barrier;

}




namespace boost
{

    namespace range_distance_adl_barrier
    {
        template< class T >
        inline constexpr typename range_difference<T>::type
        distance( const T& r )
        {
            return boost::iterators::distance( boost::begin( r ), boost::end( r ) );
        }
    }

    using namespace range_distance_adl_barrier;

}
namespace boost
{

    template< class T >
    inline bool empty( const T& r )
    {
        return boost::begin( r ) == boost::end( r );
    }

}



namespace boost {
namespace iterators {




  struct use_default;

}

using iterators::use_default;




template<class To>
struct is_convertible<use_default,To>
  : mpl::false_ {};

namespace iterators {

  namespace detail
  {
    struct enable_type;
  }
  template<typename From, typename To>
  struct enable_if_convertible
    : iterators::enable_if<
          is_convertible<From, To>
        , boost::iterators::detail::enable_type
      >
  {};






  namespace detail
  {


    template <class T, class DefaultNullaryFn>
    struct ia_dflt_help
      : mpl::eval_if<
            is_same<T, use_default>
          , DefaultNullaryFn
          , mpl::identity<T>
        >
    {
    };



    template <
        class Derived
      , class Base
      , class Value
      , class Traversal
      , class Reference
      , class Difference
    >
    struct iterator_adaptor_base
    {
        typedef iterator_facade<
            Derived


          , typename boost::iterators::detail::ia_dflt_help<
                Value
              , mpl::eval_if<
                    is_same<Reference,use_default>
                  , iterator_value<Base>
                  , remove_reference<Reference>
                >
            >::type






          , typename boost::iterators::detail::ia_dflt_help<
                Traversal
              , iterator_traversal<Base>
            >::type

          , typename boost::iterators::detail::ia_dflt_help<
                Reference
              , mpl::eval_if<
                    is_same<Value,use_default>
                  , iterator_reference<Base>
                  , add_reference<Value>
                >
            >::type

          , typename boost::iterators::detail::ia_dflt_help<
                Difference, iterator_difference<Base>
            >::type
        >
        type;
    };


    template <class Tr1, class Tr2>
    inline void iterator_adaptor_assert_traversal ()
    {
      static_assert((is_convertible<Tr1, Tr2>::value), "(is_convertible<Tr1, Tr2>::value)");
    }
  }
  template <
      class Derived
    , class Base
    , class Value = use_default
    , class Traversal = use_default
    , class Reference = use_default
    , class Difference = use_default
  >
  class iterator_adaptor
    : public boost::iterators::detail::iterator_adaptor_base<
        Derived, Base, Value, Traversal, Reference, Difference
      >::type
  {
      friend class iterator_core_access;

   protected:
      typedef typename boost::iterators::detail::iterator_adaptor_base<
          Derived, Base, Value, Traversal, Reference, Difference
      >::type super_t;
   public:
      iterator_adaptor() {}

      explicit iterator_adaptor(Base const &iter)
          : m_iterator(iter)
      {
      }

      typedef Base base_type;

      Base const& base() const
        { return m_iterator; }

   protected:

      typedef iterator_adaptor<Derived,Base,Value,Traversal,Reference,Difference> iterator_adaptor_;




      Base const& base_reference() const
        { return m_iterator; }

      Base& base_reference()
        { return m_iterator; }

   private:






      typename super_t::reference dereference() const
        { return *m_iterator; }

      template <
      class OtherDerived, class OtherIterator, class V, class C, class R, class D
      >
      bool equal(iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& x) const
      {




          return m_iterator == x.base();
      }

      typedef typename iterator_category_to_traversal<
          typename super_t::iterator_category
      >::type my_traversal;




      void advance(typename super_t::difference_type n)
      {
          boost::iterators::detail::iterator_adaptor_assert_traversal<my_traversal, random_access_traversal_tag>();
          m_iterator += n;
      }

      void increment() { ++m_iterator; }

      void decrement()
      {
          boost::iterators::detail::iterator_adaptor_assert_traversal<my_traversal, bidirectional_traversal_tag>();
           --m_iterator;
      }

      template <
          class OtherDerived, class OtherIterator, class V, class C, class R, class D
      >
      typename super_t::difference_type distance_to(
          iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& y) const
      {
          boost::iterators::detail::iterator_adaptor_assert_traversal<my_traversal, random_access_traversal_tag>();




          return y.base() - m_iterator;
      }



   private:
      Base m_iterator;
  };

}

using iterators::iterator_adaptor;
using iterators::enable_if_convertible;

}



namespace boost {
namespace iterators {




  template <class Iterator>
  class reverse_iterator
      : public iterator_adaptor< reverse_iterator<Iterator>, Iterator >
  {
      typedef iterator_adaptor< reverse_iterator<Iterator>, Iterator > super_t;

      friend class iterator_core_access;

   public:
      reverse_iterator() {}

      explicit reverse_iterator(Iterator x)
          : super_t(x) {}

      template<class OtherIterator>
      reverse_iterator(
          reverse_iterator<OtherIterator> const& r
          , typename enable_if_convertible<OtherIterator, Iterator>::type* = 0
          )
          : super_t(r.base())
      {}

   private:
      typename super_t::reference dereference() const
      {
          Iterator it = this->base_reference();
          --it;
          return *it;
      }

      void increment() { --this->base_reference(); }
      void decrement() { ++this->base_reference(); }

      void advance(typename super_t::difference_type n)
      {
          this->base_reference() -= n;
      }

      template <class OtherIterator>
      typename super_t::difference_type
      distance_to(reverse_iterator<OtherIterator> const& y) const
      {
          return this->base_reference() - y.base();
      }
  };

  template <class BidirectionalIterator>
  inline reverse_iterator<BidirectionalIterator> make_reverse_iterator(BidirectionalIterator x)
  {
      return reverse_iterator<BidirectionalIterator>(x);
  }

}

using iterators::reverse_iterator;
using iterators::make_reverse_iterator;

}


namespace boost
{




    template< typename T >
    struct range_reverse_iterator
    {
        typedef reverse_iterator<
            typename range_iterator<
                typename remove_reference<T>::type>::type > type;
    };


}

namespace boost
{
template< class C >
inline typename range_reverse_iterator<C>::type
rbegin( C& c )
{
    typedef typename range_reverse_iterator<C>::type
        iter_type;
    return iter_type( boost::end( c ) );
}

template< class C >
inline typename range_reverse_iterator<const C>::type
rbegin( const C& c )
{
    typedef typename range_reverse_iterator<const C>::type
        iter_type;
    return iter_type( boost::end( c ) );
}



template< class T >
inline typename range_reverse_iterator<const T>::type
const_rbegin( const T& r )
{
    return boost::rbegin( r );
}

}
namespace boost
{
template< class C >
inline typename range_reverse_iterator<C>::type
rend( C& c )
{
    typedef typename range_reverse_iterator<C>::type
               iter_type;
    return iter_type( boost::begin( c ) );
}

template< class C >
inline typename range_reverse_iterator<const C>::type
rend( const C& c )
{
    typedef typename range_reverse_iterator<const C>::type
        iter_type;
    return iter_type( boost::begin( c ) );
}



template< class T >
inline typename range_reverse_iterator<const T>::type
const_rend( const T& r )
{
    return boost::rend( r );
}

}



namespace boost
{
    namespace range_detail
    {


        template< class SinglePassTraversalReadableIterator1,
                  class SinglePassTraversalReadableIterator2,
                  class IteratorCategoryTag1,
                  class IteratorCategoryTag2 >
        inline bool equal_impl( SinglePassTraversalReadableIterator1 first1,
                                SinglePassTraversalReadableIterator1 last1,
                                SinglePassTraversalReadableIterator2 first2,
                                SinglePassTraversalReadableIterator2 last2,
                                IteratorCategoryTag1,
                                IteratorCategoryTag2 )
        {
            for (;;)
            {



                if (first1 == last1)
                    return first2 == last2;




                if (first2 == last2)
                    return false;


                if (*first1 != *first2)
                    break;

                ++first1;
                ++first2;
            }



            return false;
        }

        template< class SinglePassTraversalReadableIterator1,
                  class SinglePassTraversalReadableIterator2,
                  class IteratorCategoryTag1,
                  class IteratorCategoryTag2,
                  class BinaryPredicate >
        inline bool equal_impl( SinglePassTraversalReadableIterator1 first1,
                                SinglePassTraversalReadableIterator1 last1,
                                SinglePassTraversalReadableIterator2 first2,
                                SinglePassTraversalReadableIterator2 last2,
                                BinaryPredicate pred,
                                IteratorCategoryTag1,
                                IteratorCategoryTag2 )
        {
            for (;;)
            {



                if (first1 == last1)
                    return first2 == last2;




                if (first2 == last2)
                    return false;


                if (!pred(*first1, *first2))
                    break;

                ++first1;
                ++first2;
            }



            return false;
        }



        template< class RandomAccessTraversalReadableIterator1,
                  class RandomAccessTraversalReadableIterator2 >
        inline bool equal_impl( RandomAccessTraversalReadableIterator1 first1,
                                RandomAccessTraversalReadableIterator1 last1,
                                RandomAccessTraversalReadableIterator2 first2,
                                RandomAccessTraversalReadableIterator2 last2,
                                std::random_access_iterator_tag,
                                std::random_access_iterator_tag )
        {
            return ((last1 - first1) == (last2 - first2))
                && std::equal(first1, last1, first2);
        }

        template< class RandomAccessTraversalReadableIterator1,
                  class RandomAccessTraversalReadableIterator2,
                  class BinaryPredicate >
        inline bool equal_impl( RandomAccessTraversalReadableIterator1 first1,
                                RandomAccessTraversalReadableIterator1 last1,
                                RandomAccessTraversalReadableIterator2 first2,
                                RandomAccessTraversalReadableIterator2 last2,
                                BinaryPredicate pred,
                                std::random_access_iterator_tag,
                                std::random_access_iterator_tag )
        {
            return ((last1 - first1) == (last2 - first2))
                && std::equal(first1, last1, first2, pred);
        }

        template< class SinglePassTraversalReadableIterator1,
                  class SinglePassTraversalReadableIterator2 >
        inline bool equal( SinglePassTraversalReadableIterator1 first1,
                           SinglePassTraversalReadableIterator1 last1,
                           SinglePassTraversalReadableIterator2 first2,
                           SinglePassTraversalReadableIterator2 last2 )
        {
            typename std::iterator_traits< SinglePassTraversalReadableIterator1 >::iterator_category tag1;
            typename std::iterator_traits< SinglePassTraversalReadableIterator2 >::iterator_category tag2;

            return equal_impl(first1, last1, first2, last2, tag1, tag2);
        }

        template< class SinglePassTraversalReadableIterator1,
                  class SinglePassTraversalReadableIterator2,
                  class BinaryPredicate >
        inline bool equal( SinglePassTraversalReadableIterator1 first1,
                           SinglePassTraversalReadableIterator1 last1,
                           SinglePassTraversalReadableIterator2 first2,
                           SinglePassTraversalReadableIterator2 last2,
                           BinaryPredicate pred )
        {
            typename std::iterator_traits< SinglePassTraversalReadableIterator1 >::iterator_category tag1;
            typename std::iterator_traits< SinglePassTraversalReadableIterator2 >::iterator_category tag2;

            return equal_impl(first1, last1, first2, last2, pred, tag1, tag2);
        }

    }

    namespace range
    {
        template< class SinglePassRange1, class SinglePassRange2 >
        inline bool equal( const SinglePassRange1& rng1, const SinglePassRange2& rng2 )
        {
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( SinglePassRangeConcept<const SinglePassRange1> )>::failed> boost_concept_check174 __attribute__((__unused__));
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( SinglePassRangeConcept<const SinglePassRange2> )>::failed> boost_concept_check175 __attribute__((__unused__));

            return ::boost::range_detail::equal(
                ::boost::begin(rng1), ::boost::end(rng1),
                ::boost::begin(rng2), ::boost::end(rng2) );
        }


        template< class SinglePassRange1, class SinglePassRange2, class BinaryPredicate >
        inline bool equal( const SinglePassRange1& rng1, const SinglePassRange2& rng2,
                           BinaryPredicate pred )
        {
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( SinglePassRangeConcept<const SinglePassRange1> )>::failed> boost_concept_check187 __attribute__((__unused__));
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( SinglePassRangeConcept<const SinglePassRange2> )>::failed> boost_concept_check188 __attribute__((__unused__));

            return ::boost::range_detail::equal(
                ::boost::begin(rng1), ::boost::end(rng1),
                ::boost::begin(rng2), ::boost::end(rng2),
                pred);
        }

    }
    using ::boost::range::equal;
}
namespace boost
{
    namespace range_detail
    {

template<class DataMemberPtr>
class safe_bool
{
public:
    typedef safe_bool this_type;
    typedef DataMemberPtr unspecified_bool_type;
    static unspecified_bool_type to_unspecified_bool(const bool x, DataMemberPtr p)
    {
        return x ? p : 0;
    }

private:
    safe_bool();
    safe_bool(const safe_bool&);
    void operator=(const safe_bool&);
    ~safe_bool();
};

    }
}

namespace boost {


template<class...>
struct make_void {
    typedef void type;
};


template<class... Ts>
using void_t = typename make_void<Ts...>::type;
}





namespace boost
{

   namespace binary_op_detail {

      struct dont_care;

      template <class T, class U, class Ret, class = boost::void_t<>>
      struct has_plus_ret_imp : public boost::false_type {};

      template <class T, class U, class Ret>
      struct has_plus_ret_imp<T, U, Ret, boost::void_t<decltype(std::declval<typename add_reference<T>::type>() + std::declval<typename add_reference<U>::type>())> >
         : public boost::integral_constant<bool, ::boost::is_convertible<decltype(std::declval<typename add_reference<T>::type>() + std::declval<typename add_reference<U>::type>()), Ret>::value> {};

      template <class T, class U, class = boost::void_t<> >
      struct has_plus_void_imp : public boost::false_type {};

      template <class T, class U>
      struct has_plus_void_imp<T, U, boost::void_t<decltype(std::declval<typename add_reference<T>::type>() + std::declval<typename add_reference<U>::type>())> >
         : public boost::integral_constant<bool, ::boost::is_void<decltype(std::declval<typename add_reference<T>::type>() + std::declval<typename add_reference<U>::type>())>::value> {};

      template <class T, class U, class = boost::void_t<>>
      struct has_plus_dc_imp : public boost::false_type {};

      template <class T, class U>
      struct has_plus_dc_imp<T, U, boost::void_t<decltype(std::declval<typename add_reference<T>::type>() + std::declval<typename add_reference<U>::type>())> >
         : public boost::true_type {};

   }

   template <class T, class U = T, class Ret = boost::binary_op_detail::dont_care>
   struct has_plus : public boost::binary_op_detail:: has_plus_ret_imp <T, U, Ret> {};
   template <class T, class U>
   struct has_plus<T, U, void> : public boost::binary_op_detail:: has_plus_void_imp <T, U> {};
   template <class T, class U>
   struct has_plus<T, U, boost::binary_op_detail::dont_care> : public boost::binary_op_detail:: has_plus_dc_imp <T, U> {};


}
namespace boost
{

   namespace binary_op_detail {

      struct dont_care;

      template <class T, class U, class Ret, class = boost::void_t<>>
      struct has_plus_assign_ret_imp : public boost::false_type {};

      template <class T, class U, class Ret>
      struct has_plus_assign_ret_imp<T, U, Ret, boost::void_t<decltype(std::declval<typename add_reference<T>::type>() += std::declval<typename add_reference<U>::type>())> >
         : public boost::integral_constant<bool, ::boost::is_convertible<decltype(std::declval<typename add_reference<T>::type>() += std::declval<typename add_reference<U>::type>()), Ret>::value> {};

      template <class T, class U, class = boost::void_t<> >
      struct has_plus_assign_void_imp : public boost::false_type {};

      template <class T, class U>
      struct has_plus_assign_void_imp<T, U, boost::void_t<decltype(std::declval<typename add_reference<T>::type>() += std::declval<typename add_reference<U>::type>())> >
         : public boost::integral_constant<bool, ::boost::is_void<decltype(std::declval<typename add_reference<T>::type>() += std::declval<typename add_reference<U>::type>())>::value> {};

      template <class T, class U, class = boost::void_t<>>
      struct has_plus_assign_dc_imp : public boost::false_type {};

      template <class T, class U>
      struct has_plus_assign_dc_imp<T, U, boost::void_t<decltype(std::declval<typename add_reference<T>::type>() += std::declval<typename add_reference<U>::type>())> >
         : public boost::true_type {};

      template <class T, class U, class Ret>
      struct has_plus_assign_filter_ret : public boost::binary_op_detail:: has_plus_assign_ret_imp <T, U, Ret> {};
      template <class T, class U>
      struct has_plus_assign_filter_ret<T, U, void> : public boost::binary_op_detail:: has_plus_assign_void_imp <T, U> {};
      template <class T, class U>
      struct has_plus_assign_filter_ret<T, U, boost::binary_op_detail::dont_care> : public boost::binary_op_detail:: has_plus_assign_dc_imp <T, U> {};

      template <class T, class U, class Ret, bool f>
      struct has_plus_assign_filter_impossible : public boost::binary_op_detail:: has_plus_assign_filter_ret <T, U, Ret> {};
      template <class T, class U, class Ret>
      struct has_plus_assign_filter_impossible<T, U, Ret, true> : public boost::false_type {};

   }

   template <class T, class U = T, class Ret = boost::binary_op_detail::dont_care>
   struct has_plus_assign : public boost::binary_op_detail:: has_plus_assign_filter_impossible <T, U, Ret, boost::is_arithmetic<typename boost::remove_reference<T>::type>::value && boost::is_pointer<typename remove_reference<U>::type>::value && !boost::is_same<bool, typename boost::remove_cv<typename remove_reference<T>::type>::type>::value> {};

}
namespace boost
{

   namespace binary_op_detail {

      struct dont_care;

      template <class T, class U, class Ret, class = boost::void_t<>>
      struct has_minus_ret_imp : public boost::false_type {};

      template <class T, class U, class Ret>
      struct has_minus_ret_imp<T, U, Ret, boost::void_t<decltype(std::declval<typename add_reference<T>::type>() - std::declval<typename add_reference<U>::type>())> >
         : public boost::integral_constant<bool, ::boost::is_convertible<decltype(std::declval<typename add_reference<T>::type>() - std::declval<typename add_reference<U>::type>()), Ret>::value> {};

      template <class T, class U, class = boost::void_t<> >
      struct has_minus_void_imp : public boost::false_type {};

      template <class T, class U>
      struct has_minus_void_imp<T, U, boost::void_t<decltype(std::declval<typename add_reference<T>::type>() - std::declval<typename add_reference<U>::type>())> >
         : public boost::integral_constant<bool, ::boost::is_void<decltype(std::declval<typename add_reference<T>::type>() - std::declval<typename add_reference<U>::type>())>::value> {};

      template <class T, class U, class = boost::void_t<>>
      struct has_minus_dc_imp : public boost::false_type {};

      template <class T, class U>
      struct has_minus_dc_imp<T, U, boost::void_t<decltype(std::declval<typename add_reference<T>::type>() - std::declval<typename add_reference<U>::type>())> >
         : public boost::true_type {};

      template <class T, class U, class Ret>
      struct has_minus_ret_filter : public boost::binary_op_detail::has_minus_ret_imp <T, U, Ret> {};
      template <class T, class U>
      struct has_minus_ret_filter<T, U, void> : public boost::binary_op_detail::has_minus_void_imp <T, U> {};
      template <class T, class U>
      struct has_minus_ret_filter<T, U, boost::binary_op_detail::dont_care> : public boost::binary_op_detail::has_minus_dc_imp <T, U> {};

      template <class T, class U, class Ret, bool b>
      struct has_minus_void_ptr_filter : public boost::binary_op_detail::has_minus_ret_filter <T, U, Ret> {};
      template <class T, class U, class Ret>
      struct has_minus_void_ptr_filter<T, U, Ret, true> : public boost::false_type {};

   }

   template <class T, class U = T, class Ret = boost::binary_op_detail::dont_care>
   struct has_minus :
      public boost::binary_op_detail::has_minus_void_ptr_filter<
         T, U, Ret,
         boost::is_void<typename remove_pointer<typename remove_reference<T>::type>::type>::value
         || boost::is_void<typename remove_pointer<typename remove_reference<U>::type>::type>::value> {};


}
namespace boost
{

   namespace binary_op_detail {

      struct dont_care;

      template <class T, class U, class Ret, class = boost::void_t<>>
      struct has_minus_assign_ret_imp : public boost::false_type {};

      template <class T, class U, class Ret>
      struct has_minus_assign_ret_imp<T, U, Ret, boost::void_t<decltype(std::declval<typename add_reference<T>::type>() -= std::declval<typename add_reference<U>::type>())> >
         : public boost::integral_constant<bool, ::boost::is_convertible<decltype(std::declval<typename add_reference<T>::type>() -= std::declval<typename add_reference<U>::type>()), Ret>::value> {};

      template <class T, class U, class = boost::void_t<> >
      struct has_minus_assign_void_imp : public boost::false_type {};

      template <class T, class U>
      struct has_minus_assign_void_imp<T, U, boost::void_t<decltype(std::declval<typename add_reference<T>::type>() -= std::declval<typename add_reference<U>::type>())> >
         : public boost::integral_constant<bool, ::boost::is_void<decltype(std::declval<typename add_reference<T>::type>() -= std::declval<typename add_reference<U>::type>())>::value> {};

      template <class T, class U, class = boost::void_t<>>
      struct has_minus_assign_dc_imp : public boost::false_type {};

      template <class T, class U>
      struct has_minus_assign_dc_imp<T, U, boost::void_t<decltype(std::declval<typename add_reference<T>::type>() -= std::declval<typename add_reference<U>::type>())> >
         : public boost::true_type {};

      template <class T, class U, class Ret>
      struct has_minus_assign_ret_filter : public boost::binary_op_detail::has_minus_assign_ret_imp <T, U, Ret> {};
      template <class T, class U>
      struct has_minus_assign_ret_filter<T, U, void> : public boost::binary_op_detail::has_minus_assign_void_imp <T, U> {};
      template <class T, class U>
      struct has_minus_assign_ret_filter<T, U, boost::binary_op_detail::dont_care> : public boost::binary_op_detail::has_minus_assign_dc_imp <T, U> {};

      template <class T, class U, class Ret, bool b>
      struct has_minus_assign_void_ptr_filter : public boost::binary_op_detail::has_minus_assign_ret_filter <T, U, Ret> {};
      template <class T, class U, class Ret>
      struct has_minus_assign_void_ptr_filter<T, U, Ret, true> : public boost::false_type {};

   }

   template <class T, class U = T, class Ret = boost::binary_op_detail::dont_care>
   struct has_minus_assign :
      public boost::binary_op_detail::has_minus_assign_void_ptr_filter<
      T, U, Ret,
      boost::is_void<typename remove_pointer<typename remove_reference<T>::type>::type>::value
      || boost::is_void<typename remove_pointer<typename remove_reference<U>::type>::type>::value
      || (boost::is_pointer<typename remove_reference<T>::type>::value && boost::is_pointer<typename remove_reference<U>::type>::value)> {};


}
namespace boost {
namespace iterators {

    namespace detail {
        template <typename InputIterator, typename Distance>
        inline constexpr void
        advance_impl(
            InputIterator& it
          , Distance n
          , incrementable_traversal_tag
        )
        {
            while (n > 0) {
                ++it;
                --n;
            }
        }

        template <typename BidirectionalIterator, typename Distance>
        inline constexpr void
        advance_impl(
            BidirectionalIterator& it
          , Distance n
          , bidirectional_traversal_tag
        )
        {
            if (n >= 0) {
                while (n > 0) {
                    ++it;
                    --n;
                }
            }
            else {
                while (n < 0) {
                    --it;
                    ++n;
                }
            }
        }

        template <typename RandomAccessIterator, typename Distance>
        inline constexpr void
        advance_impl(
            RandomAccessIterator& it
          , Distance n
          , random_access_traversal_tag
        )
        {
            it += n;
        }
    }

    namespace advance_adl_barrier {
        template <typename InputIterator, typename Distance>
        inline constexpr void
        advance(InputIterator& it, Distance n)
        {
            detail::advance_impl(
                it, n, typename iterator_traversal<InputIterator>::type()
            );
        }
    }

    using namespace advance_adl_barrier;

}

using namespace iterators::advance_adl_barrier;

}


namespace boost {
namespace next_prior_detail {







template< typename T, typename Void = void >
struct is_iterator_class
{
    static constexpr bool value = false;
};

template< typename T >
struct is_iterator_class<
    T,
    typename enable_if_has_type<



        typename T::iterator_category

    >::type
>
{
    static constexpr bool value = true;
};

template< typename T >
struct is_iterator :
    public is_iterator_class< T >
{
};

template< typename T >
struct is_iterator< T* >
{
    static constexpr bool value = true;
};


template< typename T, typename Distance, bool HasPlus = has_plus< T, Distance >::value >
struct next_plus_impl;

template< typename T, typename Distance >
struct next_plus_impl< T, Distance, true >
{
    static T call(T x, Distance n)
    {
        return x + n;
    }
};

template< typename T, typename Distance, bool HasPlusAssign = has_plus_assign< T, Distance >::value >
struct next_plus_assign_impl :
    public next_plus_impl< T, Distance >
{
};

template< typename T, typename Distance >
struct next_plus_assign_impl< T, Distance, true >
{
    static T call(T x, Distance n)
    {
        x += n;
        return x;
    }
};

template< typename T, typename Distance, bool IsIterator = is_iterator< T >::value >
struct next_advance_impl :
    public next_plus_assign_impl< T, Distance >
{
};

template< typename T, typename Distance >
struct next_advance_impl< T, Distance, true >
{
    static T call(T x, Distance n)
    {
        boost::iterators::advance(x, n);
        return x;
    }
};


template< typename T, typename Distance, bool HasMinus = has_minus< T, Distance >::value >
struct prior_minus_impl;

template< typename T, typename Distance >
struct prior_minus_impl< T, Distance, true >
{
    static T call(T x, Distance n)
    {
        return x - n;
    }
};

template< typename T, typename Distance, bool HasMinusAssign = has_minus_assign< T, Distance >::value >
struct prior_minus_assign_impl :
    public prior_minus_impl< T, Distance >
{
};

template< typename T, typename Distance >
struct prior_minus_assign_impl< T, Distance, true >
{
    static T call(T x, Distance n)
    {
        x -= n;
        return x;
    }
};

template< typename T, typename Distance, bool IsIterator = is_iterator< T >::value >
struct prior_advance_impl :
    public prior_minus_assign_impl< T, Distance >
{
};

template< typename T, typename Distance >
struct prior_advance_impl< T, Distance, true >
{
    static T call(T x, Distance n)
    {

        boost::iterators::reverse_iterator< T > rx(x);
        boost::iterators::advance(rx, n);
        return rx.base();
    }
};

}

template <class T>
inline T next(T x) { return ++x; }

template <class T, class Distance>
inline T next(T x, Distance n)
{
    return next_prior_detail::next_advance_impl< T, Distance >::call(x, n);
}

template <class T>
inline T prior(T x) { return --x; }

template <class T, class Distance>
inline T prior(T x, Distance n)
{
    return next_prior_detail::prior_advance_impl< T, Distance >::call(x, n);
}

}
namespace boost
{
    namespace iterator_range_detail
    {




        template<class IteratorT>
        struct iterator_range_impl {
            template< class ForwardRange >
            static IteratorT adl_begin( ForwardRange& r )
            {
                return IteratorT( boost::begin( r ) );
            }

            template< class ForwardRange >
            static IteratorT adl_end( ForwardRange& r )
            {
                return IteratorT( boost::end( r ) );
            }
        };

        template< class Left, class Right >
        inline bool less_than( const Left& l, const Right& r )
        {
            return std::lexicographical_compare( boost::begin(l),
                                                 boost::end(l),
                                                 boost::begin(r),
                                                 boost::end(r) );
        }

        template< class Left, class Right >
        inline bool greater_than( const Left& l, const Right& r )
        {
            return iterator_range_detail::less_than(r,l);
        }

        template< class Left, class Right >
        inline bool less_or_equal_than( const Left& l, const Right& r )
        {
            return !iterator_range_detail::less_than(r,l);
        }

        template< class Left, class Right >
        inline bool greater_or_equal_than( const Left& l, const Right& r )
        {
            return !iterator_range_detail::less_than(l,r);
        }



        template< class Left, class Right >
        inline bool equal(const Left& l, const Right& r)
        {
            return boost::equal(l, r);
        }

struct range_tag
{
};

struct const_range_tag
{
};

struct iterator_range_tag
{
};

typedef char (&incrementable_t)[1];
typedef char (&bidirectional_t)[2];
typedef char (&random_access_t)[3];

incrementable_t test_traversal_tag(boost::incrementable_traversal_tag);
bidirectional_t test_traversal_tag(boost::bidirectional_traversal_tag);
random_access_t test_traversal_tag(boost::random_access_traversal_tag);

template<std::size_t S>
struct pure_iterator_traversal_impl
{
    typedef boost::incrementable_traversal_tag type;
};

template<>
struct pure_iterator_traversal_impl<sizeof(bidirectional_t)>
{
    typedef boost::bidirectional_traversal_tag type;
};

template<>
struct pure_iterator_traversal_impl<sizeof(random_access_t)>
{
    typedef boost::random_access_traversal_tag type;
};

template<typename IteratorT>
struct pure_iterator_traversal
{
    typedef
        typename iterator_traversal<IteratorT>::type
    traversal_t;
    static const std::size_t traversal_i = sizeof(iterator_range_detail::test_traversal_tag((traversal_t())));



    typedef
        typename pure_iterator_traversal_impl<traversal_i>::type
    type;
};

template<class IteratorT, class TraversalTag>
class iterator_range_base
    : public iterator_range_tag
{
    typedef range_detail::safe_bool<
                IteratorT iterator_range_base<IteratorT, TraversalTag>::*
    > safe_bool_t;

    typedef iterator_range_base<IteratorT, TraversalTag> type;

protected:
    typedef iterator_range_impl<IteratorT> impl;

public:
    typedef typename
        safe_bool_t::unspecified_bool_type unspecified_bool_type;

    typedef typename
        iterator_value<IteratorT>::type value_type;

    typedef typename
        iterator_difference<IteratorT>::type difference_type;

    typedef std::size_t size_type;



    typedef typename
                iterator_reference<IteratorT>::type reference;






    typedef IteratorT const_iterator;

    typedef IteratorT iterator;

protected:
    iterator_range_base()
        : m_Begin()
        , m_End()
    {
    }

    template<class Iterator>
    iterator_range_base(Iterator Begin, Iterator End)
        : m_Begin(Begin)
        , m_End(End)
    {
    }

public:
    IteratorT begin() const
    {
        return m_Begin;
    }

    IteratorT end() const
    {
        return m_End;
    }

    bool empty() const
    {
        return m_Begin == m_End;
    }

    operator unspecified_bool_type() const
    {
        return safe_bool_t::to_unspecified_bool(
                    m_Begin != m_End, &iterator_range_base::m_Begin);
    }

    bool operator!() const
    {
        return empty();
    }

    bool equal(const iterator_range_base& r) const
    {
        return m_Begin == r.m_Begin && m_End == r.m_End;
    }

   reference front() const
   {
       (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "./boost/range/iterator_range_core.hpp", 255, "!empty()") : (void)0);
       return *m_Begin;
   }

   void drop_front()
   {
       (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "./boost/range/iterator_range_core.hpp", 261, "!empty()") : (void)0);
       ++m_Begin;
   }

   void drop_front(difference_type n)
   {
       (__builtin_expect(!(n >= difference_type()), 0) ? __assert_rtn(__func__, "./boost/range/iterator_range_core.hpp", 267, "n >= difference_type()") : (void)0);
       std::advance(this->m_Begin, n);
   }


   void pop_front() { drop_front(); }

protected:
    template<class Iterator>
    void assign(Iterator first, Iterator last)
    {
        m_Begin = first;
        m_End = last;
    }

    template<class SinglePassRange>
    void assign(const SinglePassRange& r)
    {
        m_Begin = impl::adl_begin(r);
        m_End = impl::adl_end(r);
    }

    template<class SinglePassRange>
    void assign(SinglePassRange& r)
    {
        m_Begin = impl::adl_begin(r);
        m_End = impl::adl_end(r);
    }

    IteratorT m_Begin;
    IteratorT m_End;
};

template<class IteratorT>
class iterator_range_base<IteratorT, bidirectional_traversal_tag>
        : public iterator_range_base<IteratorT, incrementable_traversal_tag>
{
    typedef iterator_range_base<IteratorT, incrementable_traversal_tag> base_type;

protected:
    iterator_range_base()
    {
    }

    template<class Iterator>
    iterator_range_base(Iterator first, Iterator last)
        : base_type(first, last)
    {
    }

public:
    typedef typename base_type::difference_type difference_type;
    typedef typename base_type::reference reference;

    reference back() const
    {
        (__builtin_expect(!(!this->empty()), 0) ? __assert_rtn(__func__, "./boost/range/iterator_range_core.hpp", 323, "!this->empty()") : (void)0);
        return *boost::prior(this->m_End);
    }

    void drop_back()
    {
        (__builtin_expect(!(!this->empty()), 0) ? __assert_rtn(__func__, "./boost/range/iterator_range_core.hpp", 329, "!this->empty()") : (void)0);
        --this->m_End;
    }

    void drop_back(difference_type n)
    {
        (__builtin_expect(!(n >= difference_type()), 0) ? __assert_rtn(__func__, "./boost/range/iterator_range_core.hpp", 335, "n >= difference_type()") : (void)0);
        std::advance(this->m_End, -n);
    }


    void pop_back() { drop_back(); }
};

template<class IteratorT>
class iterator_range_base<IteratorT, random_access_traversal_tag>
        : public iterator_range_base<IteratorT, bidirectional_traversal_tag>
{
    typedef iterator_range_base<
                IteratorT, bidirectional_traversal_tag> base_type;

public:
    typedef typename
        boost::mpl::if_<
            boost::mpl::or_<
                boost::is_abstract<
                    typename base_type::value_type
                >,
                boost::is_array<
                    typename base_type::value_type
                >,
                boost::is_function<
                    typename base_type::value_type
                >
            >,
            typename base_type::reference,
            typename base_type::value_type
        >::type abstract_value_type;




    typedef typename base_type::difference_type difference_type;
    typedef typename base_type::size_type size_type;
    typedef typename base_type::reference reference;

protected:
    iterator_range_base()
    {
    }

    template<class Iterator>
    iterator_range_base(Iterator first, Iterator last)
        : base_type(first, last)
    {
    }

public:
    reference operator[](difference_type at) const
    {
        (__builtin_expect(!(at >= 0), 0) ? __assert_rtn(__func__, "./boost/range/iterator_range_core.hpp", 389, "at >= 0") : (void)0);
        (__builtin_expect(!(static_cast<typename base_type::size_type>(at) < size()), 0) ? __assert_rtn(__func__, "./boost/range/iterator_range_core.hpp", 390, "static_cast<typename base_type::size_type>(at) < size()") : (void)0);
        return this->m_Begin[at];
    }






    abstract_value_type operator()(difference_type at) const
    {
        (__builtin_expect(!(at >= 0), 0) ? __assert_rtn(__func__, "./boost/range/iterator_range_core.hpp", 401, "at >= 0") : (void)0);
        (__builtin_expect(!(static_cast<typename base_type::size_type>(at) < size()), 0) ? __assert_rtn(__func__, "./boost/range/iterator_range_core.hpp", 402, "static_cast<typename base_type::size_type>(at) < size()") : (void)0);
        return this->m_Begin[at];
    }

    typename base_type::size_type size() const
    {
        return this->m_End - this->m_Begin;
    }
};

    }
        template<class IteratorT>
        class iterator_range
            : public iterator_range_detail::iterator_range_base<
                    IteratorT,
                    typename iterator_range_detail::pure_iterator_traversal<IteratorT>::type
                >
        {
            typedef iterator_range_detail::iterator_range_base<
                    IteratorT,
                    typename iterator_range_detail::pure_iterator_traversal<IteratorT>::type
            > base_type;

            template<class Source>
            struct is_compatible_range_
              : is_convertible<
                    typename mpl::eval_if<
                        has_range_iterator<Source>,
                        range_iterator<Source>,
                        mpl::identity<void>
                    >::type,
                    typename base_type::iterator
                >
            {
            };

            template<class Source>
            struct is_compatible_range
                : mpl::and_<
                    mpl::not_<
                        is_convertible<
                            Source,
                            typename base_type::iterator
                        >
                    >,
                    is_compatible_range_<Source>
                >
            {
            };

        protected:
            typedef iterator_range_detail::iterator_range_impl<IteratorT> impl;

        public:
            typedef iterator_range<IteratorT> type;

            iterator_range()
            {
            }

            template<class Iterator>
            iterator_range(Iterator first, Iterator last)
                : base_type(first, last)
            {
            }

            template<class SinglePassRange>
            iterator_range(
                const SinglePassRange& r,
                typename ::boost::enable_if<
                    is_compatible_range<const SinglePassRange>
                >::type* = 0
            )
                : base_type(impl::adl_begin(r), impl::adl_end(r))
            {
            }

            template<class SinglePassRange>
            iterator_range(
                SinglePassRange& r,
                typename ::boost::enable_if<
                    is_compatible_range<SinglePassRange>
                >::type* = 0
            )
                : base_type(impl::adl_begin(r), impl::adl_end(r))
            {
            }

            template<class SinglePassRange>
            iterator_range(const SinglePassRange& r,
                           iterator_range_detail::const_range_tag)
                : base_type(impl::adl_begin(r), impl::adl_end(r))
            {
            }

            template<class SinglePassRange>
            iterator_range(SinglePassRange& r,
                           iterator_range_detail::range_tag)
                : base_type(impl::adl_begin(r), impl::adl_end(r))
            {
            }

            template<class Iterator>
            iterator_range& operator=(const iterator_range<Iterator>& other)
            {
                this->assign(other.begin(), other.end());
                return *this;
            }

            template<class Iterator>
            iterator_range& operator=(iterator_range<Iterator>& other)
            {
                this->assign(other.begin(), other.end());
                return *this;
            }

            template<class SinglePassRange>
            iterator_range& operator=(SinglePassRange& r)
            {
                this->assign(r);
                return *this;
            }

            template<class SinglePassRange>
            iterator_range& operator=(const SinglePassRange& r)
            {
                this->assign(r);
                return *this;
            }

            iterator_range& advance_begin(
                typename base_type::difference_type n)
            {
                std::advance(this->m_Begin, n);
                return *this;
            }

            iterator_range& advance_end(
                typename base_type::difference_type n)
            {
                std::advance(this->m_End, n);
                return *this;
            }

        protected:




            typedef iterator_range iterator_range_;
        };







        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator==( const ForwardRange& l, const iterator_range<IteratorT>& r )
        {
            return boost::equal( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator!=( const ForwardRange& l, const iterator_range<IteratorT>& r )
        {
            return !boost::equal( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator<( const ForwardRange& l, const iterator_range<IteratorT>& r )
        {
            return iterator_range_detail::less_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator<=( const ForwardRange& l, const iterator_range<IteratorT>& r )
        {
            return iterator_range_detail::less_or_equal_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator>( const ForwardRange& l, const iterator_range<IteratorT>& r )
        {
            return iterator_range_detail::greater_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator>=( const ForwardRange& l, const iterator_range<IteratorT>& r )
        {
            return iterator_range_detail::greater_or_equal_than( l, r );
        }



        template< class Iterator1T, class Iterator2T >
        inline bool
        operator==( const iterator_range<Iterator1T>& l, const iterator_range<Iterator2T>& r )
        {
            return boost::equal( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator==( const iterator_range<IteratorT>& l, const ForwardRange& r )
        {
            return boost::equal( l, r );
        }


        template< class Iterator1T, class Iterator2T >
        inline bool
        operator!=( const iterator_range<Iterator1T>& l, const iterator_range<Iterator2T>& r )
        {
            return !boost::equal( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator!=( const iterator_range<IteratorT>& l, const ForwardRange& r )
        {
            return !boost::equal( l, r );
        }


        template< class Iterator1T, class Iterator2T >
        inline bool
        operator<( const iterator_range<Iterator1T>& l, const iterator_range<Iterator2T>& r )
        {
            return iterator_range_detail::less_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator<( const iterator_range<IteratorT>& l, const ForwardRange& r )
        {
            return iterator_range_detail::less_than( l, r );
        }

        template< class Iterator1T, class Iterator2T >
        inline bool
        operator<=( const iterator_range<Iterator1T>& l, const iterator_range<Iterator2T>& r )
        {
            return iterator_range_detail::less_or_equal_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator<=( const iterator_range<IteratorT>& l, const ForwardRange& r )
        {
            return iterator_range_detail::less_or_equal_than( l, r );
        }

        template< class Iterator1T, class Iterator2T >
        inline bool
        operator>( const iterator_range<Iterator1T>& l, const iterator_range<Iterator2T>& r )
        {
            return iterator_range_detail::greater_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator>( const iterator_range<IteratorT>& l, const ForwardRange& r )
        {
            return iterator_range_detail::greater_than( l, r );
        }

        template< class Iterator1T, class Iterator2T >
        inline bool
        operator>=( const iterator_range<Iterator1T>& l, const iterator_range<Iterator2T>& r )
        {
            return iterator_range_detail::greater_or_equal_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator>=( const iterator_range<IteratorT>& l, const ForwardRange& r )
        {
            return iterator_range_detail::greater_or_equal_than( l, r );
        }
        template< typename IteratorT >
        inline iterator_range< IteratorT >
        make_iterator_range( IteratorT Begin, IteratorT End )
        {
            return iterator_range<IteratorT>( Begin, End );
        }

        template<typename IteratorT, typename IntegerT>
        inline iterator_range<IteratorT>
        make_iterator_range_n(IteratorT first, IntegerT n)
        {
            return iterator_range<IteratorT>(first, boost::next(first, n));
        }
        template< class ForwardRange >
        inline iterator_range< typename range_iterator<ForwardRange>::type >
        make_iterator_range( ForwardRange& r )
        {
           return iterator_range< typename range_iterator<ForwardRange>::type >
                ( r, iterator_range_detail::range_tag() );
        }

        template< class ForwardRange >
        inline iterator_range< typename range_iterator<const ForwardRange>::type >
        make_iterator_range( const ForwardRange& r )
        {
           return iterator_range< typename range_iterator<const ForwardRange>::type >
                ( r, iterator_range_detail::const_range_tag() );
        }



        namespace iterator_range_detail
        {
            template< class Range >
            inline iterator_range< typename range_iterator<Range>::type >
            make_range_impl( Range& r,
                             typename range_difference<Range>::type advance_begin,
                             typename range_difference<Range>::type advance_end )
            {







                typename range_iterator<Range>::type
                    new_begin = boost::begin( r ),
                    new_end = boost::end( r );
                std::advance( new_begin, advance_begin );
                std::advance( new_end, advance_end );
                return make_iterator_range( new_begin, new_end );
            }
        }
        template< class Range >
        inline iterator_range< typename range_iterator<Range>::type >
        make_iterator_range( Range& r,
                    typename range_difference<Range>::type advance_begin,
                    typename range_difference<Range>::type advance_end )
        {
            return iterator_range_detail::make_range_impl( r, advance_begin, advance_end );
        }

        template< class Range >
        inline iterator_range< typename range_iterator<const Range>::type >
        make_iterator_range( const Range& r,
                    typename range_difference<Range>::type advance_begin,
                    typename range_difference<Range>::type advance_end )
        {
            return iterator_range_detail::make_range_impl( r, advance_begin, advance_end );
        }
        template< typename SeqT, typename Range >
        inline SeqT copy_range( const Range& r )
        {
            return SeqT( boost::begin( r ), boost::end( r ) );
        }

}
namespace boost
{

    class __attribute__((__visibility__("default"))) bad_lexical_cast :




        public std::bad_cast







    {
    public:
        bad_lexical_cast() noexcept

           : source(&typeid(void)), target(&typeid(void))

        {}

        virtual const char *what() const noexcept {
            return "bad lexical cast: "
                   "source type value could not be interpreted as target";
        }

        virtual ~bad_lexical_cast() noexcept
        {}


        bad_lexical_cast(
                const std::type_info &source_type_arg,
                const std::type_info &target_type_arg) noexcept
            : source(&source_type_arg), target(&target_type_arg)
        {}

        const std::type_info &source_type() const noexcept {
            return *source;
        }

        const std::type_info &target_type() const noexcept {
            return *target;
        }

    private:
        const std::type_info *source;
        const std::type_info *target;

    };

    namespace conversion { namespace detail {






        template <class S, class T>
        inline void throw_bad_cast() {
            boost::throw_exception(bad_lexical_cast(typeid(S), typeid(T)));
        }

    }}


}
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuninitialized"
#pragma GCC diagnostic ignored "-Wsign-conversion"






namespace boost
{

template<class T> struct type_identity
{
    typedef T type;
};



template <class T> using type_identity_t = typename type_identity<T>::type;




}




namespace boost {

    namespace detail
    {

        template < typename T >
        struct is_character
        {
            typedef typename boost::integral_constant<
              bool,
              boost::is_same< T, char >::value ||

                        boost::is_same< T, wchar_t >::value ||


                        boost::is_same< T, char16_t >::value ||


                        boost::is_same< T, char32_t >::value ||

                    boost::is_same< T, unsigned char >::value ||
                    boost::is_same< T, signed char >::value
            > type;

            static const bool value = (type::value);
        };
    }
}
namespace boost {

   namespace detail{
      template <class B, class D>
      struct is_base_of_imp
      {
          typedef typename remove_cv<B>::type ncvB;
          typedef typename remove_cv<D>::type ncvD;
          static const bool value = ( (::boost::detail::is_base_and_derived_impl<ncvB,ncvD>::value) || (::boost::is_same<ncvB,ncvD>::value && ::boost::is_class<ncvB>::value));


      };
   }

   template <class Base, class Derived> struct is_base_of
      : public integral_constant<bool, (::boost::detail::is_base_of_imp<Base, Derived>::value)> {};

   template <class Base, class Derived> struct is_base_of<Base, Derived&> : false_type{};
   template <class Base, class Derived> struct is_base_of<Base&, Derived&> : false_type{};
   template <class Base, class Derived> struct is_base_of<Base&, Derived> : false_type{};

}
namespace boost {


   template <class T> struct is_float : public is_floating_point<T> {};
}









namespace boost {



  template <class T>
  struct type {};

}







namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct equal_to_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< equal_to_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< equal_to_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct equal_to_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct equal_to_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct equal_to_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct equal_to_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct equal_to

    : equal_to_impl<
          typename equal_to_tag<N1>::type
        , typename equal_to_tag<N2>::type
        >::template apply< N1,N2 >::type
{


};

template<> struct equal_to< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : equal_to< T1 , T2 > { }; }; template< typename Tag > struct lambda< equal_to< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef equal_to< na , na > result_; typedef equal_to< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< equal_to< T1 , T2 > > : int_<2> { }; template<> struct template_arity< equal_to< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct equal_to_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value == N2::value ) >
    {
    };
};

}}





namespace boost { namespace numeric { namespace convdetail
{
   template< class T1, class T2>
   struct equal_to
   {


       enum { x = ( T1::value == T2::value ) };

       static const bool value = x;

       typedef mpl::bool_<value> type;
   };
  template<class Value,
           class Case0Val,
           class Case1Val,
           class Case2Val,
           class Case0Type,
           class Case1Type,
           class Case2Type,
           class DefaultType
          >
  struct ct_switch4
  {
    typedef mpl::identity<Case0Type> Case0TypeQ ;
    typedef mpl::identity<Case1Type> Case1TypeQ ;

    typedef equal_to<Value,Case0Val> is_case0 ;
    typedef equal_to<Value,Case1Val> is_case1 ;
    typedef equal_to<Value,Case2Val> is_case2 ;

    typedef mpl::if_<is_case2,Case2Type,DefaultType> choose_2_3Q ;
    typedef mpl::eval_if<is_case1,Case1TypeQ,choose_2_3Q> choose_1_2_3Q ;

    typedef typename
      mpl::eval_if<is_case0,Case0TypeQ,choose_1_2_3Q>::type
        type ;
  } ;
  template<class expr0, class expr1, class TT, class TF, class FT, class FF>
  struct for_both
  {
    typedef mpl::identity<TF> TF_Q ;
    typedef mpl::identity<TT> TT_Q ;

    typedef typename mpl::not_<expr0>::type not_expr0 ;
    typedef typename mpl::not_<expr1>::type not_expr1 ;

    typedef typename mpl::and_<expr0,expr1>::type caseTT ;
    typedef typename mpl::and_<expr0,not_expr1>::type caseTF ;
    typedef typename mpl::and_<not_expr0,expr1>::type caseFT ;

    typedef mpl::if_<caseFT,FT,FF> choose_FT_FF_Q ;
    typedef mpl::eval_if<caseTF,TF_Q,choose_FT_FF_Q> choose_TF_FT_FF_Q ;

    typedef typename mpl::eval_if<caseTT,TT_Q,choose_TF_FT_FF_Q>::type type ;
  } ;

} } }
namespace boost { namespace numeric
{
  enum int_float_mixture_enum
  {
     integral_to_integral
    ,integral_to_float
    ,float_to_integral
    ,float_to_float
  } ;

} }




namespace boost { namespace numeric { namespace convdetail
{

  typedef mpl::integral_c<int_float_mixture_enum, integral_to_integral> int2int_c ;
  typedef mpl::integral_c<int_float_mixture_enum, integral_to_float> int2float_c ;
  typedef mpl::integral_c<int_float_mixture_enum, float_to_integral> float2int_c ;
  typedef mpl::integral_c<int_float_mixture_enum, float_to_float> float2float_c ;







  template<class T,class S>
  struct get_int_float_mixture
  {
    typedef mpl::bool_< ::std::numeric_limits<S>::is_integer > S_int ;
    typedef mpl::bool_< ::std::numeric_limits<T>::is_integer > T_int ;

    typedef typename
      for_both<S_int, T_int, int2int_c, int2float_c, float2int_c, float2float_c>::type
        type ;
  } ;
  template<class IntFloatMixture, class Int2Int, class Int2Float, class Float2Int, class Float2Float>
  struct for_int_float_mixture
  {
    typedef typename
      ct_switch4<IntFloatMixture
                 ,int2int_c, int2float_c, float2int_c
                 ,Int2Int , Int2Float , Float2Int , Float2Float
                >::type
        type ;
  } ;

} } }
namespace boost { namespace numeric
{
  enum sign_mixture_enum
  {
     unsigned_to_unsigned
    ,signed_to_signed
    ,signed_to_unsigned
    ,unsigned_to_signed
  } ;

} }




namespace boost { namespace numeric { namespace convdetail
{

  typedef mpl::integral_c<sign_mixture_enum, unsigned_to_unsigned> unsig2unsig_c ;
  typedef mpl::integral_c<sign_mixture_enum, signed_to_signed> sig2sig_c ;
  typedef mpl::integral_c<sign_mixture_enum, signed_to_unsigned> sig2unsig_c ;
  typedef mpl::integral_c<sign_mixture_enum, unsigned_to_signed> unsig2sig_c ;







  template<class T,class S>
  struct get_sign_mixture
  {
    typedef mpl::bool_< ::std::numeric_limits<S>::is_signed > S_signed ;
    typedef mpl::bool_< ::std::numeric_limits<T>::is_signed > T_signed ;

    typedef typename
      for_both<S_signed, T_signed, sig2sig_c, sig2unsig_c, unsig2sig_c, unsig2unsig_c>::type
        type ;
  } ;
  template<class SignMixture, class Sig2Sig, class Sig2Unsig, class Unsig2Sig, class Unsig2Unsig>
  struct for_sign_mixture
  {
    typedef typename
      ct_switch4<SignMixture
                 , sig2sig_c, sig2unsig_c, unsig2sig_c
                 , Sig2Sig , Sig2Unsig , Unsig2Sig , Unsig2Unsig
                >::type
        type ;
  } ;

} } }
namespace boost { namespace numeric
{
  enum udt_builtin_mixture_enum
  {
     builtin_to_builtin
    ,builtin_to_udt
    ,udt_to_builtin
    ,udt_to_udt
  } ;

} }




namespace boost { namespace numeric { namespace convdetail
{

  typedef mpl::integral_c<udt_builtin_mixture_enum, builtin_to_builtin> builtin2builtin_c ;
  typedef mpl::integral_c<udt_builtin_mixture_enum, builtin_to_udt> builtin2udt_c ;
  typedef mpl::integral_c<udt_builtin_mixture_enum, udt_to_builtin> udt2builtin_c ;
  typedef mpl::integral_c<udt_builtin_mixture_enum, udt_to_udt> udt2udt_c ;
  template<class UdtMixture, class BuiltIn2BuiltIn, class BuiltIn2Udt, class Udt2BuiltIn, class Udt2Udt>
  struct for_udt_builtin_mixture
  {
    typedef typename
      ct_switch4<UdtMixture
                 , builtin2builtin_c, builtin2udt_c, udt2builtin_c
                 , BuiltIn2BuiltIn , BuiltIn2Udt , Udt2BuiltIn , Udt2Udt
                >::type
        type ;
  } ;







  template<class T,class S>
  struct get_udt_builtin_mixture
  {
    typedef is_arithmetic<S> S_builtin ;
    typedef is_arithmetic<T> T_builtin ;

    typedef typename
      for_both<S_builtin, T_builtin, builtin2builtin_c, builtin2udt_c, udt2builtin_c, udt2udt_c>::type
        type ;
  } ;

} } }







namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct times_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< times_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< times_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct times_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct times_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct times_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct times_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    , typename N3 = na, typename N4 = na, typename N5 = na
    >
struct times
    : times< times< times< times< N1,N2 >, N3>, N4>, N5>
{





};

template<
      typename N1, typename N2, typename N3, typename N4
    >
struct times< N1,N2,N3,N4,na >

    : times< times< times< N1,N2 >, N3>, N4>
{





};

template<
      typename N1, typename N2, typename N3
    >
struct times< N1,N2,N3,na,na >

    : times< times< N1,N2 >, N3>
{





};

template<
      typename N1, typename N2
    >
struct times< N1,N2,na,na,na >
    : times_impl<
          typename times_tag<N1>::type
        , typename times_tag<N2>::type
        >::template apply< N1,N2 >::type
{






};

template<> struct times< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : times< T1 , T2 > { }; }; template< typename Tag > struct lambda< times< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef times< na , na > result_; typedef times< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< times< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< times< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {
template<>
struct times_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : integral_c<
              typename aux::largest_int<
                  typename N1::value_type
                , typename N2::value_type
                >::type
            , ( N1::value
                  * N2::value
                )
            >
    {
    };
};

}}








namespace boost { namespace mpl {







template<
      typename N1 = na , typename N2 = na , typename N3 = na , typename N4 = na , typename N5 = na
    >
struct multiplies
    : times< N1 , N2 , N3 , N4 , N5 >
{





};

template<> struct multiplies< na , na , na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct apply : multiplies< T1 , T2 , T3 , T4 , T5 > { }; }; template< typename Tag > struct lambda< multiplies< na , na , na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef multiplies< na , na , na , na , na > result_; typedef multiplies< na , na , na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< multiplies< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< multiplies< na , na , na , na , na > > : int_<-1> { }; }



}}
namespace boost { namespace numeric { namespace convdetail
{





    template<class T,class S>
    struct subranged_Sig2Unsig
    {


      typedef mpl::true_ type ;
    } ;


    template<class T,class S>
    struct subranged_Unsig2Sig
    {
       typedef mpl::int_< ::std::numeric_limits<S>::digits > S_digits ;
       typedef mpl::int_< ::std::numeric_limits<T>::digits > T_digits ;


       typedef typename T_digits::next u_T_digits ;

       typedef mpl::int_<2> Two ;

       typedef typename mpl::multiplies<S_digits,Two>::type S_digits_times_2 ;

       typedef typename mpl::less<u_T_digits,S_digits_times_2>::type type ;
    } ;


    template<class T,class S>
    struct subranged_SameSign
    {


       typedef mpl::int_< ::std::numeric_limits<S>::digits > S_digits ;
       typedef mpl::int_< ::std::numeric_limits<T>::digits > T_digits ;

       typedef typename mpl::less<T_digits,S_digits>::type type ;
    } ;


    template<class T,class S>
    struct subranged_Int2Float
    {
      typedef mpl::false_ type ;
    } ;


    template<class T,class S>
    struct subranged_Float2Int
    {
      typedef mpl::true_ type ;
    } ;


    template<class T,class S>
    struct subranged_Float2Float
    {



      typedef mpl::int_< ::std::numeric_limits<S>::digits > S_mantisa ;
      typedef mpl::int_< ::std::numeric_limits<T>::digits > T_mantisa ;

      typedef mpl::int_< ::std::numeric_limits<S>::max_exponent > S_exponent ;
      typedef mpl::int_< ::std::numeric_limits<T>::max_exponent > T_exponent ;

      typedef typename mpl::less<T_exponent,S_exponent>::type T_smaller_exponent ;

      typedef typename mpl::equal_to<T_exponent,S_exponent>::type equal_exponents ;

      typedef mpl::less<T_mantisa,S_mantisa> T_smaller_mantisa ;

      typedef mpl::eval_if<equal_exponents,T_smaller_mantisa,mpl::false_> not_bigger_exponent_case ;

      typedef typename
        mpl::eval_if<T_smaller_exponent,mpl::true_,not_bigger_exponent_case>::type
          type ;
    } ;


    template<class T,class S>
    struct subranged_Udt2BuiltIn
    {
      typedef mpl::true_ type ;
    } ;


    template<class T,class S>
    struct subranged_BuiltIn2Udt
    {
      typedef mpl::false_ type ;
    } ;


    template<class T,class S>
    struct subranged_Udt2Udt
    {
      typedef mpl::false_ type ;
    } ;





    template<class T,class S>
    struct get_subranged_Int2Int
    {
      typedef subranged_SameSign<T,S> Sig2Sig ;
      typedef subranged_Sig2Unsig<T,S> Sig2Unsig ;
      typedef subranged_Unsig2Sig<T,S> Unsig2Sig ;
      typedef Sig2Sig Unsig2Unsig ;

      typedef typename get_sign_mixture<T,S>::type sign_mixture ;

      typedef typename
        for_sign_mixture<sign_mixture, Sig2Sig, Sig2Unsig, Unsig2Sig, Unsig2Unsig>::type
           type ;
    } ;

    template<class T,class S>
    struct get_subranged_BuiltIn2BuiltIn
    {
      typedef get_subranged_Int2Int<T,S> Int2IntQ ;

      typedef subranged_Int2Float <T,S> Int2Float ;
      typedef subranged_Float2Int <T,S> Float2Int ;
      typedef subranged_Float2Float<T,S> Float2Float ;

      typedef mpl::identity<Int2Float > Int2FloatQ ;
      typedef mpl::identity<Float2Int > Float2IntQ ;
      typedef mpl::identity<Float2Float> Float2FloatQ ;

      typedef typename get_int_float_mixture<T,S>::type int_float_mixture ;

      typedef for_int_float_mixture<int_float_mixture, Int2IntQ, Int2FloatQ, Float2IntQ, Float2FloatQ> for_ ;

      typedef typename for_::type selected ;

      typedef typename selected::type type ;
    } ;

    template<class T,class S>
    struct get_subranged
    {
      typedef get_subranged_BuiltIn2BuiltIn<T,S> BuiltIn2BuiltInQ ;

      typedef subranged_BuiltIn2Udt<T,S> BuiltIn2Udt ;
      typedef subranged_Udt2BuiltIn<T,S> Udt2BuiltIn ;
      typedef subranged_Udt2Udt<T,S> Udt2Udt ;

      typedef mpl::identity<BuiltIn2Udt> BuiltIn2UdtQ ;
      typedef mpl::identity<Udt2BuiltIn> Udt2BuiltInQ ;
      typedef mpl::identity<Udt2Udt > Udt2UdtQ ;

      typedef typename get_udt_builtin_mixture<T,S>::type udt_builtin_mixture ;

      typedef typename
        for_udt_builtin_mixture<udt_builtin_mixture, BuiltIn2BuiltInQ, BuiltIn2UdtQ, Udt2BuiltInQ, Udt2UdtQ>::type
          selected ;

      typedef typename selected::type selected2 ;

      typedef typename selected2::type type ;
    } ;





  template<class T, class S>
  struct get_is_subranged
  {
    typedef get_subranged<T,S> non_trivial_case ;
    typedef mpl::identity<mpl::false_> trivial_case ;

    typedef is_same<T,S> is_trivial ;

    typedef typename mpl::if_<is_trivial,trivial_case,non_trivial_case>::type selected ;

    typedef typename selected::type type ;
  } ;

} } }

namespace boost { namespace numeric { namespace convdetail
{





  template<class T,class S>
  struct non_trivial_traits_impl
  {
    typedef typename get_int_float_mixture <T,S>::type int_float_mixture ;
    typedef typename get_sign_mixture <T,S>::type sign_mixture ;
    typedef typename get_udt_builtin_mixture <T,S>::type udt_builtin_mixture ;

    typedef typename get_is_subranged<T,S>::type subranged ;

    typedef mpl::false_ trivial ;

    typedef T target_type ;
    typedef S source_type ;
    typedef T result_type ;

    typedef typename mpl::if_< is_arithmetic<S>, S, S const&>::type argument_type ;

    typedef typename mpl::if_<subranged,S,T>::type supertype ;
    typedef typename mpl::if_<subranged,T,S>::type subtype ;
  } ;






  template<class N>
  struct trivial_traits_impl
  {
    typedef typename get_int_float_mixture <N,N>::type int_float_mixture ;
    typedef typename get_sign_mixture <N,N>::type sign_mixture ;
    typedef typename get_udt_builtin_mixture<N,N>::type udt_builtin_mixture ;

    typedef mpl::false_ subranged ;
    typedef mpl::true_ trivial ;

    typedef N target_type ;
    typedef N source_type ;
    typedef N const& result_type ;
    typedef N const& argument_type ;

    typedef N supertype ;
    typedef N subtype ;

  } ;




  template<class T, class S>
  struct get_conversion_traits
  {
    typedef typename remove_cv<T>::type target_type ;
    typedef typename remove_cv<S>::type source_type ;

    typedef typename is_same<target_type,source_type>::type is_trivial ;

    typedef trivial_traits_impl <target_type> trivial_imp ;
    typedef non_trivial_traits_impl<target_type,source_type> non_trivial_imp ;

    typedef typename mpl::if_<is_trivial,trivial_imp,non_trivial_imp>::type type ;
  } ;

} } }



namespace boost { namespace numeric
{

template<class T, class S>
struct conversion_traits
    : convdetail::get_conversion_traits<T,S>::type
{
} ;

} }
namespace boost { namespace numeric
{

template<class S>
struct Trunc
{
  typedef S source_type ;

  typedef typename mpl::if_< is_arithmetic<S>,S,S const&>::type argument_type ;

  static source_type nearbyint ( argument_type s )
  {

    using std::floor ;
    using std::ceil ;


    return s < static_cast<S>(0) ? ceil(s) : floor(s) ;
  }

  typedef mpl::integral_c< std::float_round_style, std::round_toward_zero> round_style ;
} ;



template<class S>
struct Floor
{
  typedef S source_type ;

  typedef typename mpl::if_< is_arithmetic<S>,S,S const&>::type argument_type ;

  static source_type nearbyint ( argument_type s )
  {

    using std::floor ;


    return floor(s) ;
  }

  typedef mpl::integral_c< std::float_round_style, std::round_toward_neg_infinity> round_style ;
} ;

template<class S>
struct Ceil
{
  typedef S source_type ;

  typedef typename mpl::if_< is_arithmetic<S>,S,S const&>::type argument_type ;

  static source_type nearbyint ( argument_type s )
  {

    using std::ceil ;


    return ceil(s) ;
  }

  typedef mpl::integral_c< std::float_round_style, std::round_toward_infinity> round_style ;
} ;

template<class S>
struct RoundEven
{
  typedef S source_type ;

  typedef typename mpl::if_< is_arithmetic<S>,S,S const&>::type argument_type ;

  static source_type nearbyint ( argument_type s )
  {



    using std::floor ;
    using std::ceil ;



    S prev = floor(s);
    S next = ceil(s);

    S rt = (s - prev) - (next - s);

    S const zero(0.0);
    S const two(2.0);

    if ( rt < zero )
      return prev;
    else if ( rt > zero )
      return next;
    else
    {
      bool is_prev_even = two * floor(prev / two) == prev ;
      return ( is_prev_even ? prev : next ) ;
    }
  }

  typedef mpl::integral_c< std::float_round_style, std::round_to_nearest> round_style ;
} ;


enum range_check_result
{
  cInRange = 0 ,
  cNegOverflow = 1 ,
  cPosOverflow = 2
} ;

class bad_numeric_cast : public std::bad_cast
{
  public:

    virtual const char * what() const throw()
      { return "bad numeric conversion: overflow"; }
};

class negative_overflow : public bad_numeric_cast
{
  public:

    virtual const char * what() const throw()
      { return "bad numeric conversion: negative overflow"; }
};
class positive_overflow : public bad_numeric_cast
{
  public:

    virtual const char * what() const throw()
      { return "bad numeric conversion: positive overflow"; }
};

struct def_overflow_handler
{
  void operator() ( range_check_result r )
  {

    if ( r == cNegOverflow )
      throw negative_overflow() ;
    else if ( r == cPosOverflow )
           throw positive_overflow() ;






  }
} ;

struct silent_overflow_handler
{
  void operator() ( range_check_result ) {}
} ;

template<class Traits>
struct raw_converter
{
  typedef typename Traits::result_type result_type ;
  typedef typename Traits::argument_type argument_type ;

  static result_type low_level_convert ( argument_type s ) { return static_cast<result_type>(s) ; }
} ;

struct UseInternalRangeChecker {} ;

} }

namespace boost { namespace numeric { namespace boundsdetail
{
  template<class N>
  class Integral
  {
      typedef std::numeric_limits<N> limits ;

    public :

      static N lowest () { return limits::min (); }
      static N highest () { return limits::max (); }
      static N smallest() { return static_cast<N>(1); }
  } ;

  template<class N>
  class Float
  {
      typedef std::numeric_limits<N> limits ;

    public :

      static N lowest () { return static_cast<N>(-limits::max ()) ; }
      static N highest () { return limits::max (); }
      static N smallest() { return limits::min (); }
  } ;

  template<class N>
  struct get_impl
  {
    typedef mpl::bool_< ::std::numeric_limits<N>::is_integer > is_int ;

    typedef Integral<N> impl_int ;
    typedef Float <N> impl_float ;

    typedef typename mpl::if_<is_int,impl_int,impl_float>::type type ;
  } ;

} } }

namespace boost { namespace numeric
{

template<class N>
struct bounds : boundsdetail::get_impl<N>::type
{} ;

} }





namespace boost { namespace numeric { namespace convdetail
{

  typedef mpl::integral_c<std::float_round_style, std::round_toward_zero> round2zero_c ;
  typedef mpl::integral_c<std::float_round_style, std::round_to_nearest> round2nearest_c ;
  typedef mpl::integral_c<std::float_round_style, std::round_toward_infinity> round2inf_c ;
  typedef mpl::integral_c<std::float_round_style, std::round_toward_neg_infinity> round2neg_inf_c ;
  template<class RoundStyle,class RoundToZero,class RoundToNearest,class RoundToInf,class RoundToNegInf>
  struct for_round_style
  {
    typedef ct_switch4<RoundStyle
                       , round2zero_c, round2nearest_c, round2inf_c
                       , RoundToZero , RoundToNearest , RoundToInf , RoundToNegInf
                      > selector ;

    typedef typename selector::type type ;
  } ;
  struct non_applicable { typedef mpl::false_ do_apply ; } ;
  struct applicable { typedef mpl::true_ do_apply ; } ;
    template<class Traits>
    struct LT_LoT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        return s < static_cast<S>(bounds<T>::lowest()) ? cNegOverflow : cInRange ;
      }
    } ;



    template<class Traits>
    struct LT_Zero : applicable
    {
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        return s < static_cast<S>(0) ? cNegOverflow : cInRange ;
      }
    } ;



    template<class Traits>
    struct LE_PrevLoT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        return s <= static_cast<S>(bounds<T>::lowest()) - static_cast<S>(1.0)
                 ? cNegOverflow : cInRange ;
      }
    } ;



    template<class Traits>
    struct LT_HalfPrevLoT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        return s < static_cast<S>(bounds<T>::lowest()) - static_cast<S>(0.5)
                 ? cNegOverflow : cInRange ;
      }
    } ;



    template<class Traits>
    struct GT_HiT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        return s > static_cast<S>(bounds<T>::highest())
                 ? cPosOverflow : cInRange ;
      }
    } ;



    template<class Traits>
    struct GE_SuccHiT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        return s >= static_cast<S>(bounds<T>::highest()) + static_cast<S>(1.0)
                 ? cPosOverflow : cInRange ;
      }
    } ;



    template<class Traits>
    struct GT_HalfSuccHiT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        return s >= static_cast<S>(bounds<T>::highest()) + static_cast<S>(0.5)
                 ? cPosOverflow : cInRange ;
      }
    } ;
    template<class PredA, class PredB>
    struct applyBoth
    {
      typedef typename PredA::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        range_check_result r = PredA::apply(s) ;
        if ( r == cInRange )
          r = PredB::apply(s);
        return r ;
      }
    } ;

    template<class PredA, class PredB>
    struct combine
    {
      typedef applyBoth<PredA,PredB> Both ;
      typedef void NNone ;

      typedef typename PredA::do_apply do_applyA ;
      typedef typename PredB::do_apply do_applyB ;

      typedef typename for_both<do_applyA, do_applyB, Both, PredA, PredB, NNone>::type type ;
    } ;
  template<class Traits>
  struct dummy_range_checker
  {
    typedef typename Traits::argument_type argument_type ;

    static range_check_result out_of_range ( argument_type ) { return cInRange ; }
    static void validate_range ( argument_type ) {}
  } ;
  template<class Traits, class IsNegOverflow, class IsPosOverflow, class OverflowHandler>
  struct generic_range_checker
  {
    typedef OverflowHandler overflow_handler ;

    typedef typename Traits::argument_type argument_type ;

    static range_check_result out_of_range ( argument_type s )
    {
      typedef typename combine<IsNegOverflow,IsPosOverflow>::type Predicate ;

      return Predicate::apply(s);
    }

    static void validate_range ( argument_type s )
      { OverflowHandler()( out_of_range(s) ) ; }
  } ;
  template<class Traits,class OverflowHandler>
  struct GetRC_Sig2Sig_or_Unsig2Unsig
  {
    typedef dummy_range_checker<Traits> Dummy ;

    typedef LT_LoT<Traits> Pred1 ;
    typedef GT_HiT<Traits> Pred2 ;

    typedef generic_range_checker<Traits,Pred1,Pred2,OverflowHandler> Normal ;

    typedef typename Traits::subranged subranged ;

    typedef typename mpl::if_<subranged,Normal,Dummy>::type type ;
  } ;

  template<class Traits, class OverflowHandler>
  struct GetRC_Sig2Unsig
  {
    typedef LT_Zero<Traits> Pred1 ;
    typedef GT_HiT <Traits> Pred2 ;

    typedef generic_range_checker<Traits,Pred1,Pred2,OverflowHandler> ChoiceA ;

    typedef generic_range_checker<Traits,Pred1,non_applicable,OverflowHandler> ChoiceB ;

    typedef typename Traits::target_type T ;
    typedef typename Traits::source_type S ;

    typedef typename subranged_Unsig2Sig<S,T>::type oposite_subranged ;

    typedef typename mpl::not_<oposite_subranged>::type positively_subranged ;

    typedef typename mpl::if_<positively_subranged,ChoiceA,ChoiceB>::type type ;
  } ;

  template<class Traits, class OverflowHandler>
  struct GetRC_Unsig2Sig
  {
    typedef GT_HiT<Traits> Pred1 ;

    typedef generic_range_checker<Traits,non_applicable,Pred1,OverflowHandler> type ;
  } ;

  template<class Traits,class OverflowHandler>
  struct GetRC_Int2Int
  {
    typedef GetRC_Sig2Sig_or_Unsig2Unsig<Traits,OverflowHandler> Sig2SigQ ;
    typedef GetRC_Sig2Unsig <Traits,OverflowHandler> Sig2UnsigQ ;
    typedef GetRC_Unsig2Sig <Traits,OverflowHandler> Unsig2SigQ ;
    typedef Sig2SigQ Unsig2UnsigQ ;

    typedef typename Traits::sign_mixture sign_mixture ;

    typedef typename
      for_sign_mixture<sign_mixture,Sig2SigQ,Sig2UnsigQ,Unsig2SigQ,Unsig2UnsigQ>::type
        selector ;

    typedef typename selector::type type ;
  } ;

  template<class Traits>
  struct GetRC_Int2Float
  {
    typedef dummy_range_checker<Traits> type ;
  } ;

  template<class Traits, class OverflowHandler, class Float2IntRounder>
  struct GetRC_Float2Int
  {
    typedef LE_PrevLoT <Traits> Pred1 ;
    typedef GE_SuccHiT <Traits> Pred2 ;
    typedef LT_HalfPrevLoT<Traits> Pred3 ;
    typedef GT_HalfSuccHiT<Traits> Pred4 ;
    typedef GT_HiT <Traits> Pred5 ;
    typedef LT_LoT <Traits> Pred6 ;

    typedef generic_range_checker<Traits,Pred1,Pred2,OverflowHandler> ToZero ;
    typedef generic_range_checker<Traits,Pred3,Pred4,OverflowHandler> ToNearest ;
    typedef generic_range_checker<Traits,Pred1,Pred5,OverflowHandler> ToInf ;
    typedef generic_range_checker<Traits,Pred6,Pred2,OverflowHandler> ToNegInf ;

    typedef typename Float2IntRounder::round_style round_style ;

    typedef typename for_round_style<round_style,ToZero,ToNearest,ToInf,ToNegInf>::type type ;
  } ;

  template<class Traits, class OverflowHandler>
  struct GetRC_Float2Float
  {
    typedef dummy_range_checker<Traits> Dummy ;

    typedef LT_LoT<Traits> Pred1 ;
    typedef GT_HiT<Traits> Pred2 ;

    typedef generic_range_checker<Traits,Pred1,Pred2,OverflowHandler> Normal ;

    typedef typename Traits::subranged subranged ;

    typedef typename mpl::if_<subranged,Normal,Dummy>::type type ;
  } ;

  template<class Traits, class OverflowHandler, class Float2IntRounder>
  struct GetRC_BuiltIn2BuiltIn
  {
    typedef GetRC_Int2Int<Traits,OverflowHandler> Int2IntQ ;
    typedef GetRC_Int2Float<Traits> Int2FloatQ ;
    typedef GetRC_Float2Int<Traits,OverflowHandler,Float2IntRounder> Float2IntQ ;
    typedef GetRC_Float2Float<Traits,OverflowHandler> Float2FloatQ ;

    typedef typename Traits::int_float_mixture int_float_mixture ;

    typedef typename for_int_float_mixture<int_float_mixture, Int2IntQ, Int2FloatQ, Float2IntQ, Float2FloatQ>::type selector ;

    typedef typename selector::type type ;
  } ;

  template<class Traits, class OverflowHandler, class Float2IntRounder>
  struct GetRC
  {
    typedef GetRC_BuiltIn2BuiltIn<Traits,OverflowHandler,Float2IntRounder> BuiltIn2BuiltInQ ;

    typedef dummy_range_checker<Traits> Dummy ;

    typedef mpl::identity<Dummy> DummyQ ;

    typedef typename Traits::udt_builtin_mixture udt_builtin_mixture ;

    typedef typename for_udt_builtin_mixture<udt_builtin_mixture,BuiltIn2BuiltInQ,DummyQ,DummyQ,DummyQ>::type selector ;

    typedef typename selector::type type ;
  } ;
  template<class Traits>
  struct trivial_converter_impl : public dummy_range_checker<Traits>
  {
    typedef Traits traits ;

    typedef typename Traits::source_type source_type ;
    typedef typename Traits::argument_type argument_type ;
    typedef typename Traits::result_type result_type ;

    static result_type low_level_convert ( argument_type s ) { return s ; }
    static source_type nearbyint ( argument_type s ) { return s ; }
    static result_type convert ( argument_type s ) { return s ; }
  } ;





  template<class Traits,class RangeChecker,class RawConverter,class Float2IntRounder>
  struct rounding_converter : public RangeChecker
                             ,public Float2IntRounder
                             ,public RawConverter
  {
    typedef RangeChecker RangeCheckerBase ;
    typedef Float2IntRounder Float2IntRounderBase ;
    typedef RawConverter RawConverterBase ;

    typedef Traits traits ;

    typedef typename Traits::source_type source_type ;
    typedef typename Traits::argument_type argument_type ;
    typedef typename Traits::result_type result_type ;

    static result_type convert ( argument_type s )
    {
      RangeCheckerBase::validate_range(s);
      source_type s1 = Float2IntRounderBase::nearbyint(s);
      return RawConverterBase::low_level_convert(s1);
    }
  } ;





  template<class Traits,class RangeChecker,class RawConverter>
  struct non_rounding_converter : public RangeChecker
                                 ,public RawConverter
  {
    typedef RangeChecker RangeCheckerBase ;
    typedef RawConverter RawConverterBase ;

    typedef Traits traits ;

    typedef typename Traits::source_type source_type ;
    typedef typename Traits::argument_type argument_type ;
    typedef typename Traits::result_type result_type ;

    static source_type nearbyint ( argument_type s ) { return s ; }

    static result_type convert ( argument_type s )
    {
      RangeCheckerBase::validate_range(s);
      return RawConverterBase::low_level_convert(s);
    }
  } ;
  template<class Traits,class OverflowHandler,class Float2IntRounder,class RawConverter, class UserRangeChecker>
  struct get_non_trivial_converter
  {
    typedef GetRC<Traits,OverflowHandler,Float2IntRounder> InternalRangeCheckerQ ;

    typedef is_same<UserRangeChecker,UseInternalRangeChecker> use_internal_RC ;

    typedef mpl::identity<UserRangeChecker> UserRangeCheckerQ ;

    typedef typename
      mpl::eval_if<use_internal_RC,InternalRangeCheckerQ,UserRangeCheckerQ>::type
        RangeChecker ;

    typedef non_rounding_converter<Traits,RangeChecker,RawConverter> NonRounding ;
    typedef rounding_converter<Traits,RangeChecker,RawConverter,Float2IntRounder> Rounding ;

    typedef mpl::identity<NonRounding> NonRoundingQ ;
    typedef mpl::identity<Rounding> RoundingQ ;

    typedef typename Traits::int_float_mixture int_float_mixture ;

    typedef typename
      for_int_float_mixture<int_float_mixture, NonRoundingQ, NonRoundingQ, RoundingQ, NonRoundingQ>::type
        selector ;

    typedef typename selector::type type ;
  } ;

  template< class Traits
           ,class OverflowHandler
           ,class Float2IntRounder
           ,class RawConverter
           ,class UserRangeChecker
          >
  struct get_converter_impl
  {
    typedef trivial_converter_impl<Traits> Trivial ;
    typedef mpl::identity <Trivial> TrivialQ ;

    typedef get_non_trivial_converter< Traits
                                      ,OverflowHandler
                                      ,Float2IntRounder
                                      ,RawConverter
                                      ,UserRangeChecker
                                     > NonTrivialQ ;

    typedef typename Traits::trivial trivial ;

    typedef typename mpl::eval_if<trivial,TrivialQ,NonTrivialQ>::type type ;
  } ;

} } }

namespace boost { namespace numeric
{

template<class T,
         class S,
         class Traits = conversion_traits<T,S>,
         class OverflowHandler = def_overflow_handler,
         class Float2IntRounder = Trunc< typename Traits::source_type> ,
         class RawConverter = raw_converter<Traits>,
         class UserRangeChecker = UseInternalRangeChecker
        >
struct converter : convdetail::get_converter_impl<Traits,
                                                  OverflowHandler,
                                                  Float2IntRounder,
                                                  RawConverter,
                                                  UserRangeChecker
                                                 >::type
{
  typedef Traits traits ;

  typedef typename Traits::argument_type argument_type ;
  typedef typename Traits::result_type result_type ;

  result_type operator() ( argument_type s ) const { return this->convert(s) ; }
} ;



template<class S,
         class OverflowHandler = def_overflow_handler,
         class Float2IntRounder = Trunc<S> ,
         class UserRangeChecker = UseInternalRangeChecker
        >
struct make_converter_from
{
  template<class T,
           class Traits = conversion_traits<T,S>,
           class RawConverter = raw_converter<Traits>
          >
  struct to
  {
    typedef converter<T,S,Traits,OverflowHandler,Float2IntRounder,RawConverter,UserRangeChecker> type ;
  } ;

} ;

} }
namespace boost { namespace numeric {

    template <typename Target, typename Source, typename EnableIf = void>
    struct numeric_cast_traits
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<Source> rounding_policy;
    };

}}



namespace boost { namespace numeric {

    template <>
    struct numeric_cast_traits
        <
            char
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };
}}










namespace boost { namespace numeric {


    template <>
    struct numeric_cast_traits
        <
            char
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            boost::long_long_type
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            boost::long_long_type
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            boost::ulong_long_type
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            boost::ulong_long_type
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };
}}

namespace boost
{
    template <typename Target, typename Source>
    inline Target numeric_cast( Source arg )
    {
        typedef numeric::conversion_traits<Target, Source> conv_traits;
        typedef numeric::numeric_cast_traits<Target, Source> cast_traits;
        typedef boost::numeric::converter
            <
                Target,
                Source,
                conv_traits,
                typename cast_traits::overflow_policy,
                typename cast_traits::rounding_policy,
                boost::numeric::raw_converter< conv_traits >,
                typename cast_traits::range_checking_policy
            > converter;
        return converter::convert(arg);
    }

    using numeric::bad_numeric_cast;
}

namespace boost { namespace detail {

template <class Source >
struct detect_precision_loss
{
    typedef Source source_type;
    typedef boost::numeric::Trunc<Source> Rounder;
    typedef typename conditional<
        boost::is_arithmetic<Source>::value, Source, Source const&
    >::type argument_type ;

    static inline source_type nearbyint(argument_type s, bool& is_ok) noexcept {
        const source_type near_int = Rounder::nearbyint(s);
        if (near_int && is_ok) {
            const source_type orig_div_round = s / near_int;
            const source_type eps = std::numeric_limits<source_type>::epsilon();

            is_ok = !((orig_div_round > 1 ? orig_div_round - 1 : 1 - orig_div_round) > eps);
        }

        return s;
    }

    typedef typename Rounder::round_style round_style;
};

template <typename Base, class Source>
struct fake_precision_loss: public Base
{
    typedef Source source_type ;
    typedef typename conditional<
        boost::is_arithmetic<Source>::value, Source, Source const&
    >::type argument_type ;

    static inline source_type nearbyint(argument_type s, bool& ) noexcept {
        return s;
    }
};

struct nothrow_overflow_handler
{
    inline bool operator() ( boost::numeric::range_check_result r ) const noexcept {
        return (r == boost::numeric::cInRange);
    }
};

template <typename Target, typename Source>
inline bool noexcept_numeric_convert(const Source& arg, Target& result) noexcept {
    typedef boost::numeric::converter<
            Target,
            Source,
            boost::numeric::conversion_traits<Target, Source >,
            nothrow_overflow_handler,
            detect_precision_loss<Source >
    > converter_orig_t;

    typedef typename boost::conditional<
        boost::is_base_of< detect_precision_loss<Source >, converter_orig_t >::value,
        converter_orig_t,
        fake_precision_loss<converter_orig_t, Source>
    >::type converter_t;

    bool res = nothrow_overflow_handler()(converter_t::out_of_range(arg));
    result = converter_t::low_level_convert(converter_t::nearbyint(arg, res));
    return res;
}

template <typename Target, typename Source>
struct lexical_cast_dynamic_num_not_ignoring_minus
{
    static inline bool try_convert(const Source &arg, Target& result) noexcept {
        return noexcept_numeric_convert<Target, Source >(arg, result);
    }
};

template <typename Target, typename Source>
struct lexical_cast_dynamic_num_ignoring_minus
{
    static inline bool try_convert(const Source &arg, Target& result) noexcept {
        typedef typename boost::conditional<
                boost::is_float<Source>::value,
                boost::type_identity<Source>,
                boost::make_unsigned<Source>
        >::type usource_lazy_t;
        typedef typename usource_lazy_t::type usource_t;

        if (arg < 0) {
            const bool res = noexcept_numeric_convert<Target, usource_t>(0u - arg, result);
            result = static_cast<Target>(0u - result);
            return res;
        } else {
            return noexcept_numeric_convert<Target, usource_t>(arg, result);
        }
    }
};
template <typename Target, typename Source>
struct dynamic_num_converter_impl
{
    static inline bool try_convert(const Source &arg, Target& result) noexcept {
        typedef typename boost::conditional<
            boost::is_unsigned<Target>::value &&
            (boost::is_signed<Source>::value || boost::is_float<Source>::value) &&
            !(boost::is_same<Source, bool>::value) &&
            !(boost::is_same<Target, bool>::value),
            lexical_cast_dynamic_num_ignoring_minus<Target, Source>,
            lexical_cast_dynamic_num_not_ignoring_minus<Target, Source>
        >::type caster_type;

        return caster_type::try_convert(arg, result);
    }
};

}}
namespace boost
{

   namespace binary_op_detail {

      struct dont_care;

      template <class T, class U, class Ret, class = boost::void_t<>>
      struct has_left_shift_ret_imp : public boost::false_type {};

      template <class T, class U, class Ret>
      struct has_left_shift_ret_imp<T, U, Ret, boost::void_t<decltype(std::declval<typename add_reference<T>::type>() << std::declval<typename add_reference<U>::type>())> >
         : public boost::integral_constant<bool, ::boost::is_convertible<decltype(std::declval<typename add_reference<T>::type>() << std::declval<typename add_reference<U>::type>()), Ret>::value> {};

      template <class T, class U, class = boost::void_t<> >
      struct has_left_shift_void_imp : public boost::false_type {};

      template <class T, class U>
      struct has_left_shift_void_imp<T, U, boost::void_t<decltype(std::declval<typename add_reference<T>::type>() << std::declval<typename add_reference<U>::type>())> >
         : public boost::integral_constant<bool, ::boost::is_void<decltype(std::declval<typename add_reference<T>::type>() << std::declval<typename add_reference<U>::type>())>::value> {};

      template <class T, class U, class = boost::void_t<>>
      struct has_left_shift_dc_imp : public boost::false_type {};

      template <class T, class U>
      struct has_left_shift_dc_imp<T, U, boost::void_t<decltype(std::declval<typename add_reference<T>::type>() << std::declval<typename add_reference<U>::type>())> >
         : public boost::true_type {};

   }

   template <class T, class U = T, class Ret = boost::binary_op_detail::dont_care>
   struct has_left_shift : public boost::binary_op_detail:: has_left_shift_ret_imp <T, U, Ret> {};
   template <class T, class U>
   struct has_left_shift<T, U, void> : public boost::binary_op_detail:: has_left_shift_void_imp <T, U> {};
   template <class T, class U>
   struct has_left_shift<T, U, boost::binary_op_detail::dont_care> : public boost::binary_op_detail:: has_left_shift_dc_imp <T, U> {};


}
namespace boost
{

   namespace binary_op_detail {

      struct dont_care;

      template <class T, class U, class Ret, class = boost::void_t<>>
      struct has_right_shift_ret_imp : public boost::false_type {};

      template <class T, class U, class Ret>
      struct has_right_shift_ret_imp<T, U, Ret, boost::void_t<decltype(std::declval<typename add_reference<T>::type>() >> std::declval<typename add_reference<U>::type>())> >
         : public boost::integral_constant<bool, ::boost::is_convertible<decltype(std::declval<typename add_reference<T>::type>() >> std::declval<typename add_reference<U>::type>()), Ret>::value> {};

      template <class T, class U, class = boost::void_t<> >
      struct has_right_shift_void_imp : public boost::false_type {};

      template <class T, class U>
      struct has_right_shift_void_imp<T, U, boost::void_t<decltype(std::declval<typename add_reference<T>::type>() >> std::declval<typename add_reference<U>::type>())> >
         : public boost::integral_constant<bool, ::boost::is_void<decltype(std::declval<typename add_reference<T>::type>() >> std::declval<typename add_reference<U>::type>())>::value> {};

      template <class T, class U, class = boost::void_t<>>
      struct has_right_shift_dc_imp : public boost::false_type {};

      template <class T, class U>
      struct has_right_shift_dc_imp<T, U, boost::void_t<decltype(std::declval<typename add_reference<T>::type>() >> std::declval<typename add_reference<U>::type>())> >
         : public boost::true_type {};

   }

   template <class T, class U = T, class Ret = boost::binary_op_detail::dont_care>
   struct has_right_shift : public boost::binary_op_detail:: has_right_shift_ret_imp <T, U, Ret> {};
   template <class T, class U>
   struct has_right_shift<T, U, void> : public boost::binary_op_detail:: has_right_shift_void_imp <T, U> {};
   template <class T, class U>
   struct has_right_shift<T, U, boost::binary_op_detail::dont_care> : public boost::binary_op_detail:: has_right_shift_dc_imp <T, U> {};


}



namespace boost {
template<class T>
class integer_traits : public std::numeric_limits<T>
{
public:
  static const bool is_integral = false;
};

namespace detail {
template<class T, T min_val, T max_val>
class integer_traits_base
{
public:
  static const bool is_integral = true;
  static const T const_min = min_val;
  static const T const_max = max_val;
};



template<class T, T min_val, T max_val>
const bool integer_traits_base<T, min_val, max_val>::is_integral;

template<class T, T min_val, T max_val>
const T integer_traits_base<T, min_val, max_val>::const_min;

template<class T, T min_val, T max_val>
const T integer_traits_base<T, min_val, max_val>::const_max;


}

template<>
class integer_traits<bool>
  : public std::numeric_limits<bool>,
    public detail::integer_traits_base<bool, false, true>
{ };

template<>
class integer_traits<char>
  : public std::numeric_limits<char>,
    public detail::integer_traits_base<char, (-127 -1), 127>
{ };

template<>
class integer_traits<signed char>
  : public std::numeric_limits<signed char>,
    public detail::integer_traits_base<signed char, (-127 -1), 127>
{ };

template<>
class integer_traits<unsigned char>
  : public std::numeric_limits<unsigned char>,
    public detail::integer_traits_base<unsigned char, 0, (127*2 +1)>
{ };


template<>
class integer_traits<wchar_t>
  : public std::numeric_limits<wchar_t>,
    public detail::integer_traits_base<wchar_t, (-2147483647 -1), 2147483647>



{ };


template<>
class integer_traits<short>
  : public std::numeric_limits<short>,
    public detail::integer_traits_base<short, (-32767 -1), 32767>
{ };

template<>
class integer_traits<unsigned short>
  : public std::numeric_limits<unsigned short>,
    public detail::integer_traits_base<unsigned short, 0, (32767 *2 +1)>
{ };

template<>
class integer_traits<int>
  : public std::numeric_limits<int>,
    public detail::integer_traits_base<int, (-2147483647 -1), 2147483647>
{ };

template<>
class integer_traits<unsigned int>
  : public std::numeric_limits<unsigned int>,
    public detail::integer_traits_base<unsigned int, 0, (2147483647 *2U +1U)>
{ };

template<>
class integer_traits<long>
  : public std::numeric_limits<long>,
    public detail::integer_traits_base<long, (-9223372036854775807L -1L), 9223372036854775807L>
{ };

template<>
class integer_traits<unsigned long>
  : public std::numeric_limits<unsigned long>,
    public detail::integer_traits_base<unsigned long, 0, (9223372036854775807L *2UL+1UL)>
{ };




template<>
class integer_traits< ::boost::long_long_type>
  : public std::numeric_limits< ::boost::long_long_type>,
    public detail::integer_traits_base< ::boost::long_long_type, (-9223372036854775807LL -1LL), 9223372036854775807LL>
{ };

template<>
class integer_traits< ::boost::ulong_long_type>
  : public std::numeric_limits< ::boost::ulong_long_type>,
    public detail::integer_traits_base< ::boost::ulong_long_type, 0, (9223372036854775807LL*2ULL+1ULL)>
{ };
}
namespace boost { namespace detail {

class lcast_abstract_stub {};





template<class T>
struct lcast_precision
{



    typedef typename boost::conditional<
        boost::is_abstract<T>::value
      , std::numeric_limits<lcast_abstract_stub>
      , std::numeric_limits<T>
      >::type limits;


    static const bool use_default_precision = !limits::is_specialized || limits::is_exact;



    static const bool is_specialized_bin = !use_default_precision && limits::radix == 2 && limits::digits > 0;




    static const bool is_specialized_dec = !use_default_precision && limits::radix == 10 && limits::digits10 > 0;




    static const std::streamsize streamsize_max = boost::integer_traits<std::streamsize>::const_max;



    static const unsigned int precision_dec = limits::digits10 + 1U;

    static_assert(!is_specialized_dec || precision_dec <= streamsize_max + 0UL, "!is_specialized_dec || precision_dec <= streamsize_max + 0UL");



    static const unsigned long precision_bin = 2UL + limits::digits * 30103UL / 100000UL;



    static_assert(!is_specialized_bin || (limits::digits + 0UL < (9223372036854775807L *2UL+1UL) / 30103UL && precision_bin > limits::digits10 + 0UL && precision_bin <= streamsize_max + 0UL), "!is_specialized_bin || (limits::digits + 0UL < ULONG_MAX / 30103UL && precision_bin > limits::digits10 + 0UL && precision_bin <= streamsize_max + 0UL)");





    static const std::streamsize value = is_specialized_bin ? precision_bin : is_specialized_dec ? precision_dec : 6;



};


template<class T>
inline std::streamsize lcast_get_precision(T* = 0)
{

    return lcast_precision<T>::value;
}

template<class T>
inline void lcast_set_precision(std::ios_base& stream, T*)
{
    stream.precision(lcast_get_precision<T>());
}

template<class Source, class Target>
inline void lcast_set_precision(std::ios_base& stream, Source*, Target*)
{
    std::streamsize const s = lcast_get_precision(static_cast<Source*>(0));
    std::streamsize const t = lcast_get_precision(static_cast<Target*>(0));
    stream.precision(s > t ? s : t);
}

}}

namespace boost { namespace detail {

    template <typename TargetChar, typename SourceChar>
    struct widest_char {
        typedef typename boost::conditional<
            (sizeof(TargetChar) > sizeof(SourceChar))
            , TargetChar
            , SourceChar
        >::type type;
    };

}}






namespace boost_swap_impl
{


  template<class T> struct is_const { enum _vt { value = 0 }; };
  template<class T> struct is_const<T const> { enum _vt { value = 1 }; };

  template<class T>

  void swap_impl(T& left, T& right)
  {
    using namespace std;
    swap(left,right);
  }

  template<class T, std::size_t N>

  void swap_impl(T (& left)[N], T (& right)[N])
  {
    for (std::size_t i = 0; i < N; ++i)
    {
      ::boost_swap_impl::swap_impl(left[i], right[i]);
    }
  }
}

namespace boost
{
  template<class T1, class T2>

  typename enable_if_c< !boost_swap_impl::is_const<T1>::value && !boost_swap_impl::is_const<T2>::value >::type
  swap(T1& left, T2& right)
  {
    ::boost_swap_impl::swap_impl(left, right);
  }
}


namespace boost
{

namespace detail
{

using std::iterator_traits;
using std::distance;
}

}







namespace boost {

    template<class T, std::size_t N>
    class array {
      public:
        T elems[N];

      public:

        typedef T value_type;
        typedef T* iterator;
        typedef const T* const_iterator;
        typedef T& reference;
        typedef const T& const_reference;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;


        iterator begin() { return elems; }
        const_iterator begin() const { return elems; }
        const_iterator cbegin() const { return elems; }

        iterator end() { return elems+N; }
        const_iterator end() const { return elems+N; }
        const_iterator cend() const { return elems+N; }



        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        reverse_iterator rbegin() { return reverse_iterator(end()); }
        const_reverse_iterator rbegin() const {
            return const_reverse_iterator(end());
        }
        const_reverse_iterator crbegin() const {
            return const_reverse_iterator(end());
        }

        reverse_iterator rend() { return reverse_iterator(begin()); }
        const_reverse_iterator rend() const {
            return const_reverse_iterator(begin());
        }
        const_reverse_iterator crend() const {
            return const_reverse_iterator(begin());
        }


        reference operator[](size_type i)
        {
            return (__builtin_expect(!((i < N)&&("out of range")), 0) ? __assert_rtn(__func__, "./boost/array.hpp", 118, "(i < N)&&(\"out of range\")") : (void)0), elems[i];
        }

                            const_reference operator[](size_type i) const
        {
            return (__builtin_expect(!((i < N)&&("out of range")), 0) ? __assert_rtn(__func__, "./boost/array.hpp", 123, "(i < N)&&(\"out of range\")") : (void)0), elems[i];
        }


        reference at(size_type i) { return rangecheck(i), elems[i]; }
                            const_reference at(size_type i) const { return rangecheck(i), elems[i]; }


        reference front()
        {
            return elems[0];
        }

        constexpr const_reference front() const
        {
            return elems[0];
        }

        reference back()
        {
            return elems[N-1];
        }

        constexpr const_reference back() const
        {
            return elems[N-1];
        }


        static constexpr size_type size() { return N; }
        static constexpr bool empty() { return false; }
        static constexpr size_type max_size() { return N; }
        enum { static_size = N };


        void swap (array<T,N>& y) {
            for (size_type i = 0; i < N; ++i)
                boost::swap(elems[i],y.elems[i]);
        }


        const T* data() const { return elems; }
        T* data() { return elems; }


        T* c_array() { return elems; }


        template <typename T2>
        array<T,N>& operator= (const array<T2,N>& rhs) {
            std::copy(rhs.begin(),rhs.end(), begin());
            return *this;
        }


        void assign (const T& value) { fill ( value ); }
        void fill (const T& value)
        {
            std::fill_n(begin(),size(),value);
        }


        static constexpr bool rangecheck (size_type i) {
            return i > size() ? boost::throw_exception(std::out_of_range ("array<>: index out of range")), true : true;
        }

    };

    template< class T >
    class array< T, 0 > {

      public:

        typedef T value_type;
        typedef T* iterator;
        typedef const T* const_iterator;
        typedef T& reference;
        typedef const T& const_reference;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;


        iterator begin() { return iterator( reinterpret_cast< T * >( this ) ); }
        const_iterator begin() const { return const_iterator( reinterpret_cast< const T * >( this ) ); }
        const_iterator cbegin() const { return const_iterator( reinterpret_cast< const T * >( this ) ); }

        iterator end() { return begin(); }
        const_iterator end() const { return begin(); }
        const_iterator cend() const { return cbegin(); }



        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        reverse_iterator rbegin() { return reverse_iterator(end()); }
        const_reverse_iterator rbegin() const {
            return const_reverse_iterator(end());
        }
        const_reverse_iterator crbegin() const {
            return const_reverse_iterator(end());
        }

        reverse_iterator rend() { return reverse_iterator(begin()); }
        const_reverse_iterator rend() const {
            return const_reverse_iterator(begin());
        }
        const_reverse_iterator crend() const {
            return const_reverse_iterator(begin());
        }


        reference operator[](size_type )
        {
            return failed_rangecheck();
        }

                            const_reference operator[](size_type ) const
        {
            return failed_rangecheck();
        }


        reference at(size_type ) { return failed_rangecheck(); }
                            const_reference at(size_type ) const { return failed_rangecheck(); }


        reference front()
        {
            return failed_rangecheck();
        }

        constexpr const_reference front() const
        {
            return failed_rangecheck();
        }

        reference back()
        {
            return failed_rangecheck();
        }

        constexpr const_reference back() const
        {
            return failed_rangecheck();
        }


        static constexpr size_type size() { return 0; }
        static constexpr bool empty() { return true; }
        static constexpr size_type max_size() { return 0; }
        enum { static_size = 0 };

        void swap (array<T,0>& ) {
        }


        const T* data() const { return 0; }
        T* data() { return 0; }


        T* c_array() { return 0; }


        template <typename T2>
        array<T,0>& operator= (const array<T2,0>& ) {
            return *this;
        }


        void assign (const T& value) { fill ( value ); }
        void fill (const T& ) {}


        static reference failed_rangecheck () {
                std::out_of_range e("attempt to access element of an empty array");
                boost::throw_exception(e);






                static T placeholder;
                return placeholder;

            }
    };


    template<class T, std::size_t N>
    bool operator== (const array<T,N>& x, const array<T,N>& y) {
        return std::equal(x.begin(), x.end(), y.begin());
    }
    template<class T, std::size_t N>
    bool operator< (const array<T,N>& x, const array<T,N>& y) {
        return std::lexicographical_compare(x.begin(),x.end(),y.begin(),y.end());
    }
    template<class T, std::size_t N>
    bool operator!= (const array<T,N>& x, const array<T,N>& y) {
        return !(x==y);
    }
    template<class T, std::size_t N>
    bool operator> (const array<T,N>& x, const array<T,N>& y) {
        return y<x;
    }
    template<class T, std::size_t N>
    bool operator<= (const array<T,N>& x, const array<T,N>& y) {
        return !(y<x);
    }
    template<class T, std::size_t N>
    bool operator>= (const array<T,N>& x, const array<T,N>& y) {
        return !(x<y);
    }


    template<class T, std::size_t N>
    inline void swap (array<T,N>& x, array<T,N>& y) {
        x.swap(y);
    }
    template <typename T, std::size_t N>
    T(&get_c_array(boost::array<T,N>& arg))[N]
    {
        return arg.elems;
    }


    template <typename T, std::size_t N>
    const T(&get_c_array(const boost::array<T,N>& arg))[N]
    {
        return arg.elems;
    }
    template <class It> std::size_t hash_range(It, It);

    template<class T, std::size_t N>
    std::size_t hash_value(const array<T,N>& arr)
    {
        return boost::hash_range(arr.begin(), arr.end());
    }

   template <size_t Idx, typename T, size_t N>
   T &get(boost::array<T,N> &arr) noexcept {
       static_assert(Idx < N, "boost::get<>(boost::array &) index out of range");
       return arr[Idx];
       }

   template <size_t Idx, typename T, size_t N>
   const T &get(const boost::array<T,N> &arr) noexcept {
       static_assert(Idx < N, "boost::get<>(const boost::array &) index out of range");
       return arr[Idx];
       }

}



namespace std {
   template <size_t Idx, typename T, size_t N>
   T &get(boost::array<T,N> &arr) noexcept {
       static_assert(Idx < N, "std::get<>(boost::array &) index out of range");
       return arr[Idx];
       }

   template <size_t Idx, typename T, size_t N>
   const T &get(const boost::array<T,N> &arr) noexcept {
       static_assert(Idx < N, "std::get<>(const boost::array &) index out of range");
       return arr[Idx];
       }
}

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wc++11-extensions"
namespace std {inline namespace __1 {

template<class T>
class allocator;

template<class T>
struct less;

template<class T>
struct equal_to;

template<class T1, class T2>
struct pair;

template<class T>
struct char_traits;

struct input_iterator_tag;
struct forward_iterator_tag;
struct bidirectional_iterator_tag;
struct random_access_iterator_tag;

template<class Container>
class insert_iterator;

struct allocator_arg_t;

struct piecewise_construct_t;

} }

#pragma GCC diagnostic pop


namespace boost{
namespace intrusive{
namespace detail{

}}}

namespace boost{ namespace container{ namespace dtl{
   namespace bi = boost::intrusive;
   namespace bid = boost::intrusive::detail;
}}}

namespace boost{ namespace container{ namespace pmr{
   namespace bi = boost::intrusive;
   namespace bid = boost::intrusive::detail;
}}}
namespace boost {
namespace container {



template<class T>
class new_allocator;

template <class T
         ,class Allocator = new_allocator<T>
         ,class Options = void>
class vector;

template <class T
         ,class Allocator = new_allocator<T> >
class stable_vector;

template <class T, std::size_t Capacity>
class static_vector;

template < class T, std::size_t N
         , class Allocator= new_allocator<T> >
class small_vector;

template <class T
         ,class Allocator = new_allocator<T> >
class deque;

template <class T
         ,class Allocator = new_allocator<T> >
class list;

template <class T
         ,class Allocator = new_allocator<T> >
class slist;

template <class Key
         ,class Compare = std::less<Key>
         ,class Allocator = new_allocator<Key>
         ,class Options = void>
class set;

template <class Key
         ,class Compare = std::less<Key>
         ,class Allocator = new_allocator<Key>
         ,class Options = void >
class multiset;

template <class Key
         ,class T
         ,class Compare = std::less<Key>
         ,class Allocator = new_allocator<std::pair<const Key, T> >
         ,class Options = void >
class map;

template <class Key
         ,class T
         ,class Compare = std::less<Key>
         ,class Allocator = new_allocator<std::pair<const Key, T> >
         ,class Options = void >
class multimap;

template <class Key
         ,class Compare = std::less<Key>
         ,class Allocator = new_allocator<Key> >
class flat_set;

template <class Key
         ,class Compare = std::less<Key>
         ,class Allocator = new_allocator<Key> >
class flat_multiset;

template <class Key
         ,class T
         ,class Compare = std::less<Key>
         ,class Allocator = new_allocator<std::pair<Key, T> > >
class flat_map;

template <class Key
         ,class T
         ,class Compare = std::less<Key>
         ,class Allocator = new_allocator<std::pair<Key, T> > >
class flat_multimap;

template <class CharT
         ,class Traits = std::char_traits<CharT>
         ,class Allocator = new_allocator<CharT> >
class basic_string;

typedef basic_string
   <char
   ,std::char_traits<char>
   ,new_allocator<char> >
string;

typedef basic_string
   <wchar_t
   ,std::char_traits<wchar_t>
   ,new_allocator<wchar_t> >
wstring;

static const std::size_t ADP_nodes_per_block = 256u;
static const std::size_t ADP_max_free_blocks = 2u;
static const std::size_t ADP_overhead_percent = 1u;
static const std::size_t ADP_only_alignment = 0u;

template < class T
         , std::size_t NodesPerBlock = ADP_nodes_per_block
         , std::size_t MaxFreeBlocks = ADP_max_free_blocks
         , std::size_t OverheadPercent = ADP_overhead_percent
         , unsigned Version = 2
         >
class adaptive_pool;

template < class T
         , unsigned Version = 2
         , unsigned int AllocationDisableMask = 0>
class allocator;

static const std::size_t NodeAlloc_nodes_per_block = 256u;

template
   < class T
   , std::size_t NodesPerBlock = NodeAlloc_nodes_per_block
   , std::size_t Version = 2>
class node_allocator;

namespace pmr {

class memory_resource;

template<class T>
class polymorphic_allocator;

class monotonic_buffer_resource;

struct pool_options;

template <class Allocator>
class resource_adaptor_imp;

class unsynchronized_pool_resource;

class synchronized_pool_resource;

}





struct ordered_range_t
{};



static const ordered_range_t ordered_range = ordered_range_t();



struct ordered_unique_range_t
   : public ordered_range_t
{};



static const ordered_unique_range_t ordered_unique_range = ordered_unique_range_t();



struct default_init_t
{};



static const default_init_t default_init = default_init_t();




struct value_init_t
{};



static const value_init_t value_init = value_init_t();

namespace container_detail_really_deep_namespace {



struct dummy
{
   dummy()
   {
      (void)ordered_range;
      (void)ordered_unique_range;
      (void)default_init;
   }
};

}




}}

namespace boost
{
    namespace detail
    {
        template < typename Char >
        struct lcast_char_constants {


            static const Char zero = static_cast<Char>('0');
            static const Char minus = static_cast<Char>('-');
            static const Char plus = static_cast<Char>('+');
            static const Char lowercase_e = static_cast<Char>('e');
            static const Char capital_e = static_cast<Char>('E');
            static const Char c_decimal_separator = static_cast<Char>('.');
        };
    }
}

namespace boost
{
    namespace detail
    {
        template<class T>
        inline
        typename boost::make_unsigned<T>::type lcast_to_unsigned(const T value) noexcept {
            typedef typename boost::make_unsigned<T>::type result_type;
            return value < 0
                ? static_cast<result_type>(0u - static_cast<result_type>(value))
                : static_cast<result_type>(value);
        }
    }

    namespace detail
    {
        template <class Traits, class T, class CharT>
        class lcast_put_unsigned: boost::noncopyable {
            typedef typename Traits::int_type int_type;
            typename boost::conditional<
                    (sizeof(unsigned) > sizeof(T))
                    , unsigned
                    , T
            >::type m_value;
            CharT* m_finish;
            CharT const m_czero;
            int_type const m_zero;

        public:
            lcast_put_unsigned(const T n_param, CharT* finish) noexcept
                : m_value(n_param), m_finish(finish)
                , m_czero(lcast_char_constants<CharT>::zero), m_zero(Traits::to_int_type(m_czero))
            {

                static_assert(!std::numeric_limits<T>::is_signed, "!std::numeric_limits<T>::is_signed");

            }

            CharT* convert() {

                std::locale loc;
                if (loc == std::locale::classic()) {
                    return main_convert_loop();
                }

                typedef std::numpunct<CharT> numpunct;
                numpunct const& np = std::use_facet< numpunct >(loc);
                std::string const grouping = np.grouping();
                std::string::size_type const grouping_size = grouping.size();

                if (!grouping_size || grouping[0] <= 0) {
                    return main_convert_loop();
                }



                static_assert(std::numeric_limits<T>::digits10 < 127, "std::numeric_limits<T>::digits10 < CHAR_MAX");

                CharT const thousands_sep = np.thousands_sep();
                std::string::size_type group = 0;
                char last_grp_size = grouping[0];
                char left = last_grp_size;

                do {
                    if (left == 0) {
                        ++group;
                        if (group < grouping_size) {
                            char const grp_size = grouping[group];
                            last_grp_size = (grp_size <= 0 ? static_cast<char>(127) : grp_size);
                        }

                        left = last_grp_size;
                        --m_finish;
                        Traits::assign(*m_finish, thousands_sep);
                    }

                    --left;
                } while (main_convert_iteration());

                return m_finish;



            }

        private:
            inline bool main_convert_iteration() noexcept {
                --m_finish;
                int_type const digit = static_cast<int_type>(m_value % 10U);
                Traits::assign(*m_finish, Traits::to_char_type(m_zero + digit));
                m_value /= 10;
                return !!m_value;
            }

            inline CharT* main_convert_loop() noexcept {
                while (main_convert_iteration());
                return m_finish;
            }
        };
    }

    namespace detail
    {
        template <class Traits, class T, class CharT>
        class lcast_ret_unsigned: boost::noncopyable {
            bool m_multiplier_overflowed;
            T m_multiplier;
            T& m_value;
            const CharT* const m_begin;
            const CharT* m_end;

        public:
            lcast_ret_unsigned(T& value, const CharT* const begin, const CharT* end) noexcept
                : m_multiplier_overflowed(false), m_multiplier(1), m_value(value), m_begin(begin), m_end(end)
            {

                static_assert(!std::numeric_limits<T>::is_signed, "!std::numeric_limits<T>::is_signed");






                static_assert(std::numeric_limits<T>::is_specialized, "std::numeric_limits are not specialized for integral type passed to boost::lexical_cast");



            }

            inline bool convert() {
                CharT const czero = lcast_char_constants<CharT>::zero;
                --m_end;
                m_value = static_cast<T>(0);

                if (m_begin > m_end || *m_end < czero || *m_end >= czero + 10)
                    return false;
                m_value = static_cast<T>(*m_end - czero);
                --m_end;




                std::locale loc;
                if (loc == std::locale::classic()) {
                    return main_convert_loop();
                }

                typedef std::numpunct<CharT> numpunct;
                numpunct const& np = std::use_facet< numpunct >(loc);
                std::string const& grouping = np.grouping();
                std::string::size_type const grouping_size = grouping.size();




                if (!grouping_size || grouping[0] <= 0) {
                    return main_convert_loop();
                }

                unsigned char current_grouping = 0;
                CharT const thousands_sep = np.thousands_sep();
                char remained = static_cast<char>(grouping[current_grouping] - 1);

                for (;m_end >= m_begin; --m_end)
                {
                    if (remained) {
                        if (!main_convert_iteration()) {
                            return false;
                        }
                        --remained;
                    } else {
                        if ( !Traits::eq(*m_end, thousands_sep) )
                        {
                            return main_convert_loop();
                        } else {
                            if (m_begin == m_end) return false;
                            if (current_grouping < grouping_size - 1) ++current_grouping;
                            remained = grouping[current_grouping];
                        }
                    }
                }

                return true;

            }

        private:


            inline bool main_convert_iteration() noexcept {
                CharT const czero = lcast_char_constants<CharT>::zero;
                T const maxv = (std::numeric_limits<T>::max)();

                m_multiplier_overflowed = m_multiplier_overflowed || (maxv/10 < m_multiplier);
                m_multiplier = static_cast<T>(m_multiplier * 10);

                T const dig_value = static_cast<T>(*m_end - czero);
                T const new_sub_value = static_cast<T>(m_multiplier * dig_value);



                if (*m_end < czero || *m_end >= czero + 10
                    || (dig_value && (
                        m_multiplier_overflowed
                        || static_cast<T>(maxv / dig_value) < m_multiplier
                        || static_cast<T>(maxv - new_sub_value) < m_value
                    ))
                ) return false;

                m_value = static_cast<T>(m_value + new_sub_value);

                return true;
            }

            bool main_convert_loop() noexcept {
                for ( ; m_end >= m_begin; --m_end) {
                    if (!main_convert_iteration()) {
                        return false;
                    }
                }

                return true;
            }
        };
    }
}
































































namespace boost{ namespace math{
namespace tools
{

template <class T>
inline T max (T a, T b, T c) noexcept(std::is_floating_point<T>::value)
{
   return (std::max)((std::max)(a, b), c);
}

template <class T>
inline T max (T a, T b, T c, T d) noexcept(std::is_floating_point<T>::value)
{
   return (std::max)((std::max)(a, b), (std::max)(c, d));
}

}

template <class T>
void suppress_unused_variable_warning(const T&) noexcept(std::is_floating_point<T>::value)
{
}

namespace detail{

template <class T>
struct is_integer_for_rounding
{
   static const bool value = boost::is_integral<T>::value

      || (std::numeric_limits<T>::is_specialized && std::numeric_limits<T>::is_integer)

      ;
};

}

}}
namespace boost
{
  namespace math
  {
    namespace tools
    {
      template <class T>
      struct promote_arg
      {
        typedef typename mpl::if_<is_integral<T>, double, T>::type type;
      };


      template <> struct promote_arg<float> { typedef float type; };
      template <> struct promote_arg<double>{ typedef double type; };
      template <> struct promote_arg<long double> { typedef long double type; };
      template <> struct promote_arg<int> { typedef double type; };

      template <class T1, class T2>
      struct promote_args_2
      {

        typedef typename promote_arg<T1>::type T1P;
        typedef typename promote_arg<T2>::type T2P;

        typedef typename mpl::if_<
          typename mpl::and_<is_floating_point<T1P>, is_floating_point<T2P> >::type,




             typename mpl::if_< typename mpl::or_<is_same<long double, T1P>, is_same<long double, T2P> >::type,
               long double,
               typename mpl::if_< typename mpl::or_<is_same<double, T1P>, is_same<double, T2P> >::type,
                  double,
                  float
             >::type



             >::type,

          typename mpl::if_< typename mpl::and_<mpl::not_<is_floating_point<T2P> >, ::boost::is_convertible<T1P, T2P> >, T2P, T1P>::type>::type type;
      };


      template <> struct promote_args_2<float, float> { typedef float type; };
      template <> struct promote_args_2<double, double>{ typedef double type; };
      template <> struct promote_args_2<long double, long double> { typedef long double type; };
      template <> struct promote_args_2<int, int> { typedef double type; };
      template <> struct promote_args_2<int, float> { typedef double type; };
      template <> struct promote_args_2<float, int> { typedef double type; };
      template <> struct promote_args_2<int, double> { typedef double type; };
      template <> struct promote_args_2<double, int> { typedef double type; };
      template <> struct promote_args_2<int, long double> { typedef long double type; };
      template <> struct promote_args_2<long double, int> { typedef long double type; };
      template <> struct promote_args_2<float, double> { typedef double type; };
      template <> struct promote_args_2<double, float> { typedef double type; };
      template <> struct promote_args_2<float, long double> { typedef long double type; };
      template <> struct promote_args_2<long double, float> { typedef long double type; };
      template <> struct promote_args_2<double, long double> { typedef long double type; };
      template <> struct promote_args_2<long double, double> { typedef long double type; };

      template <class T1, class T2=float, class T3=float, class T4=float, class T5=float, class T6=float>
      struct promote_args
      {
         typedef typename promote_args_2<
            typename remove_cv<T1>::type,
            typename promote_args_2<
               typename remove_cv<T2>::type,
               typename promote_args_2<
                  typename remove_cv<T3>::type,
                  typename promote_args_2<
                     typename remove_cv<T4>::type,
                     typename promote_args_2<
                        typename remove_cv<T5>::type, typename remove_cv<T6>::type
                     >::type
                  >::type
               >::type
            >::type
         >::type type;







      };






      template <class T1, class T2=float, class T3=float, class T4=float, class T5=float, class T6=float>
      struct promote_args_permissive
      {
         typedef typename promote_args_2<
            typename remove_cv<T1>::type,
            typename promote_args_2<
               typename remove_cv<T2>::type,
               typename promote_args_2<
                  typename remove_cv<T3>::type,
                  typename promote_args_2<
                     typename remove_cv<T4>::type,
                     typename promote_args_2<
                        typename remove_cv<T5>::type, typename remove_cv<T6>::type
                     >::type
                  >::type
               >::type
            >::type
         >::type type;
      };

    }
  }
}





namespace boost
{
   namespace math
   {

   template <class T, class Policy>
   typename tools::promote_args<T>::type trunc(const T& v, const Policy& pol);
   template <class T>
   typename tools::promote_args<T>::type trunc(const T& v);
   template <class T, class Policy>
   int itrunc(const T& v, const Policy& pol);
   template <class T>
   int itrunc(const T& v);
   template <class T, class Policy>
   long ltrunc(const T& v, const Policy& pol);
   template <class T>
   long ltrunc(const T& v);

   template <class T, class Policy>
   boost::long_long_type lltrunc(const T& v, const Policy& pol);
   template <class T>
   boost::long_long_type lltrunc(const T& v);

   template <class T, class Policy>
   typename tools::promote_args<T>::type round(const T& v, const Policy& pol);
   template <class T>
   typename tools::promote_args<T>::type round(const T& v);
   template <class T, class Policy>
   int iround(const T& v, const Policy& pol);
   template <class T>
   int iround(const T& v);
   template <class T, class Policy>
   long lround(const T& v, const Policy& pol);
   template <class T>
   long lround(const T& v);

   template <class T, class Policy>
   boost::long_long_type llround(const T& v, const Policy& pol);
   template <class T>
   boost::long_long_type llround(const T& v);

   template <class T, class Policy>
   T modf(const T& v, T* ipart, const Policy& pol);
   template <class T>
   T modf(const T& v, T* ipart);
   template <class T, class Policy>
   T modf(const T& v, int* ipart, const Policy& pol);
   template <class T>
   T modf(const T& v, int* ipart);
   template <class T, class Policy>
   T modf(const T& v, long* ipart, const Policy& pol);
   template <class T>
   T modf(const T& v, long* ipart);

   template <class T, class Policy>
   T modf(const T& v, boost::long_long_type* ipart, const Policy& pol);
   template <class T>
   T modf(const T& v, boost::long_long_type* ipart);


   }
}












namespace mpl_ {

template< long N > struct long_;

}
namespace boost { namespace mpl { using ::mpl_::long_; } }


namespace mpl_ {

template< long N >
struct long_
{
    static const long value = N;





    typedef long_ type;

    typedef long value_type;
    typedef integral_c_tag tag;
    typedef mpl_::long_< static_cast<long>((value + 1)) > next;
    typedef mpl_::long_< static_cast<long>((value - 1)) > prior;






    constexpr operator long() const { return static_cast<long>(this->value); }
};


template< long N >
long const mpl_::long_< N >::value;


}

namespace boost { namespace mpl {

template< typename Tag > struct push_front_impl;
template< typename Sequence, typename T > struct push_front;

}}

namespace boost { namespace mpl { namespace aux {

struct list_tag;
struct l_iter_tag;

}}}



namespace boost { namespace mpl {

template<
      typename Size
    , typename T
    , typename Next
    >
struct l_item
{




    typedef aux::list_tag tag;
    typedef l_item type;

    typedef Size size;
    typedef T item;
    typedef Next next;
};

struct l_end
{



    typedef aux::list_tag tag;
    typedef l_end type;
    typedef long_<0> size;
};

}}


namespace boost { namespace mpl {

template<>
struct push_front_impl< aux::list_tag >
{
    template< typename List, typename T > struct apply
    {
        typedef l_item<
              typename next<typename List::size>::type
            , T
            , typename List::type
            > type;
    };
};

}}
namespace boost { namespace mpl {

template< typename Tag > struct pop_front_impl;
template< typename Sequence > struct pop_front;

}}



namespace boost { namespace mpl {

template<>
struct pop_front_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef typename mpl::next<List>::type type;
    };
};

}}
namespace boost { namespace mpl {

template< typename Tag > struct push_back_impl;
template< typename Sequence, typename T > struct push_back;

}}



namespace boost { namespace mpl {

template< typename Tag > struct has_push_back_impl;

template<>
struct has_push_back_impl< aux::list_tag >
{
    template< typename Seq > struct apply
        : false_
    {
    };
};

}}
namespace boost { namespace mpl {

template< typename Tag > struct front_impl;
template< typename Sequence > struct front;

}}


namespace boost { namespace mpl {

template<>
struct front_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef typename List::item type;
    };
};

}}
namespace boost { namespace mpl {

template< typename Tag > struct clear_impl;
template< typename Sequence > struct clear;

}}



namespace boost { namespace mpl {

template<>
struct clear_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef l_end type;
    };
};

}}
namespace boost { namespace mpl {

template< typename Tag > struct O1_size_impl;
template< typename Sequence > struct O1_size;

}}


namespace boost { namespace mpl {

template<>
struct O1_size_impl< aux::list_tag >
{
    template< typename List > struct apply
        : List::size
    {
    };
};

}}
namespace boost { namespace mpl {

template< typename Tag > struct size_impl;
template< typename Sequence > struct size;

}}


namespace boost { namespace mpl {

template<>
struct size_impl< aux::list_tag >
{
    template< typename List > struct apply
        : List::size
    {
    };
};

}}
namespace boost { namespace mpl {

template< typename Tag > struct empty_impl;
template< typename Sequence > struct empty;

}}



namespace boost { namespace mpl {

template<>
struct empty_impl< aux::list_tag >
{
    template< typename List > struct apply
        : not_<typename List::size>
    {
    };
};

}}
namespace boost { namespace mpl {

struct forward_iterator_tag : int_<0> { typedef forward_iterator_tag type; };
struct bidirectional_iterator_tag : int_<1> { typedef bidirectional_iterator_tag type; };
struct random_access_iterator_tag : int_<2> { typedef random_access_iterator_tag type; };

}}






namespace boost { namespace mpl {



template< typename Node >
struct l_iter
{
    typedef aux::l_iter_tag tag;
    typedef forward_iterator_tag category;
};

template< typename Node >
struct deref< l_iter<Node> >
{
    typedef typename Node::item type;
};

template< typename Node >
struct next< l_iter<Node> >
{
    typedef l_iter< typename Node::next > type;
};
template<> struct l_iter<l_end>
{
    typedef aux::l_iter_tag tag;
    typedef forward_iterator_tag category;




};

template< typename T1 , typename Tag > struct lambda< l_iter< T1 > , Tag , int_<1> > { typedef false_ is_le; typedef l_iter< T1 > result_; typedef result_ type; };

}}



namespace boost { namespace mpl {

template<>
struct begin_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef l_iter<typename List::type> type;
    };
};

template<>
struct end_impl< aux::list_tag >
{
    template< typename > struct apply
    {
        typedef l_iter<l_end> type;
    };
};

}}


namespace boost { namespace mpl {

template< typename Dummy = na > struct list0;

template<> struct list0<na>
    : l_end
{
    typedef l_end type;
};

}}








namespace boost { namespace mpl {

template<
      typename T0
    >
struct list1
    : l_item<
          long_<1>
        , T0
        , l_end
        >
{
    typedef list1 type;
};

template<
      typename T0, typename T1
    >
struct list2
    : l_item<
          long_<2>
        , T0
        , list1<T1>
        >
{
    typedef list2 type;
};

template<
      typename T0, typename T1, typename T2
    >
struct list3
    : l_item<
          long_<3>
        , T0
        , list2< T1,T2 >
        >
{
    typedef list3 type;
};

template<
      typename T0, typename T1, typename T2, typename T3
    >
struct list4
    : l_item<
          long_<4>
        , T0
        , list3< T1,T2,T3 >
        >
{
    typedef list4 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    >
struct list5
    : l_item<
          long_<5>
        , T0
        , list4< T1,T2,T3,T4 >
        >
{
    typedef list5 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct list6
    : l_item<
          long_<6>
        , T0
        , list5< T1,T2,T3,T4,T5 >
        >
{
    typedef list6 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6
    >
struct list7
    : l_item<
          long_<7>
        , T0
        , list6< T1,T2,T3,T4,T5,T6 >
        >
{
    typedef list7 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7
    >
struct list8
    : l_item<
          long_<8>
        , T0
        , list7< T1,T2,T3,T4,T5,T6,T7 >
        >
{
    typedef list8 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8
    >
struct list9
    : l_item<
          long_<9>
        , T0
        , list8< T1,T2,T3,T4,T5,T6,T7,T8 >
        >
{
    typedef list9 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    >
struct list10
    : l_item<
          long_<10>
        , T0
        , list9< T1,T2,T3,T4,T5,T6,T7,T8,T9 >
        >
{
    typedef list10 type;
};

}}








namespace boost { namespace mpl {

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10
    >
struct list11
    : l_item<
          long_<11>
        , T0
        , list10< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >
        >
{
    typedef list11 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11
    >
struct list12
    : l_item<
          long_<12>
        , T0
        , list11< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >
        >
{
    typedef list12 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12
    >
struct list13
    : l_item<
          long_<13>
        , T0
        , list12< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >
        >
{
    typedef list13 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13
    >
struct list14
    : l_item<
          long_<14>
        , T0
        , list13< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >
        >
{
    typedef list14 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    >
struct list15
    : l_item<
          long_<15>
        , T0
        , list14< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14 >
        >
{
    typedef list15 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15
    >
struct list16
    : l_item<
          long_<16>
        , T0
        , list15< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15 >
        >
{
    typedef list16 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16
    >
struct list17
    : l_item<
          long_<17>
        , T0
        , list16< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16 >
        >
{
    typedef list17 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17
    >
struct list18
    : l_item<
          long_<18>
        , T0
        , list17< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17 >
        >
{
    typedef list18 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18
    >
struct list19
    : l_item<
          long_<19>
        , T0
        , list18< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18 >
        >
{
    typedef list19 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    >
struct list20
    : l_item<
          long_<20>
        , T0
        , list19< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19 >
        >
{
    typedef list20 type;
};

}}
namespace boost { namespace mpl {

template<
      typename T0 = na, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na, typename T6 = na, typename T7 = na
    , typename T8 = na, typename T9 = na, typename T10 = na, typename T11 = na
    , typename T12 = na, typename T13 = na, typename T14 = na
    , typename T15 = na, typename T16 = na, typename T17 = na
    , typename T18 = na, typename T19 = na
    >
struct list;

template<

    >
struct list<
          na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list0< >
{
    typedef list0< >::type type;
};

template<
      typename T0
    >
struct list<
          T0, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list1<T0>
{
    typedef typename list1<T0>::type type;
};

template<
      typename T0, typename T1
    >
struct list<
          T0, T1, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list2< T0,T1 >
{
    typedef typename list2< T0,T1 >::type type;
};

template<
      typename T0, typename T1, typename T2
    >
struct list<
          T0, T1, T2, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list3< T0,T1,T2 >
{
    typedef typename list3< T0,T1,T2 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3
    >
struct list<
          T0, T1, T2, T3, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list4< T0,T1,T2,T3 >
{
    typedef typename list4< T0,T1,T2,T3 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    >
struct list<
          T0, T1, T2, T3, T4, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list5< T0,T1,T2,T3,T4 >
{
    typedef typename list5< T0,T1,T2,T3,T4 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct list<
          T0, T1, T2, T3, T4, T5, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list6< T0,T1,T2,T3,T4,T5 >
{
    typedef typename list6< T0,T1,T2,T3,T4,T5 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list7< T0,T1,T2,T3,T4,T5,T6 >
{
    typedef typename list7< T0,T1,T2,T3,T4,T5,T6 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list8< T0,T1,T2,T3,T4,T5,T6,T7 >
{
    typedef typename list8< T0,T1,T2,T3,T4,T5,T6,T7 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >
{
    typedef typename list9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, na, na, na, na, na, na, na
        , na, na, na
        >
    : list10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >
{
    typedef typename list10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, na, na, na, na, na, na
        , na, na, na
        >
    : list11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >
{
    typedef typename list11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, na, na, na, na
        , na, na, na, na
        >
    : list12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >
{
    typedef typename list12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, na, na, na
        , na, na, na, na
        >
    : list13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >
{
    typedef typename list13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, na, na
        , na, na, na, na
        >
    : list14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >
{
    typedef typename list14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, na
        , na, na, na, na
        >
    : list15<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        >
{
    typedef typename list15< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, na, na, na, na
        >
    : list16<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15
        >
{
    typedef typename list16< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, na, na, na
        >
    : list17<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16
        >
{
    typedef typename list17< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, na, na
        >
    : list18<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17
        >
{
    typedef typename list18< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18, na
        >
    : list19<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18
        >
{
    typedef typename list19< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18 >::type type;
};



template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    >
struct list
    : list20<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18, T19
        >
{
    typedef typename list20< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19 >::type type;
};

}}
namespace boost { namespace mpl {

template< typename Tag > struct contains_impl;
template< typename Sequence, typename T > struct contains;

}}

namespace boost { namespace mpl {

template< typename T1 >
struct same_as
{
    template< typename T2 > struct apply

        : is_same<T1,T2>
    {




    };
};

template< typename T1 >
struct not_same_as
{
    template< typename T2 > struct apply

        : not_< is_same<T1,T2> >
    {




    };
};

}}



namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename T = na
    >
struct find
    : find_if< Sequence,same_as<T> >
{

};

template<> struct find< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : find< T1 , T2 > { }; }; template< typename Tag > struct lambda< find< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef find< na , na > result_; typedef find< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< find< T1 , T2 > > : int_<2> { }; template<> struct template_arity< find< na , na > > : int_<-1> { }; }

}}







namespace boost { namespace mpl {

template< typename Tag >
struct contains_impl
{
    template< typename Sequence, typename T > struct apply

        : not_< is_same<
              typename find<Sequence,T>::type
            , typename end<Sequence>::type
            > >
    {
    };
};

 template<> struct contains_impl<non_sequence_tag> {};

}}



namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename T = na
    >
struct contains
    : contains_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,T >
{

};

template<> struct contains< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : contains< T1 , T2 > { }; }; template< typename Tag > struct lambda< contains< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef contains< na , na > result_; typedef contains< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< contains< T1 , T2 > > : int_<2> { }; template<> struct template_arity< contains< na , na > > : int_<-1> { }; }

}}


namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_size { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::size>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}





namespace boost { namespace mpl {
namespace aux {
template< typename Sequence > struct O1_size_impl
    : Sequence::size
{
};
}

template< typename Tag >
struct O1_size_impl
{
    template< typename Sequence > struct apply

        : if_<
              aux::has_size<Sequence>
            , aux::O1_size_impl<Sequence>
            , long_<-1>
            >::type
    {
    };
};
}}



namespace boost { namespace mpl {


template<
      typename Sequence = na
    >
struct O1_size
    : O1_size_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{

};

template<> struct O1_size< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : O1_size< T1 > { }; }; template< typename Tag > struct lambda< O1_size< na > , Tag , int_<-1> > { typedef false_ is_le; typedef O1_size< na > result_; typedef O1_size< na > type; }; namespace aux { template< typename T1 > struct template_arity< O1_size< T1 > > : int_<1> { }; template<> struct template_arity< O1_size< na > > : int_<-1> { }; }

}}
namespace boost { namespace mpl { namespace aux {



template<
      int N
    , typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl;

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< 0,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef state0 state;
    typedef iter0 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< 1,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp, state0, typename deref<iter0>::type >::type state1;
    typedef typename mpl::next<iter0>::type iter1;


    typedef state1 state;
    typedef iter1 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< 2,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp, state0, typename deref<iter0>::type >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, state1, typename deref<iter1>::type >::type state2;
    typedef typename mpl::next<iter1>::type iter2;


    typedef state2 state;
    typedef iter2 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< 3,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp, state0, typename deref<iter0>::type >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, state1, typename deref<iter1>::type >::type state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp, state2, typename deref<iter2>::type >::type state3;
    typedef typename mpl::next<iter2>::type iter3;


    typedef state3 state;
    typedef iter3 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< 4,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp, state0, typename deref<iter0>::type >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, state1, typename deref<iter1>::type >::type state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp, state2, typename deref<iter2>::type >::type state3;
    typedef typename mpl::next<iter2>::type iter3;
    typedef typename apply2< ForwardOp, state3, typename deref<iter3>::type >::type state4;
    typedef typename mpl::next<iter3>::type iter4;


    typedef state4 state;
    typedef iter4 iterator;
};

template<
      int N
    , typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl
{
    typedef fold_impl<
          4
        , First
        , Last
        , State
        , ForwardOp
        > chunk_;

    typedef fold_impl<
          ( (N - 4) < 0 ? 0 : N - 4 )
        , typename chunk_::iterator
        , Last
        , typename chunk_::state
        , ForwardOp
        > res_;

    typedef typename res_::state state;
    typedef typename res_::iterator iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< -1,First,Last,State,ForwardOp >
    : fold_impl<
          -1
        , typename mpl::next<First>::type
        , Last
        , typename apply2<ForwardOp,State, typename deref<First>::type>::type
        , ForwardOp
        >
{
};

template<
      typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< -1,Last,Last,State,ForwardOp >
{
    typedef State state;
    typedef Last iterator;
};

}}}



namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename State = na
    , typename ForwardOp = na
    >
struct fold
{
    typedef typename aux::fold_impl<
          ::boost::mpl::O1_size<Sequence>::value
        , typename begin<Sequence>::type
        , typename end<Sequence>::type
        , State
        , ForwardOp
        >::state type;


};

template<> struct fold< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : fold< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< fold< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef fold< na , na , na > result_; typedef fold< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< fold< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< fold< na , na , na > > : int_<-1> { }; }

}}
namespace boost { namespace mpl { namespace aux {



template<
      long N
    , typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl;

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< 0,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef fwd_state0 bkwd_state0;
    typedef bkwd_state0 state;
    typedef iter0 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< 1,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp, fwd_state0, typename deref<iter0>::type >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;


    typedef fwd_state1 bkwd_state1;
    typedef typename apply2< BackwardOp, bkwd_state1, typename deref<iter0>::type >::type bkwd_state0;
    typedef bkwd_state0 state;
    typedef iter1 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< 2,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp, fwd_state0, typename deref<iter0>::type >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, fwd_state1, typename deref<iter1>::type >::type fwd_state2;
    typedef typename mpl::next<iter1>::type iter2;


    typedef fwd_state2 bkwd_state2;
    typedef typename apply2< BackwardOp, bkwd_state2, typename deref<iter1>::type >::type bkwd_state1;
    typedef typename apply2< BackwardOp, bkwd_state1, typename deref<iter0>::type >::type bkwd_state0;


    typedef bkwd_state0 state;
    typedef iter2 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< 3,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp, fwd_state0, typename deref<iter0>::type >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, fwd_state1, typename deref<iter1>::type >::type fwd_state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp, fwd_state2, typename deref<iter2>::type >::type fwd_state3;
    typedef typename mpl::next<iter2>::type iter3;


    typedef fwd_state3 bkwd_state3;
    typedef typename apply2< BackwardOp, bkwd_state3, typename deref<iter2>::type >::type bkwd_state2;
    typedef typename apply2< BackwardOp, bkwd_state2, typename deref<iter1>::type >::type bkwd_state1;
    typedef typename apply2< BackwardOp, bkwd_state1, typename deref<iter0>::type >::type bkwd_state0;


    typedef bkwd_state0 state;
    typedef iter3 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< 4,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp, fwd_state0, typename deref<iter0>::type >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, fwd_state1, typename deref<iter1>::type >::type fwd_state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp, fwd_state2, typename deref<iter2>::type >::type fwd_state3;
    typedef typename mpl::next<iter2>::type iter3;
    typedef typename apply2< ForwardOp, fwd_state3, typename deref<iter3>::type >::type fwd_state4;
    typedef typename mpl::next<iter3>::type iter4;


    typedef fwd_state4 bkwd_state4;
    typedef typename apply2< BackwardOp, bkwd_state4, typename deref<iter3>::type >::type bkwd_state3;
    typedef typename apply2< BackwardOp, bkwd_state3, typename deref<iter2>::type >::type bkwd_state2;
    typedef typename apply2< BackwardOp, bkwd_state2, typename deref<iter1>::type >::type bkwd_state1;
    typedef typename apply2< BackwardOp, bkwd_state1, typename deref<iter0>::type >::type bkwd_state0;


    typedef bkwd_state0 state;
    typedef iter4 iterator;
};

template<
      long N
    , typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp, fwd_state0, typename deref<iter0>::type >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, fwd_state1, typename deref<iter1>::type >::type fwd_state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp, fwd_state2, typename deref<iter2>::type >::type fwd_state3;
    typedef typename mpl::next<iter2>::type iter3;
    typedef typename apply2< ForwardOp, fwd_state3, typename deref<iter3>::type >::type fwd_state4;
    typedef typename mpl::next<iter3>::type iter4;


    typedef reverse_fold_impl<
          ( (N - 4) < 0 ? 0 : N - 4 )
        , iter4
        , Last
        , fwd_state4
        , BackwardOp
        , ForwardOp
        > nested_chunk;

    typedef typename nested_chunk::state bkwd_state4;
    typedef typename apply2< BackwardOp, bkwd_state4, typename deref<iter3>::type >::type bkwd_state3;
    typedef typename apply2< BackwardOp, bkwd_state3, typename deref<iter2>::type >::type bkwd_state2;
    typedef typename apply2< BackwardOp, bkwd_state2, typename deref<iter1>::type >::type bkwd_state1;
    typedef typename apply2< BackwardOp, bkwd_state1, typename deref<iter0>::type >::type bkwd_state0;


    typedef bkwd_state0 state;
    typedef typename nested_chunk::iterator iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< -1,First,Last,State,BackwardOp,ForwardOp >
{
    typedef reverse_fold_impl<
          -1
        , typename mpl::next<First>::type
        , Last
        , typename apply2<ForwardOp,State, typename deref<First>::type>::type
        , BackwardOp
        , ForwardOp
        > nested_step;

    typedef typename apply2<
          BackwardOp
        , typename nested_step::state
        , typename deref<First>::type
        >::type state;

    typedef typename nested_step::iterator iterator;
};

template<
      typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< -1,Last,Last,State,BackwardOp,ForwardOp >
{
    typedef State state;
    typedef Last iterator;
};

}}}


namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename State = na
    , typename BackwardOp = na
    , typename ForwardOp = arg<1>
    >
struct reverse_fold
{
    typedef typename aux::reverse_fold_impl<
          ::boost::mpl::O1_size<Sequence>::value
        , typename begin<Sequence>::type
        , typename end<Sequence>::type
        , State
        , BackwardOp
        , ForwardOp
        >::state type;


};

template<> struct reverse_fold< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : reverse_fold< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< reverse_fold< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef reverse_fold< na , na , na > result_; typedef reverse_fold< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< reverse_fold< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< reverse_fold< na , na , na > > : int_<-1> { }; }

}}




namespace boost { namespace mpl {

struct has_push_back_arg {};



template< typename Tag >
struct push_back_impl
{
    template< typename Sequence, typename T > struct apply
    {



        struct REQUESTED_PUSH_BACK_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST; typedef struct REQUESTED_PUSH_BACK_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST44 : boost::mpl::assert_ { static boost::mpl::failed ************ (REQUESTED_PUSH_BACK_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST::************ assert_arg()) ( Sequence ) { return 0; } } mpl_assert_arg44; enum { mpl_assertion_in_line_44 = sizeof( boost::mpl::assertion_failed<(( boost::is_same< T, has_push_back_arg >::value ))>( mpl_assert_arg44::assert_arg() ) ) };




    };
};

template< typename Tag >
struct has_push_back_impl
{
    template< typename Seq > struct apply

        : aux::has_type< push_back< Seq, has_push_back_arg > >
    {







    };
};

 template<> struct push_back_impl<non_sequence_tag> {};
 template<> struct has_push_back_impl<non_sequence_tag> {};

}}




namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename T = na
    >
struct push_back
    : push_back_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,T >
{

};


template<
      typename Sequence = na
    >
struct has_push_back
    : has_push_back_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{

};


template<> struct push_back< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : push_back< T1 , T2 > { }; }; template< typename Tag > struct lambda< push_back< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef push_back< na , na > result_; typedef push_back< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< push_back< T1 , T2 > > : int_<2> { }; template<> struct template_arity< push_back< na , na > > : int_<-1> { }; }
template<> struct has_push_back< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : has_push_back< T1 > { }; }; template< typename Tag > struct lambda< has_push_back< na > , Tag , int_<-1> > { typedef false_ is_le; typedef has_push_back< na > result_; typedef has_push_back< na > type; }; namespace aux { template< typename T1 > struct template_arity< has_push_back< T1 > > : int_<1> { }; template<> struct template_arity< has_push_back< na > > : int_<-1> { }; }

}}
namespace boost { namespace mpl {

template<
      typename Sequence
    , typename Operation
    >
struct inserter
{
    typedef Sequence state;
    typedef Operation operation;
};

}}

namespace boost {
namespace mpl {

template<
      typename Sequence
    >
struct back_inserter
    : inserter< Sequence,push_back<> >
{
};

}}
namespace boost { namespace mpl {

struct has_push_front_arg {};




template< typename Tag >
struct push_front_impl
{
    template< typename Sequence, typename T > struct apply
    {



        struct REQUESTED_PUSH_FRONT_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST; typedef struct REQUESTED_PUSH_FRONT_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST45 : boost::mpl::assert_ { static boost::mpl::failed ************ (REQUESTED_PUSH_FRONT_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST::************ assert_arg()) ( Sequence ) { return 0; } } mpl_assert_arg45; enum { mpl_assertion_in_line_45 = sizeof( boost::mpl::assertion_failed<(( boost::is_same< T, has_push_front_arg >::value ))>( mpl_assert_arg45::assert_arg() ) ) };




    };
};

template< typename Tag >
struct has_push_front_impl
{
    template< typename Seq > struct apply

        : aux::has_type< push_front< Seq, has_push_front_arg > >
    {







    };
};

 template<> struct push_front_impl<non_sequence_tag> {};
 template<> struct has_push_front_impl<non_sequence_tag> {};

}}




namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename T = na
    >
struct push_front
    : push_front_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,T >
{

};


template<
      typename Sequence = na
    >
struct has_push_front
    : has_push_front_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{

};

template<> struct push_front< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : push_front< T1 , T2 > { }; }; template< typename Tag > struct lambda< push_front< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef push_front< na , na > result_; typedef push_front< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< push_front< T1 , T2 > > : int_<2> { }; template<> struct template_arity< push_front< na , na > > : int_<-1> { }; }
template<> struct has_push_front< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : has_push_front< T1 > { }; }; template< typename Tag > struct lambda< has_push_front< na > , Tag , int_<-1> > { typedef false_ is_le; typedef has_push_front< na > result_; typedef has_push_front< na > type; }; namespace aux { template< typename T1 > struct template_arity< has_push_front< T1 > > : int_<1> { }; template<> struct template_arity< has_push_front< na > > : int_<-1> { }; }

}}


namespace boost { namespace mpl {

template<
      typename Sequence
    >
struct front_inserter
    : inserter< Sequence,push_front<> >
{
};

}}




namespace boost { namespace mpl {



template< typename Tag >
struct clear_impl
{
    template< typename Sequence > struct apply;
};

 template<> struct clear_impl<non_sequence_tag> {};

}}




namespace boost { namespace mpl {

template<
      typename Sequence = na
    >
struct clear
    : clear_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{

};

template<> struct clear< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : clear< T1 > { }; }; template< typename Tag > struct lambda< clear< na > , Tag , int_<-1> > { typedef false_ is_le; typedef clear< na > result_; typedef clear< na > type; }; namespace aux { template< typename T1 > struct template_arity< clear< T1 > > : int_<1> { }; template<> struct template_arity< clear< na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

namespace aux {

template< typename Pred, typename InsertOp > struct remove_if_helper
{
    template< typename Sequence, typename U > struct apply
    {
        typedef typename eval_if<
              typename apply1<Pred,U>::type
            , identity<Sequence>
            , apply2<InsertOp,Sequence,U>
            >::type type;
    };
};

template<
      typename Sequence
    , typename Predicate
    , typename Inserter
    >
struct remove_if_impl
    : fold<
          Sequence
        , typename Inserter::state
        , protect< aux::remove_if_helper<
              typename lambda<Predicate>::type
            , typename Inserter::operation
            > >
        >
{
};

template<
      typename Sequence
    , typename Predicate
    , typename Inserter
    >
struct reverse_remove_if_impl
    : reverse_fold<
          Sequence
        , typename Inserter::state
        , protect< aux::remove_if_helper<
              typename lambda<Predicate>::type
            , typename Inserter::operation
            > >
        >
{
};

}

 template< typename P1 = na , typename P2 = na , typename P3 = na > struct remove_if : aux::remove_if_impl< P1 , P2 , P3> { }; template< typename P1 , typename P2 > struct remove_if< P1 , P2,na > : if_< has_push_back< typename clear<P1>::type> , aux::remove_if_impl< P1 , P2 , back_inserter< typename clear<P1>::type > > , aux::reverse_remove_if_impl< P1 , P2 , front_inserter< typename clear<P1>::type > > >::type { }; template< typename P1 = na , typename P2 = na , typename P3 = na > struct reverse_remove_if : aux::reverse_remove_if_impl< P1 , P2 , P3> { }; template< typename P1 , typename P2 > struct reverse_remove_if< P1 , P2,na > : if_< has_push_back<P1> , aux::reverse_remove_if_impl< P1 , P2 , back_inserter< typename clear<P1>::type > > , aux::remove_if_impl< P1 , P2 , front_inserter< typename clear<P1>::type > > >::type { }; template<> struct remove_if< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : remove_if< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< remove_if< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef remove_if< na , na , na > result_; typedef remove_if< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< remove_if< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< remove_if< na , na , na > > : int_<-1> { }; } template<> struct reverse_remove_if< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : reverse_remove_if< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< reverse_remove_if< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef reverse_remove_if< na , na , na > result_; typedef reverse_remove_if< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< reverse_remove_if< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< reverse_remove_if< na , na , na > > : int_<-1> { }; }

}}



namespace boost { namespace mpl {

template< typename Tag > struct at_impl;
template< typename Sequence, typename N > struct at;

}}


namespace boost { namespace mpl { namespace aux {

struct v_iter_tag;


struct vector_tag;




}}}








namespace boost { namespace mpl {



template< typename Vector, long n_ >
struct v_at_impl
{
    typedef long_< (Vector::lower_bound_::value + n_) > index_;
    typedef __typeof__( Vector::item_(index_()) ) type;
};


template< typename Vector, long n_ >
struct v_at
    : aux::wrapped_type< typename v_at_impl<Vector,n_>::type >
{
};

template<>
struct at_impl< aux::vector_tag >
{
    template< typename Vector, typename N > struct apply
        : v_at<
              Vector
            , N::value
            >
    {
    };
};
}}
namespace boost { namespace mpl {



template<>
struct front_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
        : v_at<Vector,0>
    {
    };
};
}}
namespace boost { namespace mpl {



template<
      typename T
    , typename Base
    , int at_front = 0
    >
struct v_item
    : Base
{
    typedef typename Base::upper_bound_ index_;
    typedef typename next<index_>::type upper_bound_;
    typedef typename next<typename Base::size>::type size;
    typedef Base base;
    typedef v_item type;



    static aux::type_wrapper<T> item_(index_);
    using Base::item_;
};

template<
      typename T
    , typename Base
    >
struct v_item<T,Base,1>
    : Base
{
    typedef typename prior<typename Base::lower_bound_>::type index_;
    typedef index_ lower_bound_;
    typedef typename next<typename Base::size>::type size;
    typedef Base base;
    typedef v_item type;

    static aux::type_wrapper<T> item_(index_);
    using Base::item_;
};


template<
      typename Base
    , int at_front
    >
struct v_mask
    : Base
{
    typedef typename prior<typename Base::upper_bound_>::type index_;
    typedef index_ upper_bound_;
    typedef typename prior<typename Base::size>::type size;
    typedef Base base;
    typedef v_mask type;

    static aux::type_wrapper<void_> item_(index_);
    using Base::item_;
};

template<
      typename Base
    >
struct v_mask<Base,1>
    : Base
{
    typedef typename Base::lower_bound_ index_;
    typedef typename next<index_>::type lower_bound_;
    typedef typename prior<typename Base::size>::type size;
    typedef Base base;
    typedef v_mask type;

    static aux::type_wrapper<void_> item_(index_);
    using Base::item_;
};



}}


namespace boost { namespace mpl {

template<>
struct push_front_impl< aux::vector_tag >
{
    template< typename Vector, typename T > struct apply
    {
        typedef v_item<T,Vector,1> type;
    };
};

}}
namespace boost { namespace mpl {

template<>
struct pop_front_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef v_mask<Vector,1> type;
    };
};

}}
namespace boost { namespace mpl {

template<>
struct push_back_impl< aux::vector_tag >
{
    template< typename Vector, typename T > struct apply
    {
        typedef v_item<T,Vector,0> type;
    };
};

}}
namespace boost { namespace mpl {

template< typename Tag > struct pop_back_impl;
template< typename Sequence > struct pop_back;

}}







namespace boost { namespace mpl {

template<>
struct pop_back_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef v_mask<Vector,0> type;
    };
};

}}
namespace boost { namespace mpl {

template< typename Tag > struct back_impl;
template< typename Sequence > struct back;

}}






namespace boost { namespace mpl {



template<>
struct back_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
        : v_at<
              Vector
            , prior<typename Vector::size>::type::value
            >
    {
    };
};
}}







namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct minus_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< minus_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< minus_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct minus_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct minus_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct minus_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct minus_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    , typename N3 = na, typename N4 = na, typename N5 = na
    >
struct minus
    : minus< minus< minus< minus< N1,N2 >, N3>, N4>, N5>
{





};

template<
      typename N1, typename N2, typename N3, typename N4
    >
struct minus< N1,N2,N3,N4,na >

    : minus< minus< minus< N1,N2 >, N3>, N4>
{





};

template<
      typename N1, typename N2, typename N3
    >
struct minus< N1,N2,N3,na,na >

    : minus< minus< N1,N2 >, N3>
{





};

template<
      typename N1, typename N2
    >
struct minus< N1,N2,na,na,na >
    : minus_impl<
          typename minus_tag<N1>::type
        , typename minus_tag<N2>::type
        >::template apply< N1,N2 >::type
{






};

template<> struct minus< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : minus< T1 , T2 > { }; }; template< typename Tag > struct lambda< minus< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef minus< na , na > result_; typedef minus< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< minus< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< minus< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {
template<>
struct minus_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : integral_c<
              typename aux::largest_int<
                  typename N1::value_type
                , typename N2::value_type
                >::type
            , ( N1::value
                  - N2::value
                )
            >
    {
    };
};

}}
namespace boost { namespace mpl {



template< typename Tag > struct advance_impl;
template< typename Iterator, typename N > struct advance;

}}
namespace boost { namespace mpl {



template< typename Tag > struct distance_impl;
template< typename First, typename Last > struct distance;

}}






namespace boost { namespace mpl {

template<
      typename Vector
    , long n_
    >
struct v_iter
{
    typedef aux::v_iter_tag tag;
    typedef random_access_iterator_tag category;
    typedef typename v_at<Vector,n_>::type type;

    typedef Vector vector_;
    typedef mpl::long_<n_> pos;
};




template<
      typename Vector
    , long n_
    >
struct next< v_iter<Vector,n_> >
{
    typedef v_iter<Vector,(n_ + 1)> type;
};

template<
      typename Vector
    , long n_
    >
struct prior< v_iter<Vector,n_> >
{
    typedef v_iter<Vector,(n_ - 1)> type;
};

template<
      typename Vector
    , long n_
    , typename Distance
    >
struct advance< v_iter<Vector,n_>,Distance>
{
    typedef v_iter<
          Vector
        , (n_ + Distance::value)
        > type;
};

template<
      typename Vector
    , long n_
    , long m_
    >
struct distance< v_iter<Vector,n_>, v_iter<Vector,m_> >
    : mpl::long_<(m_ - n_)>
{
};
}}



namespace boost { namespace mpl {

template< typename Dummy = na > struct vector0;

template<> struct vector0<na>
{

    typedef aux::vector_tag tag;
    typedef vector0 type;
    typedef long_<32768> lower_bound_;
    typedef lower_bound_ upper_bound_;
    typedef long_<0> size;

    static aux::type_wrapper<void_> item_(...);
};

}}




namespace boost { namespace mpl {



template<>
struct clear_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef vector0<> type;
    };
};
}}
namespace boost { namespace mpl {



template<>
struct O1_size_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
        : Vector::size
    {
    };
};
}}
namespace boost { namespace mpl {



template<>
struct size_impl< aux::vector_tag >
    : O1_size_impl< aux::vector_tag >
{
};
}}
namespace boost { namespace mpl {



template<>
struct empty_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
        : is_same<
              typename Vector::lower_bound_
            , typename Vector::upper_bound_
            >
    {
    };
};
}}



namespace boost { namespace mpl {

template<>
struct begin_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef v_iter<Vector,0> type;
    };
};

template<>
struct end_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef v_iter<Vector,Vector::size::value> type;
    };
};

}}








namespace boost { namespace mpl {

template<
      typename T0
    >
struct vector1
    : v_item<
          T0
        , vector0< >
        >
{
    typedef vector1 type;
};

template<
      typename T0, typename T1
    >
struct vector2
    : v_item<
          T1
        , vector1<T0>
        >
{
    typedef vector2 type;
};

template<
      typename T0, typename T1, typename T2
    >
struct vector3
    : v_item<
          T2
        , vector2< T0,T1 >
        >
{
    typedef vector3 type;
};

template<
      typename T0, typename T1, typename T2, typename T3
    >
struct vector4
    : v_item<
          T3
        , vector3< T0,T1,T2 >
        >
{
    typedef vector4 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    >
struct vector5
    : v_item<
          T4
        , vector4< T0,T1,T2,T3 >
        >
{
    typedef vector5 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct vector6
    : v_item<
          T5
        , vector5< T0,T1,T2,T3,T4 >
        >
{
    typedef vector6 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6
    >
struct vector7
    : v_item<
          T6
        , vector6< T0,T1,T2,T3,T4,T5 >
        >
{
    typedef vector7 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7
    >
struct vector8
    : v_item<
          T7
        , vector7< T0,T1,T2,T3,T4,T5,T6 >
        >
{
    typedef vector8 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8
    >
struct vector9
    : v_item<
          T8
        , vector8< T0,T1,T2,T3,T4,T5,T6,T7 >
        >
{
    typedef vector9 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    >
struct vector10
    : v_item<
          T9
        , vector9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >
        >
{
    typedef vector10 type;
};

}}








namespace boost { namespace mpl {

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10
    >
struct vector11
    : v_item<
          T10
        , vector10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >
        >
{
    typedef vector11 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11
    >
struct vector12
    : v_item<
          T11
        , vector11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >
        >
{
    typedef vector12 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12
    >
struct vector13
    : v_item<
          T12
        , vector12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >
        >
{
    typedef vector13 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13
    >
struct vector14
    : v_item<
          T13
        , vector13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >
        >
{
    typedef vector14 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    >
struct vector15
    : v_item<
          T14
        , vector14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >
        >
{
    typedef vector15 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15
    >
struct vector16
    : v_item<
          T15
        , vector15< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14 >
        >
{
    typedef vector16 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16
    >
struct vector17
    : v_item<
          T16
        , vector16< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15 >
        >
{
    typedef vector17 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17
    >
struct vector18
    : v_item<
          T17
        , vector17< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16 >
        >
{
    typedef vector18 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18
    >
struct vector19
    : v_item<
          T18
        , vector18< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17 >
        >
{
    typedef vector19 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    >
struct vector20
    : v_item<
          T19
        , vector19< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18 >
        >
{
    typedef vector20 type;
};

}}
namespace boost { namespace mpl {

template<
      typename T0 = na, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na, typename T6 = na, typename T7 = na
    , typename T8 = na, typename T9 = na, typename T10 = na, typename T11 = na
    , typename T12 = na, typename T13 = na, typename T14 = na
    , typename T15 = na, typename T16 = na, typename T17 = na
    , typename T18 = na, typename T19 = na
    >
struct vector;

template<

    >
struct vector<
          na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector0< >
{
    typedef vector0< >::type type;
};

template<
      typename T0
    >
struct vector<
          T0, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector1<T0>
{
    typedef typename vector1<T0>::type type;
};

template<
      typename T0, typename T1
    >
struct vector<
          T0, T1, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector2< T0,T1 >
{
    typedef typename vector2< T0,T1 >::type type;
};

template<
      typename T0, typename T1, typename T2
    >
struct vector<
          T0, T1, T2, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector3< T0,T1,T2 >
{
    typedef typename vector3< T0,T1,T2 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3
    >
struct vector<
          T0, T1, T2, T3, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector4< T0,T1,T2,T3 >
{
    typedef typename vector4< T0,T1,T2,T3 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    >
struct vector<
          T0, T1, T2, T3, T4, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector5< T0,T1,T2,T3,T4 >
{
    typedef typename vector5< T0,T1,T2,T3,T4 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct vector<
          T0, T1, T2, T3, T4, T5, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector6< T0,T1,T2,T3,T4,T5 >
{
    typedef typename vector6< T0,T1,T2,T3,T4,T5 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector7< T0,T1,T2,T3,T4,T5,T6 >
{
    typedef typename vector7< T0,T1,T2,T3,T4,T5,T6 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector8< T0,T1,T2,T3,T4,T5,T6,T7 >
{
    typedef typename vector8< T0,T1,T2,T3,T4,T5,T6,T7 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >
{
    typedef typename vector9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >
{
    typedef typename vector10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, na, na, na, na, na, na
        , na, na, na
        >
    : vector11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >
{
    typedef typename vector11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, na, na, na, na
        , na, na, na, na
        >
    : vector12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >
{
    typedef typename vector12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, na, na, na
        , na, na, na, na
        >
    : vector13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >
{
    typedef typename vector13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, na, na
        , na, na, na, na
        >
    : vector14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >
{
    typedef typename vector14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, na
        , na, na, na, na
        >
    : vector15<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        >
{
    typedef typename vector15< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, na, na, na, na
        >
    : vector16<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15
        >
{
    typedef typename vector16< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, na, na, na
        >
    : vector17<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16
        >
{
    typedef typename vector17< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, na, na
        >
    : vector18<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17
        >
{
    typedef typename vector18< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18, na
        >
    : vector19<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18
        >
{
    typedef typename vector19< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18 >::type type;
};



template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    >
struct vector
    : vector20<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18, T19
        >
{
    typedef typename vector20< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19 >::type type;
};

}}

namespace boost { namespace mpl {

template< typename Tag > struct negate_impl;

template< typename T > struct negate_tag
{
    typedef typename T::tag type;
};

template<
      typename N = na
    >
struct negate

    : negate_impl<
          typename negate_tag<N>::type
        >::template apply<N>::type






{

};

template<> struct negate< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : negate< T1 > { }; }; template< typename Tag > struct lambda< negate< na > , Tag , int_<-1> > { typedef false_ is_le; typedef negate< na > result_; typedef negate< na > type; }; namespace aux { template< typename T1 > struct template_arity< negate< T1 > > : int_<1> { }; template<> struct template_arity< negate< na > > : int_<-1> { }; }
template<>
struct negate_impl<integral_c_tag>
{




    template< typename N > struct apply
        : integral_c< typename N::value_type, (-N::value) >

    {
    };
};

}}











namespace boost { namespace mpl { namespace aux {

template< long N > struct advance_forward;
template<>
struct advance_forward<0>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef iter0 type;
    };
};

template<>
struct advance_forward<1>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename next<iter0>::type iter1;
        typedef iter1 type;
    };
};

template<>
struct advance_forward<2>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename next<iter0>::type iter1;
        typedef typename next<iter1>::type iter2;
        typedef iter2 type;
    };
};

template<>
struct advance_forward<3>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename next<iter0>::type iter1;
        typedef typename next<iter1>::type iter2;
        typedef typename next<iter2>::type iter3;
        typedef iter3 type;
    };
};

template<>
struct advance_forward<4>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename next<iter0>::type iter1;
        typedef typename next<iter1>::type iter2;
        typedef typename next<iter2>::type iter3;
        typedef typename next<iter3>::type iter4;
        typedef iter4 type;
    };
};

template< long N >
struct advance_forward
{
    template< typename Iterator > struct apply
    {
        typedef typename apply_wrap1<
              advance_forward<4>
            , Iterator
            >::type chunk_result_;

        typedef typename apply_wrap1<
              advance_forward<(
                (N - 4) < 0
                    ? 0
                    : N - 4
                    )>
            , chunk_result_
            >::type type;
    };
};

}}}








namespace boost { namespace mpl { namespace aux {

template< long N > struct advance_backward;
template<>
struct advance_backward<0>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef iter0 type;
    };
};

template<>
struct advance_backward<1>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename prior<iter0>::type iter1;
        typedef iter1 type;
    };
};

template<>
struct advance_backward<2>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename prior<iter0>::type iter1;
        typedef typename prior<iter1>::type iter2;
        typedef iter2 type;
    };
};

template<>
struct advance_backward<3>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename prior<iter0>::type iter1;
        typedef typename prior<iter1>::type iter2;
        typedef typename prior<iter2>::type iter3;
        typedef iter3 type;
    };
};

template<>
struct advance_backward<4>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename prior<iter0>::type iter1;
        typedef typename prior<iter1>::type iter2;
        typedef typename prior<iter2>::type iter3;
        typedef typename prior<iter3>::type iter4;
        typedef iter4 type;
    };
};

template< long N >
struct advance_backward
{
    template< typename Iterator > struct apply
    {
        typedef typename apply_wrap1<
              advance_backward<4>
            , Iterator
            >::type chunk_result_;

        typedef typename apply_wrap1<
              advance_backward<(
                (N - 4) < 0
                    ? 0
                    : N - 4
                    )>
            , chunk_result_
            >::type type;
    };
};

}}}




namespace boost { namespace mpl {


template< typename Tag >
struct advance_impl
{
    template< typename Iterator, typename N > struct apply
    {
        typedef typename less< N,long_<0> >::type backward_;
        typedef typename if_< backward_, negate<N>, N >::type offset_;

        typedef typename if_<
              backward_
            , aux::advance_backward< offset_::value >
            , aux::advance_forward< offset_::value >
            >::type f_;

        typedef typename apply_wrap1<f_,Iterator>::type type;
    };
};


template<
      typename Iterator = na
    , typename N = na
    >
struct advance
    : advance_impl< typename tag<Iterator>::type >
        ::template apply<Iterator,N>
{
};

template<
      typename Iterator
    , long N
    >
struct advance_c
    : advance_impl< typename tag<Iterator>::type >
        ::template apply<Iterator,long_<N> >
{
};

template<> struct advance< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : advance< T1 , T2 > { }; }; template< typename Tag > struct lambda< advance< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef advance< na , na > result_; typedef advance< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< advance< T1 , T2 > > : int_<2> { }; template<> struct template_arity< advance< na , na > > : int_<-1> { }; }

}}



namespace boost { namespace mpl {




template< typename Tag >
struct at_impl
{
    template< typename Sequence, typename N > struct apply
    {
        typedef typename advance<
              typename begin<Sequence>::type
            , N
            >::type iter_;

        typedef typename deref<iter_>::type type;
    };
};

 template<> struct at_impl<non_sequence_tag> {};

}}






namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename N = na
    >
struct at
    : at_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,N >
{

};

template<
      typename Sequence
    , long N
    >
struct at_c
    : at_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,mpl::long_<N> >
{
};

template<> struct at< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : at< T1 , T2 > { }; }; template< typename Tag > struct lambda< at< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef at< na , na > result_; typedef at< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< at< T1 , T2 > > : int_<2> { }; template<> struct template_arity< at< na , na > > : int_<-1> { }; }

}}
namespace boost { namespace mpl { namespace aux {



template<
      int N
    , typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl;

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 0,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef state0 state;
    typedef iter0 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 1,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp,state0,iter0 >::type state1;
    typedef typename mpl::next<iter0>::type iter1;


    typedef state1 state;
    typedef iter1 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 2,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp,state0,iter0 >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp,state1,iter1 >::type state2;
    typedef typename mpl::next<iter1>::type iter2;


    typedef state2 state;
    typedef iter2 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 3,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp,state0,iter0 >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp,state1,iter1 >::type state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp,state2,iter2 >::type state3;
    typedef typename mpl::next<iter2>::type iter3;


    typedef state3 state;
    typedef iter3 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 4,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp,state0,iter0 >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp,state1,iter1 >::type state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp,state2,iter2 >::type state3;
    typedef typename mpl::next<iter2>::type iter3;
    typedef typename apply2< ForwardOp,state3,iter3 >::type state4;
    typedef typename mpl::next<iter3>::type iter4;


    typedef state4 state;
    typedef iter4 iterator;
};

template<
      int N
    , typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl
{
    typedef iter_fold_impl<
          4
        , First
        , Last
        , State
        , ForwardOp
        > chunk_;

    typedef iter_fold_impl<
          ( (N - 4) < 0 ? 0 : N - 4 )
        , typename chunk_::iterator
        , Last
        , typename chunk_::state
        , ForwardOp
        > res_;

    typedef typename res_::state state;
    typedef typename res_::iterator iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< -1,First,Last,State,ForwardOp >
    : iter_fold_impl<
          -1
        , typename mpl::next<First>::type
        , Last
        , typename apply2< ForwardOp,State,First >::type
        , ForwardOp
        >
{
};

template<
      typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< -1,Last,Last,State,ForwardOp >
{
    typedef State state;
    typedef Last iterator;
};

}}}



namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename State = na
    , typename ForwardOp = na
    >
struct iter_fold
{
    typedef typename aux::iter_fold_impl<
          ::boost::mpl::O1_size<Sequence>::value
        , typename begin<Sequence>::type
        , typename end<Sequence>::type
        , State
        , typename lambda<ForwardOp>::type
        >::state type;


};

template<> struct iter_fold< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : iter_fold< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< iter_fold< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef iter_fold< na , na , na > result_; typedef iter_fold< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< iter_fold< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< iter_fold< na , na , na > > : int_<-1> { }; }

}}
namespace boost { namespace mpl {

struct iterator_range_tag;

template<
      typename First = na
    , typename Last = na
    >
struct iterator_range
{
    typedef iterator_range_tag tag;
    typedef iterator_range type;
    typedef First begin;
    typedef Last end;


};

template<> struct iterator_range< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : iterator_range< T1 , T2 > { }; }; template< typename Tag > struct lambda< iterator_range< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef iterator_range< na , na > result_; typedef iterator_range< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< iterator_range< T1 , T2 > > : int_<2> { }; template<> struct template_arity< iterator_range< na , na > > : int_<-1> { }; }

}}










namespace boost { namespace mpl {


template< typename Tag > struct distance_impl
{
    template< typename First, typename Last > struct apply

        : aux::msvc_eti_base< typename iter_fold<
              iterator_range<First,Last>
            , mpl::long_<0>
            , next<>
            >::type >
    {
    };
};

template<
      typename First = na
    , typename Last = na
    >
struct distance
    : distance_impl< typename tag<First>::type >
        ::template apply<First, Last>
{

};

template<> struct distance< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : distance< T1 , T2 > { }; }; template< typename Tag > struct lambda< distance< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef distance< na , na > result_; typedef distance< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< distance< T1 , T2 > > : int_<2> { }; template<> struct template_arity< distance< na , na > > : int_<-1> { }; }

}}



namespace boost { namespace mpl {




template< typename Tag >
struct size_impl
{
    template< typename Sequence > struct apply

        : distance<
              typename begin<Sequence>::type
            , typename end<Sequence>::type
            >
    {







    };
};

 template<> struct size_impl<non_sequence_tag> {};

}}




namespace boost { namespace mpl {

template<
      typename Sequence = na
    >
struct size
    : aux::msvc_eti_base<
        typename size_impl< typename sequence_tag<Sequence>::type >
            ::template apply< Sequence >::type
      >::type
{

};

template<> struct size< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : size< T1 > { }; }; template< typename Tag > struct lambda< size< na > , Tag , int_<-1> > { typedef false_ is_le; typedef size< na > result_; typedef size< na > type; }; namespace aux { template< typename T1 > struct template_arity< size< T1 > > : int_<1> { }; template<> struct template_arity< size< na > > : int_<-1> { }; }

}}







namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct not_equal_to_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< not_equal_to_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< not_equal_to_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct not_equal_to_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct not_equal_to_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct not_equal_to_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct not_equal_to_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct not_equal_to

    : not_equal_to_impl<
          typename not_equal_to_tag<N1>::type
        , typename not_equal_to_tag<N2>::type
        >::template apply< N1,N2 >::type
{


};

template<> struct not_equal_to< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : not_equal_to< T1 , T2 > { }; }; template< typename Tag > struct lambda< not_equal_to< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef not_equal_to< na , na > result_; typedef not_equal_to< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< not_equal_to< T1 , T2 > > : int_<2> { }; template<> struct template_arity< not_equal_to< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct not_equal_to_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value != N2::value ) >
    {
    };
};

}}








namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct greater_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< greater_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< greater_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct greater_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct greater_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct greater_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct greater_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct greater

    : greater_impl<
          typename greater_tag<N1>::type
        , typename greater_tag<N2>::type
        >::template apply< N1,N2 >::type
{


};

template<> struct greater< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : greater< T1 , T2 > { }; }; template< typename Tag > struct lambda< greater< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef greater< na , na > result_; typedef greater< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< greater< T1 , T2 > > : int_<2> { }; template<> struct template_arity< greater< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct greater_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value > N2::value ) >
    {
    };
};

}}







namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct less_equal_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< less_equal_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< less_equal_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct less_equal_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct less_equal_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct less_equal_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct less_equal_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct less_equal

    : less_equal_impl<
          typename less_equal_tag<N1>::type
        , typename less_equal_tag<N2>::type
        >::template apply< N1,N2 >::type
{


};

template<> struct less_equal< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : less_equal< T1 , T2 > { }; }; template< typename Tag > struct lambda< less_equal< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef less_equal< na , na > result_; typedef less_equal< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< less_equal< T1 , T2 > > : int_<2> { }; template<> struct template_arity< less_equal< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct less_equal_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value <= N2::value ) >
    {
    };
};

}}







namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct greater_equal_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< greater_equal_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< greater_equal_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct greater_equal_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct greater_equal_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct greater_equal_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct greater_equal_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct greater_equal

    : greater_equal_impl<
          typename greater_equal_tag<N1>::type
        , typename greater_equal_tag<N2>::type
        >::template apply< N1,N2 >::type
{


};

template<> struct greater_equal< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : greater_equal< T1 , T2 > { }; }; template< typename Tag > struct lambda< greater_equal< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef greater_equal< na , na > result_; typedef greater_equal< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< greater_equal< T1 , T2 > > : int_<2> { }; template<> struct template_arity< greater_equal< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct greater_equal_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value >= N2::value ) >
    {
    };
};

}}









namespace boost{ namespace math{

namespace tools{

template <class T>
constexpr int digits() noexcept;
template <class T>
constexpr T epsilon() noexcept(std::is_floating_point<T>::value);

}

namespace policies{
enum error_policy_type
{
   throw_on_error = 0,
   errno_on_error = 1,
   ignore_error = 2,
   user_error = 3
};

template <error_policy_type N = throw_on_error> struct domain_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const domain_error<N>*); char test_is_default_arg(const domain_error<throw_on_error>*); template <class T> struct is_domain_error_imp { template <error_policy_type N> static char test(const domain_error<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_domain_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_domain_error_imp<T>::value>{};
template <error_policy_type N = throw_on_error> struct pole_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const pole_error<N>*); char test_is_default_arg(const pole_error<throw_on_error>*); template <class T> struct is_pole_error_imp { template <error_policy_type N> static char test(const pole_error<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_pole_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_pole_error_imp<T>::value>{};
template <error_policy_type N = throw_on_error> struct overflow_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const overflow_error<N>*); char test_is_default_arg(const overflow_error<throw_on_error>*); template <class T> struct is_overflow_error_imp { template <error_policy_type N> static char test(const overflow_error<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_overflow_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_overflow_error_imp<T>::value>{};
template <error_policy_type N = ignore_error> struct underflow_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const underflow_error<N>*); char test_is_default_arg(const underflow_error<ignore_error>*); template <class T> struct is_underflow_error_imp { template <error_policy_type N> static char test(const underflow_error<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_underflow_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_underflow_error_imp<T>::value>{};
template <error_policy_type N = ignore_error> struct denorm_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const denorm_error<N>*); char test_is_default_arg(const denorm_error<ignore_error>*); template <class T> struct is_denorm_error_imp { template <error_policy_type N> static char test(const denorm_error<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_denorm_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_denorm_error_imp<T>::value>{};
template <error_policy_type N = throw_on_error> struct evaluation_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const evaluation_error<N>*); char test_is_default_arg(const evaluation_error<throw_on_error>*); template <class T> struct is_evaluation_error_imp { template <error_policy_type N> static char test(const evaluation_error<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_evaluation_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_evaluation_error_imp<T>::value>{};
template <error_policy_type N = throw_on_error> struct rounding_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const rounding_error<N>*); char test_is_default_arg(const rounding_error<throw_on_error>*); template <class T> struct is_rounding_error_imp { template <error_policy_type N> static char test(const rounding_error<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_rounding_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_rounding_error_imp<T>::value>{};
template <error_policy_type N = ignore_error> struct indeterminate_result_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const indeterminate_result_error<N>*); char test_is_default_arg(const indeterminate_result_error<ignore_error>*); template <class T> struct is_indeterminate_result_error_imp { template <error_policy_type N> static char test(const indeterminate_result_error<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_indeterminate_result_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_indeterminate_result_error_imp<T>::value>{};




template <bool N = true> struct promote_float : public boost::mpl::bool_<N>{}; namespace detail{ template <bool N> char test_is_valid_arg(const promote_float<N>*); char test_is_default_arg(const promote_float<true>*); template <class T> struct is_promote_float_imp { template <bool N> static char test(const promote_float<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_promote_float : public boost::mpl::bool_< ::boost::math::policies::detail::is_promote_float_imp<T>::value>{};
template <bool N = true> struct promote_double : public boost::mpl::bool_<N>{}; namespace detail{ template <bool N> char test_is_valid_arg(const promote_double<N>*); char test_is_default_arg(const promote_double<true>*); template <class T> struct is_promote_double_imp { template <bool N> static char test(const promote_double<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_promote_double : public boost::mpl::bool_< ::boost::math::policies::detail::is_promote_double_imp<T>::value>{};
template <bool N = true> struct assert_undefined : public boost::mpl::bool_<N>{}; namespace detail{ template <bool N> char test_is_valid_arg(const assert_undefined<N>*); char test_is_default_arg(const assert_undefined<true>*); template <class T> struct is_assert_undefined_imp { template <bool N> static char test(const assert_undefined<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_assert_undefined : public boost::mpl::bool_< ::boost::math::policies::detail::is_assert_undefined_imp<T>::value>{};



enum discrete_quantile_policy_type
{
   real,
   integer_round_outwards,
   integer_round_inwards,
   integer_round_down,
   integer_round_up,
   integer_round_nearest
};

template <discrete_quantile_policy_type N = integer_round_outwards> struct discrete_quantile : public boost::mpl::int_<N>{}; namespace detail{ template <discrete_quantile_policy_type N> char test_is_valid_arg(const discrete_quantile<N>*); char test_is_default_arg(const discrete_quantile<integer_round_outwards>*); template <class T> struct is_discrete_quantile_imp { template <discrete_quantile_policy_type N> static char test(const discrete_quantile<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_discrete_quantile : public boost::mpl::bool_< ::boost::math::policies::detail::is_discrete_quantile_imp<T>::value>{};



template <int N = 0> struct digits10 : public boost::mpl::int_<N>{}; namespace detail{ template <int N> char test_is_valid_arg(const digits10<N>*); char test_is_default_arg(const digits10<0>*); template <class T> struct is_digits10_imp { template <int N> static char test(const digits10<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_digits10 : public boost::mpl::bool_< ::boost::math::policies::detail::is_digits10_imp<T>::value>{};
template <int N = 0> struct digits2 : public boost::mpl::int_<N>{}; namespace detail{ template <int N> char test_is_valid_arg(const digits2<N>*); char test_is_default_arg(const digits2<0>*); template <class T> struct is_digits2_imp { template <int N> static char test(const digits2<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_digits2 : public boost::mpl::bool_< ::boost::math::policies::detail::is_digits2_imp<T>::value>{};



template <unsigned long N = 1000000> struct max_series_iterations : public boost::mpl::int_<N>{}; namespace detail{ template <unsigned long N> char test_is_valid_arg(const max_series_iterations<N>*); char test_is_default_arg(const max_series_iterations<1000000>*); template <class T> struct is_max_series_iterations_imp { template <unsigned long N> static char test(const max_series_iterations<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_max_series_iterations : public boost::mpl::bool_< ::boost::math::policies::detail::is_max_series_iterations_imp<T>::value>{};
template <unsigned long N = 200> struct max_root_iterations : public boost::mpl::int_<N>{}; namespace detail{ template <unsigned long N> char test_is_valid_arg(const max_root_iterations<N>*); char test_is_default_arg(const max_root_iterations<200>*); template <class T> struct is_max_root_iterations_imp { template <unsigned long N> static char test(const max_root_iterations<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_max_root_iterations : public boost::mpl::bool_< ::boost::math::policies::detail::is_max_root_iterations_imp<T>::value>{};







struct default_policy{};

namespace detail{



template <class Digits10, class Digits2>
struct precision
{



   typedef typename mpl::if_c<
      (Digits10::value == 0),
      digits2<0>,
      digits2<((Digits10::value + 1) * 1000L) / 301L>
   >::type digits2_type;
public:





   typedef typename mpl::if_c<
      (Digits2::value > digits2_type::value),
      Digits2, digits2_type>::type type;

};

template <class A, class B, bool b>
struct select_result
{
   typedef A type;
};
template <class A, class B>
struct select_result<A, B, false>
{
   typedef typename mpl::deref<B>::type type;
};

template <class Seq, class Pred, class DefaultType>
struct find_arg
{
private:
   typedef typename mpl::find_if<Seq, Pred>::type iter;
   typedef typename mpl::end<Seq>::type end_type;
public:
   typedef typename select_result<
      DefaultType, iter,
      ::boost::is_same<iter, end_type>::value>::type type;
};

double test_is_valid_arg(...);
double test_is_default_arg(...);
char test_is_valid_arg(const default_policy*);
char test_is_default_arg(const default_policy*);

template <class T>
struct is_valid_policy_imp
{
   static const bool value = sizeof(::boost::math::policies::detail::test_is_valid_arg(static_cast<T*>(0))) == 1;
};

template <class T>
struct is_default_policy_imp
{
   static const bool value = sizeof(::boost::math::policies::detail::test_is_default_arg(static_cast<T*>(0))) == 1;
};

template <class T> struct is_valid_policy
: public mpl::bool_<
   ::boost::math::policies::detail::is_valid_policy_imp<T>::value>
{};

template <class T> struct is_default_policy
: public mpl::bool_<
   ::boost::math::policies::detail::is_default_policy_imp<T>::value>
{
   template <class U>
   struct apply
   {
      typedef is_default_policy<U> type;
   };
};

template <class Seq, class T, int N>
struct append_N
{
   typedef typename mpl::push_back<Seq, T>::type new_seq;
   typedef typename append_N<new_seq, T, N-1>::type type;
};

template <class Seq, class T>
struct append_N<Seq, T, 0>
{
   typedef Seq type;
};





template <bool f, bool d>
struct default_args
{
   typedef promote_float<false> arg1;
   typedef promote_double<false> arg2;
};

template <>
struct default_args<false, false>
{
   typedef default_policy arg1;
   typedef default_policy arg2;
};

template <>
struct default_args<true, false>
{
   typedef promote_float<false> arg1;
   typedef default_policy arg2;
};

template <>
struct default_args<false, true>
{
   typedef promote_double<false> arg1;
   typedef default_policy arg2;
};

typedef default_args<true, true>::arg1 forwarding_arg1;
typedef default_args<true, true>::arg2 forwarding_arg2;

}




template <class A1 = default_policy,
          class A2 = default_policy,
          class A3 = default_policy,
          class A4 = default_policy,
          class A5 = default_policy,
          class A6 = default_policy,
          class A7 = default_policy,
          class A8 = default_policy,
          class A9 = default_policy,
          class A10 = default_policy,
          class A11 = default_policy,
          class A12 = default_policy,
          class A13 = default_policy>
struct policy
{
private:



   static_assert(::boost::math::policies::detail::is_valid_policy<A1>::value, "::boost::math::policies::detail::is_valid_policy<A1>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A2>::value, "::boost::math::policies::detail::is_valid_policy<A2>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A3>::value, "::boost::math::policies::detail::is_valid_policy<A3>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A4>::value, "::boost::math::policies::detail::is_valid_policy<A4>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A5>::value, "::boost::math::policies::detail::is_valid_policy<A5>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A6>::value, "::boost::math::policies::detail::is_valid_policy<A6>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A7>::value, "::boost::math::policies::detail::is_valid_policy<A7>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A8>::value, "::boost::math::policies::detail::is_valid_policy<A8>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A9>::value, "::boost::math::policies::detail::is_valid_policy<A9>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A10>::value, "::boost::math::policies::detail::is_valid_policy<A10>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A11>::value, "::boost::math::policies::detail::is_valid_policy<A11>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A12>::value, "::boost::math::policies::detail::is_valid_policy<A12>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A13>::value, "::boost::math::policies::detail::is_valid_policy<A13>::value");



   typedef mpl::list<A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13> arg_list;

public:
   typedef typename detail::find_arg<arg_list, is_domain_error<mpl::_1>, domain_error<> >::type domain_error_type;
   typedef typename detail::find_arg<arg_list, is_pole_error<mpl::_1>, pole_error<> >::type pole_error_type;
   typedef typename detail::find_arg<arg_list, is_overflow_error<mpl::_1>, overflow_error<> >::type overflow_error_type;
   typedef typename detail::find_arg<arg_list, is_underflow_error<mpl::_1>, underflow_error<> >::type underflow_error_type;
   typedef typename detail::find_arg<arg_list, is_denorm_error<mpl::_1>, denorm_error<> >::type denorm_error_type;
   typedef typename detail::find_arg<arg_list, is_evaluation_error<mpl::_1>, evaluation_error<> >::type evaluation_error_type;
   typedef typename detail::find_arg<arg_list, is_rounding_error<mpl::_1>, rounding_error<> >::type rounding_error_type;
   typedef typename detail::find_arg<arg_list, is_indeterminate_result_error<mpl::_1>, indeterminate_result_error<> >::type indeterminate_result_error_type;
private:



   typedef typename detail::find_arg<arg_list, is_digits10<mpl::_1>, digits10<> >::type digits10_type;
   typedef typename detail::find_arg<arg_list, is_digits2<mpl::_1>, digits2<> >::type bits_precision_type;
public:
   typedef typename detail::precision<digits10_type, bits_precision_type>::type precision_type;



   typedef typename detail::find_arg<arg_list, is_promote_float<mpl::_1>, promote_float<> >::type promote_float_type;
   typedef typename detail::find_arg<arg_list, is_promote_double<mpl::_1>, promote_double<> >::type promote_double_type;



   typedef typename detail::find_arg<arg_list, is_discrete_quantile<mpl::_1>, discrete_quantile<> >::type discrete_quantile_type;



   typedef typename detail::find_arg<arg_list, is_assert_undefined<mpl::_1>, assert_undefined<> >::type assert_undefined_type;



   typedef typename detail::find_arg<arg_list, is_max_series_iterations<mpl::_1>, max_series_iterations<> >::type max_series_iterations_type;
   typedef typename detail::find_arg<arg_list, is_max_root_iterations<mpl::_1>, max_root_iterations<> >::type max_root_iterations_type;
};





template <>
struct policy<default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy>
{
public:
   typedef domain_error<> domain_error_type;
   typedef pole_error<> pole_error_type;
   typedef overflow_error<> overflow_error_type;
   typedef underflow_error<> underflow_error_type;
   typedef denorm_error<> denorm_error_type;
   typedef evaluation_error<> evaluation_error_type;
   typedef rounding_error<> rounding_error_type;
   typedef indeterminate_result_error<> indeterminate_result_error_type;

   typedef digits2<> precision_type;



   typedef promote_float<> promote_float_type;
   typedef promote_double<> promote_double_type;
   typedef discrete_quantile<> discrete_quantile_type;
   typedef assert_undefined<> assert_undefined_type;
   typedef max_series_iterations<> max_series_iterations_type;
   typedef max_root_iterations<> max_root_iterations_type;
};

template <>
struct policy<detail::forwarding_arg1, detail::forwarding_arg2, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy>
{
public:
   typedef domain_error<> domain_error_type;
   typedef pole_error<> pole_error_type;
   typedef overflow_error<> overflow_error_type;
   typedef underflow_error<> underflow_error_type;
   typedef denorm_error<> denorm_error_type;
   typedef evaluation_error<> evaluation_error_type;
   typedef rounding_error<> rounding_error_type;
   typedef indeterminate_result_error<> indeterminate_result_error_type;

   typedef digits2<> precision_type;



   typedef promote_float<false> promote_float_type;
   typedef promote_double<false> promote_double_type;
   typedef discrete_quantile<> discrete_quantile_type;
   typedef assert_undefined<> assert_undefined_type;
   typedef max_series_iterations<> max_series_iterations_type;
   typedef max_root_iterations<> max_root_iterations_type;
};

template <class Policy,
          class A1 = default_policy,
          class A2 = default_policy,
          class A3 = default_policy,
          class A4 = default_policy,
          class A5 = default_policy,
          class A6 = default_policy,
          class A7 = default_policy,
          class A8 = default_policy,
          class A9 = default_policy,
          class A10 = default_policy,
          class A11 = default_policy,
          class A12 = default_policy,
          class A13 = default_policy>
struct normalise
{
private:
   typedef mpl::list<A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13> arg_list;
   typedef typename detail::find_arg<arg_list, is_domain_error<mpl::_1>, typename Policy::domain_error_type >::type domain_error_type;
   typedef typename detail::find_arg<arg_list, is_pole_error<mpl::_1>, typename Policy::pole_error_type >::type pole_error_type;
   typedef typename detail::find_arg<arg_list, is_overflow_error<mpl::_1>, typename Policy::overflow_error_type >::type overflow_error_type;
   typedef typename detail::find_arg<arg_list, is_underflow_error<mpl::_1>, typename Policy::underflow_error_type >::type underflow_error_type;
   typedef typename detail::find_arg<arg_list, is_denorm_error<mpl::_1>, typename Policy::denorm_error_type >::type denorm_error_type;
   typedef typename detail::find_arg<arg_list, is_evaluation_error<mpl::_1>, typename Policy::evaluation_error_type >::type evaluation_error_type;
   typedef typename detail::find_arg<arg_list, is_rounding_error<mpl::_1>, typename Policy::rounding_error_type >::type rounding_error_type;
   typedef typename detail::find_arg<arg_list, is_indeterminate_result_error<mpl::_1>, typename Policy::indeterminate_result_error_type >::type indeterminate_result_error_type;



   typedef typename detail::find_arg<arg_list, is_digits10<mpl::_1>, digits10<> >::type digits10_type;
   typedef typename detail::find_arg<arg_list, is_digits2<mpl::_1>, typename Policy::precision_type >::type bits_precision_type;
   typedef typename detail::precision<digits10_type, bits_precision_type>::type precision_type;



   typedef typename detail::find_arg<arg_list, is_promote_float<mpl::_1>, typename Policy::promote_float_type >::type promote_float_type;
   typedef typename detail::find_arg<arg_list, is_promote_double<mpl::_1>, typename Policy::promote_double_type >::type promote_double_type;



   typedef typename detail::find_arg<arg_list, is_discrete_quantile<mpl::_1>, typename Policy::discrete_quantile_type >::type discrete_quantile_type;



   typedef typename detail::find_arg<arg_list, is_assert_undefined<mpl::_1>, typename Policy::assert_undefined_type >::type assert_undefined_type;



   typedef typename detail::find_arg<arg_list, is_max_series_iterations<mpl::_1>, typename Policy::max_series_iterations_type>::type max_series_iterations_type;
   typedef typename detail::find_arg<arg_list, is_max_root_iterations<mpl::_1>, typename Policy::max_root_iterations_type>::type max_root_iterations_type;



   typedef mpl::vector<
      domain_error_type,
      pole_error_type,
      overflow_error_type,
      underflow_error_type,
      denorm_error_type,
      evaluation_error_type,
      rounding_error_type,
      indeterminate_result_error_type,
      precision_type,
      promote_float_type,
      promote_double_type,
      discrete_quantile_type,
      assert_undefined_type,
      max_series_iterations_type,
      max_root_iterations_type> result_list;



   typedef typename mpl::remove_if<result_list, detail::is_default_policy<mpl::_> >::type reduced_list;



   typedef typename detail::append_N<reduced_list, default_policy, (14 - ::boost::mpl::size<reduced_list>::value)>::type result_type;
public:
   typedef policy<
      typename mpl::at<result_type, mpl::int_<0> >::type,
      typename mpl::at<result_type, mpl::int_<1> >::type,
      typename mpl::at<result_type, mpl::int_<2> >::type,
      typename mpl::at<result_type, mpl::int_<3> >::type,
      typename mpl::at<result_type, mpl::int_<4> >::type,
      typename mpl::at<result_type, mpl::int_<5> >::type,
      typename mpl::at<result_type, mpl::int_<6> >::type,
      typename mpl::at<result_type, mpl::int_<7> >::type,
      typename mpl::at<result_type, mpl::int_<8> >::type,
      typename mpl::at<result_type, mpl::int_<9> >::type,
      typename mpl::at<result_type, mpl::int_<10> >::type,
      typename mpl::at<result_type, mpl::int_<11> >::type,
      typename mpl::at<result_type, mpl::int_<12> >::type > type;
};



template <>
struct normalise<policy<>,
          promote_float<false>,
          promote_double<false>,
          discrete_quantile<>,
          assert_undefined<>,
          default_policy,
          default_policy,
          default_policy,
          default_policy,
          default_policy,
          default_policy,
          default_policy>
{
   typedef policy<detail::forwarding_arg1, detail::forwarding_arg2> type;
};

template <>
struct normalise<policy<detail::forwarding_arg1, detail::forwarding_arg2>,
          promote_float<false>,
          promote_double<false>,
          discrete_quantile<>,
          assert_undefined<>,
          default_policy,
          default_policy,
          default_policy,
          default_policy,
          default_policy,
          default_policy,
          default_policy>
{
   typedef policy<detail::forwarding_arg1, detail::forwarding_arg2> type;
};

inline constexpr policy<> make_policy() noexcept
{ return policy<>(); }

template <class A1>
inline constexpr typename normalise<policy<>, A1>::type make_policy(const A1&) noexcept
{
   typedef typename normalise<policy<>, A1>::type result_type;
   return result_type();
}

template <class A1, class A2>
inline constexpr typename normalise<policy<>, A1, A2>::type make_policy(const A1&, const A2&) noexcept
{
   typedef typename normalise<policy<>, A1, A2>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3>
inline constexpr typename normalise<policy<>, A1, A2, A3>::type make_policy(const A1&, const A2&, const A3&) noexcept
{
   typedef typename normalise<policy<>, A1, A2, A3>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4>
inline constexpr typename normalise<policy<>, A1, A2, A3, A4>::type make_policy(const A1&, const A2&, const A3&, const A4&) noexcept
{
   typedef typename normalise<policy<>, A1, A2, A3, A4>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4, class A5>
inline constexpr typename normalise<policy<>, A1, A2, A3, A4, A5>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&) noexcept
{
   typedef typename normalise<policy<>, A1, A2, A3, A4, A5>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4, class A5, class A6>
inline constexpr typename normalise<policy<>, A1, A2, A3, A4, A5, A6>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&) noexcept
{
   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4, class A5, class A6, class A7>
inline constexpr typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&, const A7&) noexcept
{
   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
inline constexpr typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&, const A7&, const A8&) noexcept
{
   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
inline constexpr typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&, const A7&, const A8&, const A9&) noexcept
{
   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
inline constexpr typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&, const A7&, const A8&, const A9&, const A10&) noexcept
{
   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
inline constexpr typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&, const A7&, const A8&, const A9&, const A10&, const A11&) noexcept
{
   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>::type result_type;
   return result_type();
}




template <class Real, class Policy>
struct evaluation
{
   typedef Real type;
};

template <class Policy>
struct evaluation<float, Policy>
{
   typedef typename mpl::if_<typename Policy::promote_float_type, double, float>::type type;
};

template <class Policy>
struct evaluation<double, Policy>
{
   typedef typename mpl::if_<typename Policy::promote_double_type, long double, double>::type type;
};
template <class Real, class Policy>
struct precision
{
   static_assert((::std::numeric_limits<Real>::radix == 2) || ((::std::numeric_limits<Real>::is_specialized == 0) || (::std::numeric_limits<Real>::digits == 0)), "(::std::numeric_limits<Real>::radix == 2) || ((::std::numeric_limits<Real>::is_specialized == 0) || (::std::numeric_limits<Real>::digits == 0))");

   typedef typename Policy::precision_type precision_type;
   typedef typename mpl::if_c<
      ((::std::numeric_limits<Real>::is_specialized == 0) || (::std::numeric_limits<Real>::digits == 0)),

      precision_type,
      typename mpl::if_c<
         ((::std::numeric_limits<Real>::digits <= precision_type::value)
         || (Policy::precision_type::value <= 0)),

         digits2< ::std::numeric_limits<Real>::digits>,

         precision_type
      >::type
   >::type type;
};
namespace detail{

template <class T, class Policy>
inline constexpr int digits_imp(mpl::true_ const&) noexcept
{

   static_assert(::std::numeric_limits<T>::is_specialized, "::std::numeric_limits<T>::is_specialized");



   typedef typename boost::math::policies::precision<T, Policy>::type p_t;
   return p_t::value;
}

template <class T, class Policy>
inline constexpr int digits_imp(mpl::false_ const&) noexcept
{
   return tools::digits<T>();
}

}

template <class T, class Policy>
inline constexpr int digits() noexcept
{
   typedef mpl::bool_< std::numeric_limits<T>::is_specialized > tag_type;
   return detail::digits_imp<T, Policy>(tag_type());
}
template <class T, class Policy>
inline constexpr int digits_base10() noexcept
{
   return boost::math::policies::digits<T, Policy>() * 301 / 1000L;
}

template <class Policy>
inline constexpr unsigned long get_max_series_iterations() noexcept
{
   typedef typename Policy::max_series_iterations_type iter_type;
   return iter_type::value;
}

template <class Policy>
inline constexpr unsigned long get_max_root_iterations() noexcept
{
   typedef typename Policy::max_root_iterations_type iter_type;
   return iter_type::value;
}

namespace detail{

template <class T, class Digits, class Small, class Default>
struct series_factor_calc
{
   static T get() noexcept(std::is_floating_point<T>::value)
   {
      return ldexp(T(1.0), 1 - Digits::value);
   }
};

template <class T, class Digits>
struct series_factor_calc<T, Digits, mpl::true_, mpl::true_>
{
   static constexpr T get() noexcept(std::is_floating_point<T>::value)
   {
      return boost::math::tools::epsilon<T>();
   }
};
template <class T, class Digits>
struct series_factor_calc<T, Digits, mpl::true_, mpl::false_>
{
   static constexpr T get() noexcept(std::is_floating_point<T>::value)
   {
      return 1 / static_cast<T>(static_cast<boost::uintmax_t>(1u) << (Digits::value - 1));
   }
};
template <class T, class Digits>
struct series_factor_calc<T, Digits, mpl::false_, mpl::true_>
{
   static constexpr T get() noexcept(std::is_floating_point<T>::value)
   {
      return boost::math::tools::epsilon<T>();
   }
};

template <class T, class Policy>
inline constexpr T get_epsilon_imp(mpl::true_ const&) noexcept(std::is_floating_point<T>::value)
{

   static_assert(::std::numeric_limits<T>::is_specialized, "::std::numeric_limits<T>::is_specialized");
   static_assert(::std::numeric_limits<T>::radix == 2, "::std::numeric_limits<T>::radix == 2");




   typedef typename boost::math::policies::precision<T, Policy>::type p_t;
   typedef mpl::bool_<p_t::value <= std::numeric_limits<boost::uintmax_t>::digits> is_small_int;
   typedef mpl::bool_<p_t::value >= std::numeric_limits<T>::digits> is_default_value;
   return series_factor_calc<T, p_t, is_small_int, is_default_value>::get();
}

template <class T, class Policy>
inline constexpr T get_epsilon_imp(mpl::false_ const&) noexcept(std::is_floating_point<T>::value)
{
   return tools::epsilon<T>();
}

}

template <class T, class Policy>
inline constexpr T get_epsilon() noexcept(std::is_floating_point<T>::value)
{
   typedef mpl::bool_< (std::numeric_limits<T>::is_specialized && (std::numeric_limits<T>::radix == 2)) > tag_type;
   return detail::get_epsilon_imp<T, Policy>(tag_type());
}

namespace detail{

template <class A1,
          class A2,
          class A3,
          class A4,
          class A5,
          class A6,
          class A7,
          class A8,
          class A9,
          class A10,
          class A11>
char test_is_policy(const policy<A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11>*);
double test_is_policy(...);

template <class P>
struct is_policy_imp
{
   static const bool value = (sizeof(::boost::math::policies::detail::test_is_policy(static_cast<P*>(0))) == 1);
};

}

template <class P>
struct is_policy : public mpl::bool_< ::boost::math::policies::detail::is_policy_imp<P>::value> {};




template <class Policy>
struct constructor_error_check
{
   typedef typename Policy::domain_error_type domain_error_type;
   typedef typename mpl::if_c<
      (domain_error_type::value == throw_on_error) || (domain_error_type::value == user_error) || (domain_error_type::value == errno_on_error),
      mpl::true_,
      mpl::false_>::type type;
};

template <class Policy>
struct method_error_check
{
   typedef typename Policy::domain_error_type domain_error_type;
   typedef typename mpl::if_c<
      (domain_error_type::value == throw_on_error) && (domain_error_type::value != user_error),
      mpl::false_,
      mpl::true_>::type type;
};



template <class Policy>
struct is_noexcept_error_policy
{
   typedef typename Policy::domain_error_type t1;
   typedef typename Policy::pole_error_type t2;
   typedef typename Policy::overflow_error_type t3;
   typedef typename Policy::underflow_error_type t4;
   typedef typename Policy::denorm_error_type t5;
   typedef typename Policy::evaluation_error_type t6;
   typedef typename Policy::rounding_error_type t7;
   typedef typename Policy::indeterminate_result_error_type t8;

   static const bool value = ((t1::value != throw_on_error) && (t1::value != user_error) && (t2::value != throw_on_error) && (t2::value != user_error) && (t3::value != throw_on_error) && (t3::value != user_error) && (t4::value != throw_on_error) && (t4::value != user_error) && (t5::value != throw_on_error) && (t5::value != user_error) && (t6::value != throw_on_error) && (t6::value != user_error) && (t7::value != throw_on_error) && (t7::value != user_error) && (t8::value != throw_on_error) && (t8::value != user_error));
};

}}}





namespace boost
{
   namespace math
   {


   template <class RT1, class RT2>
   typename tools::promote_args<RT1, RT2>::type
         beta(RT1 a, RT2 b);

   template <class RT1, class RT2, class A>
   typename tools::promote_args<RT1, RT2, A>::type
         beta(RT1 a, RT2 b, A x);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         beta(RT1 a, RT2 b, RT3 x, const Policy& pol);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         betac(RT1 a, RT2 b, RT3 x);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         betac(RT1 a, RT2 b, RT3 x, const Policy& pol);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta(RT1 a, RT2 b, RT3 x);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta(RT1 a, RT2 b, RT3 x, const Policy& pol);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac(RT1 a, RT2 b, RT3 x);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac(RT1 a, RT2 b, RT3 x, const Policy& pol);

   template <class T1, class T2, class T3, class T4>
   typename tools::promote_args<T1, T2, T3, T4>::type
         ibeta_inv(T1 a, T2 b, T3 p, T4* py);

   template <class T1, class T2, class T3, class T4, class Policy>
   typename tools::promote_args<T1, T2, T3, T4>::type
         ibeta_inv(T1 a, T2 b, T3 p, T4* py, const Policy& pol);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_inv(RT1 a, RT2 b, RT3 p);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_inv(RT1 a, RT2 b, RT3 p, const Policy&);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_inva(RT1 a, RT2 b, RT3 p);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_inva(RT1 a, RT2 b, RT3 p, const Policy&);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_invb(RT1 a, RT2 b, RT3 p);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_invb(RT1 a, RT2 b, RT3 p, const Policy&);

   template <class T1, class T2, class T3, class T4>
   typename tools::promote_args<T1, T2, T3, T4>::type
         ibetac_inv(T1 a, T2 b, T3 q, T4* py);

   template <class T1, class T2, class T3, class T4, class Policy>
   typename tools::promote_args<T1, T2, T3, T4>::type
         ibetac_inv(T1 a, T2 b, T3 q, T4* py, const Policy& pol);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac_inv(RT1 a, RT2 b, RT3 q);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac_inv(RT1 a, RT2 b, RT3 q, const Policy&);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac_inva(RT1 a, RT2 b, RT3 q);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac_inva(RT1 a, RT2 b, RT3 q, const Policy&);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac_invb(RT1 a, RT2 b, RT3 q);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac_invb(RT1 a, RT2 b, RT3 q, const Policy&);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_derivative(RT1 a, RT2 b, RT3 x);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_derivative(RT1 a, RT2 b, RT3 x, const Policy& pol);


   template <class T, class Policy>
   T binomial_coefficient(unsigned n, unsigned k, const Policy& pol);
   template <class T>
   T binomial_coefficient(unsigned n, unsigned k);


   template <class RT>
   typename tools::promote_args<RT>::type erf(RT z);
   template <class RT, class Policy>
   typename tools::promote_args<RT>::type erf(RT z, const Policy&);

   template <class RT>
   typename tools::promote_args<RT>::type erfc(RT z);
   template <class RT, class Policy>
   typename tools::promote_args<RT>::type erfc(RT z, const Policy&);

   template <class RT>
   typename tools::promote_args<RT>::type erf_inv(RT z);
   template <class RT, class Policy>
   typename tools::promote_args<RT>::type erf_inv(RT z, const Policy& pol);

   template <class RT>
   typename tools::promote_args<RT>::type erfc_inv(RT z);
   template <class RT, class Policy>
   typename tools::promote_args<RT>::type erfc_inv(RT z, const Policy& pol);


   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
         legendre_next(unsigned l, T1 x, T2 Pl, T3 Plm1);

   template <class T>
   typename tools::promote_args<T>::type
         legendre_p(int l, T x);
   template <class T>
   typename tools::promote_args<T>::type
          legendre_p_prime(int l, T x);


   template <class T, class Policy>
   inline std::vector<T> legendre_p_zeros(int l, const Policy& pol);

   template <class T>
   inline std::vector<T> legendre_p_zeros(int l);


   template <class T, class Policy>
   typename boost::enable_if_c<policies::is_policy<Policy>::value, typename tools::promote_args<T>::type>::type
         legendre_p(int l, T x, const Policy& pol);
   template <class T, class Policy>
   inline typename boost::enable_if_c<policies::is_policy<Policy>::value, typename tools::promote_args<T>::type>::type
      legendre_p_prime(int l, T x, const Policy& pol);

   template <class T>
   typename tools::promote_args<T>::type
         legendre_q(unsigned l, T x);

   template <class T, class Policy>
   typename boost::enable_if_c<policies::is_policy<Policy>::value, typename tools::promote_args<T>::type>::type
         legendre_q(unsigned l, T x, const Policy& pol);

   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
         legendre_next(unsigned l, unsigned m, T1 x, T2 Pl, T3 Plm1);

   template <class T>
   typename tools::promote_args<T>::type
         legendre_p(int l, int m, T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type
         legendre_p(int l, int m, T x, const Policy& pol);

   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
         laguerre_next(unsigned n, T1 x, T2 Ln, T3 Lnm1);

   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
      laguerre_next(unsigned n, unsigned l, T1 x, T2 Pl, T3 Plm1);

   template <class T>
   typename tools::promote_args<T>::type
      laguerre(unsigned n, T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type
      laguerre(unsigned n, unsigned m, T x, const Policy& pol);

   template <class T1, class T2>
   struct laguerre_result
   {
      typedef typename mpl::if_<
         policies::is_policy<T2>,
         typename tools::promote_args<T1>::type,
         typename tools::promote_args<T2>::type
      >::type type;
   };

   template <class T1, class T2>
   typename laguerre_result<T1, T2>::type
      laguerre(unsigned n, T1 m, T2 x);

   template <class T>
   typename tools::promote_args<T>::type
      hermite(unsigned n, T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type
      hermite(unsigned n, T x, const Policy& pol);

   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
      hermite_next(unsigned n, T1 x, T2 Hn, T3 Hnm1);

   template<class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type chebyshev_next(T1 const & x, T2 const & Tn, T3 const & Tn_1);

   template <class Real, class Policy>
   typename tools::promote_args<Real>::type
      chebyshev_t(unsigned n, Real const & x, const Policy&);
   template<class Real>
   typename tools::promote_args<Real>::type chebyshev_t(unsigned n, Real const & x);

   template <class Real, class Policy>
   typename tools::promote_args<Real>::type
      chebyshev_u(unsigned n, Real const & x, const Policy&);
   template<class Real>
   typename tools::promote_args<Real>::type chebyshev_u(unsigned n, Real const & x);

   template <class Real, class Policy>
   typename tools::promote_args<Real>::type
      chebyshev_t_prime(unsigned n, Real const & x, const Policy&);
   template<class Real>
   typename tools::promote_args<Real>::type chebyshev_t_prime(unsigned n, Real const & x);

   template<class Real, class T2>
   Real chebyshev_clenshaw_recurrence(const Real* const c, size_t length, const T2& x);

   template <class T1, class T2>
   std::complex<typename tools::promote_args<T1, T2>::type>
         spherical_harmonic(unsigned n, int m, T1 theta, T2 phi);

   template <class T1, class T2, class Policy>
   std::complex<typename tools::promote_args<T1, T2>::type>
      spherical_harmonic(unsigned n, int m, T1 theta, T2 phi, const Policy& pol);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type
         spherical_harmonic_r(unsigned n, int m, T1 theta, T2 phi);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type
      spherical_harmonic_r(unsigned n, int m, T1 theta, T2 phi, const Policy& pol);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type
         spherical_harmonic_i(unsigned n, int m, T1 theta, T2 phi);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type
      spherical_harmonic_i(unsigned n, int m, T1 theta, T2 phi, const Policy& pol);


   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
         ellint_rf(T1 x, T2 y, T3 z);

   template <class T1, class T2, class T3, class Policy>
   typename tools::promote_args<T1, T2, T3>::type
         ellint_rf(T1 x, T2 y, T3 z, const Policy& pol);

   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
         ellint_rd(T1 x, T2 y, T3 z);

   template <class T1, class T2, class T3, class Policy>
   typename tools::promote_args<T1, T2, T3>::type
         ellint_rd(T1 x, T2 y, T3 z, const Policy& pol);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type
         ellint_rc(T1 x, T2 y);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type
         ellint_rc(T1 x, T2 y, const Policy& pol);

   template <class T1, class T2, class T3, class T4>
   typename tools::promote_args<T1, T2, T3, T4>::type
         ellint_rj(T1 x, T2 y, T3 z, T4 p);

   template <class T1, class T2, class T3, class T4, class Policy>
   typename tools::promote_args<T1, T2, T3, T4>::type
         ellint_rj(T1 x, T2 y, T3 z, T4 p, const Policy& pol);

   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
      ellint_rg(T1 x, T2 y, T3 z);

   template <class T1, class T2, class T3, class Policy>
   typename tools::promote_args<T1, T2, T3>::type
      ellint_rg(T1 x, T2 y, T3 z, const Policy& pol);

   template <typename T>
   typename tools::promote_args<T>::type ellint_2(T k);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type ellint_2(T1 k, T2 phi);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type ellint_2(T1 k, T2 phi, const Policy& pol);

   template <typename T>
   typename tools::promote_args<T>::type ellint_1(T k);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type ellint_1(T1 k, T2 phi);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type ellint_1(T1 k, T2 phi, const Policy& pol);

   template <typename T>
   typename tools::promote_args<T>::type ellint_d(T k);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type ellint_d(T1 k, T2 phi);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type ellint_d(T1 k, T2 phi, const Policy& pol);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type jacobi_zeta(T1 k, T2 phi);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type jacobi_zeta(T1 k, T2 phi, const Policy& pol);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type heuman_lambda(T1 k, T2 phi);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type heuman_lambda(T1 k, T2 phi, const Policy& pol);

   namespace detail{

   template <class T, class U, class V>
   struct ellint_3_result
   {
      typedef typename mpl::if_<
         policies::is_policy<V>,
         typename tools::promote_args<T, U>::type,
         typename tools::promote_args<T, U, V>::type
      >::type type;
   };

   }


   template <class T1, class T2, class T3>
   typename detail::ellint_3_result<T1, T2, T3>::type ellint_3(T1 k, T2 v, T3 phi);

   template <class T1, class T2, class T3, class Policy>
   typename tools::promote_args<T1, T2, T3>::type ellint_3(T1 k, T2 v, T3 phi, const Policy& pol);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type ellint_3(T1 k, T2 v);



   template <class RT>
   struct max_factorial;
   template <class RT>
   RT factorial(unsigned int);
   template <class RT, class Policy>
   RT factorial(unsigned int, const Policy& pol);
   template <class RT>
   RT unchecked_factorial(unsigned int );
   template <class RT>
   RT double_factorial(unsigned i);
   template <class RT, class Policy>
   RT double_factorial(unsigned i, const Policy& pol);

   template <class RT>
   typename tools::promote_args<RT>::type falling_factorial(RT x, unsigned n);

   template <class RT, class Policy>
   typename tools::promote_args<RT>::type falling_factorial(RT x, unsigned n, const Policy& pol);

   template <class RT>
   typename tools::promote_args<RT>::type rising_factorial(RT x, int n);

   template <class RT, class Policy>
   typename tools::promote_args<RT>::type rising_factorial(RT x, int n, const Policy& pol);


   template <class RT>
   typename tools::promote_args<RT>::type tgamma(RT z);

   template <class RT>
   typename tools::promote_args<RT>::type tgamma1pm1(RT z);

   template <class RT, class Policy>
   typename tools::promote_args<RT>::type tgamma1pm1(RT z, const Policy& pol);

   template <class RT1, class RT2>
   typename tools::promote_args<RT1, RT2>::type tgamma(RT1 a, RT2 z);

   template <class RT1, class RT2, class Policy>
   typename tools::promote_args<RT1, RT2>::type tgamma(RT1 a, RT2 z, const Policy& pol);

   template <class RT>
   typename tools::promote_args<RT>::type lgamma(RT z, int* sign);

   template <class RT, class Policy>
   typename tools::promote_args<RT>::type lgamma(RT z, int* sign, const Policy& pol);

   template <class RT>
   typename tools::promote_args<RT>::type lgamma(RT x);

   template <class RT, class Policy>
   typename tools::promote_args<RT>::type lgamma(RT x, const Policy& pol);

   template <class RT1, class RT2>
   typename tools::promote_args<RT1, RT2>::type tgamma_lower(RT1 a, RT2 z);

   template <class RT1, class RT2, class Policy>
   typename tools::promote_args<RT1, RT2>::type tgamma_lower(RT1 a, RT2 z, const Policy&);

   template <class RT1, class RT2>
   typename tools::promote_args<RT1, RT2>::type gamma_q(RT1 a, RT2 z);

   template <class RT1, class RT2, class Policy>
   typename tools::promote_args<RT1, RT2>::type gamma_q(RT1 a, RT2 z, const Policy&);

   template <class RT1, class RT2>
   typename tools::promote_args<RT1, RT2>::type gamma_p(RT1 a, RT2 z);

   template <class RT1, class RT2, class Policy>
   typename tools::promote_args<RT1, RT2>::type gamma_p(RT1 a, RT2 z, const Policy&);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type tgamma_delta_ratio(T1 z, T2 delta);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type tgamma_delta_ratio(T1 z, T2 delta, const Policy&);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type tgamma_ratio(T1 a, T2 b);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type tgamma_ratio(T1 a, T2 b, const Policy&);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type gamma_p_derivative(T1 a, T2 x);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type gamma_p_derivative(T1 a, T2 x, const Policy&);


   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type gamma_p_inv(T1 a, T2 p);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type gamma_p_inva(T1 a, T2 p, const Policy&);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type gamma_p_inva(T1 a, T2 p);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type gamma_p_inv(T1 a, T2 p, const Policy&);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type gamma_q_inv(T1 a, T2 q);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type gamma_q_inv(T1 a, T2 q, const Policy&);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type gamma_q_inva(T1 a, T2 q);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type gamma_q_inva(T1 a, T2 q, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type digamma(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type digamma(T x, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type trigamma(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type trigamma(T x, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type polygamma(int n, T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type polygamma(int n, T x, const Policy&);


   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type
         hypot(T1 x, T2 y);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type
         hypot(T1 x, T2 y, const Policy&);


   template <class RT>
   typename tools::promote_args<RT>::type cbrt(RT z);

   template <class RT, class Policy>
   typename tools::promote_args<RT>::type cbrt(RT z, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type log1p(T);

   template <class T, class Policy>
   typename tools::promote_args<T>::type log1p(T, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type log1pmx(T);

   template <class T, class Policy>
   typename tools::promote_args<T>::type log1pmx(T, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type expm1(T);

   template <class T, class Policy>
   typename tools::promote_args<T>::type expm1(T, const Policy&);


   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type
         powm1(const T1 a, const T2 z);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type
         powm1(const T1 a, const T2 z, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type sqrt1pm1(const T& val);

   template <class T, class Policy>
   typename tools::promote_args<T>::type sqrt1pm1(const T& val, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type sinc_pi(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type sinc_pi(T x, const Policy&);

   template <class T>
   typename tools::promote_args<T>::type sinhc_pi(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type sinhc_pi(T x, const Policy&);


   template<typename T>
   typename tools::promote_args<T>::type asinh(T x);

   template<typename T, class Policy>
   typename tools::promote_args<T>::type asinh(T x, const Policy&);

   template<typename T>
   typename tools::promote_args<T>::type acosh(T x);

   template<typename T, class Policy>
   typename tools::promote_args<T>::type acosh(T x, const Policy&);

   template<typename T>
   typename tools::promote_args<T>::type atanh(T x);

   template<typename T, class Policy>
   typename tools::promote_args<T>::type atanh(T x, const Policy&);

   namespace detail{

      typedef mpl::int_<0> bessel_no_int_tag;
      typedef mpl::int_<1> bessel_maybe_int_tag;
      typedef mpl::int_<2> bessel_int_tag;

      template <class T1, class T2, class Policy>
      struct bessel_traits
      {
         typedef typename mpl::if_<
            is_integral<T1>,
            typename tools::promote_args<T2>::type,
            typename tools::promote_args<T1, T2>::type
         >::type result_type;

         typedef typename policies::precision<result_type, Policy>::type precision_type;

         typedef typename mpl::if_<
            mpl::or_<
               mpl::less_equal<precision_type, mpl::int_<0> >,
               mpl::greater<precision_type, mpl::int_<64> > >,
            bessel_no_int_tag,
            typename mpl::if_<
               is_integral<T1>,
               bessel_int_tag,
               bessel_maybe_int_tag
            >::type
         >::type optimisation_tag;
         typedef typename mpl::if_<
            mpl::or_<
               mpl::less_equal<precision_type, mpl::int_<0> >,
               mpl::greater<precision_type, mpl::int_<113> > >,
            bessel_no_int_tag,
            typename mpl::if_<
               is_integral<T1>,
               bessel_int_tag,
               bessel_maybe_int_tag
            >::type
         >::type optimisation_tag128;
      };
   }


   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_bessel_j(T1 v, T2 x, const Policy& pol);
   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_bessel_j_prime(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_bessel_j(T1 v, T2 x);
   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_bessel_j_prime(T1 v, T2 x);

   template <class T, class Policy>
   typename detail::bessel_traits<T, T, Policy>::result_type sph_bessel(unsigned v, T x, const Policy& pol);
   template <class T, class Policy>
   typename detail::bessel_traits<T, T, Policy>::result_type sph_bessel_prime(unsigned v, T x, const Policy& pol);

   template <class T>
   typename detail::bessel_traits<T, T, policies::policy<> >::result_type sph_bessel(unsigned v, T x);
   template <class T>
   typename detail::bessel_traits<T, T, policies::policy<> >::result_type sph_bessel_prime(unsigned v, T x);

   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_bessel_i(T1 v, T2 x, const Policy& pol);
   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_bessel_i_prime(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_bessel_i(T1 v, T2 x);
   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_bessel_i_prime(T1 v, T2 x);

   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_bessel_k(T1 v, T2 x, const Policy& pol);
   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_bessel_k_prime(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_bessel_k(T1 v, T2 x);
   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_bessel_k_prime(T1 v, T2 x);

   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_neumann(T1 v, T2 x, const Policy& pol);
   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_neumann_prime(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_neumann(T1 v, T2 x);
   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_neumann_prime(T1 v, T2 x);

   template <class T, class Policy>
   typename detail::bessel_traits<T, T, Policy>::result_type sph_neumann(unsigned v, T x, const Policy& pol);
   template <class T, class Policy>
   typename detail::bessel_traits<T, T, Policy>::result_type sph_neumann_prime(unsigned v, T x, const Policy& pol);

   template <class T>
   typename detail::bessel_traits<T, T, policies::policy<> >::result_type sph_neumann(unsigned v, T x);
   template <class T>
   typename detail::bessel_traits<T, T, policies::policy<> >::result_type sph_neumann_prime(unsigned v, T x);

   template <class T, class Policy>
   typename detail::bessel_traits<T, T, Policy>::result_type cyl_bessel_j_zero(T v, int m, const Policy& pol);

   template <class T>
   typename detail::bessel_traits<T, T, policies::policy<> >::result_type cyl_bessel_j_zero(T v, int m);

   template <class T, class OutputIterator>
   OutputIterator cyl_bessel_j_zero(T v,
                          int start_index,
                          unsigned number_of_zeros,
                          OutputIterator out_it);

   template <class T, class OutputIterator, class Policy>
   OutputIterator cyl_bessel_j_zero(T v,
                          int start_index,
                          unsigned number_of_zeros,
                          OutputIterator out_it,
                          const Policy&);

   template <class T, class Policy>
   typename detail::bessel_traits<T, T, Policy>::result_type cyl_neumann_zero(T v, int m, const Policy& pol);

   template <class T>
   typename detail::bessel_traits<T, T, policies::policy<> >::result_type cyl_neumann_zero(T v, int m);

   template <class T, class OutputIterator>
   OutputIterator cyl_neumann_zero(T v,
                         int start_index,
                         unsigned number_of_zeros,
                         OutputIterator out_it);

   template <class T, class OutputIterator, class Policy>
   OutputIterator cyl_neumann_zero(T v,
                         int start_index,
                         unsigned number_of_zeros,
                         OutputIterator out_it,
                         const Policy&);

   template <class T1, class T2>
   std::complex<typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type> cyl_hankel_1(T1 v, T2 x);

   template <class T1, class T2, class Policy>
   std::complex<typename detail::bessel_traits<T1, T2, Policy>::result_type> cyl_hankel_1(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2, class Policy>
   std::complex<typename detail::bessel_traits<T1, T2, Policy>::result_type> cyl_hankel_2(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2>
   std::complex<typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type> cyl_hankel_2(T1 v, T2 x);

   template <class T1, class T2, class Policy>
   std::complex<typename detail::bessel_traits<T1, T2, Policy>::result_type> sph_hankel_1(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2>
   std::complex<typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type> sph_hankel_1(T1 v, T2 x);

   template <class T1, class T2, class Policy>
   std::complex<typename detail::bessel_traits<T1, T2, Policy>::result_type> sph_hankel_2(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2>
   std::complex<typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type> sph_hankel_2(T1 v, T2 x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type airy_ai(T x, const Policy&);

   template <class T>
   typename tools::promote_args<T>::type airy_ai(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type airy_bi(T x, const Policy&);

   template <class T>
   typename tools::promote_args<T>::type airy_bi(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type airy_ai_prime(T x, const Policy&);

   template <class T>
   typename tools::promote_args<T>::type airy_ai_prime(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type airy_bi_prime(T x, const Policy&);

   template <class T>
   typename tools::promote_args<T>::type airy_bi_prime(T x);

   template <class T>
   T airy_ai_zero(int m);
   template <class T, class Policy>
   T airy_ai_zero(int m, const Policy&);

   template <class OutputIterator>
   OutputIterator airy_ai_zero(
                     int start_index,
                     unsigned number_of_zeros,
                     OutputIterator out_it);
   template <class OutputIterator, class Policy>
   OutputIterator airy_ai_zero(
                     int start_index,
                     unsigned number_of_zeros,
                     OutputIterator out_it,
                     const Policy&);

   template <class T>
   T airy_bi_zero(int m);
   template <class T, class Policy>
   T airy_bi_zero(int m, const Policy&);

   template <class OutputIterator>
   OutputIterator airy_bi_zero(
                     int start_index,
                     unsigned number_of_zeros,
                     OutputIterator out_it);
   template <class OutputIterator, class Policy>
   OutputIterator airy_bi_zero(
                     int start_index,
                     unsigned number_of_zeros,
                     OutputIterator out_it,
                     const Policy&);

   template <class T, class Policy>
   typename tools::promote_args<T>::type sin_pi(T x, const Policy&);

   template <class T>
   typename tools::promote_args<T>::type sin_pi(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type cos_pi(T x, const Policy&);

   template <class T>
   typename tools::promote_args<T>::type cos_pi(T x);

   template <class T>
   int fpclassify (T t);

   template <class T>
   bool isfinite (T z);

   template <class T>
   bool isinf (T t);

   template <class T>
   bool isnan (T t);

   template <class T>
   bool isnormal (T t);

   template<class T>
   int signbit (T x);

   template <class T>
   int sign (const T& z);

   template <class T, class U>
   typename tools::promote_args_permissive<T, U>::type copysign (const T& x, const U& y);

   template <class T>
   typename tools::promote_args_permissive<T>::type changesign (const T& z);


   namespace detail{

   template <class T, class U>
   struct expint_result
   {
      typedef typename mpl::if_<
         policies::is_policy<U>,
         typename tools::promote_args<T>::type,
         typename tools::promote_args<U>::type
      >::type type;
   };

   }

   template <class T, class Policy>
   typename tools::promote_args<T>::type expint(unsigned n, T z, const Policy&);

   template <class T, class U>
   typename detail::expint_result<T, U>::type expint(T const z, U const u);

   template <class T>
   typename tools::promote_args<T>::type expint(T z);


   template <class T, class Policy>
   typename tools::promote_args<T>::type zeta(T s, const Policy&);


   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type owens_t(T1 h, T2 a, const Policy& pol);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type owens_t(T1 h, T2 a);


   template <class T, class U, class V, class Policy>
   typename tools::promote_args<T, U, V>::type jacobi_elliptic(T k, U theta, V* pcn, V* pdn, const Policy&);

   template <class T, class U, class V>
   typename tools::promote_args<T, U, V>::type jacobi_elliptic(T k, U theta, V* pcn = 0, V* pdn = 0);

   template <class U, class T, class Policy>
   typename tools::promote_args<T, U>::type jacobi_sn(U k, T theta, const Policy& pol);

   template <class U, class T>
   typename tools::promote_args<T, U>::type jacobi_sn(U k, T theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_cn(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_cn(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_dn(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_dn(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_cd(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_cd(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_dc(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_dc(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_ns(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_ns(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_sd(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_sd(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_ds(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_ds(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_nc(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_nc(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_nd(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_nd(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_sc(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_sc(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_cs(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_cs(T k, U theta);


   template <class T>
   typename tools::promote_args<T>::type zeta(T s);


   template <int N, typename T, class Policy>
   typename tools::promote_args<T>::type pow(T base, const Policy& policy);

   template <int N, typename T>
   typename tools::promote_args<T>::type pow(T base);


   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type nextafter(const T&, const U&, const Policy&);
   template <class T, class U>
   typename tools::promote_args<T, U>::type nextafter(const T&, const U&);
   template <class T, class Policy>
   typename tools::promote_args<T>::type float_next(const T&, const Policy&);
   template <class T>
   typename tools::promote_args<T>::type float_next(const T&);
   template <class T, class Policy>
   typename tools::promote_args<T>::type float_prior(const T&, const Policy&);
   template <class T>
   typename tools::promote_args<T>::type float_prior(const T&);
   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type float_distance(const T&, const U&, const Policy&);
   template <class T, class U>
   typename tools::promote_args<T, U>::type float_distance(const T&, const U&);
   template <class T, class Policy>
   typename tools::promote_args<T>::type float_advance(T val, int distance, const Policy& pol);
   template <class T>
   typename tools::promote_args<T>::type float_advance(const T& val, int distance);

   template <class T, class Policy>
   typename tools::promote_args<T>::type ulp(const T& val, const Policy& pol);
   template <class T>
   typename tools::promote_args<T>::type ulp(const T& val);

   template <class T, class U>
   typename tools::promote_args<T, U>::type relative_difference(const T&, const U&);
   template <class T, class U>
   typename tools::promote_args<T, U>::type epsilon_difference(const T&, const U&);

   template<class T>
   constexpr T unchecked_bernoulli_b2n(const std::size_t n);
   template <class T, class Policy>
   T bernoulli_b2n(const int i, const Policy &pol);
   template <class T>
   T bernoulli_b2n(const int i);
   template <class T, class OutputIterator, class Policy>
   OutputIterator bernoulli_b2n(const int start_index,
                                       const unsigned number_of_bernoullis_b2n,
                                       OutputIterator out_it,
                                       const Policy& pol);
   template <class T, class OutputIterator>
   OutputIterator bernoulli_b2n(const int start_index,
                                       const unsigned number_of_bernoullis_b2n,
                                       OutputIterator out_it);
   template <class T, class Policy>
   T tangent_t2n(const int i, const Policy &pol);
   template <class T>
   T tangent_t2n(const int i);
   template <class T, class OutputIterator, class Policy>
   OutputIterator tangent_t2n(const int start_index,
                                       const unsigned number_of_bernoullis_b2n,
                                       OutputIterator out_it,
                                       const Policy& pol);
   template <class T, class OutputIterator>
   OutputIterator tangent_t2n(const int start_index,
                                       const unsigned number_of_bernoullis_b2n,
                                       OutputIterator out_it);


   template <class T, class Policy>
   typename boost::math::tools::promote_args<T>::type lambert_w0(T z, const Policy& pol);
   template <class T>
   typename boost::math::tools::promote_args<T>::type lambert_w0(T z);
   template <class T, class Policy>
   typename boost::math::tools::promote_args<T>::type lambert_wm1(T z, const Policy& pol);
   template <class T>
   typename boost::math::tools::promote_args<T>::type lambert_wm1(T z);
   template <class T, class Policy>
   typename boost::math::tools::promote_args<T>::type lambert_w0_prime(T z, const Policy& pol);
   template <class T>
   typename boost::math::tools::promote_args<T>::type lambert_w0_prime(T z);
   template <class T, class Policy>
   typename boost::math::tools::promote_args<T>::type lambert_wm1_prime(T z, const Policy& pol);
   template <class T>
   typename boost::math::tools::promote_args<T>::type lambert_wm1_prime(T z);




    }
}
namespace boost {
namespace math {
namespace detail {
struct native_tag {};
template <bool has_limits>
struct generic_tag {};
struct ieee_tag {};
struct ieee_copy_all_bits_tag : public ieee_tag {};
struct ieee_copy_leading_bits_tag : public ieee_tag {};
struct unknown_precision{};
struct single_precision {};
struct double_precision {};
struct extended_double_precision {};



template<class T> struct fp_traits_native
{
    typedef native_tag method;
};



template<class T, class U> struct fp_traits_non_native
{

   typedef generic_tag<std::numeric_limits<T>::is_specialized> method;



};
template<> struct fp_traits_non_native<float, single_precision>
{
    typedef ieee_copy_all_bits_tag method;

    static const uint32_t sign = 0x80000000u;
    static const uint32_t exponent = 0x7f800000;
    static const uint32_t flag = 0x00000000;
    static const uint32_t significand = 0x007fffff;

    typedef uint32_t bits;
    static void get_bits(float x, uint32_t& a) { std::memcpy(&a, &x, 4); }
    static void set_bits(float& x, uint32_t a) { std::memcpy(&x, &a, 4); }
};
template<> struct fp_traits_non_native<double, double_precision>
{
    typedef ieee_copy_all_bits_tag method;

    static const uint64_t sign = ((uint64_t)0x80000000u) << 32;
    static const uint64_t exponent = ((uint64_t)0x7ff00000) << 32;
    static const uint64_t flag = 0;
    static const uint64_t significand
        = (((uint64_t)0x000fffff) << 32) + ((uint64_t)0xffffffffu);

    typedef uint64_t bits;
    static void get_bits(double x, uint64_t& a) { std::memcpy(&a, &x, 8); }
    static void set_bits(double& x, uint64_t a) { std::memcpy(&x, &a, 8); }
};
template<> struct fp_traits_non_native<long double, double_precision>
{
    typedef ieee_copy_all_bits_tag method;

    static const uint64_t sign = (uint64_t)0x80000000u << 32;
    static const uint64_t exponent = (uint64_t)0x7ff00000 << 32;
    static const uint64_t flag = 0;
    static const uint64_t significand
        = ((uint64_t)0x000fffff << 32) + (uint64_t)0xffffffffu;

    typedef uint64_t bits;
    static void get_bits(long double x, uint64_t& a) { std::memcpy(&a, &x, 8); }
    static void set_bits(long double& x, uint64_t a) { std::memcpy(&x, &a, 8); }
};
template<>
struct fp_traits_non_native<long double, extended_double_precision>
{
    typedef ieee_copy_leading_bits_tag method;

    static const uint32_t sign = 0x80000000u;
    static const uint32_t exponent = 0x7fff0000;
    static const uint32_t flag = 0x00008000;
    static const uint32_t significand = 0x00007fff;

    typedef uint32_t bits;

    static void get_bits(long double x, uint32_t& a)
    {
        std::memcpy(&a, reinterpret_cast<const unsigned char*>(&x) + 6, 4);
    }

    static void set_bits(long double& x, uint32_t a)
    {
        std::memcpy(reinterpret_cast<unsigned char*>(&x) + 6, &a, 4);
    }
};
template<int n, bool fp> struct size_to_precision
{
   typedef unknown_precision type;
};

template<> struct size_to_precision<4, true>
{
    typedef single_precision type;
};

template<> struct size_to_precision<8, true>
{
    typedef double_precision type;
};

template<> struct size_to_precision<10, true>
{
    typedef extended_double_precision type;
};

template<> struct size_to_precision<12, true>
{
    typedef extended_double_precision type;
};

template<> struct size_to_precision<16, true>
{
    typedef extended_double_precision type;
};






template <class T>
struct select_native
{
    typedef typename size_to_precision<sizeof(T), ::boost::is_floating_point<T>::value>::type precision;
    typedef fp_traits_non_native<T, precision> type;
};
template<>
struct select_native<float>
{
    typedef fp_traits_native<float> type;
};
template<>
struct select_native<double>
{
    typedef fp_traits_native<double> type;
};
template<>
struct select_native<long double>
{
    typedef fp_traits_native<long double> type;
};
template<class T> struct fp_traits
{
    typedef typename size_to_precision<sizeof(T), ::boost::is_floating_point<T>::value>::type precision;

    typedef typename select_native<T>::type type;



    typedef fp_traits_non_native<T, precision> sign_change_type;
};



}
}
}

namespace boost{ namespace math{

namespace detail {




    template<class T>
    inline int signbit_impl(T x, native_tag const&)
    {
        return (std::signbit)(x) ? 1 : 0;
    }





    template<class T>
    inline int signbit_impl(T x, generic_tag<true> const&)
    {
        return x < 0;
    }

    template<class T>
    inline int signbit_impl(T x, generic_tag<false> const&)
    {
        return x < 0;
    }
    template<class T>
    inline int signbit_impl(T x, ieee_copy_all_bits_tag const&)
    {
        typedef typename fp_traits<T>::type traits;

        typename traits::bits a;
        traits::get_bits(x,a);
        return a & traits::sign ? 1 : 0;
    }

    template<class T>
    inline int signbit_impl(T x, ieee_copy_leading_bits_tag const&)
    {
        typedef typename fp_traits<T>::type traits;

        typename traits::bits a;
        traits::get_bits(x,a);

        return a & traits::sign ? 1 : 0;
    }






    template<class T>
    inline T (changesign_impl)(T x, generic_tag<true> const&)
    {
        return -x;
    }

    template<class T>
    inline T (changesign_impl)(T x, generic_tag<false> const&)
    {
        return -x;
    }
    template<class T>
    inline T changesign_impl(T x, ieee_copy_all_bits_tag const&)
    {
        typedef typename fp_traits<T>::sign_change_type traits;

        typename traits::bits a;
        traits::get_bits(x,a);
        a ^= traits::sign;
        traits::set_bits(x,a);
        return x;
    }

    template<class T>
    inline T (changesign_impl)(T x, ieee_copy_leading_bits_tag const&)
    {
        typedef typename fp_traits<T>::sign_change_type traits;

        typename traits::bits a;
        traits::get_bits(x,a);
        a ^= traits::sign;
        traits::set_bits(x,a);
        return x;
    }


}

template<class T> int (signbit)(T x)
{
   typedef typename detail::fp_traits<T>::type traits;
   typedef typename traits::method method;

   typedef typename tools::promote_args_permissive<T>::type result_type;
   return detail::signbit_impl(static_cast<result_type>(x), method());
}

template <class T>
inline int sign (const T& z)
{
   return (z == 0) ? 0 : (boost::math::signbit)(z) ? -1 : 1;
}

template <class T> typename tools::promote_args_permissive<T>::type (changesign)(const T& x)
{
   typedef typename detail::fp_traits<T>::sign_change_type traits;
   typedef typename traits::method method;

   typedef typename tools::promote_args_permissive<T>::type result_type;

   return detail::changesign_impl(static_cast<result_type>(x), method());
}

template <class T, class U>
inline typename tools::promote_args_permissive<T, U>::type
   copysign (const T& x, const U& y)
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;
   typedef typename tools::promote_args_permissive<T, U>::type result_type;
   return (boost::math::signbit)(static_cast<result_type>(x)) != (boost::math::signbit)(static_cast<result_type>(y))
      ? (boost::math::changesign)(static_cast<result_type>(x)) : static_cast<result_type>(x);
}

}
}
namespace boost{ namespace math
{
  namespace tools
  {
    template <class To, class T>
    inline constexpr To real_cast(T t) noexcept(((std::is_floating_point<T>::value) && (std::is_floating_point<To>::value)))
    {
       return static_cast<To>(t);
    }
  }
}
}
namespace boost{






namespace math_detail{






template <class T>
inline bool is_nan_helper(T t, const boost::true_type&)
{



   (void)t;
   return false;



}





template <class T>
inline bool is_nan_helper(T, const boost::false_type&)
{
   return false;
}
}

namespace math{

namespace detail{


template <class T>
inline int fpclassify_imp (T t, const native_tag&)
{
   return (std::fpclassify)(t);
}


template <class T>
inline int fpclassify_imp (T t, const generic_tag<true>&)
{
                                    ;
   T at = (t < T(0)) ? -t : t;







   if(at <= (std::numeric_limits<T>::max)())
   {
      if(at >= (std::numeric_limits<T>::min)())
         return 4;
      return (at != 0) ? 5 : 3;
   }
   else if(at > (std::numeric_limits<T>::max)())
      return 2;
   return 1;
}

template <class T>
inline int fpclassify_imp (T t, const generic_tag<false>&)
{
                                    ;

   return t == 0 ? 3 : 4;
}

template<class T>
int fpclassify_imp (T x, ieee_copy_all_bits_tag)
{
   typedef typename fp_traits<T>::type traits;

                                    ;

   typename traits::bits a;
   traits::get_bits(x,a);
                                    ;
   a &= traits::exponent | traits::flag | traits::significand;
                                                                                          ;
                                    ;

   if(a <= traits::significand) {
      if(a == 0)
         return 3;
      else
         return 5;
   }

   if(a < traits::exponent) return 4;

   a &= traits::significand;
   if(a == 0) return 2;

   return 1;
}

template<class T>
int fpclassify_imp (T x, ieee_copy_leading_bits_tag)
{
   typedef typename fp_traits<T>::type traits;

                                    ;

   typename traits::bits a;
   traits::get_bits(x,a);
   a &= traits::exponent | traits::flag | traits::significand;

   if(a <= traits::significand) {
      if(x == 0)
         return 3;
      else
         return 5;
   }

   if(a < traits::exponent) return 4;

   a &= traits::significand;
   traits::set_bits(x,a);
   if(x == 0) return 2;

   return 1;
}
}

template <class T>
inline int fpclassify (T t)
{
   typedef typename detail::fp_traits<T>::type traits;
   typedef typename traits::method method;
   typedef typename tools::promote_args_permissive<T>::type value_type;





   return detail::fpclassify_imp(static_cast<value_type>(t), method());

}
namespace detail {


    template<class T>
    inline bool isfinite_impl(T x, native_tag const&)
    {
        return (std::isfinite)(x);
    }


    template<class T>
    inline bool isfinite_impl(T x, generic_tag<true> const&)
    {
        return x >= -(std::numeric_limits<T>::max)()
            && x <= (std::numeric_limits<T>::max)();
    }

    template<class T>
    inline bool isfinite_impl(T x, generic_tag<false> const&)
    {




       (void)x;
       return true;
    }

    template<class T>
    inline bool isfinite_impl(T x, ieee_tag const&)
    {
        typedef typename detail::fp_traits<T>::type traits;
        typename traits::bits a;
        traits::get_bits(x,a);
        a &= traits::exponent;
        return a != traits::exponent;
    }
}

template<class T>
inline bool (isfinite)(T x)
{
   typedef typename detail::fp_traits<T>::type traits;
   typedef typename traits::method method;

   typedef typename tools::promote_args_permissive<T>::type value_type;
   return detail::isfinite_impl(static_cast<value_type>(x), method());
}
namespace detail {


    template<class T>
    inline bool isnormal_impl(T x, native_tag const&)
    {
        return (std::isnormal)(x);
    }


    template<class T>
    inline bool isnormal_impl(T x, generic_tag<true> const&)
    {
        if(x < 0) x = -x;
        return x >= (std::numeric_limits<T>::min)()
            && x <= (std::numeric_limits<T>::max)();
    }

    template<class T>
    inline bool isnormal_impl(T x, generic_tag<false> const&)
    {




       return !(x == 0);
    }

    template<class T>
    inline bool isnormal_impl(T x, ieee_tag const&)
    {
        typedef typename detail::fp_traits<T>::type traits;
        typename traits::bits a;
        traits::get_bits(x,a);
        a &= traits::exponent | traits::flag;
        return (a != 0) && (a < traits::exponent);
    }
}

template<class T>
inline bool (isnormal)(T x)
{
   typedef typename detail::fp_traits<T>::type traits;
   typedef typename traits::method method;

   typedef typename tools::promote_args_permissive<T>::type value_type;
   return detail::isnormal_impl(static_cast<value_type>(x), method());
}
namespace detail {


    template<class T>
    inline bool isinf_impl(T x, native_tag const&)
    {
        return (std::isinf)(x);
    }


    template<class T>
    inline bool isinf_impl(T x, generic_tag<true> const&)
    {
        (void)x;
        return std::numeric_limits<T>::has_infinity
            && ( x == std::numeric_limits<T>::infinity()
                 || x == -std::numeric_limits<T>::infinity());
    }

    template<class T>
    inline bool isinf_impl(T x, generic_tag<false> const&)
    {




        (void)x;
        return false;
    }

    template<class T>
    inline bool isinf_impl(T x, ieee_copy_all_bits_tag const&)
    {
        typedef typename fp_traits<T>::type traits;

        typename traits::bits a;
        traits::get_bits(x,a);
        a &= traits::exponent | traits::significand;
        return a == traits::exponent;
    }

    template<class T>
    inline bool isinf_impl(T x, ieee_copy_leading_bits_tag const&)
    {
        typedef typename fp_traits<T>::type traits;

        typename traits::bits a;
        traits::get_bits(x,a);
        a &= traits::exponent | traits::significand;
        if(a != traits::exponent)
            return false;

        traits::set_bits(x,0);
        return x == 0;
    }
}

template<class T>
inline bool (isinf)(T x)
{
   typedef typename detail::fp_traits<T>::type traits;
   typedef typename traits::method method;

   typedef typename tools::promote_args_permissive<T>::type value_type;
   return detail::isinf_impl(static_cast<value_type>(x), method());
}
namespace detail {


    template<class T>
    inline bool isnan_impl(T x, native_tag const&)
    {
        return (std::isnan)(x);
    }


    template<class T>
    inline bool isnan_impl(T x, generic_tag<true> const&)
    {
        return std::numeric_limits<T>::has_infinity
            ? !(x <= std::numeric_limits<T>::infinity())
            : x != x;
    }

    template<class T>
    inline bool isnan_impl(T x, generic_tag<false> const&)
    {




        (void)x;
        return false;
    }

    template<class T>
    inline bool isnan_impl(T x, ieee_copy_all_bits_tag const&)
    {
        typedef typename fp_traits<T>::type traits;

        typename traits::bits a;
        traits::get_bits(x,a);
        a &= traits::exponent | traits::significand;
        return a > traits::exponent;
    }

    template<class T>
    inline bool isnan_impl(T x, ieee_copy_leading_bits_tag const&)
    {
        typedef typename fp_traits<T>::type traits;

        typename traits::bits a;
        traits::get_bits(x,a);

        a &= traits::exponent | traits::significand;
        if(a < traits::exponent)
            return false;

        a &= traits::significand;
        traits::set_bits(x,a);
        return x != 0;
    }

}

template<class T>
inline bool (isnan)(T x)
{
   typedef typename detail::fp_traits<T>::type traits;
   typedef typename traits::method method;

   return detail::isnan_impl(x, method());
}
}
}



namespace boost {
    namespace detail
    {
        template <class CharT>
        bool lc_iequal(const CharT* val, const CharT* lcase, const CharT* ucase, unsigned int len) noexcept {
            for( unsigned int i=0; i < len; ++i ) {
                if ( val[i] != lcase[i] && val[i] != ucase[i] ) return false;
            }

            return true;
        }


        template <class CharT, class T>
        inline bool parse_inf_nan_impl(const CharT* begin, const CharT* end, T& value
            , const CharT* lc_NAN, const CharT* lc_nan
            , const CharT* lc_INFINITY, const CharT* lc_infinity
            , const CharT opening_brace, const CharT closing_brace) noexcept
        {
            using namespace std;
            if (begin == end) return false;
            const CharT minus = lcast_char_constants<CharT>::minus;
            const CharT plus = lcast_char_constants<CharT>::plus;
            const int inifinity_size = 8;


            bool const has_minus = (*begin == minus);
            if (has_minus || *begin == plus) {
                ++ begin;
            }

            if (end - begin < 3) return false;
            if (lc_iequal(begin, lc_nan, lc_NAN, 3)) {
                begin += 3;
                if (end != begin) {


                    if (end - begin < 2) return false;
                    -- end;
                    if (*begin != opening_brace || *end != closing_brace) return false;
                }

                if( !has_minus ) value = std::numeric_limits<T>::quiet_NaN();
                else value = (boost::math::changesign) (std::numeric_limits<T>::quiet_NaN());
                return true;
            } else if (
                (
                  end - begin == 3
                  && lc_iequal(begin, lc_infinity, lc_INFINITY, 3)
                )
                ||
                (
                  end - begin == inifinity_size
                  && lc_iequal(begin, lc_infinity, lc_INFINITY, inifinity_size)
                )
             )
            {
                if( !has_minus ) value = std::numeric_limits<T>::infinity();
                else value = (boost::math::changesign) (std::numeric_limits<T>::infinity());
                return true;
            }

            return false;
        }

        template <class CharT, class T>
        bool put_inf_nan_impl(CharT* begin, CharT*& end, const T& value
                         , const CharT* lc_nan
                         , const CharT* lc_infinity) noexcept
        {
            using namespace std;
            const CharT minus = lcast_char_constants<CharT>::minus;
            if ((boost::math::isnan)(value)) {
                if ((boost::math::signbit)(value)) {
                    *begin = minus;
                    ++ begin;
                }

                memcpy(begin, lc_nan, 3 * sizeof(CharT));
                end = begin + 3;
                return true;
            } else if ((boost::math::isinf)(value)) {
                if ((boost::math::signbit)(value)) {
                    *begin = minus;
                    ++ begin;
                }

                memcpy(begin, lc_infinity, 3 * sizeof(CharT));
                end = begin + 3;
                return true;
            }

            return false;
        }



        template <class T>
        bool parse_inf_nan(const wchar_t* begin, const wchar_t* end, T& value) noexcept {
            return parse_inf_nan_impl(begin, end, value
                               , L"NAN", L"nan"
                               , L"INFINITY", L"infinity"
                               , L'(', L')');
        }

        template <class T>
        bool put_inf_nan(wchar_t* begin, wchar_t*& end, const T& value) noexcept {
            return put_inf_nan_impl(begin, end, value, L"nan", L"infinity");
        }



        template <class T>
        bool parse_inf_nan(const char16_t* begin, const char16_t* end, T& value) noexcept {
            return parse_inf_nan_impl(begin, end, value
                               , u"NAN", u"nan"
                               , u"INFINITY", u"infinity"
                               , u'(', u')');
        }

        template <class T>
        bool put_inf_nan(char16_t* begin, char16_t*& end, const T& value) noexcept {
            return put_inf_nan_impl(begin, end, value, u"nan", u"infinity");
        }


        template <class T>
        bool parse_inf_nan(const char32_t* begin, const char32_t* end, T& value) noexcept {
            return parse_inf_nan_impl(begin, end, value
                               , U"NAN", U"nan"
                               , U"INFINITY", U"infinity"
                               , U'(', U')');
        }

        template <class T>
        bool put_inf_nan(char32_t* begin, char32_t*& end, const T& value) noexcept {
            return put_inf_nan_impl(begin, end, value, U"nan", U"infinity");
        }


        template <class CharT, class T>
        bool parse_inf_nan(const CharT* begin, const CharT* end, T& value) noexcept {
            return parse_inf_nan_impl(begin, end, value
                               , "NAN", "nan"
                               , "INFINITY", "infinity"
                               , '(', ')');
        }

        template <class CharT, class T>
        bool put_inf_nan(CharT* begin, CharT*& end, const T& value) noexcept {
            return put_inf_nan_impl(begin, end, value, "nan", "infinity");
        }
    }
}


namespace boost
{







     typedef boost::uintmax_t static_min_max_unsigned_type;
     typedef boost::intmax_t static_min_max_signed_type;
     typedef boost::uintmax_t static_log2_argument_type;
     typedef int static_log2_result_type;
template < class T >
    class integer_traits;

template < >
    class integer_traits< bool >;

template < >
    class integer_traits< char >;

template < >
    class integer_traits< signed char >;

template < >
    class integer_traits< unsigned char >;


template < >
    class integer_traits< wchar_t >;


template < >
    class integer_traits< short >;

template < >
    class integer_traits< unsigned short >;

template < >
    class integer_traits< int >;

template < >
    class integer_traits< unsigned int >;

template < >
    class integer_traits< long >;

template < >
    class integer_traits< unsigned long >;


template < >
class integer_traits< ::boost::long_long_type>;

template < >
class integer_traits< ::boost::ulong_long_type >;
template < typename LeastInt >
    struct int_fast_t;

template< int Bits >
    struct int_t;

template< int Bits >
    struct uint_t;


    template< boost::long_long_type MaxValue >



    struct int_max_value_t;


  template< boost::long_long_type MinValue >



    struct int_min_value_t;


  template< boost::ulong_long_type MaxValue >



    struct uint_value_t;




template < std::size_t Bit >
    struct high_bit_mask_t;

template < std::size_t Bits >
    struct low_bits_mask_t;

template < >
    struct low_bits_mask_t< ::std::numeric_limits<unsigned char>::digits >;



template <static_log2_argument_type Value >
    struct static_log2;

template <> struct static_log2<0u>;




template <static_min_max_signed_type Value1, static_min_max_signed_type Value2>
    struct static_signed_min;

template <static_min_max_signed_type Value1, static_min_max_signed_type Value2>
    struct static_signed_max;

template <static_min_max_unsigned_type Value1, static_min_max_unsigned_type Value2>
    struct static_unsigned_min;

template <static_min_max_unsigned_type Value1, static_min_max_unsigned_type Value2>
    struct static_unsigned_max;


namespace integer
{





     typedef boost::uintmax_t static_gcd_type;


template < static_gcd_type Value1, static_gcd_type Value2 >
    struct static_gcd;
template < static_gcd_type Value1, static_gcd_type Value2 >
    struct static_lcm;




template < typename IntegerType >
    class gcd_evaluator;
template < typename IntegerType >
    class lcm_evaluator;

}

}





namespace boost
{





  template< typename LeastInt >
  struct int_fast_t
  {
     typedef LeastInt fast;
     typedef fast type;
  };

  namespace detail{


  template< int Category > struct int_least_helper {};
  template< int Category > struct uint_least_helper {};





  template<> struct int_least_helper<1> { typedef boost::long_long_type least; };



  template<> struct int_least_helper<2> { typedef long least; };
  template<> struct int_least_helper<3> { typedef int least; };
  template<> struct int_least_helper<4> { typedef short least; };
  template<> struct int_least_helper<5> { typedef signed char least; };

  template<> struct uint_least_helper<1> { typedef boost::ulong_long_type least; };



  template<> struct uint_least_helper<2> { typedef unsigned long least; };
  template<> struct uint_least_helper<3> { typedef unsigned int least; };
  template<> struct uint_least_helper<4> { typedef unsigned short least; };
  template<> struct uint_least_helper<5> { typedef unsigned char least; };

  template <int Bits>
  struct exact_signed_base_helper{};
  template <int Bits>
  struct exact_unsigned_base_helper{};

  template <> struct exact_signed_base_helper<sizeof(signed char)* 8> { typedef signed char exact; };
  template <> struct exact_unsigned_base_helper<sizeof(unsigned char)* 8> { typedef unsigned char exact; };

  template <> struct exact_signed_base_helper<sizeof(short)* 8> { typedef short exact; };
  template <> struct exact_unsigned_base_helper<sizeof(unsigned short)* 8> { typedef unsigned short exact; };


  template <> struct exact_signed_base_helper<sizeof(int)* 8> { typedef int exact; };
  template <> struct exact_unsigned_base_helper<sizeof(unsigned int)* 8> { typedef unsigned int exact; };



  template <> struct exact_signed_base_helper<sizeof(long)* 8> { typedef long exact; };
  template <> struct exact_unsigned_base_helper<sizeof(unsigned long)* 8> { typedef unsigned long exact; };
  }




  template< int Bits >
  struct int_t : public boost::detail::exact_signed_base_helper<Bits>
  {
      static_assert(Bits <= (int)(sizeof(boost::intmax_t) * 8), "No suitable signed integer type with the requested number of bits is available.");

      typedef typename boost::detail::int_least_helper
        <

          (Bits <= (int)(sizeof(boost::long_long_type) * 8)) +



          (Bits-1 <= ::std::numeric_limits<long>::digits) +
          (Bits-1 <= ::std::numeric_limits<int>::digits) +
          (Bits-1 <= ::std::numeric_limits<short>::digits) +
          (Bits-1 <= ::std::numeric_limits<signed char>::digits)
        >::least least;
      typedef typename int_fast_t<least>::type fast;
  };


  template< int Bits >
  struct uint_t : public boost::detail::exact_unsigned_base_helper<Bits>
  {
     static_assert(Bits <= (int)(sizeof(boost::uintmax_t) * 8), "No suitable unsigned integer type with the requested number of bits is available.");
      typedef typename boost::detail::uint_least_helper
        <

          (Bits <= (int)(sizeof(boost::long_long_type) * 8)) +



          (Bits <= ::std::numeric_limits<unsigned long>::digits) +
          (Bits <= ::std::numeric_limits<unsigned int>::digits) +
          (Bits <= ::std::numeric_limits<unsigned short>::digits) +
          (Bits <= ::std::numeric_limits<unsigned char>::digits)
        >::least least;

      typedef typename int_fast_t<least>::type fast;

  };





  template< boost::long_long_type MaxValue >



  struct int_max_value_t
  {
      typedef typename boost::detail::int_least_helper
        <

          (MaxValue <= ::boost::integer_traits<boost::long_long_type>::const_max) +



          (MaxValue <= ::boost::integer_traits<long>::const_max) +
          (MaxValue <= ::boost::integer_traits<int>::const_max) +
          (MaxValue <= ::boost::integer_traits<short>::const_max) +
          (MaxValue <= ::boost::integer_traits<signed char>::const_max)
        >::least least;
      typedef typename int_fast_t<least>::type fast;
  };


  template< boost::long_long_type MinValue >



  struct int_min_value_t
  {
      typedef typename boost::detail::int_least_helper
        <

          (MinValue >= ::boost::integer_traits<boost::long_long_type>::const_min) +



          (MinValue >= ::boost::integer_traits<long>::const_min) +
          (MinValue >= ::boost::integer_traits<int>::const_min) +
          (MinValue >= ::boost::integer_traits<short>::const_min) +
          (MinValue >= ::boost::integer_traits<signed char>::const_min)
        >::least least;
      typedef typename int_fast_t<least>::type fast;
  };



  template< boost::ulong_long_type MaxValue >



  struct uint_value_t
  {
      typedef typename boost::detail::uint_least_helper
        <

          (MaxValue <= ::boost::integer_traits<boost::ulong_long_type>::const_max) +



          (MaxValue <= ::boost::integer_traits<unsigned long>::const_max) +
          (MaxValue <= ::boost::integer_traits<unsigned int>::const_max) +
          (MaxValue <= ::boost::integer_traits<unsigned short>::const_max) +
          (MaxValue <= ::boost::integer_traits<unsigned char>::const_max)
        >::least least;

      typedef typename int_fast_t<least>::type fast;
  };


}
namespace boost { namespace detail {





template <class charT, class BufferT >
class basic_pointerbuf : public BufferT {
protected:
   typedef BufferT base_type;
   typedef basic_pointerbuf<charT, BufferT> this_type;
   typedef typename base_type::int_type int_type;
   typedef typename base_type::char_type char_type;
   typedef typename base_type::pos_type pos_type;
   typedef ::std::streamsize streamsize;
   typedef typename base_type::off_type off_type;

public:
   basic_pointerbuf() : base_type() { this_type::setbuf(0, 0); }
   const charT* getnext() { return this->gptr(); }


    using base_type::pptr;
    using base_type::pbase;





protected:




   inline base_type* setbuf(char_type* s, streamsize n);
   inline typename this_type::pos_type seekpos(pos_type sp, ::std::ios_base::openmode which);
   inline typename this_type::pos_type seekoff(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which);

private:
   basic_pointerbuf& operator=(const basic_pointerbuf&);
   basic_pointerbuf(const basic_pointerbuf&);
};

template<class charT, class BufferT>
BufferT*
basic_pointerbuf<charT, BufferT>::setbuf(char_type* s, streamsize n)
{
   this->setg(s, s, s + n);
   return this;
}

template<class charT, class BufferT>
typename basic_pointerbuf<charT, BufferT>::pos_type
basic_pointerbuf<charT, BufferT>::seekoff(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which)
{
   typedef typename boost::int_t<sizeof(way) * 8>::least cast_type;

   if(which & ::std::ios_base::out)
      return pos_type(off_type(-1));
   std::ptrdiff_t size = this->egptr() - this->eback();
   std::ptrdiff_t pos = this->gptr() - this->eback();
   charT* g = this->eback();
   switch(static_cast<cast_type>(way))
   {
   case ::std::ios_base::beg:
      if((off < 0) || (off > size))
         return pos_type(off_type(-1));
      else
         this->setg(g, g + off, g + size);
      break;
   case ::std::ios_base::end:
      if((off < 0) || (off > size))
         return pos_type(off_type(-1));
      else
         this->setg(g, g + size - off, g + size);
      break;
   case ::std::ios_base::cur:
   {
      std::ptrdiff_t newpos = static_cast<std::ptrdiff_t>(pos + off);
      if((newpos < 0) || (newpos > size))
         return pos_type(off_type(-1));
      else
         this->setg(g, g + newpos, g + size);
      break;
   }
   default: ;
   }




   return static_cast<pos_type>(this->gptr() - this->eback());



}

template<class charT, class BufferT>
typename basic_pointerbuf<charT, BufferT>::pos_type
basic_pointerbuf<charT, BufferT>::seekpos(pos_type sp, ::std::ios_base::openmode which)
{
   if(which & ::std::ios_base::out)
      return pos_type(off_type(-1));
   off_type size = static_cast<off_type>(this->egptr() - this->eback());
   charT* g = this->eback();
   if(off_type(sp) <= size)
   {
      this->setg(g, g + off_type(sp), g + size);
   }
   return pos_type(off_type(-1));
}

}}





namespace boost {

    namespace detail
    {


        template <class BufferType, class CharT>
        class basic_unlockedbuf : public basic_pointerbuf<CharT, BufferType> {
        public:
           typedef basic_pointerbuf<CharT, BufferType> base_type;
           typedef typename base_type::streamsize streamsize;


            using base_type::pptr;
            using base_type::pbase;
            using base_type::setbuf;





        };
    }

    namespace detail
    {
        struct do_not_construct_out_buffer_t{};
        struct do_not_construct_out_stream_t{
            do_not_construct_out_stream_t(do_not_construct_out_buffer_t*){}
        };

        template <class CharT, class Traits>
        struct out_stream_helper_trait {
            typedef std::basic_ostream<CharT, Traits> out_stream_t;
            typedef basic_unlockedbuf<std::basic_stringbuf<CharT, Traits>, CharT> stringbuffer_t;
            typedef basic_unlockedbuf<std::basic_streambuf<CharT, Traits>, CharT> buffer_t;

        };
    }

    namespace detail
    {
        template< class CharT
                , class Traits
                , bool RequiresStringbuffer
                , std::size_t CharacterBufferSize
                >
        class lexical_istream_limited_src: boost::noncopyable {
            typedef typename boost::conditional<
                RequiresStringbuffer,
                typename out_stream_helper_trait<CharT, Traits>::out_stream_t,
                do_not_construct_out_stream_t
            >::type deduced_out_stream_t;

            typedef typename boost::conditional<
                RequiresStringbuffer,
                typename out_stream_helper_trait<CharT, Traits>::stringbuffer_t,
                do_not_construct_out_buffer_t
            >::type deduced_out_buffer_t;

            deduced_out_buffer_t out_buffer;
            deduced_out_stream_t out_stream;
            CharT buffer[CharacterBufferSize];



            const CharT* start;
            const CharT* finish;

        public:
            lexical_istream_limited_src() noexcept
              : out_buffer()
              , out_stream(&out_buffer)
              , start(buffer)
              , finish(buffer + CharacterBufferSize)
            {}

            const CharT* cbegin() const noexcept {
                return start;
            }

            const CharT* cend() const noexcept {
                return finish;
            }

        private:

            bool shl_char(CharT ch) noexcept {
                Traits::assign(buffer[0], ch);
                finish = start + 1;
                return true;
            }


            template <class T>
            bool shl_char(T ch) {
                static_assert(( sizeof(T) <= sizeof(CharT)) , "boost::lexical_cast does not support narrowing of char types." "Use boost::locale instead");



                std::locale loc;
                CharT const w = std::use_facet< std::ctype<CharT> >(loc).widen(ch);



                Traits::assign(buffer[0], w);
                finish = start + 1;
                return true;
            }


            bool shl_char_array(CharT const* str_value) noexcept {
                start = str_value;
                finish = start + Traits::length(str_value);
                return true;
            }

            template <class T>
            bool shl_char_array(T const* str_value) {
                static_assert(( sizeof(T) <= sizeof(CharT)), "boost::lexical_cast does not support narrowing of char types." "Use boost::locale instead");


                return shl_input_streamable(str_value);
            }

            bool shl_char_array_limited(CharT const* str, std::size_t max_size) noexcept {
                start = str;
                finish = std::find(start, start + max_size, Traits::to_char_type(0));
                return true;
            }

            template<typename InputStreamable>
            bool shl_input_streamable(InputStreamable& input) {







                out_stream.exceptions(std::ios::badbit);
                try {

                bool const result = !(out_stream << input).fail();
                const deduced_out_buffer_t* const p = static_cast<deduced_out_buffer_t*>(
                    out_stream.rdbuf()
                );
                start = p->pbase();
                finish = p->pptr();
                return result;

                } catch (const ::std::ios_base::failure& ) {
                    return false;
                }

            }

            template <class T>
            inline bool shl_unsigned(const T n) {
                CharT* tmp_finish = buffer + CharacterBufferSize;
                start = lcast_put_unsigned<Traits, T, CharT>(n, tmp_finish).convert();
                finish = tmp_finish;
                return true;
            }

            template <class T>
            inline bool shl_signed(const T n) {
                CharT* tmp_finish = buffer + CharacterBufferSize;
                typedef typename boost::make_unsigned<T>::type utype;
                CharT* tmp_start = lcast_put_unsigned<Traits, utype, CharT>(lcast_to_unsigned(n), tmp_finish).convert();
                if (n < 0) {
                    --tmp_start;
                    CharT const minus = lcast_char_constants<CharT>::minus;
                    Traits::assign(*tmp_start, minus);
                }
                start = tmp_start;
                finish = tmp_finish;
                return true;
            }

            template <class T, class SomeCharT>
            bool shl_real_type(const T& val, SomeCharT* ) {
                lcast_set_precision(out_stream, &val);
                return shl_input_streamable(val);
            }

            bool shl_real_type(float val, char* begin) {
                using namespace std;
                const double val_as_double = val;
                finish = start +



                    sprintf(begin,

                    "%.*g", static_cast<int>(boost::detail::lcast_get_precision<float>()), val_as_double);
                return finish > start;
            }

            bool shl_real_type(double val, char* begin) {
                using namespace std;
                finish = start +



                    sprintf(begin,

                    "%.*g", static_cast<int>(boost::detail::lcast_get_precision<double>()), val);
                return finish > start;
            }


            bool shl_real_type(long double val, char* begin) {
                using namespace std;
                finish = start +



                    sprintf(begin,

                    "%.*Lg", static_cast<int>(boost::detail::lcast_get_precision<long double>()), val );
                return finish > start;
            }




            bool shl_real_type(float val, wchar_t* begin) {
                using namespace std;
                const double val_as_double = val;
                finish = start + swprintf(begin, CharacterBufferSize,
                                       L"%.*g",
                                       static_cast<int>(boost::detail::lcast_get_precision<float >()),
                                       val_as_double );
                return finish > start;
            }

            bool shl_real_type(double val, wchar_t* begin) {
                using namespace std;
                finish = start + swprintf(begin, CharacterBufferSize,
                                          L"%.*g", static_cast<int>(boost::detail::lcast_get_precision<double >()), val );
                return finish > start;
            }

            bool shl_real_type(long double val, wchar_t* begin) {
                using namespace std;
                finish = start + swprintf(begin, CharacterBufferSize,
                                          L"%.*Lg", static_cast<int>(boost::detail::lcast_get_precision<long double >()), val );
                return finish > start;
            }

            template <class T>
            bool shl_real(T val) {
                CharT* tmp_finish = buffer + CharacterBufferSize;
                if (put_inf_nan(buffer, tmp_finish, val)) {
                    finish = tmp_finish;
                    return true;
                }

                return shl_real_type(val, static_cast<CharT*>(buffer));
            }


        public:
            template<class Alloc>
            bool operator<<(std::basic_string<CharT,Traits,Alloc> const& str) noexcept {
                start = str.data();
                finish = start + str.length();
                return true;
            }

            template<class Alloc>
            bool operator<<(boost::container::basic_string<CharT,Traits,Alloc> const& str) noexcept {
                start = str.data();
                finish = start + str.length();
                return true;
            }

            bool operator<<(bool value) noexcept {
                CharT const czero = lcast_char_constants<CharT>::zero;
                Traits::assign(buffer[0], Traits::to_char_type(czero + value));
                finish = start + 1;
                return true;
            }

            template <class C>
            typename boost::disable_if<boost::is_const<C>, bool>::type
            operator<<(const iterator_range<C*>& rng) noexcept {
                return (*this) << iterator_range<const C*>(rng.begin(), rng.end());
            }

            bool operator<<(const iterator_range<const CharT*>& rng) noexcept {
                start = rng.begin();
                finish = rng.end();
                return true;
            }

            bool operator<<(const iterator_range<const signed char*>& rng) noexcept {
                return (*this) << iterator_range<const char*>(
                    reinterpret_cast<const char*>(rng.begin()),
                    reinterpret_cast<const char*>(rng.end())
                );
            }

            bool operator<<(const iterator_range<const unsigned char*>& rng) noexcept {
                return (*this) << iterator_range<const char*>(
                    reinterpret_cast<const char*>(rng.begin()),
                    reinterpret_cast<const char*>(rng.end())
                );
            }

            bool operator<<(char ch) { return shl_char(ch); }
            bool operator<<(unsigned char ch) { return ((*this) << static_cast<char>(ch)); }
            bool operator<<(signed char ch) { return ((*this) << static_cast<char>(ch)); }

            bool operator<<(wchar_t const* str) { return shl_char_array(str); }
            bool operator<<(wchar_t * str) { return shl_char_array(str); }

            bool operator<<(wchar_t ch) { return shl_char(ch); }



            bool operator<<(char16_t ch) { return shl_char(ch); }
            bool operator<<(char16_t * str) { return shl_char_array(str); }
            bool operator<<(char16_t const * str) { return shl_char_array(str); }


            bool operator<<(char32_t ch) { return shl_char(ch); }
            bool operator<<(char32_t * str) { return shl_char_array(str); }
            bool operator<<(char32_t const * str) { return shl_char_array(str); }

            bool operator<<(unsigned char const* ch) { return ((*this) << reinterpret_cast<char const*>(ch)); }
            bool operator<<(unsigned char * ch) { return ((*this) << reinterpret_cast<char *>(ch)); }
            bool operator<<(signed char const* ch) { return ((*this) << reinterpret_cast<char const*>(ch)); }
            bool operator<<(signed char * ch) { return ((*this) << reinterpret_cast<char *>(ch)); }
            bool operator<<(char const* str_value) { return shl_char_array(str_value); }
            bool operator<<(char* str_value) { return shl_char_array(str_value); }
            bool operator<<(short n) { return shl_signed(n); }
            bool operator<<(int n) { return shl_signed(n); }
            bool operator<<(long n) { return shl_signed(n); }
            bool operator<<(unsigned short n) { return shl_unsigned(n); }
            bool operator<<(unsigned int n) { return shl_unsigned(n); }
            bool operator<<(unsigned long n) { return shl_unsigned(n); }


            bool operator<<(boost::ulong_long_type n) { return shl_unsigned(n); }
            bool operator<<(boost::long_long_type n) { return shl_signed(n); }






            bool operator<<(const boost::uint128_type& n) { return shl_unsigned(n); }
            bool operator<<(const boost::int128_type& n) { return shl_signed(n); }

            bool operator<<(float val) { return shl_real(val); }
            bool operator<<(double val) { return shl_real(val); }
            bool operator<<(long double val) {

                return shl_real(val);



            }


            template <class C, std::size_t N>
            typename boost::disable_if<boost::is_const<C>, bool>::type
            operator<<(boost::array<C, N> const& input) noexcept {
                static_assert((sizeof(boost::array<const C, N>) == sizeof(boost::array<C, N>)), "boost::array<C, N> and boost::array<const C, N> must have exactly the same layout.");



                return ((*this) << reinterpret_cast<boost::array<const C, N> const& >(input));
            }

            template <std::size_t N>
            bool operator<<(boost::array<const CharT, N> const& input) noexcept {
                return shl_char_array_limited(input.data(), N);
            }

            template <std::size_t N>
            bool operator<<(boost::array<const unsigned char, N> const& input) noexcept {
                return ((*this) << reinterpret_cast<boost::array<const char, N> const& >(input));
            }

            template <std::size_t N>
            bool operator<<(boost::array<const signed char, N> const& input) noexcept {
                return ((*this) << reinterpret_cast<boost::array<const char, N> const& >(input));
            }



            template <class C, std::size_t N>
            bool operator<<(std::array<C, N> const& input) noexcept {
                static_assert((sizeof(std::array<C, N>) == sizeof(boost::array<C, N>)), "std::array and boost::array must have exactly the same layout. " "Bug in implementation of std::array or boost::array.");




                return ((*this) << reinterpret_cast<boost::array<C, N> const& >(input));
            }

            template <class InStreamable>
            bool operator<<(const InStreamable& input) { return shl_input_streamable(input); }
        };


        template <class CharT, class Traits>
        class lexical_ostream_limited_src: boost::noncopyable {

            const CharT* start;
            const CharT* const finish;

        public:
            lexical_ostream_limited_src(const CharT* begin, const CharT* end) noexcept
              : start(begin)
              , finish(end)
            {}


        private:
            template <typename Type>
            bool shr_unsigned(Type& output) {
                if (start == finish) return false;
                CharT const minus = lcast_char_constants<CharT>::minus;
                CharT const plus = lcast_char_constants<CharT>::plus;
                bool const has_minus = Traits::eq(minus, *start);


                if (has_minus || Traits::eq(plus, *start)) {
                    ++start;
                }

                bool const succeed = lcast_ret_unsigned<Traits, Type, CharT>(output, start, finish).convert();

                if (has_minus) {
                    output = static_cast<Type>(0u - output);
                }

                return succeed;
            }

            template <typename Type>
            bool shr_signed(Type& output) {
                if (start == finish) return false;
                CharT const minus = lcast_char_constants<CharT>::minus;
                CharT const plus = lcast_char_constants<CharT>::plus;
                typedef typename make_unsigned<Type>::type utype;
                utype out_tmp = 0;
                bool const has_minus = Traits::eq(minus, *start);


                if (has_minus || Traits::eq(plus, *start)) {
                    ++start;
                }

                bool succeed = lcast_ret_unsigned<Traits, utype, CharT>(out_tmp, start, finish).convert();
                if (has_minus) {
                    utype const comp_val = (static_cast<utype>(1) << std::numeric_limits<Type>::digits);
                    succeed = succeed && out_tmp<=comp_val;
                    output = static_cast<Type>(0u - out_tmp);
                } else {
                    utype const comp_val = static_cast<utype>((std::numeric_limits<Type>::max)());
                    succeed = succeed && out_tmp<=comp_val;
                    output = static_cast<Type>(out_tmp);
                }
                return succeed;
            }

            template<typename InputStreamable>
            bool shr_using_base_class(InputStreamable& output)
            {
                static_assert((!boost::is_pointer<InputStreamable>::value), "boost::lexical_cast can not convert to pointers");
                typedef typename out_stream_helper_trait<CharT, Traits>::buffer_t buffer_t;
                buffer_t buf;


                buf.setbuf(const_cast<CharT*>(start), static_cast<typename buffer_t::streamsize>(finish - start));



                std::basic_istream<CharT, Traits> stream(&buf);




                stream.exceptions(std::ios::badbit);
                try {

                stream.unsetf(std::ios::skipws);
                lcast_set_precision(stream, static_cast<InputStreamable*>(0));

                return (stream >> output)
                    && (stream.get() == Traits::eof());


                } catch (const ::std::ios_base::failure& ) {
                    return false;
                }

            }

            template<class T>
            inline bool shr_xchar(T& output) noexcept {
                static_assert(( sizeof(CharT) == sizeof(T) ), "boost::lexical_cast does not support narrowing of character types." "Use boost::locale instead");


                bool const ok = (finish - start == 1);
                if (ok) {
                    CharT out;
                    Traits::assign(out, *start);
                    output = static_cast<T>(out);
                }
                return ok;
            }

            template <std::size_t N, class ArrayT>
            bool shr_std_array(ArrayT& output) noexcept {
                using namespace std;
                const std::size_t size = static_cast<std::size_t>(finish - start);
                if (size > N - 1) {
                    return false;
                }

                memcpy(&output[0], start, size * sizeof(CharT));
                output[size] = Traits::to_char_type(0);
                return true;
            }


        public:
            bool operator>>(unsigned short& output) { return shr_unsigned(output); }
            bool operator>>(unsigned int& output) { return shr_unsigned(output); }
            bool operator>>(unsigned long int& output) { return shr_unsigned(output); }
            bool operator>>(short& output) { return shr_signed(output); }
            bool operator>>(int& output) { return shr_signed(output); }
            bool operator>>(long int& output) { return shr_signed(output); }

            bool operator>>(boost::ulong_long_type& output) { return shr_unsigned(output); }
            bool operator>>(boost::long_long_type& output) { return shr_signed(output); }






            bool operator>>(boost::uint128_type& output) { return shr_unsigned(output); }
            bool operator>>(boost::int128_type& output) { return shr_signed(output); }


            bool operator>>(char& output) { return shr_xchar(output); }
            bool operator>>(unsigned char& output) { return shr_xchar(output); }
            bool operator>>(signed char& output) { return shr_xchar(output); }

            bool operator>>(wchar_t& output) { return shr_xchar(output); }


            bool operator>>(char16_t& output) { return shr_xchar(output); }


            bool operator>>(char32_t& output) { return shr_xchar(output); }

            template<class Alloc>
            bool operator>>(std::basic_string<CharT,Traits,Alloc>& str) {
                str.assign(start, finish); return true;
            }

            template<class Alloc>
            bool operator>>(boost::container::basic_string<CharT,Traits,Alloc>& str) {
                str.assign(start, finish); return true;
            }

            template <std::size_t N>
            bool operator>>(boost::array<CharT, N>& output) noexcept {
                return shr_std_array<N>(output);
            }

            template <std::size_t N>
            bool operator>>(boost::array<unsigned char, N>& output) noexcept {
                return ((*this) >> reinterpret_cast<boost::array<char, N>& >(output));
            }

            template <std::size_t N>
            bool operator>>(boost::array<signed char, N>& output) noexcept {
                return ((*this) >> reinterpret_cast<boost::array<char, N>& >(output));
            }


            template <class C, std::size_t N>
            bool operator>>(std::array<C, N>& output) noexcept {
                static_assert((sizeof(std::array<C, N>) == sizeof(boost::array<C, N>)), "std::array<C, N> and boost::array<C, N> must have exactly the same layout.");



                return ((*this) >> reinterpret_cast<boost::array<C, N>& >(output));
            }


            bool operator>>(bool& output) noexcept {
                output = false;

                if (start == finish) return false;
                CharT const zero = lcast_char_constants<CharT>::zero;
                CharT const plus = lcast_char_constants<CharT>::plus;
                CharT const minus = lcast_char_constants<CharT>::minus;

                const CharT* const dec_finish = finish - 1;
                output = Traits::eq(*dec_finish, zero + 1);
                if (!output && !Traits::eq(*dec_finish, zero)) {
                    return false;
                }

                if (start == dec_finish) return true;


                if (Traits::eq(plus, *start) || (Traits::eq(minus, *start) && !output)) {
                    ++ start;
                }


                while (start != dec_finish) {
                    if (!Traits::eq(zero, *start)) {
                        return false;
                    }

                    ++ start;
                }

                return true;
            }

        private:

            template <class T>
            bool float_types_converter_internal(T& output) {
                if (parse_inf_nan(start, finish, output)) return true;
                bool const return_value = shr_using_base_class(output);







                CharT const minus = lcast_char_constants<CharT>::minus;
                CharT const plus = lcast_char_constants<CharT>::plus;
                CharT const capital_e = lcast_char_constants<CharT>::capital_e;
                CharT const lowercase_e = lcast_char_constants<CharT>::lowercase_e;
                if ( return_value &&
                     (
                        Traits::eq(*(finish-1), lowercase_e)
                        || Traits::eq(*(finish-1), capital_e)
                        || Traits::eq(*(finish-1), minus)
                        || Traits::eq(*(finish-1), plus)
                     )
                ) return false;

                return return_value;
            }

        public:
            bool operator>>(float& output) { return float_types_converter_internal(output); }
            bool operator>>(double& output) { return float_types_converter_internal(output); }
            bool operator>>(long double& output) { return float_types_converter_internal(output); }



            template <typename InputStreamable>
            bool operator>>(InputStreamable& output) {
                return shr_using_base_class(output);
            }
        };
    }
}

namespace boost {

    namespace detail
    {

        template < class Char >
        struct normalize_single_byte_char
        {
            typedef Char type;
        };

        template <>
        struct normalize_single_byte_char< signed char >
        {
            typedef char type;
        };

        template <>
        struct normalize_single_byte_char< unsigned char >
        {
            typedef char type;
        };
    }

    namespace detail
    {


        template < class T > struct deduce_character_type_later {};
    }

    namespace detail
    {



        template < typename Type >
        struct stream_char_common: public boost::conditional<
            boost::detail::is_character< Type >::value,
            Type,
            boost::detail::deduce_character_type_later< Type >
        > {};

        template < typename Char >
        struct stream_char_common< Char* >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< Char* >
        > {};

        template < typename Char >
        struct stream_char_common< const Char* >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< const Char* >
        > {};

        template < typename Char >
        struct stream_char_common< boost::iterator_range< Char* > >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< boost::iterator_range< Char* > >
        > {};

        template < typename Char >
        struct stream_char_common< boost::iterator_range< const Char* > >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< boost::iterator_range< const Char* > >
        > {};

        template < class Char, class Traits, class Alloc >
        struct stream_char_common< std::basic_string< Char, Traits, Alloc > >
        {
            typedef Char type;
        };

        template < class Char, class Traits, class Alloc >
        struct stream_char_common< boost::container::basic_string< Char, Traits, Alloc > >
        {
            typedef Char type;
        };

        template < typename Char, std::size_t N >
        struct stream_char_common< boost::array< Char, N > >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< boost::array< Char, N > >
        > {};

        template < typename Char, std::size_t N >
        struct stream_char_common< boost::array< const Char, N > >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< boost::array< const Char, N > >
        > {};


        template < typename Char, std::size_t N >
        struct stream_char_common< std::array<Char, N > >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< std::array< Char, N > >
        > {};

        template < typename Char, std::size_t N >
        struct stream_char_common< std::array< const Char, N > >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< std::array< const Char, N > >
        > {};



        template <> struct stream_char_common< boost::int128_type >: public boost::type_identity< char > {};
        template <> struct stream_char_common< boost::uint128_type >: public boost::type_identity< char > {};
    }

    namespace detail
    {





        template < class Char >
        struct deduce_source_char_impl
        {
            typedef typename boost::detail::normalize_single_byte_char< Char >::type type;
        };

        template < class T >
        struct deduce_source_char_impl< deduce_character_type_later< T > >
        {
            typedef boost::has_left_shift< std::basic_ostream< char >, T > result_t;






            typedef typename boost::conditional<
                result_t::value, char, wchar_t
            >::type type;

            static_assert((result_t::value || boost::has_left_shift< std::basic_ostream< type >, T >::value), "Source type is neither std::ostream`able nor std::wostream`able");


        };
    }

    namespace detail
    {





        template < class Char >
        struct deduce_target_char_impl
        {
            typedef typename normalize_single_byte_char< Char >::type type;
        };

        template < class T >
        struct deduce_target_char_impl< deduce_character_type_later<T> >
        {
            typedef boost::has_right_shift<std::basic_istream<char>, T > result_t;






            typedef typename boost::conditional<
                result_t::value, char, wchar_t
            >::type type;

            static_assert((result_t::value || boost::has_right_shift<std::basic_istream<wchar_t>, T >::value), "Target type is neither std::istream`able nor std::wistream`able");


        };
    }

    namespace detail
    {
        template < class T >
        struct deduce_target_char
        {
            typedef typename stream_char_common< T >::type stage1_type;
            typedef typename deduce_target_char_impl< stage1_type >::type stage2_type;

            typedef stage2_type type;
        };

        template < class T >
        struct deduce_source_char
        {
            typedef typename stream_char_common< T >::type stage1_type;
            typedef typename deduce_source_char_impl< stage1_type >::type stage2_type;

            typedef stage2_type type;
        };
    }

    namespace detail
    {


        template < class Char, class T >
        struct extract_char_traits
                : boost::false_type
        {
            typedef std::char_traits< Char > trait_t;
        };

        template < class Char, class Traits, class Alloc >
        struct extract_char_traits< Char, std::basic_string< Char, Traits, Alloc > >
            : boost::true_type
        {
            typedef Traits trait_t;
        };

        template < class Char, class Traits, class Alloc>
        struct extract_char_traits< Char, boost::container::basic_string< Char, Traits, Alloc > >
            : boost::true_type
        {
            typedef Traits trait_t;
        };
    }

    namespace detail
    {
        template<class T>
        struct array_to_pointer_decay
        {
            typedef T type;
        };

        template<class T, std::size_t N>
        struct array_to_pointer_decay<T[N]>
        {
            typedef const T * type;
        };
    }

    namespace detail
    {

        template< class Source,
                  class Enable = void
                >
        struct lcast_src_length
        {
            static const std::size_t value = 1;
        };
        template <class Source>
        struct lcast_src_length<
                    Source, typename boost::enable_if<boost::is_integral<Source> >::type
                >
        {

            static const std::size_t value = std::numeric_limits<Source>::is_signed + std::numeric_limits<Source>::is_specialized + std::numeric_limits<Source>::digits10 * 2;
        };
        template<class Source>
        struct lcast_src_length<
                Source, typename boost::enable_if<boost::is_float<Source> >::type
            >
        {


            static_assert(std::numeric_limits<Source>::max_exponent10 <= 999999L && std::numeric_limits<Source>::min_exponent10 >= -999999L, "std::numeric_limits<Source>::max_exponent10 <= 999999L && std::numeric_limits<Source>::min_exponent10 >= -999999L");




            static const std::size_t value = 5 + lcast_precision<Source>::value + 6;





        };
    }

    namespace detail
    {
        template <class Source, class Target>
        struct lexical_cast_stream_traits {
            typedef typename boost::detail::array_to_pointer_decay<Source>::type src;
            typedef typename boost::remove_cv<src>::type no_cv_src;

            typedef boost::detail::deduce_source_char<no_cv_src> deduce_src_char_metafunc;
            typedef typename deduce_src_char_metafunc::type src_char_t;
            typedef typename boost::detail::deduce_target_char<Target>::type target_char_t;

            typedef typename boost::detail::widest_char<
                target_char_t, src_char_t
            >::type char_type;
            typedef typename boost::conditional<
                boost::detail::extract_char_traits<char_type, Target>::value,
                typename boost::detail::extract_char_traits<char_type, Target>,
                typename boost::detail::extract_char_traits<char_type, no_cv_src>
            >::type::trait_t traits;

            typedef boost::integral_constant<
              bool,
              boost::is_same<char, src_char_t>::value &&
                (sizeof(char) != sizeof(target_char_t)) &&
                (!(boost::detail::is_character<no_cv_src>::value))
             > is_string_widening_required_t;

            typedef boost::integral_constant<
              bool,
             !(boost::is_integral<no_cv_src>::value ||
                  boost::detail::is_character<
                    typename deduce_src_char_metafunc::stage1_type
                  >::value
              )
             > is_source_input_not_optimized_t;



            static const bool requires_stringbuf = (is_string_widening_required_t::value || is_source_input_not_optimized_t::value);



            typedef boost::detail::lcast_src_length<no_cv_src> len_t;
        };
    }

    namespace detail
    {
        template<typename Target, typename Source>
        struct lexical_converter_impl
        {
            typedef lexical_cast_stream_traits<Source, Target> stream_trait;

            typedef detail::lexical_istream_limited_src<
                typename stream_trait::char_type,
                typename stream_trait::traits,
                stream_trait::requires_stringbuf,
                stream_trait::len_t::value + 1
            > i_interpreter_type;

            typedef detail::lexical_ostream_limited_src<
                typename stream_trait::char_type,
                typename stream_trait::traits
            > o_interpreter_type;

            static inline bool try_convert(const Source& arg, Target& result) {
                i_interpreter_type i_interpreter;


                if (!(i_interpreter.operator <<(arg)))
                    return false;

                o_interpreter_type out(i_interpreter.cbegin(), i_interpreter.cend());


                if(!(out.operator >>(result)))
                    return false;

                return true;
            }
        };
    }

}




namespace boost {
    namespace detail
    {
        template<typename T>
        struct is_stdstring
            : boost::false_type
        {};

        template<typename CharT, typename Traits, typename Alloc>
        struct is_stdstring< std::basic_string<CharT, Traits, Alloc> >
            : boost::true_type
        {};



        template<typename T>
        struct is_booststring
            : boost::false_type
        {};

        template<typename CharT, typename Traits, typename Alloc>
        struct is_booststring< boost::container::basic_string<CharT, Traits, Alloc> >
            : boost::true_type
        {};

        template<typename Target, typename Source>
        struct is_arithmetic_and_not_xchars
        {
            typedef boost::integral_constant<
                bool,
                !(boost::detail::is_character<Target>::value) &&
                    !(boost::detail::is_character<Source>::value) &&
                    boost::is_arithmetic<Source>::value &&
                    boost::is_arithmetic<Target>::value
                > type;

            static const bool value = ( type::value );


        };





        template<typename Target, typename Source>
        struct is_xchar_to_xchar
        {
            typedef boost::integral_constant<
                bool,
                sizeof(Source) == sizeof(Target) &&
                     sizeof(Source) == sizeof(char) &&
                     boost::detail::is_character<Target>::value &&
                     boost::detail::is_character<Source>::value
                > type;

            static const bool value = ( type::value );


        };

        template<typename Target, typename Source>
        struct is_char_array_to_stdstring
            : boost::false_type
        {};

        template<typename CharT, typename Traits, typename Alloc>
        struct is_char_array_to_stdstring< std::basic_string<CharT, Traits, Alloc>, CharT* >
            : boost::true_type
        {};

        template<typename CharT, typename Traits, typename Alloc>
        struct is_char_array_to_stdstring< std::basic_string<CharT, Traits, Alloc>, const CharT* >
            : boost::true_type
        {};



        template<typename Target, typename Source>
        struct is_char_array_to_booststring
            : boost::false_type
        {};

        template<typename CharT, typename Traits, typename Alloc>
        struct is_char_array_to_booststring< boost::container::basic_string<CharT, Traits, Alloc>, CharT* >
            : boost::true_type
        {};

        template<typename CharT, typename Traits, typename Alloc>
        struct is_char_array_to_booststring< boost::container::basic_string<CharT, Traits, Alloc>, const CharT* >
            : boost::true_type
        {};

        template <typename Target, typename Source>
        struct copy_converter_impl
        {



            template <class T>
            static inline bool try_convert(T&& arg, Target& result) {
                result = static_cast<T&&>(arg);
                return true;
            }






        };
    }

    namespace conversion { namespace detail {

        template <typename Target, typename Source>
        inline bool try_lexical_convert(const Source& arg, Target& result)
        {
            typedef typename boost::detail::array_to_pointer_decay<Source>::type src;

            typedef boost::integral_constant<
                bool,
                boost::detail::is_xchar_to_xchar<Target, src >::value ||
                boost::detail::is_char_array_to_stdstring<Target, src >::value ||
                boost::detail::is_char_array_to_booststring<Target, src >::value ||
                (
                     boost::is_same<Target, src >::value &&
                     (boost::detail::is_stdstring<Target >::value || boost::detail::is_booststring<Target >::value)
                ) ||
                (
                     boost::is_same<Target, src >::value &&
                     boost::detail::is_character<Target >::value
                )
            > shall_we_copy_t;

            typedef boost::detail::is_arithmetic_and_not_xchars<Target, src >
                shall_we_copy_with_dynamic_check_t;



            typedef typename boost::conditional<
                shall_we_copy_t::value,
                boost::type_identity<boost::detail::copy_converter_impl<Target, src > >,
                boost::conditional<
                     shall_we_copy_with_dynamic_check_t::value,
                     boost::detail::dynamic_num_converter_impl<Target, src >,
                     boost::detail::lexical_converter_impl<Target, src >
                >
            >::type caster_type_lazy;

            typedef typename caster_type_lazy::type caster_type;

            return caster_type::try_convert(arg, result);
        }

        template <typename Target, typename CharacterT>
        inline bool try_lexical_convert(const CharacterT* chars, std::size_t count, Target& result)
        {
            static_assert(boost::detail::is_character<CharacterT>::value, "This overload of try_lexical_convert is meant to be used only with arrays of characters.");



            return ::boost::conversion::detail::try_lexical_convert(
                ::boost::iterator_range<const CharacterT*>(chars, chars + count), result
            );
        }

    }}

    namespace conversion {

        using ::boost::conversion::detail::try_lexical_convert;
    }

}




#pragma GCC diagnostic pop

namespace boost
{
    template <typename Target, typename Source>
    inline Target lexical_cast(const Source &arg)
    {
        Target result = Target();

        if (!boost::conversion::detail::try_lexical_convert(arg, result)) {
            boost::conversion::detail::throw_bad_cast<Source, Target>();
        }

        return result;
    }

    template <typename Target>
    inline Target lexical_cast(const char* chars, std::size_t count)
    {
        return ::boost::lexical_cast<Target>(
            ::boost::iterator_range<const char*>(chars, chars + count)
        );
    }

    template <typename Target>
    inline Target lexical_cast(const unsigned char* chars, std::size_t count)
    {
        return ::boost::lexical_cast<Target>(
            ::boost::iterator_range<const unsigned char*>(chars, chars + count)
        );
    }

    template <typename Target>
    inline Target lexical_cast(const signed char* chars, std::size_t count)
    {
        return ::boost::lexical_cast<Target>(
            ::boost::iterator_range<const signed char*>(chars, chars + count)
        );
    }


    template <typename Target>
    inline Target lexical_cast(const wchar_t* chars, std::size_t count)
    {
        return ::boost::lexical_cast<Target>(
            ::boost::iterator_range<const wchar_t*>(chars, chars + count)
        );
    }


    template <typename Target>
    inline Target lexical_cast(const char16_t* chars, std::size_t count)
    {
        return ::boost::lexical_cast<Target>(
            ::boost::iterator_range<const char16_t*>(chars, chars + count)
        );
    }


    template <typename Target>
    inline Target lexical_cast(const char32_t* chars, std::size_t count)
    {
        return ::boost::lexical_cast<Target>(
            ::boost::iterator_range<const char32_t*>(chars, chars + count)
        );
    }


}
namespace boost{
   namespace multiprecision{

enum expression_template_option
{
   et_off = 0,
   et_on = 1
};

template <class Backend>
struct expression_template_default
{
   static const expression_template_option value = et_on;
};

template <class Backend, expression_template_option ExpressionTemplates = expression_template_default<Backend>::value>
class number;

template <class T>
struct is_number : public mpl::false_ {};

template <class Backend, expression_template_option ExpressionTemplates>
struct is_number<number<Backend, ExpressionTemplates> > : public mpl::true_ {};

template <class T>
struct is_et_number : public mpl::false_ {};

template <class Backend>
struct is_et_number<number<Backend, et_on> > : public mpl::true_ {};

template <class T>
struct is_no_et_number : public mpl::false_ {};

template <class Backend>
struct is_no_et_number<number<Backend, et_off> > : public mpl::true_ {};

namespace detail{


template<class tag, class Arg1 = void, class Arg2 = void, class Arg3 = void, class Arg4 = void>
struct expression;

}

template <class T>
struct is_number_expression : public mpl::false_ {};

template<class tag, class Arg1, class Arg2, class Arg3, class Arg4>
struct is_number_expression<detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > : public mpl::true_ {};

template <class T, class Num>
struct is_compatible_arithmetic_type
   : public mpl::bool_<
         is_convertible<T, Num>::value
         && !is_same<T, Num>::value
         && !is_number_expression<T>::value>
{};

namespace detail{



template <class T>
constexpr typename enable_if_c<(is_signed<T>::value || is_floating_point<T>::value), T>::type abs(T t) noexcept
{



   return t < 0 ? T(1u) + T(-(t + 1)) : t;
}
template <class T>
constexpr typename enable_if_c<(is_unsigned<T>::value), T>::type abs(T t) noexcept
{
   return t;
}



template <class T>
constexpr typename enable_if_c<(is_signed<T>::value || is_floating_point<T>::value), typename make_unsigned<T>::type>::type unsigned_abs(T t) noexcept
{



   return t < 0 ? static_cast<typename make_unsigned<T>::type>(1u) + static_cast<typename make_unsigned<T>::type>(-(t + 1)) : static_cast<typename make_unsigned<T>::type>(t);
}
template <class T>
constexpr typename enable_if_c<(is_unsigned<T>::value), T>::type unsigned_abs(T t) noexcept
{
   return t;
}
template <class T>
struct bits_of
{
   static_assert(is_integral<T>::value || is_enum<T>::value || std::numeric_limits<T>::is_specialized, "is_integral<T>::value || is_enum<T>::value || std::numeric_limits<T>::is_specialized");
   static const unsigned value =
      std::numeric_limits<T>::is_specialized ?
         std::numeric_limits<T>::digits
         : sizeof(T) * 8 - (is_signed<T>::value ? 1 : 0);
};





template <int b>
struct has_enough_bits
{
   template <class T>
   struct type : public mpl::bool_<bits_of<T>::value>= b>{};
};

template <class Val, class Backend, class Tag>
struct canonical_imp
{
   typedef typename remove_cv<typename decay<const Val>::type>::type type;
};
template <class B, class Backend, class Tag>
struct canonical_imp<number<B, et_on>, Backend, Tag>
{
   typedef B type;
};
template <class B, class Backend, class Tag>
struct canonical_imp<number<B, et_off>, Backend, Tag>
{
   typedef B type;
};
template <class Val, class Backend>
struct canonical_imp<Val, Backend, mpl::int_<0> >
{
   typedef typename has_enough_bits<bits_of<Val>::value>::template type<mpl::_> pred_type;
   typedef typename mpl::find_if<
      typename Backend::signed_types,
      pred_type
   >::type iter_type;
   typedef typename mpl::end<typename Backend::signed_types>::type end_type;
   typedef typename mpl::eval_if<boost::is_same<iter_type, end_type>, mpl::identity<Val>, mpl::deref<iter_type> >::type type;
};
template <class Val, class Backend>
struct canonical_imp<Val, Backend, mpl::int_<1> >
{
   typedef typename has_enough_bits<bits_of<Val>::value>::template type<mpl::_> pred_type;
   typedef typename mpl::find_if<
      typename Backend::unsigned_types,
      pred_type
   >::type iter_type;
   typedef typename mpl::end<typename Backend::unsigned_types>::type end_type;
   typedef typename mpl::eval_if<boost::is_same<iter_type, end_type>, mpl::identity<Val>, mpl::deref<iter_type> >::type type;
};
template <class Val, class Backend>
struct canonical_imp<Val, Backend, mpl::int_<2> >
{
   typedef typename has_enough_bits<bits_of<Val>::value>::template type<mpl::_> pred_type;
   typedef typename mpl::find_if<
      typename Backend::float_types,
      pred_type
   >::type iter_type;
   typedef typename mpl::end<typename Backend::float_types>::type end_type;
   typedef typename mpl::eval_if<boost::is_same<iter_type, end_type>, mpl::identity<Val>, mpl::deref<iter_type> >::type type;
};
template <class Val, class Backend>
struct canonical_imp<Val, Backend, mpl::int_<3> >
{
   typedef const char* type;
};

template <class Val, class Backend>
struct canonical
{
   typedef typename mpl::if_<
      is_signed<Val>,
      mpl::int_<0>,
      typename mpl::if_<
         is_unsigned<Val>,
         mpl::int_<1>,
         typename mpl::if_<
            is_floating_point<Val>,
            mpl::int_<2>,
            typename mpl::if_<
               mpl::or_<
                  is_convertible<Val, const char*>,
                  is_same<Val, std::string>
               >,
               mpl::int_<3>,
               mpl::int_<4>
            >::type
         >::type
      >::type
   >::type tag_type;

   typedef typename canonical_imp<Val, Backend, tag_type>::type type;
};

struct terminal{};
struct negate{};
struct plus{};
struct minus{};
struct multiplies{};
struct divides{};
struct modulus{};
struct shift_left{};
struct shift_right{};
struct bitwise_and{};
struct bitwise_or{};
struct bitwise_xor{};
struct bitwise_complement{};
struct add_immediates{};
struct subtract_immediates{};
struct multiply_immediates{};
struct divide_immediates{};
struct modulus_immediates{};
struct bitwise_and_immediates{};
struct bitwise_or_immediates{};
struct bitwise_xor_immediates{};
struct complement_immediates{};
struct function{};
struct multiply_add{};
struct multiply_subtract{};

template <class T>
struct backend_type;

template <class T, expression_template_option ExpressionTemplates>
struct backend_type<number<T, ExpressionTemplates> >
{
   typedef T type;
};

template <class tag, class A1, class A2, class A3, class A4>
struct backend_type<expression<tag, A1, A2, A3, A4> >
{
   typedef typename backend_type<typename expression<tag, A1, A2, A3, A4>::result_type>::type type;
};


template <class T1, class T2>
struct combine_expression
{



   typedef decltype(T1() + T2()) type;

};

template <class T1, expression_template_option ExpressionTemplates, class T2>
struct combine_expression<number<T1, ExpressionTemplates>, T2>
{
   typedef number<T1, ExpressionTemplates> type;
};

template <class T1, class T2, expression_template_option ExpressionTemplates>
struct combine_expression<T1, number<T2, ExpressionTemplates> >
{
   typedef number<T2, ExpressionTemplates> type;
};

template <class T, expression_template_option ExpressionTemplates>
struct combine_expression<number<T, ExpressionTemplates>, number<T, ExpressionTemplates> >
{
   typedef number<T, ExpressionTemplates> type;
};

template <class T1, expression_template_option ExpressionTemplates1, class T2, expression_template_option ExpressionTemplates2>
struct combine_expression<number<T1, ExpressionTemplates1>, number<T2, ExpressionTemplates2> >
{
   typedef typename mpl::if_c<
      is_convertible<number<T2, ExpressionTemplates2>, number<T1, ExpressionTemplates2> >::value,
      number<T1, ExpressionTemplates1>,
      number<T2, ExpressionTemplates2>
      >::type type;
};

template <class T>
struct arg_type
{
   typedef expression<terminal, T> type;
};

template <class Tag, class Arg1, class Arg2, class Arg3, class Arg4>
struct arg_type<expression<Tag, Arg1, Arg2, Arg3, Arg4> >
{
   typedef expression<Tag, Arg1, Arg2, Arg3, Arg4> type;
};

struct unmentionable
{
   unmentionable* proc(){ return 0; }
};

typedef unmentionable* (unmentionable::*unmentionable_type)();

template <class T, bool b>
struct expression_storage_base
{
   typedef const T& type;
};

template <class T>
struct expression_storage_base<T, true>
{
   typedef T type;
};

template <class T>
struct expression_storage : public expression_storage_base<T, boost::is_arithmetic<T>::value> {};

template <class T>
struct expression_storage<T*>
{
   typedef T* type;
};

template <class T>
struct expression_storage<const T*>
{
   typedef const T* type;
};

template <class tag, class A1, class A2, class A3, class A4>
struct expression_storage<expression<tag, A1, A2, A3, A4> >
{
   typedef expression<tag, A1, A2, A3, A4> type;
};

template<class tag, class Arg1>
struct expression<tag, Arg1, void, void, void>
{
   typedef mpl::int_<1> arity;
   typedef typename arg_type<Arg1>::type left_type;
   typedef typename left_type::result_type left_result_type;
   typedef typename left_type::result_type result_type;
   typedef tag tag_type;

   explicit expression(const Arg1& a) : arg(a) {}






   template <class Other>
   expression& operator=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not assign to a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   expression& operator++()
   {

      static_assert(sizeof(*this) == 2147483647, "You can not increment a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   expression& operator++(int)
   {

      static_assert(sizeof(*this) == 2147483647, "You can not increment a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   expression& operator--()
   {

      static_assert(sizeof(*this) == 2147483647, "You can not decrement a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   expression& operator--(int)
   {

      static_assert(sizeof(*this) == 2147483647, "You can not decrement a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator+=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator+= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator-=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator-= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator*=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator*= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator/=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator/= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator%=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator%= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator|=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator|= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator&=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator&= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator^=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator^= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator<<=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator<<= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator>>=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator>>= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }


   left_type left()const { return left_type(arg); }

   const Arg1& left_ref()const noexcept { return arg; }

   static const unsigned depth = left_type::depth + 1;
   template <class T

, typename boost::disable_if_c<is_number<T>::value || is_constructible<T const&, result_type>::value, int>::type = 0

>
   explicit operator T()const
   {
      return static_cast<T>(static_cast<result_type>(*this));
   }
   inline explicit operator bool()const
   {
      result_type r(*this);
      return static_cast<bool>(r);
   }
   template <class T>
   T convert_to()
   {
      result_type r(*this);
      return r.template convert_to<T>();
   }

private:
   typename expression_storage<Arg1>::type arg;
   expression& operator=(const expression&);
};

template<class Arg1>
struct expression<terminal, Arg1, void, void, void>
{
   typedef mpl::int_<0> arity;
   typedef Arg1 result_type;
   typedef terminal tag_type;

   explicit expression(const Arg1& a) : arg(a) {}






   template <class Other>
   expression& operator=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not assign to a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   expression& operator++()
   {

      static_assert(sizeof(*this) == 2147483647, "You can not increment a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   expression& operator++(int)
   {

      static_assert(sizeof(*this) == 2147483647, "You can not increment a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   expression& operator--()
   {

      static_assert(sizeof(*this) == 2147483647, "You can not decrement a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   expression& operator--(int)
   {

      static_assert(sizeof(*this) == 2147483647, "You can not decrement a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator+=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator+= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator-=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator-= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator*=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator*= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator/=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator/= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator%=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator%= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator|=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator|= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator&=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator&= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator^=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator^= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator<<=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator<<= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator>>=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator>>= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }


   const Arg1& value()const noexcept { return arg; }

   static const unsigned depth = 0;
   template <class T

, typename boost::disable_if_c<is_number<T>::value || is_constructible<T const&, result_type>::value, int>::type = 0

>
   explicit operator T()const
   {
      return static_cast<T>(static_cast<result_type>(*this));
   }
   inline explicit operator bool()const
   {
      result_type r(*this);
      return static_cast<bool>(r);
   }
   template <class T>
   T convert_to()
   {
      result_type r(*this);
      return r.template convert_to<T>();
   }

private:
   typename expression_storage<Arg1>::type arg;
   expression& operator=(const expression&);
};

template <class tag, class Arg1, class Arg2>
struct expression<tag, Arg1, Arg2, void, void>
{
   typedef mpl::int_<2> arity;
   typedef typename arg_type<Arg1>::type left_type;
   typedef typename arg_type<Arg2>::type right_type;
   typedef typename left_type::result_type left_result_type;
   typedef typename right_type::result_type right_result_type;
   typedef typename combine_expression<left_result_type, right_result_type>::type result_type;
   typedef tag tag_type;

   expression(const Arg1& a1, const Arg2& a2) : arg1(a1), arg2(a2) {}






   template <class Other>
   expression& operator=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not assign to a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   expression& operator++()
   {

      static_assert(sizeof(*this) == 2147483647, "You can not increment a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   expression& operator++(int)
   {

      static_assert(sizeof(*this) == 2147483647, "You can not increment a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   expression& operator--()
   {

      static_assert(sizeof(*this) == 2147483647, "You can not decrement a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   expression& operator--(int)
   {

      static_assert(sizeof(*this) == 2147483647, "You can not decrement a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator+=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator+= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator-=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator-= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator*=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator*= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator/=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator/= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator%=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator%= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator|=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator|= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator&=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator&= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator^=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator^= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator<<=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator<<= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator>>=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator>>= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }


   left_type left()const { return left_type(arg1); }
   right_type right()const { return right_type(arg2); }
   const Arg1& left_ref()const noexcept { return arg1; }
   const Arg2& right_ref()const noexcept { return arg2; }
   template <class T

, typename boost::disable_if_c<is_number<T>::value || is_constructible<T const&, result_type>::value, int>::type = 0

>
   explicit operator T()const
   {
      return static_cast<T>(static_cast<result_type>(*this));
   }
   inline explicit operator bool()const
   {
      result_type r(*this);
      return static_cast<bool>(r);
   }
   template <class T>
   T convert_to()
   {
      result_type r(*this);
      return r.template convert_to<T>();
   }

   static const unsigned left_depth = left_type::depth + 1;
   static const unsigned right_depth = right_type::depth + 1;
   static const unsigned depth = left_depth > right_depth ? left_depth : right_depth;
private:
   typename expression_storage<Arg1>::type arg1;
   typename expression_storage<Arg2>::type arg2;
   expression& operator=(const expression&);
};

template <class tag, class Arg1, class Arg2, class Arg3>
struct expression<tag, Arg1, Arg2, Arg3, void>
{
   typedef mpl::int_<3> arity;
   typedef typename arg_type<Arg1>::type left_type;
   typedef typename arg_type<Arg2>::type middle_type;
   typedef typename arg_type<Arg3>::type right_type;
   typedef typename left_type::result_type left_result_type;
   typedef typename middle_type::result_type middle_result_type;
   typedef typename right_type::result_type right_result_type;
   typedef typename combine_expression<
      left_result_type,
      typename combine_expression<right_result_type, middle_result_type>::type
   >::type result_type;
   typedef tag tag_type;

   expression(const Arg1& a1, const Arg2& a2, const Arg3& a3) : arg1(a1), arg2(a2), arg3(a3) {}






   template <class Other>
   expression& operator=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not assign to a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   expression& operator++()
   {

      static_assert(sizeof(*this) == 2147483647, "You can not increment a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   expression& operator++(int)
   {

      static_assert(sizeof(*this) == 2147483647, "You can not increment a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   expression& operator--()
   {

      static_assert(sizeof(*this) == 2147483647, "You can not decrement a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   expression& operator--(int)
   {

      static_assert(sizeof(*this) == 2147483647, "You can not decrement a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator+=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator+= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator-=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator-= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator*=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator*= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator/=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator/= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator%=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator%= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator|=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator|= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator&=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator&= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator^=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator^= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator<<=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator<<= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator>>=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator>>= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }


   left_type left()const { return left_type(arg1); }
   middle_type middle()const { return middle_type(arg2); }
   right_type right()const { return right_type(arg3); }
   const Arg1& left_ref()const noexcept { return arg1; }
   const Arg2& middle_ref()const noexcept { return arg2; }
   const Arg3& right_ref()const noexcept { return arg3; }
   template <class T

, typename boost::disable_if_c<is_number<T>::value || is_constructible<T const&, result_type>::value, int>::type = 0

>
   explicit operator T()const
   {
      return static_cast<T>(static_cast<result_type>(*this));
   }
   inline explicit operator bool()const
   {
      result_type r(*this);
      return static_cast<bool>(r);
   }
   template <class T>
   T convert_to()
   {
      result_type r(*this);
      return r.template convert_to<T>();
   }

   static const unsigned left_depth = left_type::depth + 1;
   static const unsigned middle_depth = middle_type::depth + 1;
   static const unsigned right_depth = right_type::depth + 1;
   static const unsigned depth = left_depth > right_depth ? (left_depth > middle_depth ? left_depth : middle_depth) : (right_depth > middle_depth ? right_depth : middle_depth);
private:
   typename expression_storage<Arg1>::type arg1;
   typename expression_storage<Arg2>::type arg2;
   typename expression_storage<Arg3>::type arg3;
   expression& operator=(const expression&);
};

template <class tag, class Arg1, class Arg2, class Arg3, class Arg4>
struct expression
{
   typedef mpl::int_<4> arity;
   typedef typename arg_type<Arg1>::type left_type;
   typedef typename arg_type<Arg2>::type left_middle_type;
   typedef typename arg_type<Arg3>::type right_middle_type;
   typedef typename arg_type<Arg4>::type right_type;
   typedef typename left_type::result_type left_result_type;
   typedef typename left_middle_type::result_type left_middle_result_type;
   typedef typename right_middle_type::result_type right_middle_result_type;
   typedef typename right_type::result_type right_result_type;
   typedef typename combine_expression<
      left_result_type,
      typename combine_expression<
         left_middle_result_type,
         typename combine_expression<right_middle_result_type, right_result_type>::type
      >::type
   >::type result_type;
   typedef tag tag_type;

   expression(const Arg1& a1, const Arg2& a2, const Arg3& a3, const Arg4& a4) : arg1(a1), arg2(a2), arg3(a3), arg4(a4) {}






   template <class Other>
   expression& operator=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not assign to a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   expression& operator++()
   {

      static_assert(sizeof(*this) == 2147483647, "You can not increment a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   expression& operator++(int)
   {

      static_assert(sizeof(*this) == 2147483647, "You can not increment a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   expression& operator--()
   {

      static_assert(sizeof(*this) == 2147483647, "You can not decrement a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   expression& operator--(int)
   {

      static_assert(sizeof(*this) == 2147483647, "You can not decrement a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator+=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator+= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator-=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator-= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator*=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator*= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator/=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator/= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator%=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator%= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator|=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator|= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator&=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator&= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator^=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator^= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator<<=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator<<= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }
   template <class Other>
   expression& operator>>=(const Other&)
   {

      static_assert(sizeof(Other) == 2147483647, "You can not use operator>>= on a Boost.Multiprecision expression template: did you inadvertantly store an expression template in a \"auto\" variable?  Or pass an expression to a template function with deduced temnplate arguments?");
      return *this;
   }


   left_type left()const { return left_type(arg1); }
   left_middle_type left_middle()const { return left_middle_type(arg2); }
   right_middle_type right_middle()const { return right_middle_type(arg3); }
   right_type right()const { return right_type(arg4); }
   const Arg1& left_ref()const noexcept { return arg1; }
   const Arg2& left_middle_ref()const noexcept { return arg2; }
   const Arg3& right_middle_ref()const noexcept { return arg3; }
   const Arg4& right_ref()const noexcept { return arg4; }
   template <class T

, typename boost::disable_if_c<is_number<T>::value || is_constructible<T const&, result_type>::value, int>::type = 0

>
   explicit operator T()const
   {
      return static_cast<T>(static_cast<result_type>(*this));
   }
   inline explicit operator bool()const
   {
      result_type r(*this);
      return static_cast<bool>(r);
   }
   template <class T>
   T convert_to()
   {
      result_type r(*this);
      return r.template convert_to<T>();
   }

   static const unsigned left_depth = left_type::depth + 1;
   static const unsigned left_middle_depth = left_middle_type::depth + 1;
   static const unsigned right_middle_depth = right_middle_type::depth + 1;
   static const unsigned right_depth = right_type::depth + 1;

   static const unsigned left_max_depth = left_depth > left_middle_depth ? left_depth : left_middle_depth;
   static const unsigned right_max_depth = right_depth > right_middle_depth ? right_depth : right_middle_depth;

   static const unsigned depth = left_max_depth > right_max_depth ? left_max_depth : right_max_depth;
private:
   typename expression_storage<Arg1>::type arg1;
   typename expression_storage<Arg2>::type arg2;
   typename expression_storage<Arg3>::type arg3;
   typename expression_storage<Arg4>::type arg4;
   expression& operator=(const expression&);
};

template <class T>
struct digits2
{
   static_assert(std::numeric_limits<T>::is_specialized, "std::numeric_limits<T>::is_specialized");
   static_assert((std::numeric_limits<T>::radix == 2) || (std::numeric_limits<T>::radix == 10), "(std::numeric_limits<T>::radix == 2) || (std::numeric_limits<T>::radix == 10)");

   static_assert(9223372036854775807L / 1000 > (std::numeric_limits<T>::digits + 1), "LONG_MAX / 1000 > (std::numeric_limits<T>::digits + 1)");
   static const long m_value = std::numeric_limits<T>::radix == 10 ? (((std::numeric_limits<T>::digits + 1) * 1000L) / 301L) : std::numeric_limits<T>::digits;
   static inline constexpr long value()noexcept { return m_value; }
};
template <class S>
void format_float_string(S& str, boost::intmax_t my_exp, boost::intmax_t digits, std::ios_base::fmtflags f, bool iszero)
{
   typedef typename S::size_type size_type;
   bool scientific = (f & std::ios_base::scientific) == std::ios_base::scientific;
   bool fixed = (f & std::ios_base::fixed) == std::ios_base::fixed;
   bool showpoint = (f & std::ios_base::showpoint) == std::ios_base::showpoint;
   bool showpos = (f & std::ios_base::showpos) == std::ios_base::showpos;

   bool neg = str.size() && (str[0] == '-');

   if(neg)
      str.erase(0, 1);

   if(digits == 0)
   {
      digits = (std::max)(str.size(), size_type(16));
   }

   if(iszero || str.empty() || (str.find_first_not_of('0') == S::npos))
   {


      str = "0";
      if(scientific || fixed)
      {
         str.append(1, '.');
         str.append(size_type(digits), '0');
         if(scientific)
            str.append("e+00");
      }
      else
      {
         if(showpoint)
         {
            str.append(1, '.');
            if(digits > 1)
               str.append(size_type(digits - 1), '0');
         }
      }
      if(neg)
         str.insert(static_cast<std::string::size_type>(0), 1, '-');
      else if(showpos)
         str.insert(static_cast<std::string::size_type>(0), 1, '+');
      return;
   }

   if(!fixed && !scientific && !showpoint)
   {



      std::string::iterator pos = str.end();
      while(pos != str.begin() && *--pos == '0'){}
      if(pos != str.end())
         ++pos;
      str.erase(pos, str.end());
      if(str.empty())
         str = '0';
   }
   else if(!fixed || (my_exp >= 0))
   {



      boost::intmax_t chars = str.size();
      chars = digits - chars;
      if(scientific)
         ++chars;
      if(chars > 0)
      {
         str.append(static_cast<std::string::size_type>(chars), '0');
      }
   }

   if(fixed || (!scientific && (my_exp >= -4) && (my_exp < digits)))
   {
      if(1 + my_exp > static_cast<boost::intmax_t>(str.size()))
      {

         str.append(static_cast<std::string::size_type>(1 + my_exp - str.size()), '0');
         if(showpoint || fixed)
            str.append(".");
      }
      else if(my_exp + 1 < static_cast<boost::intmax_t>(str.size()))
      {
         if(my_exp < 0)
         {
            str.insert(static_cast<std::string::size_type>(0), static_cast<std::string::size_type>(-1 - my_exp), '0');
            str.insert(static_cast<std::string::size_type>(0), "0.");
         }
         else
         {

            str.insert(static_cast<std::string::size_type>(my_exp + 1), 1, '.');
         }
      }
      else if(showpoint || fixed)
         str += ".";

      if(fixed)
      {

         boost::intmax_t l = str.find('.') + 1;
         l = digits - (str.size() - l);
         if(l > 0)
            str.append(size_type(l), '0');
      }
   }
   else
   {
      using boost::multiprecision::detail::abs;

      if(showpoint || (str.size() > 1))
         str.insert(static_cast<std::string::size_type>(1u), 1, '.');
      str.append(static_cast<std::string::size_type>(1u), 'e');
      S e = boost::lexical_cast<S>(abs(my_exp));
      if(e.size() < 2)
         e.insert(static_cast<std::string::size_type>(0), 2 - e.size(), '0');
      if(my_exp < 0)
         e.insert(static_cast<std::string::size_type>(0), 1, '-');
      else
         e.insert(static_cast<std::string::size_type>(0), 1, '+');
      str.append(e);
   }
   if(neg)
      str.insert(static_cast<std::string::size_type>(0), 1, '-');
   else if(showpos)
      str.insert(static_cast<std::string::size_type>(0), 1, '+');
}

template <class V>
void check_shift_range(V val, const mpl::true_&, const mpl::true_&)
{
   if(val > (std::numeric_limits<std::size_t>::max)())
      ::boost::exception_detail::throw_exception_(std::out_of_range("Can not shift by a value greater than std::numeric_limits<std::size_t>::max()."),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/number_base.hpp",1503);
   if(val < 0)
      ::boost::exception_detail::throw_exception_(std::out_of_range("Can not shift by a negative value."),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/number_base.hpp",1505);
}
template <class V>
void check_shift_range(V val, const mpl::false_&, const mpl::true_&)
{
   if(val < 0)
      ::boost::exception_detail::throw_exception_(std::out_of_range("Can not shift by a negative value."),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/number_base.hpp",1511);
}
template <class V>
void check_shift_range(V val, const mpl::true_&, const mpl::false_&)
{
   if(val > (std::numeric_limits<std::size_t>::max)())
      ::boost::exception_detail::throw_exception_(std::out_of_range("Can not shift by a value greater than std::numeric_limits<std::size_t>::max()."),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/number_base.hpp",1517);
}
template <class V>
void check_shift_range(V, const mpl::false_&, const mpl::false_&) noexcept{}

template <class T>
const T& evaluate_if_expression(const T& val) { return val; }
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4>
typename expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type evaluate_if_expression(const expression<tag, Arg1, Arg2, Arg3, Arg4>& val) { return val; }


}




enum number_category_type
{
   number_kind_unknown = -1,
   number_kind_integer = 0,
   number_kind_floating_point = 1,
   number_kind_rational = 2,
   number_kind_fixed_point = 3,
   number_kind_complex = 4
};

template <class Num>
struct number_category : public mpl::int_<std::numeric_limits<Num>::is_integer ? number_kind_integer : (std::numeric_limits<Num>::max_exponent ? number_kind_floating_point : number_kind_unknown)> {};
template <class Backend, expression_template_option ExpressionTemplates>
struct number_category<number<Backend, ExpressionTemplates> > : public number_category<Backend>{};
template <class tag, class A1, class A2, class A3, class A4>
struct number_category<detail::expression<tag, A1, A2, A3, A4> > : public number_category<typename detail::expression<tag, A1, A2, A3, A4>::result_type>{};




template <>
struct number_category<__int128> : public mpl::int_<number_kind_integer> {};
template <>
struct number_category<unsigned __int128> : public mpl::int_<number_kind_integer> {};






template <class T>
struct component_type { typedef T type; };
template <class tag, class A1, class A2, class A3, class A4>
struct component_type<detail::expression<tag, A1, A2, A3, A4> > : public component_type<typename detail::expression<tag, A1, A2, A3, A4>::result_type>{};

template <class T>
struct scalar_result_from_possible_complex
{
   typedef typename mpl::if_c<number_category<T>::value == number_kind_complex,
      typename component_type<T>::type, T>::type type;
};

template <class T>
struct complex_result_from_scalar;

template <class T>
struct is_unsigned_number : public mpl::false_{};
template <class Backend, expression_template_option ExpressionTemplates>
struct is_unsigned_number<number<Backend, ExpressionTemplates> > : public is_unsigned_number<Backend> {};
template <class T>
struct is_signed_number : public mpl::bool_<!is_unsigned_number<T>::value> {};
template <class T>
struct is_interval_number : public mpl::false_ {};
template <class Backend, expression_template_option ExpressionTemplates>
struct is_interval_number<number<Backend, ExpressionTemplates> > : public is_interval_number<Backend>{};

}}

namespace boost{ namespace math{ namespace tools{

template <class T>
struct promote_arg;

template <class tag, class A1, class A2, class A3, class A4>
struct promote_arg<boost::multiprecision::detail::expression<tag, A1, A2, A3, A4> >
{
   typedef typename boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type type;
};

template <class R, class B, boost::multiprecision::expression_template_option ET>
inline R real_cast(const boost::multiprecision::number<B, ET>& val)
{
   return val.template convert_to<R>();
}

template <class R, class tag, class A1, class A2, class A3, class A4>
inline R real_cast(const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>& val)
{
   typedef typename boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type val_type;
   return val_type(val).template convert_to<R>();
}


}

namespace constants{

   template <class T>
   struct is_explicitly_convertible_from_string;

   template <class B, boost::multiprecision::expression_template_option ET>
   struct is_explicitly_convertible_from_string<boost::multiprecision::number<B, ET> >
   {
      static const bool value = true;
   };

}

}}

namespace boost{ namespace multiprecision{ namespace detail{

   template <class Backend>
   struct is_variable_precision : public false_type{};

   template <class Backend, expression_template_option ExpressionTemplates>
   struct is_variable_precision<number<Backend, ExpressionTemplates> > : public is_variable_precision<Backend> {};

}
}
}


namespace boost{ namespace multiprecision{ namespace detail{

   template <class B, boost::multiprecision::expression_template_option ET>
   inline unsigned current_precision_of_imp(const boost::multiprecision::number<B, ET>& n, const mpl::true_&)
   {
      return n.precision();
   }
   template <class B, boost::multiprecision::expression_template_option ET>
   inline constexpr unsigned current_precision_of_imp(const boost::multiprecision::number<B, ET>&, const mpl::false_&)
   {
      return std::numeric_limits<boost::multiprecision::number<B, ET> >::digits10;
   }

   template <class Terminal>
   inline constexpr unsigned current_precision_of(const Terminal&)
   {
      return std::numeric_limits<Terminal>::digits10;
   }

   template <class Terminal, std::size_t N>
   inline constexpr unsigned current_precision_of(const Terminal(&)[N])
   {
      return 0;
   }

   template <class B, boost::multiprecision::expression_template_option ET>
   inline constexpr unsigned current_precision_of(const boost::multiprecision::number<B, ET>& n)
   {
      return current_precision_of_imp(n, boost::multiprecision::detail::is_variable_precision<boost::multiprecision::number<B, ET> >());
   }

   template<class tag, class Arg1>
   inline constexpr unsigned current_precision_of(const expression<tag, Arg1, void, void, void>& expr)
   {
      return current_precision_of(expr.left_ref());
   }

   template<class Arg1>
   inline constexpr unsigned current_precision_of(const expression<terminal, Arg1, void, void, void>& expr)
   {
      return current_precision_of(expr.value());
   }

   template <class tag, class Arg1, class Arg2>
   inline constexpr unsigned current_precision_of(const expression<tag, Arg1, Arg2, void, void>& expr)
   {
      return (std::max)(current_precision_of(expr.left_ref()), current_precision_of(expr.right_ref()));
   }

   template <class tag, class Arg1, class Arg2, class Arg3>
   inline constexpr unsigned current_precision_of(const expression<tag, Arg1, Arg2, Arg3, void>& expr)
   {
      return (std::max)((std::max)(current_precision_of(expr.left_ref()), current_precision_of(expr.right_ref())), current_precision_of(expr.middle_ref()));
   }

   template <class R, bool = boost::multiprecision::detail::is_variable_precision<R>::value>
   struct scoped_default_precision
   {
      template <class T>
      scoped_default_precision(const T&) {}
      template <class T, class U>
      scoped_default_precision(const T&, const U&) {}
      template <class T, class U, class V>
      scoped_default_precision(const T&, const U&, const V&) {}
   };

   template <class R>
   struct scoped_default_precision<R, true>
   {
      template <class T>
      scoped_default_precision(const T& a)
      {
         init(current_precision_of(a));
      }
      template <class T, class U>
      scoped_default_precision(const T& a, const U& b)
      {
         init((std::max)(current_precision_of(a), current_precision_of(b)));
      }
      template <class T, class U, class V>
      scoped_default_precision(const T& a, const U& b, const V& c)
      {
         init((std::max)((std::max)(current_precision_of(a), current_precision_of(b)), current_precision_of(c)));
      }
      ~scoped_default_precision()
      {
         R::default_precision(m_prec);
      }
   private:
      void init(unsigned p)
      {
         m_prec = R::default_precision();
         if (p)
            R::default_precision(p);
      }
      unsigned m_prec;
   };

   template <class T>
   inline void maybe_promote_precision(T*, const mpl::false_&){}

   template <class T>
   inline void maybe_promote_precision(T* obj, const mpl::true_&)
   {
      if (obj->precision() != T::default_precision())
      {
         obj->precision(T::default_precision());
      }
   }

   template <class T>
   inline void maybe_promote_precision(T* obj)
   {
      maybe_promote_precision(obj, boost::multiprecision::detail::is_variable_precision<T>());
   }
}
}
}
















namespace boost{ namespace math
{
namespace tools
{
template <class T>
inline constexpr int digits() noexcept
{

   static_assert(::std::numeric_limits<T>::is_specialized, "::std::numeric_limits<T>::is_specialized");
   static_assert(::std::numeric_limits<T>::radix == 2 || ::std::numeric_limits<T>::radix == 10, "::std::numeric_limits<T>::radix == 2 || ::std::numeric_limits<T>::radix == 10");




   return std::numeric_limits<T>::radix == 2
      ? std::numeric_limits<T>::digits
      : ((std::numeric_limits<T>::digits + 1) * 1000L) / 301L;
}

template <class T>
inline constexpr T max_value() noexcept(std::is_floating_point<T>::value)
{

   static_assert(::std::numeric_limits<T>::is_specialized, "::std::numeric_limits<T>::is_specialized");



   return (std::numeric_limits<T>::max)();
}


template <class T>
inline constexpr T min_value() noexcept(std::is_floating_point<T>::value)
{

   static_assert(::std::numeric_limits<T>::is_specialized, "::std::numeric_limits<T>::is_specialized");



   return (std::numeric_limits<T>::min)();
}

namespace detail{
template <class T>
inline constexpr T log_max_value(const mpl::int_<128>& ) noexcept(std::is_floating_point<T>::value)
{
   return 88.0f;
}

template <class T>
inline constexpr T log_min_value(const mpl::int_<128>& ) noexcept(std::is_floating_point<T>::value)
{
   return -87.0f;
}



template <class T>
inline constexpr T log_max_value(const mpl::int_<1024>& ) noexcept(std::is_floating_point<T>::value)
{
   return 709.0;
}

template <class T>
inline constexpr T log_min_value(const mpl::int_<1024>& ) noexcept(std::is_floating_point<T>::value)
{
   return -708.0;
}



template <class T>
inline constexpr T log_max_value(const mpl::int_<16384>& ) noexcept(std::is_floating_point<T>::value)
{
   return 11356.0L;
}

template <class T>
inline constexpr T log_min_value(const mpl::int_<16384>& ) noexcept(std::is_floating_point<T>::value)
{
   return -11355.0L;
}

template <class T>
inline T log_max_value(const mpl::int_<0>& )
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;




   static const T val = log(boost::math::tools::max_value<T>());

   return val;
}

template <class T>
inline T log_min_value(const mpl::int_<0>& )
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;




   static const T val = log(boost::math::tools::min_value<T>());

   return val;
}

template <class T>
inline constexpr T epsilon(const mpl::true_& ) noexcept(std::is_floating_point<T>::value)
{
   return std::numeric_limits<T>::epsilon();
}
template <class T>
inline T epsilon(const mpl::false_& )
{

   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;
   return ldexp(static_cast<T>(1), 1-policies::digits<T, policies::policy<> >());
}

template <class T>
struct log_limit_traits
{
   typedef typename mpl::if_c<
      (std::numeric_limits<T>::radix == 2) &&
      (std::numeric_limits<T>::max_exponent == 128
         || std::numeric_limits<T>::max_exponent == 1024
         || std::numeric_limits<T>::max_exponent == 16384),
      mpl::int_<(std::numeric_limits<T>::max_exponent > 2147483647 ? 2147483647 : static_cast<int>(std::numeric_limits<T>::max_exponent))>,
      mpl::int_<0>
   >::type tag_type;
   static const bool value = tag_type::value ? true : false;
   static_assert(::std::numeric_limits<T>::is_specialized || (value == 0), "::std::numeric_limits<T>::is_specialized || (value == 0)");
};

template <class T, bool b> struct log_limit_noexcept_traits_imp : public log_limit_traits<T> {};
template <class T> struct log_limit_noexcept_traits_imp<T, false> : public boost::integral_constant<bool, false> {};

template <class T>
struct log_limit_noexcept_traits : public log_limit_noexcept_traits_imp<T, (std::is_floating_point<T>::value)> {};

}






template <class T>
inline constexpr T log_max_value() noexcept((detail::log_limit_noexcept_traits<T>::value))
{

   return detail::log_max_value<T>(typename detail::log_limit_traits<T>::tag_type());






}

template <class T>
inline constexpr T log_min_value() noexcept((detail::log_limit_noexcept_traits<T>::value))
{

   return detail::log_min_value<T>(typename detail::log_limit_traits<T>::tag_type());






}





template <class T>
inline constexpr T epsilon() noexcept(std::is_floating_point<T>::value)
{

   return detail::epsilon<T>(mpl::bool_< ::std::numeric_limits<T>::is_specialized>());





}

namespace detail{

template <class T>
inline constexpr T root_epsilon_imp(const mpl::int_<24>&) noexcept(std::is_floating_point<T>::value)
{
   return static_cast<T>(0.00034526698300124390839884978618400831996329879769945L);
}

template <class T>
inline constexpr T root_epsilon_imp(const T*, const mpl::int_<53>&) noexcept(std::is_floating_point<T>::value)
{
   return static_cast<T>(0.1490116119384765625e-7L);
}

template <class T>
inline constexpr T root_epsilon_imp(const T*, const mpl::int_<64>&) noexcept(std::is_floating_point<T>::value)
{
   return static_cast<T>(0.32927225399135962333569506281281311031656150598474e-9L);
}

template <class T>
inline constexpr T root_epsilon_imp(const T*, const mpl::int_<113>&) noexcept(std::is_floating_point<T>::value)
{
   return static_cast<T>(0.1387778780781445675529539585113525390625e-16L);
}

template <class T, class Tag>
inline T root_epsilon_imp(const T*, const Tag&)
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;
   static const T r_eps = sqrt(tools::epsilon<T>());
   return r_eps;
}

template <class T>
inline T root_epsilon_imp(const T*, const mpl::int_<0>&)
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;
   return sqrt(tools::epsilon<T>());
}

template <class T>
inline constexpr T cbrt_epsilon_imp(const mpl::int_<24>&) noexcept(std::is_floating_point<T>::value)
{
   return static_cast<T>(0.0049215666011518482998719164346805794944150447839903L);
}

template <class T>
inline constexpr T cbrt_epsilon_imp(const T*, const mpl::int_<53>&) noexcept(std::is_floating_point<T>::value)
{
   return static_cast<T>(6.05545445239333906078989272793696693569753008995e-6L);
}

template <class T>
inline constexpr T cbrt_epsilon_imp(const T*, const mpl::int_<64>&) noexcept(std::is_floating_point<T>::value)
{
   return static_cast<T>(4.76837158203125e-7L);
}

template <class T>
inline constexpr T cbrt_epsilon_imp(const T*, const mpl::int_<113>&) noexcept(std::is_floating_point<T>::value)
{
   return static_cast<T>(5.7749313854154005630396773604745549542403508090496e-12L);
}

template <class T, class Tag>
inline T cbrt_epsilon_imp(const T*, const Tag&)
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;;
   static const T cbrt_eps = pow(tools::epsilon<T>(), T(1) / 3);
   return cbrt_eps;
}

template <class T>
inline T cbrt_epsilon_imp(const T*, const mpl::int_<0>&)
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;;
   return pow(tools::epsilon<T>(), T(1) / 3);
}

template <class T>
inline constexpr T forth_root_epsilon_imp(const T*, const mpl::int_<24>&) noexcept(std::is_floating_point<T>::value)
{
   return static_cast<T>(0.018581361171917516667460937040007436176452688944747L);
}

template <class T>
inline constexpr T forth_root_epsilon_imp(const T*, const mpl::int_<53>&) noexcept(std::is_floating_point<T>::value)
{
   return static_cast<T>(0.0001220703125L);
}

template <class T>
inline constexpr T forth_root_epsilon_imp(const T*, const mpl::int_<64>&) noexcept(std::is_floating_point<T>::value)
{
   return static_cast<T>(0.18145860519450699870567321328132261891067079047605e-4L);
}

template <class T>
inline constexpr T forth_root_epsilon_imp(const T*, const mpl::int_<113>&) noexcept(std::is_floating_point<T>::value)
{
   return static_cast<T>(0.37252902984619140625e-8L);
}

template <class T, class Tag>
inline T forth_root_epsilon_imp(const T*, const Tag&)
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;
   static const T r_eps = sqrt(sqrt(tools::epsilon<T>()));
   return r_eps;
}

template <class T>
inline T forth_root_epsilon_imp(const T*, const mpl::int_<0>&)
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;
   return sqrt(sqrt(tools::epsilon<T>()));
}

template <class T>
struct root_epsilon_traits
{
   typedef mpl::int_< (::std::numeric_limits<T>::radix == 2) && (::std::numeric_limits<T>::digits != 2147483647) ? std::numeric_limits<T>::digits : 0> tag_type;
   static const bool has_noexcept = (tag_type::value == 113) || (tag_type::value == 64) || (tag_type::value == 53) || (tag_type::value == 24);
};

}

template <class T>
inline constexpr T root_epsilon() noexcept(((std::is_floating_point<T>::value) && detail::root_epsilon_traits<T>::has_noexcept))
{
   return detail::root_epsilon_imp(static_cast<T const*>(0), typename detail::root_epsilon_traits<T>::tag_type());
}

template <class T>
inline constexpr T cbrt_epsilon() noexcept(((std::is_floating_point<T>::value) && detail::root_epsilon_traits<T>::has_noexcept))
{
   return detail::cbrt_epsilon_imp(static_cast<T const*>(0), typename detail::root_epsilon_traits<T>::tag_type());
}

template <class T>
inline constexpr T forth_root_epsilon() noexcept(((std::is_floating_point<T>::value) && detail::root_epsilon_traits<T>::has_noexcept))
{
   return detail::forth_root_epsilon_imp(static_cast<T const*>(0), typename detail::root_epsilon_traits<T>::tag_type());
}

}
}
}

namespace boost{ namespace math{

class evaluation_error : public std::runtime_error
{
public:
   evaluation_error(const std::string& s) : std::runtime_error(s){}
};

class rounding_error : public std::runtime_error
{
public:
   rounding_error(const std::string& s) : std::runtime_error(s){}
};

namespace policies{




template <class T>
T user_domain_error(const char* function, const char* message, const T& val);
template <class T>
T user_pole_error(const char* function, const char* message, const T& val);
template <class T>
T user_overflow_error(const char* function, const char* message, const T& val);
template <class T>
T user_underflow_error(const char* function, const char* message, const T& val);
template <class T>
T user_denorm_error(const char* function, const char* message, const T& val);
template <class T>
T user_evaluation_error(const char* function, const char* message, const T& val);
template <class T, class TargetType>
T user_rounding_error(const char* function, const char* message, const T& val, const TargetType& t);
template <class T>
T user_indeterminate_result_error(const char* function, const char* message, const T& val);

namespace detail
{

template <class T>
std::string prec_format(const T& val)
{
   typedef typename boost::math::policies::precision<T, boost::math::policies::policy<> >::type prec_type;
   std::stringstream ss;
   if(prec_type::value)
   {
      int prec = 2 + (prec_type::value * 30103UL) / 100000UL;
      ss << std::setprecision(prec);
   }
   ss << val;
   return ss.str();
}

inline void replace_all_in_string(std::string& result, const char* what, const char* with)
{
   std::string::size_type pos = 0;
   std::string::size_type slen = std::strlen(what);
   std::string::size_type rlen = std::strlen(with);
   while((pos = result.find(what, pos)) != std::string::npos)
   {
      result.replace(pos, slen, with);
      pos += rlen;
   }
}

template <class T>
inline const char* name_of()
{

   return typeid(T).name();



}
template <> inline const char* name_of<float>(){ return "float"; }
template <> inline const char* name_of<double>(){ return "double"; }
template <> inline const char* name_of<long double>(){ return "long double"; }
template <class E, class T>
void raise_error(const char* pfunction, const char* message)
{
  if(pfunction == 0)
     pfunction = "Unknown function operating on type %1%";
  if(message == 0)
     message = "Cause unknown";

  std::string function(pfunction);
  std::string msg("Error in function ");

  replace_all_in_string(function, "%1%", boost::math::policies::detail::name_of<T>());



  msg += function;
  msg += ": ";
  msg += message;

  E e(msg);
  boost::throw_exception(e);
}

template <class E, class T>
void raise_error(const char* pfunction, const char* pmessage, const T& val)
{
  if(pfunction == 0)
     pfunction = "Unknown function operating on type %1%";
  if(pmessage == 0)
     pmessage = "Cause unknown: error caused by bad argument with value %1%";

  std::string function(pfunction);
  std::string message(pmessage);
  std::string msg("Error in function ");

  replace_all_in_string(function, "%1%", boost::math::policies::detail::name_of<T>());



  msg += function;
  msg += ": ";

  std::string sval = prec_format(val);
  replace_all_in_string(message, "%1%", sval.c_str());
  msg += message;

  E e(msg);
  boost::throw_exception(e);
}

template <class T>
inline T raise_domain_error(
           const char* function,
           const char* message,
           const T& val,
           const ::boost::math::policies::domain_error< ::boost::math::policies::throw_on_error>&)
{
   raise_error<std::domain_error, T>(function, message, val);

   return std::numeric_limits<T>::quiet_NaN();
}

template <class T>
inline constexpr T raise_domain_error(
           const char* ,
           const char* ,
           const T& ,
           const ::boost::math::policies::domain_error< ::boost::math::policies::ignore_error>&) noexcept(std::is_floating_point<T>::value)
{


   return std::numeric_limits<T>::quiet_NaN();
}

template <class T>
inline T raise_domain_error(
           const char* ,
           const char* ,
           const T& ,
           const ::boost::math::policies::domain_error< ::boost::math::policies::errno_on_error>&) noexcept(std::is_floating_point<T>::value)
{
   (*__error()) = 33;


   return std::numeric_limits<T>::quiet_NaN();
}

template <class T>
inline T raise_domain_error(
           const char* function,
           const char* message,
           const T& val,
           const ::boost::math::policies::domain_error< ::boost::math::policies::user_error>&)
{
   return user_domain_error(function, message, val);
}

template <class T>
inline T raise_pole_error(
           const char* function,
           const char* message,
           const T& val,
           const ::boost::math::policies::pole_error< ::boost::math::policies::throw_on_error>&)
{
   return boost::math::policies::detail::raise_domain_error(function, message, val, ::boost::math::policies::domain_error< ::boost::math::policies::throw_on_error>());
}

template <class T>
inline constexpr T raise_pole_error(
           const char* function,
           const char* message,
           const T& val,
           const ::boost::math::policies::pole_error< ::boost::math::policies::ignore_error>&) noexcept(std::is_floating_point<T>::value)
{
   return ::boost::math::policies::detail::raise_domain_error(function, message, val, ::boost::math::policies::domain_error< ::boost::math::policies::ignore_error>());
}

template <class T>
inline constexpr T raise_pole_error(
           const char* function,
           const char* message,
           const T& val,
           const ::boost::math::policies::pole_error< ::boost::math::policies::errno_on_error>&) noexcept(std::is_floating_point<T>::value)
{
   return ::boost::math::policies::detail::raise_domain_error(function, message, val, ::boost::math::policies::domain_error< ::boost::math::policies::errno_on_error>());
}

template <class T>
inline T raise_pole_error(
           const char* function,
           const char* message,
           const T& val,
           const ::boost::math::policies::pole_error< ::boost::math::policies::user_error>&)
{
   return user_pole_error(function, message, val);
}


template <class T>
inline T raise_overflow_error(
           const char* function,
           const char* message,
           const ::boost::math::policies::overflow_error< ::boost::math::policies::throw_on_error>&)
{
   raise_error<std::overflow_error, T>(function, message ? message : "numeric overflow");

   return std::numeric_limits<T>::has_infinity ? std::numeric_limits<T>::infinity() : boost::math::tools::max_value<T>();
}

template <class T>
inline T raise_overflow_error(
           const char* function,
           const char* message,
           const T& val,
           const ::boost::math::policies::overflow_error< ::boost::math::policies::throw_on_error>&)
{
   raise_error<std::overflow_error, T>(function, message ? message : "numeric overflow", val);

   return std::numeric_limits<T>::has_infinity ? std::numeric_limits<T>::infinity() : boost::math::tools::max_value<T>();
}

template <class T>
inline constexpr T raise_overflow_error(
           const char* ,
           const char* ,
           const ::boost::math::policies::overflow_error< ::boost::math::policies::ignore_error>&) noexcept(std::is_floating_point<T>::value)
{


   return std::numeric_limits<T>::has_infinity ? std::numeric_limits<T>::infinity() : boost::math::tools::max_value<T>();
}

template <class T>
inline constexpr T raise_overflow_error(
           const char* ,
           const char* ,
           const T&,
           const ::boost::math::policies::overflow_error< ::boost::math::policies::ignore_error>&) noexcept(std::is_floating_point<T>::value)
{


   return std::numeric_limits<T>::has_infinity ? std::numeric_limits<T>::infinity() : boost::math::tools::max_value<T>();
}

template <class T>
inline T raise_overflow_error(
           const char* ,
           const char* ,
           const ::boost::math::policies::overflow_error< ::boost::math::policies::errno_on_error>&) noexcept(std::is_floating_point<T>::value)
{
   (*__error()) = 34;


   return std::numeric_limits<T>::has_infinity ? std::numeric_limits<T>::infinity() : boost::math::tools::max_value<T>();
}

template <class T>
inline T raise_overflow_error(
           const char* ,
           const char* ,
           const T&,
           const ::boost::math::policies::overflow_error< ::boost::math::policies::errno_on_error>&) noexcept(std::is_floating_point<T>::value)
{
   (*__error()) = 34;


   return std::numeric_limits<T>::has_infinity ? std::numeric_limits<T>::infinity() : boost::math::tools::max_value<T>();
}

template <class T>
inline T raise_overflow_error(
           const char* function,
           const char* message,
           const ::boost::math::policies::overflow_error< ::boost::math::policies::user_error>&)
{
   return user_overflow_error(function, message, std::numeric_limits<T>::infinity());
}

template <class T>
inline T raise_overflow_error(
           const char* function,
           const char* message,
           const T& val,
           const ::boost::math::policies::overflow_error< ::boost::math::policies::user_error>&)
{
   std::string m(message ? message : "");
   std::string sval = prec_format(val);
   replace_all_in_string(m, "%1%", sval.c_str());

   return user_overflow_error(function, m.c_str(), std::numeric_limits<T>::infinity());
}

template <class T>
inline T raise_underflow_error(
           const char* function,
           const char* message,
           const ::boost::math::policies::underflow_error< ::boost::math::policies::throw_on_error>&)
{
   raise_error<std::underflow_error, T>(function, message ? message : "numeric underflow");

   return 0;
}

template <class T>
inline constexpr T raise_underflow_error(
           const char* ,
           const char* ,
           const ::boost::math::policies::underflow_error< ::boost::math::policies::ignore_error>&) noexcept(std::is_floating_point<T>::value)
{


   return T(0);
}

template <class T>
inline T raise_underflow_error(
           const char* ,
           const char* ,
           const ::boost::math::policies::underflow_error< ::boost::math::policies::errno_on_error>&) noexcept(std::is_floating_point<T>::value)
{
   (*__error()) = 34;


   return T(0);
}

template <class T>
inline T raise_underflow_error(
           const char* function,
           const char* message,
           const ::boost::math::policies::underflow_error< ::boost::math::policies::user_error>&)
{
   return user_underflow_error(function, message, T(0));
}

template <class T>
inline T raise_denorm_error(
           const char* function,
           const char* message,
           const T& ,
           const ::boost::math::policies::denorm_error< ::boost::math::policies::throw_on_error>&)
{
   raise_error<std::underflow_error, T>(function, message ? message : "denormalised result");

   return T(0);
}

template <class T>
inline constexpr T raise_denorm_error(
           const char* ,
           const char* ,
           const T& val,
           const ::boost::math::policies::denorm_error< ::boost::math::policies::ignore_error>&) noexcept(std::is_floating_point<T>::value)
{


   return val;
}

template <class T>
inline T raise_denorm_error(
           const char* ,
           const char* ,
           const T& val,
           const ::boost::math::policies::denorm_error< ::boost::math::policies::errno_on_error>&) noexcept(std::is_floating_point<T>::value)
{
   (*__error()) = 34;


   return val;
}

template <class T>
inline T raise_denorm_error(
           const char* function,
           const char* message,
           const T& val,
           const ::boost::math::policies::denorm_error< ::boost::math::policies::user_error>&)
{
   return user_denorm_error(function, message, val);
}

template <class T>
inline T raise_evaluation_error(
           const char* function,
           const char* message,
           const T& val,
           const ::boost::math::policies::evaluation_error< ::boost::math::policies::throw_on_error>&)
{
   raise_error<boost::math::evaluation_error, T>(function, message, val);

   return T(0);
}

template <class T>
inline constexpr T raise_evaluation_error(
           const char* ,
           const char* ,
           const T& val,
           const ::boost::math::policies::evaluation_error< ::boost::math::policies::ignore_error>&) noexcept(std::is_floating_point<T>::value)
{


   return val;
}

template <class T>
inline T raise_evaluation_error(
           const char* ,
           const char* ,
           const T& val,
           const ::boost::math::policies::evaluation_error< ::boost::math::policies::errno_on_error>&) noexcept(std::is_floating_point<T>::value)
{
   (*__error()) = 33;


   return val;
}

template <class T>
inline T raise_evaluation_error(
           const char* function,
           const char* message,
           const T& val,
           const ::boost::math::policies::evaluation_error< ::boost::math::policies::user_error>&)
{
   return user_evaluation_error(function, message, val);
}

template <class T, class TargetType>
inline TargetType raise_rounding_error(
           const char* function,
           const char* message,
           const T& val,
           const TargetType&,
           const ::boost::math::policies::rounding_error< ::boost::math::policies::throw_on_error>&)
{
   raise_error<boost::math::rounding_error, T>(function, message, val);

   return TargetType(0);
}

template <class T, class TargetType>
inline constexpr TargetType raise_rounding_error(
           const char* ,
           const char* ,
           const T& val,
           const TargetType&,
           const ::boost::math::policies::rounding_error< ::boost::math::policies::ignore_error>&) noexcept(std::is_floating_point<T>::value)
{


   static_assert(std::numeric_limits<TargetType>::is_specialized, "std::numeric_limits<TargetType>::is_specialized");
   return val > 0 ? (std::numeric_limits<TargetType>::max)() : (std::numeric_limits<TargetType>::is_integer ? (std::numeric_limits<TargetType>::min)() : -(std::numeric_limits<TargetType>::max)());
}

template <class T, class TargetType>
inline TargetType raise_rounding_error(
           const char* ,
           const char* ,
           const T& val,
           const TargetType&,
           const ::boost::math::policies::rounding_error< ::boost::math::policies::errno_on_error>&) noexcept(std::is_floating_point<T>::value)
{
   (*__error()) = 34;


   static_assert(std::numeric_limits<TargetType>::is_specialized, "std::numeric_limits<TargetType>::is_specialized");
   return val > 0 ? (std::numeric_limits<TargetType>::max)() : (std::numeric_limits<TargetType>::is_integer ? (std::numeric_limits<TargetType>::min)() : -(std::numeric_limits<TargetType>::max)());
}

template <class T>
inline T raise_rounding_error(
           const char* ,
           const char* ,
           const T& val,
           const T&,
           const ::boost::math::policies::rounding_error< ::boost::math::policies::errno_on_error>&) noexcept(std::is_floating_point<T>::value)
{
   (*__error()) = 34;


   return val > 0 ? boost::math::tools::max_value<T>() : -boost::math::tools::max_value<T>();
}

template <class T, class TargetType>
inline TargetType raise_rounding_error(
           const char* function,
           const char* message,
           const T& val,
           const TargetType& t,
           const ::boost::math::policies::rounding_error< ::boost::math::policies::user_error>&)
{
   return user_rounding_error(function, message, val, t);
}

template <class T, class R>
inline T raise_indeterminate_result_error(
           const char* function,
           const char* message,
           const T& val,
           const R& ,
           const ::boost::math::policies::indeterminate_result_error< ::boost::math::policies::throw_on_error>&)
{
   raise_error<std::domain_error, T>(function, message, val);

   return std::numeric_limits<T>::quiet_NaN();
}

template <class T, class R>
inline constexpr T raise_indeterminate_result_error(
           const char* ,
           const char* ,
           const T& ,
           const R& result,
           const ::boost::math::policies::indeterminate_result_error< ::boost::math::policies::ignore_error>&) noexcept(std::is_floating_point<T>::value)
{


   return result;
}

template <class T, class R>
inline T raise_indeterminate_result_error(
           const char* ,
           const char* ,
           const T& ,
           const R& result,
           const ::boost::math::policies::indeterminate_result_error< ::boost::math::policies::errno_on_error>&)
{
   (*__error()) = 33;


   return result;
}

template <class T, class R>
inline T raise_indeterminate_result_error(
           const char* function,
           const char* message,
           const T& val,
           const R& ,
           const ::boost::math::policies::indeterminate_result_error< ::boost::math::policies::user_error>&)
{
   return user_indeterminate_result_error(function, message, val);
}

}

template <class T, class Policy>
inline constexpr T raise_domain_error(const char* function, const char* message, const T& val, const Policy&) noexcept((is_noexcept_error_policy<Policy>::value && (std::is_floating_point<T>::value)))
{
   typedef typename Policy::domain_error_type policy_type;
   return detail::raise_domain_error(
      function, message ? message : "Domain Error evaluating function at %1%",
      val, policy_type());
}

template <class T, class Policy>
inline constexpr T raise_pole_error(const char* function, const char* message, const T& val, const Policy&) noexcept((is_noexcept_error_policy<Policy>::value && (std::is_floating_point<T>::value)))
{
   typedef typename Policy::pole_error_type policy_type;
   return detail::raise_pole_error(
      function, message ? message : "Evaluation of function at pole %1%",
      val, policy_type());
}

template <class T, class Policy>
inline constexpr T raise_overflow_error(const char* function, const char* message, const Policy&) noexcept((is_noexcept_error_policy<Policy>::value && (std::is_floating_point<T>::value)))
{
   typedef typename Policy::overflow_error_type policy_type;
   return detail::raise_overflow_error<T>(
      function, message ? message : "Overflow Error",
      policy_type());
}

template <class T, class Policy>
inline constexpr T raise_overflow_error(const char* function, const char* message, const T& val, const Policy&) noexcept((is_noexcept_error_policy<Policy>::value && (std::is_floating_point<T>::value)))
{
   typedef typename Policy::overflow_error_type policy_type;
   return detail::raise_overflow_error(
      function, message ? message : "Overflow evaluating function at %1%",
      val, policy_type());
}

template <class T, class Policy>
inline constexpr T raise_underflow_error(const char* function, const char* message, const Policy&) noexcept((is_noexcept_error_policy<Policy>::value && (std::is_floating_point<T>::value)))
{
   typedef typename Policy::underflow_error_type policy_type;
   return detail::raise_underflow_error<T>(
      function, message ? message : "Underflow Error",
      policy_type());
}

template <class T, class Policy>
inline constexpr T raise_denorm_error(const char* function, const char* message, const T& val, const Policy&) noexcept((is_noexcept_error_policy<Policy>::value && (std::is_floating_point<T>::value)))
{
   typedef typename Policy::denorm_error_type policy_type;
   return detail::raise_denorm_error<T>(
      function, message ? message : "Denorm Error",
      val,
      policy_type());
}

template <class T, class Policy>
inline constexpr T raise_evaluation_error(const char* function, const char* message, const T& val, const Policy&) noexcept((is_noexcept_error_policy<Policy>::value && (std::is_floating_point<T>::value)))
{
   typedef typename Policy::evaluation_error_type policy_type;
   return detail::raise_evaluation_error(
      function, message ? message : "Internal Evaluation Error, best value so far was %1%",
      val, policy_type());
}

template <class T, class TargetType, class Policy>
inline constexpr TargetType raise_rounding_error(const char* function, const char* message, const T& val, const TargetType& t, const Policy&) noexcept((is_noexcept_error_policy<Policy>::value && (std::is_floating_point<T>::value)))
{
   typedef typename Policy::rounding_error_type policy_type;
   return detail::raise_rounding_error(
      function, message ? message : "Value %1% can not be represented in the target integer type.",
      val, t, policy_type());
}

template <class T, class R, class Policy>
inline constexpr T raise_indeterminate_result_error(const char* function, const char* message, const T& val, const R& result, const Policy&) noexcept((is_noexcept_error_policy<Policy>::value && (std::is_floating_point<T>::value)))
{
   typedef typename Policy::indeterminate_result_error_type policy_type;
   return detail::raise_indeterminate_result_error(
      function, message ? message : "Indeterminate result with value %1%",
      val, result, policy_type());
}




namespace detail
{

template <class R, class T, class Policy>
inline bool check_overflow(T val, R* result, const char* function, const Policy& pol) noexcept(((std::is_floating_point<R>::value) && (std::is_floating_point<T>::value) && (Policy::value != throw_on_error) && (Policy::value != user_error)))
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;
   if(fabs(val) > tools::max_value<R>())
   {
      boost::math::policies::detail::raise_overflow_error<R>(function, 0, pol);
      *result = static_cast<R>(val);
      return true;
   }
   return false;
}
template <class R, class T, class Policy>
inline bool check_overflow(std::complex<T> val, R* result, const char* function, const Policy& pol) noexcept(((std::is_floating_point<R>::value) && (std::is_floating_point<T>::value) && (Policy::value != throw_on_error) && (Policy::value != user_error)))
{
   typedef typename R::value_type r_type;
   r_type re, im;
   bool r = check_overflow<r_type>(val.real(), &re, function, pol);
   r = check_overflow<r_type>(val.imag(), &im, function, pol) || r;
   *result = R(re, im);
   return r;
}
template <class R, class T, class Policy>
inline bool check_underflow(T val, R* result, const char* function, const Policy& pol) noexcept(((std::is_floating_point<R>::value) && (std::is_floating_point<T>::value) && (Policy::value != throw_on_error) && (Policy::value != user_error)))
{
   if((val != 0) && (static_cast<R>(val) == 0))
   {
      *result = static_cast<R>(boost::math::policies::detail::raise_underflow_error<R>(function, 0, pol));
      return true;
   }
   return false;
}
template <class R, class T, class Policy>
inline bool check_underflow(std::complex<T> val, R* result, const char* function, const Policy& pol) noexcept(((std::is_floating_point<R>::value) && (std::is_floating_point<T>::value) && (Policy::value != throw_on_error) && (Policy::value != user_error)))
{
   typedef typename R::value_type r_type;
   r_type re, im;
   bool r = check_underflow<r_type>(val.real(), &re, function, pol);
   r = check_underflow<r_type>(val.imag(), &im, function, pol) || r;
   *result = R(re, im);
   return r;
}
template <class R, class T, class Policy>
inline bool check_denorm(T val, R* result, const char* function, const Policy& pol) noexcept(((std::is_floating_point<R>::value) && (std::is_floating_point<T>::value) && (Policy::value != throw_on_error) && (Policy::value != user_error)))
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;
   if((fabs(val) < static_cast<T>(tools::min_value<R>())) && (static_cast<R>(val) != 0))
   {
      *result = static_cast<R>(boost::math::policies::detail::raise_denorm_error<R>(function, 0, static_cast<R>(val), pol));
      return true;
   }
   return false;
}
template <class R, class T, class Policy>
inline bool check_denorm(std::complex<T> val, R* result, const char* function, const Policy& pol) noexcept(((std::is_floating_point<R>::value) && (std::is_floating_point<T>::value) && (Policy::value != throw_on_error) && (Policy::value != user_error)))
{
   typedef typename R::value_type r_type;
   r_type re, im;
   bool r = check_denorm<r_type>(val.real(), &re, function, pol);
   r = check_denorm<r_type>(val.imag(), &im, function, pol) || r;
   *result = R(re, im);
   return r;
}


template <class R, class T>
inline constexpr bool check_overflow(T , R* , const char* , const overflow_error<ignore_error>&) noexcept(((std::is_floating_point<R>::value) && (std::is_floating_point<T>::value)))
{ return false; }
template <class R, class T>
inline constexpr bool check_overflow(std::complex<T> , R* , const char* , const overflow_error<ignore_error>&) noexcept(((std::is_floating_point<R>::value) && (std::is_floating_point<T>::value)))
{ return false; }
template <class R, class T>
inline constexpr bool check_underflow(T , R* , const char* , const underflow_error<ignore_error>&) noexcept(((std::is_floating_point<R>::value) && (std::is_floating_point<T>::value)))
{ return false; }
template <class R, class T>
inline constexpr bool check_underflow(std::complex<T> , R* , const char* , const underflow_error<ignore_error>&) noexcept(((std::is_floating_point<R>::value) && (std::is_floating_point<T>::value)))
{ return false; }
template <class R, class T>
inline constexpr bool check_denorm(T , R* , const char* , const denorm_error<ignore_error>&) noexcept(((std::is_floating_point<R>::value) && (std::is_floating_point<T>::value)))
{ return false; }
template <class R, class T>
inline constexpr bool check_denorm(std::complex<T> , R* , const char* , const denorm_error<ignore_error>&) noexcept(((std::is_floating_point<R>::value) && (std::is_floating_point<T>::value)))
{ return false; }

}

template <class R, class Policy, class T>
inline R checked_narrowing_cast(T val, const char* function) noexcept(((std::is_floating_point<R>::value) && (std::is_floating_point<T>::value) && is_noexcept_error_policy<Policy>::value))
{
   typedef typename Policy::overflow_error_type overflow_type;
   typedef typename Policy::underflow_error_type underflow_type;
   typedef typename Policy::denorm_error_type denorm_type;



   R result = 0;
   if(detail::check_overflow<R>(val, &result, function, overflow_type()))
      return result;
   if(detail::check_underflow<R>(val, &result, function, underflow_type()))
      return result;
   if(detail::check_denorm<R>(val, &result, function, denorm_type()))
      return result;

   return static_cast<R>(val);
}

template <class T, class Policy>
inline void check_series_iterations(const char* function, boost::uintmax_t max_iter, const Policy& pol) noexcept(((std::is_floating_point<T>::value) && is_noexcept_error_policy<Policy>::value))
{
   if(max_iter >= policies::get_max_series_iterations<Policy>())
      raise_evaluation_error<T>(
         function,
         "Series evaluation exceeded %1% iterations, giving up now.", static_cast<T>(static_cast<double>(max_iter)), pol);
}

template <class T, class Policy>
inline void check_root_iterations(const char* function, boost::uintmax_t max_iter, const Policy& pol) noexcept(((std::is_floating_point<T>::value) && is_noexcept_error_policy<Policy>::value))
{
   if(max_iter >= policies::get_max_root_iterations<Policy>())
      raise_evaluation_error<T>(
         function,
         "Root finding evaluation exceeded %1% iterations, giving up now.", static_cast<T>(static_cast<double>(max_iter)), pol);
}

}

namespace detail{





template <class T>
std::pair<T, T> pair_from_single(const T& val) noexcept(std::is_floating_point<T>::value)
{
   return std::make_pair(val, val);
}

}





}}


namespace boost{ namespace math{ namespace detail{

template <class T, class Policy>
inline typename tools::promote_args<T>::type trunc(const T& v, const Policy& pol, const mpl::false_&)
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;
   typedef typename tools::promote_args<T>::type result_type;
   if(!(boost::math::isfinite)(v))
      return policies::raise_rounding_error("boost::math::trunc<%1%>(%1%)", 0, static_cast<result_type>(v), static_cast<result_type>(v), pol);
   return (v >= 0) ? static_cast<result_type>(floor(v)) : static_cast<result_type>(ceil(v));
}

template <class T, class Policy>
inline typename tools::promote_args<T>::type trunc(const T& v, const Policy&, const mpl::true_&)
{
   return v;
}

}

template <class T, class Policy>
inline typename tools::promote_args<T>::type trunc(const T& v, const Policy& pol)
{
   return detail::trunc(v, pol, mpl::bool_<detail::is_integer_for_rounding<T>::value>());
}
template <class T>
inline typename tools::promote_args<T>::type trunc(const T& v)
{
   return trunc(v, policies::policy<>());
}
template <class T, class Policy>
inline int itrunc(const T& v, const Policy& pol)
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;
   typedef typename tools::promote_args<T>::type result_type;
   result_type r = boost::math::trunc(v, pol);
   if((r > (std::numeric_limits<int>::max)()) || (r < (std::numeric_limits<int>::min)()))
      return static_cast<int>(policies::raise_rounding_error("boost::math::itrunc<%1%>(%1%)", 0, static_cast<result_type>(v), 0, pol));
   return static_cast<int>(r);
}
template <class T>
inline int itrunc(const T& v)
{
   return itrunc(v, policies::policy<>());
}

template <class T, class Policy>
inline long ltrunc(const T& v, const Policy& pol)
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;
   typedef typename tools::promote_args<T>::type result_type;
   result_type r = boost::math::trunc(v, pol);
   if((r > (std::numeric_limits<long>::max)()) || (r < (std::numeric_limits<long>::min)()))
      return static_cast<long>(policies::raise_rounding_error("boost::math::ltrunc<%1%>(%1%)", 0, static_cast<result_type>(v), 0L, pol));
   return static_cast<long>(r);
}
template <class T>
inline long ltrunc(const T& v)
{
   return ltrunc(v, policies::policy<>());
}



template <class T, class Policy>
inline boost::long_long_type lltrunc(const T& v, const Policy& pol)
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;
   typedef typename tools::promote_args<T>::type result_type;
   result_type r = boost::math::trunc(v, pol);
   if((r > (std::numeric_limits<boost::long_long_type>::max)()) || (r < (std::numeric_limits<boost::long_long_type>::min)()))
      return static_cast<boost::long_long_type>(policies::raise_rounding_error("boost::math::lltrunc<%1%>(%1%)", 0, v, static_cast<boost::long_long_type>(0), pol));
   return static_cast<boost::long_long_type>(r);
}
template <class T>
inline boost::long_long_type lltrunc(const T& v)
{
   return lltrunc(v, policies::policy<>());
}



}}









namespace boost{ namespace math{

   namespace concepts {

      class real_concept;
      class std_real_concept;

   }

namespace detail{

template <class T>
struct has_hidden_guard_digits;
template <>
struct has_hidden_guard_digits<float> : public mpl::false_ {};
template <>
struct has_hidden_guard_digits<double> : public mpl::false_ {};
template <>
struct has_hidden_guard_digits<long double> : public mpl::false_ {};




template <>
struct has_hidden_guard_digits<boost::math::concepts::real_concept> : public mpl::false_ {};
template <>
struct has_hidden_guard_digits<boost::math::concepts::std_real_concept> : public mpl::false_ {};

template <class T, bool b>
struct has_hidden_guard_digits_10 : public mpl::false_ {};
template <class T>
struct has_hidden_guard_digits_10<T, true> : public mpl::bool_<(std::numeric_limits<T>::digits10 != std::numeric_limits<T>::max_digits10)> {};

template <class T>
struct has_hidden_guard_digits
   : public has_hidden_guard_digits_10<T,
   std::numeric_limits<T>::is_specialized
   && (std::numeric_limits<T>::radix == 10) >
{};

template <class T>
inline const T& normalize_value(const T& val, const mpl::false_&) { return val; }
template <class T>
inline T normalize_value(const T& val, const mpl::true_&)
{
   static_assert(std::numeric_limits<T>::is_specialized, "std::numeric_limits<T>::is_specialized");
   static_assert(std::numeric_limits<T>::radix != 2, "std::numeric_limits<T>::radix != 2");

   boost::intmax_t shift = (boost::intmax_t)std::numeric_limits<T>::digits - (boost::intmax_t)ilogb(val) - 1;
   T result = scalbn(val, shift);
   result = round(result);
   return scalbn(result, -shift);
}

template <class T>
inline T get_smallest_value(mpl::true_ const&)
{





   static const T m = std::numeric_limits<T>::denorm_min();

   return (_mm_getcsr() & ((0x8000) | 0x40)) ? tools::min_value<T>() : m;;



}

template <class T>
inline T get_smallest_value(mpl::false_ const&)
{
   return tools::min_value<T>();
}

template <class T>
inline T get_smallest_value()
{



   return get_smallest_value<T>(mpl::bool_<std::numeric_limits<T>::is_specialized && (std::numeric_limits<T>::has_denorm == std::denorm_present)>());

}





template <class T>
T get_min_shift_value();

template <class T>
struct min_shift_initializer
{
   struct init
   {
      init()
      {
         do_init();
      }
      static void do_init()
      {
         get_min_shift_value<T>();
      }
      void force_instantiate()const{}
   };
   static const init initializer;
   static void force_instantiate()
   {
      initializer.force_instantiate();
   }
};

template <class T>
const typename min_shift_initializer<T>::init min_shift_initializer<T>::initializer;

template <class T>
inline T calc_min_shifted(const mpl::true_&)
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;
   return ldexp(tools::min_value<T>(), tools::digits<T>() + 1);
}
template <class T>
inline T calc_min_shifted(const mpl::false_&)
{
   static_assert(std::numeric_limits<T>::is_specialized, "std::numeric_limits<T>::is_specialized");
   static_assert(std::numeric_limits<T>::radix != 2, "std::numeric_limits<T>::radix != 2");

   return scalbn(tools::min_value<T>(), std::numeric_limits<T>::digits + 1);
}


template <class T>
inline T get_min_shift_value()
{
   static const T val = calc_min_shifted<T>(mpl::bool_<!std::numeric_limits<T>::is_specialized || std::numeric_limits<T>::radix == 2>());
   min_shift_initializer<T>::force_instantiate();

   return val;
}

template <class T, class Policy>
T float_next_imp(const T& val, const mpl::true_&, const Policy& pol)
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;
   int expon;
   static const char* function = "float_next<%1%>(%1%)";

   int fpclass = (boost::math::fpclassify)(val);

   if((fpclass == (int)1) || (fpclass == (int)2))
   {
      if(val < 0)
         return -tools::max_value<T>();
      return policies::raise_domain_error<T>(
         function,
         "Argument must be finite, but got %1%", val, pol);
   }

   if(val >= tools::max_value<T>())
      return policies::raise_overflow_error<T>(function, 0, pol);

   if(val == 0)
      return detail::get_smallest_value<T>();

   if((fpclass != (int)5) && (fpclass != (int)3) && (fabs(val) < detail::get_min_shift_value<T>()) && (val != -tools::min_value<T>()))
   {





      return ldexp(float_next(T(ldexp(val, 2 * tools::digits<T>())), pol), -2 * tools::digits<T>());
   }

   if(-0.5f == frexp(val, &expon))
      --expon;
   T diff = ldexp(T(1), expon - tools::digits<T>());
   if(diff == 0)
      diff = detail::get_smallest_value<T>();
   return val + diff;
}



template <class T, class Policy>
T float_next_imp(const T& val, const mpl::false_&, const Policy& pol)
{
   static_assert(std::numeric_limits<T>::is_specialized, "std::numeric_limits<T>::is_specialized");
   static_assert(std::numeric_limits<T>::radix != 2, "std::numeric_limits<T>::radix != 2");

   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;
   boost::intmax_t expon;
   static const char* function = "float_next<%1%>(%1%)";

   int fpclass = (boost::math::fpclassify)(val);

   if((fpclass == (int)1) || (fpclass == (int)2))
   {
      if(val < 0)
         return -tools::max_value<T>();
      return policies::raise_domain_error<T>(
         function,
         "Argument must be finite, but got %1%", val, pol);
   }

   if(val >= tools::max_value<T>())
      return policies::raise_overflow_error<T>(function, 0, pol);

   if(val == 0)
      return detail::get_smallest_value<T>();

   if((fpclass != (int)5) && (fpclass != (int)3) && (fabs(val) < detail::get_min_shift_value<T>()) && (val != -tools::min_value<T>()))
   {





      return scalbn(float_next(T(scalbn(val, 2 * std::numeric_limits<T>::digits)), pol), -2 * std::numeric_limits<T>::digits);
   }

   expon = 1 + ilogb(val);
   if(-1 == scalbn(val, -expon) * std::numeric_limits<T>::radix)
      --expon;
   T diff = scalbn(T(1), expon - std::numeric_limits<T>::digits);
   if(diff == 0)
      diff = detail::get_smallest_value<T>();
   return val + diff;
}

}

template <class T, class Policy>
inline typename tools::promote_args<T>::type float_next(const T& val, const Policy& pol)
{
   typedef typename tools::promote_args<T>::type result_type;
   return detail::float_next_imp(detail::normalize_value(static_cast<result_type>(val), typename detail::has_hidden_guard_digits<result_type>::type()), mpl::bool_<!std::numeric_limits<result_type>::is_specialized || (std::numeric_limits<result_type>::radix == 2)>(), pol);
}
template <class T>
inline typename tools::promote_args<T>::type float_next(const T& val)
{
   return float_next(val, policies::policy<>());
}

namespace detail{

template <class T, class Policy>
T float_prior_imp(const T& val, const mpl::true_&, const Policy& pol)
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;
   int expon;
   static const char* function = "float_prior<%1%>(%1%)";

   int fpclass = (boost::math::fpclassify)(val);

   if((fpclass == (int)1) || (fpclass == (int)2))
   {
      if(val > 0)
         return tools::max_value<T>();
      return policies::raise_domain_error<T>(
         function,
         "Argument must be finite, but got %1%", val, pol);
   }

   if(val <= -tools::max_value<T>())
      return -policies::raise_overflow_error<T>(function, 0, pol);

   if(val == 0)
      return -detail::get_smallest_value<T>();

   if((fpclass != (int)5) && (fpclass != (int)3) && (fabs(val) < detail::get_min_shift_value<T>()) && (val != tools::min_value<T>()))
   {





      return ldexp(float_prior(T(ldexp(val, 2 * tools::digits<T>())), pol), -2 * tools::digits<T>());
   }

   T remain = frexp(val, &expon);
   if(remain == 0.5f)
      --expon;
   T diff = ldexp(T(1), expon - tools::digits<T>());
   if(diff == 0)
      diff = detail::get_smallest_value<T>();
   return val - diff;
}



template <class T, class Policy>
T float_prior_imp(const T& val, const mpl::false_&, const Policy& pol)
{
   static_assert(std::numeric_limits<T>::is_specialized, "std::numeric_limits<T>::is_specialized");
   static_assert(std::numeric_limits<T>::radix != 2, "std::numeric_limits<T>::radix != 2");

   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;
   boost::intmax_t expon;
   static const char* function = "float_prior<%1%>(%1%)";

   int fpclass = (boost::math::fpclassify)(val);

   if((fpclass == (int)1) || (fpclass == (int)2))
   {
      if(val > 0)
         return tools::max_value<T>();
      return policies::raise_domain_error<T>(
         function,
         "Argument must be finite, but got %1%", val, pol);
   }

   if(val <= -tools::max_value<T>())
      return -policies::raise_overflow_error<T>(function, 0, pol);

   if(val == 0)
      return -detail::get_smallest_value<T>();

   if((fpclass != (int)5) && (fpclass != (int)3) && (fabs(val) < detail::get_min_shift_value<T>()) && (val != tools::min_value<T>()))
   {





      return scalbn(float_prior(T(scalbn(val, 2 * std::numeric_limits<T>::digits)), pol), -2 * std::numeric_limits<T>::digits);
   }

   expon = 1 + ilogb(val);
   T remain = scalbn(val, -expon);
   if(remain * std::numeric_limits<T>::radix == 1)
      --expon;
   T diff = scalbn(T(1), expon - std::numeric_limits<T>::digits);
   if(diff == 0)
      diff = detail::get_smallest_value<T>();
   return val - diff;
}

}

template <class T, class Policy>
inline typename tools::promote_args<T>::type float_prior(const T& val, const Policy& pol)
{
   typedef typename tools::promote_args<T>::type result_type;
   return detail::float_prior_imp(detail::normalize_value(static_cast<result_type>(val), typename detail::has_hidden_guard_digits<result_type>::type()), mpl::bool_<!std::numeric_limits<result_type>::is_specialized || (std::numeric_limits<result_type>::radix == 2)>(), pol);
}
template <class T>
inline typename tools::promote_args<T>::type float_prior(const T& val)
{
   return float_prior(val, policies::policy<>());
}

template <class T, class U, class Policy>
inline typename tools::promote_args<T, U>::type nextafter(const T& val, const U& direction, const Policy& pol)
{
   typedef typename tools::promote_args<T, U>::type result_type;
   return val < direction ? boost::math::float_next<result_type>(val, pol) : val == direction ? val : boost::math::float_prior<result_type>(val, pol);
}

template <class T, class U>
inline typename tools::promote_args<T, U>::type nextafter(const T& val, const U& direction)
{
   return nextafter(val, direction, policies::policy<>());
}

namespace detail{

template <class T, class Policy>
T float_distance_imp(const T& a, const T& b, const mpl::true_&, const Policy& pol)
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;



   static const char* function = "float_distance<%1%>(%1%, %1%)";
   if(!(boost::math::isfinite)(a))
      return policies::raise_domain_error<T>(
         function,
         "Argument a must be finite, but got %1%", a, pol);
   if(!(boost::math::isfinite)(b))
      return policies::raise_domain_error<T>(
         function,
         "Argument b must be finite, but got %1%", b, pol);



   if(a > b)
      return -float_distance(b, a, pol);
   if(a == b)
      return T(0);
   if(a == 0)
      return 1 + fabs(float_distance(static_cast<T>((b < 0) ? T(-detail::get_smallest_value<T>()) : detail::get_smallest_value<T>()), b, pol));
   if(b == 0)
      return 1 + fabs(float_distance(static_cast<T>((a < 0) ? T(-detail::get_smallest_value<T>()) : detail::get_smallest_value<T>()), a, pol));
   if(boost::math::sign(a) != boost::math::sign(b))
      return 2 + fabs(float_distance(static_cast<T>((b < 0) ? T(-detail::get_smallest_value<T>()) : detail::get_smallest_value<T>()), b, pol))
         + fabs(float_distance(static_cast<T>((a < 0) ? T(-detail::get_smallest_value<T>()) : detail::get_smallest_value<T>()), a, pol));




   if(a < 0)
      return float_distance(static_cast<T>(-b), static_cast<T>(-a), pol);

   (__builtin_expect(!(a >= 0), 0) ? __assert_rtn(__func__, "./boost/math/special_functions/next.hpp", 483, "a >= 0") : (void)0);
   (__builtin_expect(!(b >= a), 0) ? __assert_rtn(__func__, "./boost/math/special_functions/next.hpp", 484, "b >= a") : (void)0);

   int expon;





   frexp(((boost::math::fpclassify)(a) == (int)5) ? tools::min_value<T>() : a, &expon);
   T upper = ldexp(T(1), expon);
   T result = T(0);




   if(b > upper)
   {
      int expon2;
      frexp(b, &expon2);
      T upper2 = ldexp(T(0.5), expon2);
      result = float_distance(upper2, b);
      result += (expon2 - expon - 1) * ldexp(T(1), tools::digits<T>() - 1);
   }




   expon = tools::digits<T>() - expon;
   T mb, x, y, z;
   if(((boost::math::fpclassify)(a) == (int)5) || (b - a < tools::min_value<T>()))
   {





      T a2 = ldexp(a, tools::digits<T>());
      T b2 = ldexp(b, tools::digits<T>());
      mb = -(std::min)(T(ldexp(upper, tools::digits<T>())), b2);
      x = a2 + mb;
      z = x - a2;
      y = (a2 - (x - z)) + (mb - z);

      expon -= tools::digits<T>();
   }
   else
   {
      mb = -(std::min)(upper, b);
      x = a + mb;
      z = x - a;
      y = (a - (x - z)) + (mb - z);
   }
   if(x < 0)
   {
      x = -x;
      y = -y;
   }
   result += ldexp(x, expon) + ldexp(y, expon);



   (__builtin_expect(!(result == floor(result)), 0) ? __assert_rtn(__func__, "./boost/math/special_functions/next.hpp", 545, "result == floor(result)") : (void)0);
   return result;
}



template <class T, class Policy>
T float_distance_imp(const T& a, const T& b, const mpl::false_&, const Policy& pol)
{
   static_assert(std::numeric_limits<T>::is_specialized, "std::numeric_limits<T>::is_specialized");
   static_assert(std::numeric_limits<T>::radix != 2, "std::numeric_limits<T>::radix != 2");

   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;



   static const char* function = "float_distance<%1%>(%1%, %1%)";
   if(!(boost::math::isfinite)(a))
      return policies::raise_domain_error<T>(
         function,
         "Argument a must be finite, but got %1%", a, pol);
   if(!(boost::math::isfinite)(b))
      return policies::raise_domain_error<T>(
         function,
         "Argument b must be finite, but got %1%", b, pol);



   if(a > b)
      return -float_distance(b, a, pol);
   if(a == b)
      return T(0);
   if(a == 0)
      return 1 + fabs(float_distance(static_cast<T>((b < 0) ? T(-detail::get_smallest_value<T>()) : detail::get_smallest_value<T>()), b, pol));
   if(b == 0)
      return 1 + fabs(float_distance(static_cast<T>((a < 0) ? T(-detail::get_smallest_value<T>()) : detail::get_smallest_value<T>()), a, pol));
   if(boost::math::sign(a) != boost::math::sign(b))
      return 2 + fabs(float_distance(static_cast<T>((b < 0) ? T(-detail::get_smallest_value<T>()) : detail::get_smallest_value<T>()), b, pol))
         + fabs(float_distance(static_cast<T>((a < 0) ? T(-detail::get_smallest_value<T>()) : detail::get_smallest_value<T>()), a, pol));




   if(a < 0)
      return float_distance(static_cast<T>(-b), static_cast<T>(-a), pol);

   (__builtin_expect(!(a >= 0), 0) ? __assert_rtn(__func__, "./boost/math/special_functions/next.hpp", 591, "a >= 0") : (void)0);
   (__builtin_expect(!(b >= a), 0) ? __assert_rtn(__func__, "./boost/math/special_functions/next.hpp", 592, "b >= a") : (void)0);

   boost::intmax_t expon;





   expon = 1 + ilogb(((boost::math::fpclassify)(a) == (int)5) ? tools::min_value<T>() : a);
   T upper = scalbn(T(1), expon);
   T result = T(0);




   if(b > upper)
   {
      boost::intmax_t expon2 = 1 + ilogb(b);
      T upper2 = scalbn(T(1), expon2 - 1);
      result = float_distance(upper2, b);
      result += (expon2 - expon - 1) * scalbn(T(1), std::numeric_limits<T>::digits - 1);
   }




   expon = std::numeric_limits<T>::digits - expon;
   T mb, x, y, z;
   if(((boost::math::fpclassify)(a) == (int)5) || (b - a < tools::min_value<T>()))
   {





      T a2 = scalbn(a, std::numeric_limits<T>::digits);
      T b2 = scalbn(b, std::numeric_limits<T>::digits);
      mb = -(std::min)(T(scalbn(upper, std::numeric_limits<T>::digits)), b2);
      x = a2 + mb;
      z = x - a2;
      y = (a2 - (x - z)) + (mb - z);

      expon -= std::numeric_limits<T>::digits;
   }
   else
   {
      mb = -(std::min)(upper, b);
      x = a + mb;
      z = x - a;
      y = (a - (x - z)) + (mb - z);
   }
   if(x < 0)
   {
      x = -x;
      y = -y;
   }
   result += scalbn(x, expon) + scalbn(y, expon);



   (__builtin_expect(!(result == floor(result)), 0) ? __assert_rtn(__func__, "./boost/math/special_functions/next.hpp", 652, "result == floor(result)") : (void)0);
   return result;
}

}

template <class T, class U, class Policy>
inline typename tools::promote_args<T, U>::type float_distance(const T& a, const U& b, const Policy& pol)
{
   typedef typename tools::promote_args<T, U>::type result_type;
   return detail::float_distance_imp(detail::normalize_value(static_cast<result_type>(a), typename detail::has_hidden_guard_digits<result_type>::type()), detail::normalize_value(static_cast<result_type>(b), typename detail::has_hidden_guard_digits<result_type>::type()), mpl::bool_<!std::numeric_limits<result_type>::is_specialized || (std::numeric_limits<result_type>::radix == 2)>(), pol);
}

template <class T, class U>
typename tools::promote_args<T, U>::type float_distance(const T& a, const U& b)
{
   return boost::math::float_distance(a, b, policies::policy<>());
}

namespace detail{

template <class T, class Policy>
T float_advance_imp(T val, int distance, const mpl::true_&, const Policy& pol)
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;



   static const char* function = "float_advance<%1%>(%1%, int)";

   int fpclass = (boost::math::fpclassify)(val);

   if((fpclass == (int)1) || (fpclass == (int)2))
      return policies::raise_domain_error<T>(
         function,
         "Argument val must be finite, but got %1%", val, pol);

   if(val < 0)
      return -float_advance(-val, -distance, pol);
   if(distance == 0)
      return val;
   if(distance == 1)
      return float_next(val, pol);
   if(distance == -1)
      return float_prior(val, pol);

   if(fabs(val) < detail::get_min_shift_value<T>())
   {





      if(distance > 0)
      {
         do{ val = float_next(val, pol); } while(--distance);
      }
      else
      {
         do{ val = float_prior(val, pol); } while(++distance);
      }
      return val;
   }

   int expon;
   frexp(val, &expon);
   T limit = ldexp((distance < 0 ? T(0.5f) : T(1)), expon);
   if(val <= tools::min_value<T>())
   {
      limit = sign(T(distance)) * tools::min_value<T>();
   }
   T limit_distance = float_distance(val, limit);
   while(fabs(limit_distance) < abs(distance))
   {
      distance -= itrunc(limit_distance);
      val = limit;
      if(distance < 0)
      {
         limit /= 2;
         expon--;
      }
      else
      {
         limit *= 2;
         expon++;
      }
      limit_distance = float_distance(val, limit);
      if(distance && (limit_distance == 0))
      {
         return policies::raise_evaluation_error<T>(function, "Internal logic failed while trying to increment floating point value %1%: most likely your FPU is in non-IEEE conforming mode.", val, pol);
      }
   }
   if((0.5f == frexp(val, &expon)) && (distance < 0))
      --expon;
   T diff = 0;
   if(val != 0)
      diff = distance * ldexp(T(1), expon - tools::digits<T>());
   if(diff == 0)
      diff = distance * detail::get_smallest_value<T>();
   return val += diff;
}



template <class T, class Policy>
T float_advance_imp(T val, int distance, const mpl::false_&, const Policy& pol)
{
   static_assert(std::numeric_limits<T>::is_specialized, "std::numeric_limits<T>::is_specialized");
   static_assert(std::numeric_limits<T>::radix != 2, "std::numeric_limits<T>::radix != 2");

   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;



   static const char* function = "float_advance<%1%>(%1%, int)";

   int fpclass = (boost::math::fpclassify)(val);

   if((fpclass == (int)1) || (fpclass == (int)2))
      return policies::raise_domain_error<T>(
         function,
         "Argument val must be finite, but got %1%", val, pol);

   if(val < 0)
      return -float_advance(-val, -distance, pol);
   if(distance == 0)
      return val;
   if(distance == 1)
      return float_next(val, pol);
   if(distance == -1)
      return float_prior(val, pol);

   if(fabs(val) < detail::get_min_shift_value<T>())
   {





      if(distance > 0)
      {
         do{ val = float_next(val, pol); } while(--distance);
      }
      else
      {
         do{ val = float_prior(val, pol); } while(++distance);
      }
      return val;
   }

   boost::intmax_t expon = 1 + ilogb(val);
   T limit = scalbn(T(1), distance < 0 ? expon - 1 : expon);
   if(val <= tools::min_value<T>())
   {
      limit = sign(T(distance)) * tools::min_value<T>();
   }
   T limit_distance = float_distance(val, limit);
   while(fabs(limit_distance) < abs(distance))
   {
      distance -= itrunc(limit_distance);
      val = limit;
      if(distance < 0)
      {
         limit /= std::numeric_limits<T>::radix;
         expon--;
      }
      else
      {
         limit *= std::numeric_limits<T>::radix;
         expon++;
      }
      limit_distance = float_distance(val, limit);
      if(distance && (limit_distance == 0))
      {
         return policies::raise_evaluation_error<T>(function, "Internal logic failed while trying to increment floating point value %1%: most likely your FPU is in non-IEEE conforming mode.", val, pol);
      }
   }



   T diff = 0;
   if(val != 0)
      diff = distance * scalbn(T(1), expon - std::numeric_limits<T>::digits);
   if(diff == 0)
      diff = distance * detail::get_smallest_value<T>();
   return val += diff;
}

}

template <class T, class Policy>
inline typename tools::promote_args<T>::type float_advance(T val, int distance, const Policy& pol)
{
   typedef typename tools::promote_args<T>::type result_type;
   return detail::float_advance_imp(detail::normalize_value(static_cast<result_type>(val), typename detail::has_hidden_guard_digits<result_type>::type()), distance, mpl::bool_<!std::numeric_limits<result_type>::is_specialized || (std::numeric_limits<result_type>::radix == 2)>(), pol);
}

template <class T>
inline typename tools::promote_args<T>::type float_advance(const T& val, int distance)
{
   return boost::math::float_advance(val, distance, policies::policy<>());
}

}}
namespace boost{ namespace math{ namespace detail{

template <class T, class Policy>
T hypot_imp(T x, T y, const Policy& pol)
{



   using std::fabs; using std::sqrt;

   x = fabs(x);
   y = fabs(y);






   if(std::numeric_limits<T>::has_infinity
      && ((x == std::numeric_limits<T>::infinity())
      || (y == std::numeric_limits<T>::infinity())))
      return policies::raise_overflow_error<T>("boost::math::hypot<%1%>(%1%,%1%)", 0, pol);




   if(y > x)
      (std::swap)(x, y);

   if(x * tools::epsilon<T>() >= y)
      return x;

   T rat = y / x;
   return x * sqrt(1 + rat*rat);
}

}

template <class T1, class T2>
inline typename tools::promote_args<T1, T2>::type
   hypot(T1 x, T2 y)
{
   typedef typename tools::promote_args<T1, T2>::type result_type;
   return detail::hypot_imp(
      static_cast<result_type>(x), static_cast<result_type>(y), policies::policy<>());
}

template <class T1, class T2, class Policy>
inline typename tools::promote_args<T1, T2>::type
   hypot(T1 x, T2 y, const Policy& pol)
{
   typedef typename tools::promote_args<T1, T2>::type result_type;
   return detail::hypot_imp(
      static_cast<result_type>(x), static_cast<result_type>(y), pol);
}

}
}

namespace boost { namespace mpl {




template< typename Tag >
struct front_impl
{
    template< typename Sequence > struct apply
    {
        typedef typename begin<Sequence>::type iter_;
        typedef typename deref<iter_>::type type;
    };
};

 template<> struct front_impl<non_sequence_tag> {};

}}




namespace boost { namespace mpl {

template<
      typename Sequence = na
    >
struct front
    : front_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{

};

template<> struct front< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : front< T1 > { }; }; template< typename Tag > struct lambda< front< na > , Tag , int_<-1> > { typedef false_ is_le; typedef front< na > result_; typedef front< na > type; }; namespace aux { template< typename T1 > struct template_arity< front< T1 > > : int_<1> { }; template<> struct template_arity< front< na > > : int_<-1> { }; }

}}

namespace boost{ namespace multiprecision{

   namespace detail {

      template <class T>
      struct is_backend;

      template <class To, class From>
      void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_floating_point>& , const mpl::int_<number_kind_integer>& );
      template <class To, class From>
      void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_integer>& , const mpl::int_<number_kind_integer>& );
      template <class To, class From>
      void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_floating_point>& , const mpl::int_<number_kind_floating_point>& );
      template <class To, class From>
      void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_rational>& , const mpl::int_<number_kind_rational>& );
      template <class To, class From>
      void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_rational>& , const mpl::int_<number_kind_integer>& );

}

namespace default_ops{
template <class T, class V>
inline typename disable_if_c<is_convertible<V, T>::value >::type
   eval_add(T& result, V const& v)
{
   T t;
   t = v;
   eval_add(result, t);
}
template <class T, class V>
inline typename enable_if_c<is_convertible<V, T>::value >::type
   eval_add(T& result, V const& v)
{
   T t(v);
   eval_add(result, t);
}
template <class T, class V>
inline typename disable_if_c<is_convertible<V, T>::value>::type
   eval_subtract(T& result, V const& v)
{
   T t;
   t = v;
   eval_subtract(result, t);
}
template <class T, class V>
inline typename enable_if_c<is_convertible<V, T>::value>::type
   eval_subtract(T& result, V const& v)
{
   T t(v);
   eval_subtract(result, t);
}
template <class T, class V>
inline typename disable_if_c<is_convertible<V, T>::value>::type
   eval_multiply(T& result, V const& v)
{
   T t;
   t = v;
   eval_multiply(result, t);
}
template <class T, class V>
inline typename enable_if_c<is_convertible<V, T>::value>::type
   eval_multiply(T& result, V const& v)
{
   T t(v);
   eval_multiply(result, t);
}

template <class T, class U, class V>
void eval_multiply(T& t, const U& u, const V& v);

template <class T, class U, class V>
inline typename disable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_add(T& t, const U& u, const V& v)
{
   T z;
   eval_multiply(z, u, v);
   eval_add(t, z);
}
template <class T, class U, class V>
inline typename enable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_add(T& t, const U& u, const V& v)
{
   eval_multiply_add(t, v, u);
}
template <class T, class U, class V>
inline typename disable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_subtract(T& t, const U& u, const V& v)
{
   T z;
   eval_multiply(z, u, v);
   eval_subtract(t, z);
}
template <class T, class U, class V>
inline typename enable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_subtract(T& t, const U& u, const V& v)
{
   eval_multiply_subtract(t, v, u);
}
template <class T, class V>
inline typename enable_if_c<is_convertible<V, number<T, et_on> >::value && !is_convertible<V, T>::value>::type
   eval_divide(T& result, V const& v)
{
   T t;
   t = v;
   eval_divide(result, t);
}
template <class T, class V>
inline typename enable_if_c<is_convertible<V, number<T, et_on> >::value && is_convertible<V, T>::value>::type
   eval_divide(T& result, V const& v)
{
   T t(v);
   eval_divide(result, t);
}
template <class T, class V>
inline typename enable_if_c<is_convertible<V, number<T, et_on> >::value && !is_convertible<V, T>::value>::type
   eval_modulus(T& result, V const& v)
{
   T t;
   t = v;
   eval_modulus(result, t);
}
template <class T, class V>
inline typename enable_if_c<is_convertible<V, number<T, et_on> >::value&& is_convertible<V, T>::value>::type
   eval_modulus(T& result, V const& v)
{
   T t(v);
   eval_modulus(result, t);
}
template <class T, class V>
inline typename enable_if_c<is_convertible<V, number<T, et_on> >::value && !is_convertible<V, T>::value>::type
   eval_bitwise_and(T& result, V const& v)
{
   T t;
   t = v;
   eval_bitwise_and(result, t);
}
template <class T, class V>
inline typename enable_if_c<is_convertible<V, number<T, et_on> >::value && is_convertible<V, T>::value>::type
   eval_bitwise_and(T& result, V const& v)
{
   T t(v);
   eval_bitwise_and(result, t);
}
template <class T, class V>
inline typename enable_if_c<is_convertible<V, number<T, et_on> >::value && !is_convertible<V, T>::value>::type
   eval_bitwise_or(T& result, V const& v)
{
   T t;
   t = v;
   eval_bitwise_or(result, t);
}
template <class T, class V>
inline typename enable_if_c<is_convertible<V, number<T, et_on> >::value && is_convertible<V, T>::value>::type
   eval_bitwise_or(T& result, V const& v)
{
   T t(v);
   eval_bitwise_or(result, t);
}
template <class T, class V>
inline typename enable_if_c<is_convertible<V, number<T, et_on> >::value && !is_convertible<V, T>::value>::type
   eval_bitwise_xor(T& result, V const& v)
{
   T t;
   t = v;
   eval_bitwise_xor(result, t);
}
template <class T, class V>
inline typename enable_if_c<is_convertible<V, number<T, et_on> >::value && is_convertible<V, T>::value>::type
   eval_bitwise_xor(T& result, V const& v)
{
   T t(v);
   eval_bitwise_xor(result, t);
}

template <class T, class V>
inline typename enable_if_c<is_convertible<V, number<T, et_on> >::value && !is_convertible<V, T>::value>::type
   eval_complement(T& result, V const& v)
{
   T t;
   t = v;
   eval_complement(result, t);
}
template <class T, class V>
inline typename enable_if_c<is_convertible<V, number<T, et_on> >::value && is_convertible<V, T>::value>::type
   eval_complement(T& result, V const& v)
{
   T t(v);
   eval_complement(result, t);
}




template <class T, class U, class V>
void eval_add(T& t, const U& u, const V& v);

template <class T>
inline void eval_add_default(T& t, const T& u, const T& v)
{
   if(&t == &v)
   {
      eval_add(t, u);
   }
   else if(&t == &u)
   {
      eval_add(t, v);
   }
   else
   {
      t = u;
      eval_add(t, v);
   }
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_add_default(T& t, const T& u, const U& v)
{
   T vv;
   vv = v;
   eval_add(t, u, vv);
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_add_default(T& t, const T& u, const U& v)
{
   T vv(v);
   eval_add(t, u, vv);
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_add_default(T& t, const U& u, const T& v)
{
   eval_add(t, v, u);
}
template <class T, class U, class V>
inline void eval_add_default(T& t, const U& u, const V& v)
{
   if(is_same<T, V>::value && ((void*)&t == (void*)&v))
   {
      eval_add(t, u);
   }
   else
   {
      t = u;
      eval_add(t, v);
   }
}
template <class T, class U, class V>
inline void eval_add(T& t, const U& u, const V& v)
{
   eval_add_default(t, u, v);
}

template <class T, class U, class V>
void eval_subtract(T& t, const U& u, const V& v);

template <class T>
inline void eval_subtract_default(T& t, const T& u, const T& v)
{
   if((&t == &v) && is_signed_number<T>::value)
   {
      eval_subtract(t, u);
      t.negate();
   }
   else if(&t == &u)
   {
      eval_subtract(t, v);
   }
   else
   {
      t = u;
      eval_subtract(t, v);
   }
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_subtract_default(T& t, const T& u, const U& v)
{
   T vv;
   vv = v;
   eval_subtract(t, u, vv);
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_subtract_default(T& t, const T& u, const U& v)
{
   T vv(v);
   eval_subtract(t, u, vv);
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_signed_number<T>::value>::type eval_subtract_default(T& t, const U& u, const T& v)
{
   eval_subtract(t, v, u);
   t.negate();
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value && is_unsigned_number<T>::value>::type eval_subtract_default(T& t, const U& u, const T& v)
{
   T temp;
   temp = u;
   eval_subtract(t, temp, v);
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value && is_unsigned_number<T>::value>::type eval_subtract_default(T& t, const U& u, const T& v)
{
   T temp(u);
   eval_subtract(t, temp, v);
}
template <class T, class U, class V>
inline void eval_subtract_default(T& t, const U& u, const V& v)
{
   if(is_same<T, V>::value && ((void*)&t == (void*)&v))
   {
      eval_subtract(t, u);
      t.negate();
   }
   else
   {
      t = u;
      eval_subtract(t, v);
   }
}
template <class T, class U, class V>
inline void eval_subtract(T& t, const U& u, const V& v)
{
   eval_subtract_default(t, u, v);
}

template <class T>
inline void eval_multiply_default(T& t, const T& u, const T& v)
{
   if(&t == &v)
   {
      eval_multiply(t, u);
   }
   else if(&t == &u)
   {
      eval_multiply(t, v);
   }
   else
   {
      t = u;
      eval_multiply(t, v);
   }
}

template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_multiply_default(T& t, const T& u, const U& v)
{
   T vv;
   vv = v;
   eval_multiply(t, u, vv);
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_multiply_default(T& t, const T& u, const U& v)
{
   T vv(v);
   eval_multiply(t, u, vv);
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_multiply_default(T& t, const U& u, const T& v)
{
   eval_multiply(t, v, u);
}

template <class T, class U, class V>
inline void eval_multiply_default(T& t, const U& u, const V& v)
{
   if(is_same<T, V>::value && ((void*)&t == (void*)&v))
   {
      eval_multiply(t, u);
   }
   else
   {
      t = number<T>::canonical_value(u);
      eval_multiply(t, v);
   }
}
template <class T, class U, class V>
inline void eval_multiply(T& t, const U& u, const V& v)
{
   eval_multiply_default(t, u, v);
}

template <class T>
inline void eval_multiply_add(T& t, const T& u, const T& v, const T& x)
{
   if((void*)&x == (void*)&t)
   {
      T z;
      z = number<T>::canonical_value(x);
      eval_multiply_add(t, u, v, z);
   }
   else
   {
      eval_multiply(t, u, v);
      eval_add(t, x);
   }
}

template <class T, class U>
inline typename boost::disable_if_c<boost::is_same<T, U>::value, T>::type make_T(const U& u)
{
   T t;
   t = number<T>::canonical_value(u);
   return std::move(t);
}
template <class T>
inline const T& make_T(const T& t)
{
   return t;
}

template <class T, class U, class V, class X>
inline typename disable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_add(T& t, const U& u, const V& v, const X& x)
{
   eval_multiply_add(t, make_T<T>(u), make_T<T>(v), make_T<T>(x));
}
template <class T, class U, class V, class X>
inline typename enable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_add(T& t, const U& u, const V& v, const X& x)
{
   eval_multiply_add(t, v, u, x);
}
template <class T, class U, class V, class X>
inline typename disable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_subtract(T& t, const U& u, const V& v, const X& x)
{
   if((void*)&x == (void*)&t)
   {
      T z;
      z = x;
      eval_multiply_subtract(t, u, v, z);
   }
   else
   {
      eval_multiply(t, u, v);
      eval_subtract(t, x);
   }
}
template <class T, class U, class V, class X>
inline typename enable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_subtract(T& t, const U& u, const V& v, const X& x)
{
   eval_multiply_subtract(t, v, u, x);
}

template <class T, class U, class V>
void eval_divide(T& t, const U& u, const V& v);

template <class T>
inline void eval_divide_default(T& t, const T& u, const T& v)
{
   if(&t == &u)
      eval_divide(t, v);
   else if(&t == &v)
   {
      T temp;
      eval_divide(temp, u, v);
      temp.swap(t);
   }
   else
   {
      t = u;
      eval_divide(t, v);
   }
}

template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_divide_default(T& t, const T& u, const U& v)
{
   T vv;
   vv = v;
   eval_divide(t, u, vv);
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_divide_default(T& t, const T& u, const U& v)
{
   T vv(v);
   eval_divide(t, u, vv);
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_divide_default(T& t, const U& u, const T& v)
{
   T uu;
   uu = u;
   eval_divide(t, uu, v);
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_divide_default(T& t, const U& u, const T& v)
{
   T uu(u);
   eval_divide(t, uu, v);
}

template <class T, class U, class V>
inline void eval_divide_default(T& t, const U& u, const V& v)
{
   if(is_same<T, V>::value && ((void*)&t == (void*)&v))
   {
      T temp;
      temp = u;
      eval_divide(temp, v);
      t = temp;
   }
   else
   {
      t = u;
      eval_divide(t, v);
   }
}
template <class T, class U, class V>
inline void eval_divide(T& t, const U& u, const V& v)
{
   eval_divide_default(t, u, v);
}

template <class T, class U, class V>
void eval_modulus(T& t, const U& u, const V& v);

template <class T>
inline void eval_modulus_default(T& t, const T& u, const T& v)
{
   if(&t == &u)
      eval_modulus(t, v);
   else if(&t == &v)
   {
      T temp;
      eval_modulus(temp, u, v);
      temp.swap(t);
   }
   else
   {
      t = u;
      eval_modulus(t, v);
   }
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_modulus_default(T& t, const T& u, const U& v)
{
   T vv;
   vv = v;
   eval_modulus(t, u, vv);
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_modulus_default(T& t, const T& u, const U& v)
{
   T vv(v);
   eval_modulus(t, u, vv);
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_modulus_default(T& t, const U& u, const T& v)
{
   T uu;
   uu = u;
   eval_modulus(t, uu, v);
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_modulus_default(T& t, const U& u, const T& v)
{
   T uu(u);
   eval_modulus(t, uu, v);
}
template <class T, class U, class V>
inline void eval_modulus_default(T& t, const U& u, const V& v)
{
   if(is_same<T, V>::value && ((void*)&t == (void*)&v))
   {
      T temp(u);
      eval_modulus(temp, v);
      t = temp;
   }
   else
   {
      t = u;
      eval_modulus(t, v);
   }
}
template <class T, class U, class V>
inline void eval_modulus(T& t, const U& u, const V& v)
{
   eval_modulus_default(t, u, v);
}

template <class T, class U, class V>
void eval_bitwise_and(T& t, const U& u, const V& v);

template <class T>
inline void eval_bitwise_and_default(T& t, const T& u, const T& v)
{
   if(&t == &v)
   {
      eval_bitwise_and(t, u);
   }
   else if(&t == &u)
   {
      eval_bitwise_and(t, v);
   }
   else
   {
      t = u;
      eval_bitwise_and(t, v);
   }
}
template <class T, class U>
inline typename disable_if_c<is_convertible<U, T>::value>::type eval_bitwise_and_default(T& t, const T& u, const U& v)
{
   T vv;
   vv = v;
   eval_bitwise_and(t, u, vv);
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, T>::value>::type eval_bitwise_and_default(T& t, const T& u, const U& v)
{
   T vv(v);
   eval_bitwise_and(t, u, vv);
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_bitwise_and_default(T& t, const U& u, const T& v)
{
   eval_bitwise_and(t, v, u);
}
template <class T, class U, class V>
inline typename disable_if_c<is_same<T, U>::value || is_same<T, V>::value>::type eval_bitwise_and_default(T& t, const U& u, const V& v)
{
   t = u;
   eval_bitwise_and(t, v);
}
template <class T, class U, class V>
inline void eval_bitwise_and(T& t, const U& u, const V& v)
{
   eval_bitwise_and_default(t, u, v);
}

template <class T, class U, class V>
void eval_bitwise_or(T& t, const U& u, const V& v);

template <class T>
inline void eval_bitwise_or_default(T& t, const T& u, const T& v)
{
   if(&t == &v)
   {
      eval_bitwise_or(t, u);
   }
   else if(&t == &u)
   {
      eval_bitwise_or(t, v);
   }
   else
   {
      t = u;
      eval_bitwise_or(t, v);
   }
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_bitwise_or_default(T& t, const T& u, const U& v)
{
   T vv;
   vv = v;
   eval_bitwise_or(t, u, vv);
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_bitwise_or_default(T& t, const T& u, const U& v)
{
   T vv(v);
   eval_bitwise_or(t, u, vv);
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_bitwise_or_default(T& t, const U& u, const T& v)
{
   eval_bitwise_or(t, v, u);
}
template <class T, class U, class V>
inline void eval_bitwise_or_default(T& t, const U& u, const V& v)
{
   if(is_same<T, V>::value && ((void*)&t == (void*)&v))
   {
      eval_bitwise_or(t, u);
   }
   else
   {
      t = u;
      eval_bitwise_or(t, v);
   }
}
template <class T, class U, class V>
inline void eval_bitwise_or(T& t, const U& u, const V& v)
{
   eval_bitwise_or_default(t, u, v);
}

template <class T, class U, class V>
void eval_bitwise_xor(T& t, const U& u, const V& v);

template <class T>
inline void eval_bitwise_xor_default(T& t, const T& u, const T& v)
{
   if(&t == &v)
   {
      eval_bitwise_xor(t, u);
   }
   else if(&t == &u)
   {
      eval_bitwise_xor(t, v);
   }
   else
   {
      t = u;
      eval_bitwise_xor(t, v);
   }
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_bitwise_xor_default(T& t, const T& u, const U& v)
{
   T vv;
   vv = v;
   eval_bitwise_xor(t, u, vv);
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_bitwise_xor_default(T& t, const T& u, const U& v)
{
   T vv(v);
   eval_bitwise_xor(t, u, vv);
}
template <class T, class U>
inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_bitwise_xor_default(T& t, const U& u, const T& v)
{
   eval_bitwise_xor(t, v, u);
}
template <class T, class U, class V>
inline void eval_bitwise_xor_default(T& t, const U& u, const V& v)
{
   if(is_same<T, V>::value && ((void*)&t == (void*)&v))
   {
      eval_bitwise_xor(t, u);
   }
   else
   {
      t = u;
      eval_bitwise_xor(t, v);
   }
}
template <class T, class U, class V>
inline void eval_bitwise_xor(T& t, const U& u, const V& v)
{
   eval_bitwise_xor_default(t, u, v);
}

template <class T>
inline void eval_increment(T& val)
{
   typedef typename mpl::front<typename T::unsigned_types>::type ui_type;
   eval_add(val, static_cast<ui_type>(1u));
}
template <class T>
inline void eval_decrement(T& val)
{
   typedef typename mpl::front<typename T::unsigned_types>::type ui_type;
   eval_subtract(val, static_cast<ui_type>(1u));
}

template <class T, class V>
inline void eval_left_shift(T& result, const T& arg, const V val)
{
   result = arg;
   eval_left_shift(result, val);
}

template <class T, class V>
inline void eval_right_shift(T& result, const T& arg, const V val)
{
   result = arg;
   eval_right_shift(result, val);
}

template <class T>
inline bool eval_is_zero(const T& val)
{
   typedef typename mpl::front<typename T::unsigned_types>::type ui_type;
   return val.compare(static_cast<ui_type>(0)) == 0;
}
template <class T>
inline int eval_get_sign(const T& val)
{
   typedef typename mpl::front<typename T::unsigned_types>::type ui_type;
   return val.compare(static_cast<ui_type>(0));
}

template <class T, class V, class U>
inline void assign_components_imp(T& result, const V& v1, const U& v2, const mpl::int_<number_kind_rational>&)
{
   result = v1;
   T t;
   t = v2;
   eval_divide(result, t);
}

template <class T, class V, class U, int N>
inline void assign_components_imp(T& result, const V& v1, const U& v2, const mpl::int_<N>&)
{
   typedef typename component_type<number<T> >::type component_number_type;

   component_number_type x(v1), y(v2);
   assign_components(result, x.backend(), y.backend());
}

template <class T, class V, class U>
inline void assign_components(T& result, const V& v1, const U& v2)
{
   return assign_components_imp(result, v1, v2, typename number_category<T>::type());
}

template <class Result, class Traits>
inline void assign_from_string_view(Result& result, const std::basic_string_view<char, Traits>& view)
{


   std::string s(view);
   result = s.c_str();
}
template <class Result, class Traits>
inline void assign_from_string_view(Result& result, const std::basic_string_view<char, Traits>& view_x, const std::basic_string_view<char, Traits>& view_y)
{


   std::string x(view_x), y(view_y);
   assign_components(result, x.c_str(), y.c_str());
}

template <class R, int b>
struct has_enough_bits
{
   template <class T>
   struct type : public mpl::and_<mpl::not_<is_same<R, T> >, mpl::bool_<std::numeric_limits<T>::digits >= b> >{};
};

template <class R>
struct terminal
{
   terminal(const R& v) : value(v){}
   terminal(){}
   terminal& operator = (R val) { value = val; return *this; }
   R value;
   operator R()const { return value; }
};

template<class R, class B>
struct calculate_next_larger_type
{

   typedef typename mpl::if_<
      is_signed<R>,
      typename B::signed_types,
      typename mpl::if_<
         is_unsigned<R>,
         typename B::unsigned_types,
         typename B::float_types
      >::type
   >::type list_type;

   typedef typename has_enough_bits<R, std::numeric_limits<R>::digits>::template type<mpl::_> pred_type;

   typedef typename mpl::find_if<
      list_type,
      is_same<R, mpl::_>
   >::type start_last;

   typedef typename mpl::if_<is_same<start_last, typename mpl::end<list_type>::type>, typename mpl::begin<list_type>::type, start_last>::type start_seq;

   typedef mpl::iterator_range<start_seq, typename mpl::end<list_type>::type> range;

   typedef typename mpl::find_if<
      range,
      pred_type
   >::type iter_type;

   typedef typename mpl::eval_if<
      is_same<typename mpl::end<list_type>::type, iter_type>,
      mpl::identity<terminal<R> >,
      mpl::deref<iter_type>
      >::type type;
};

template <class R, class T>
inline typename boost::enable_if_c<boost::is_integral<R>::value, bool>::type check_in_range(const T& t)
{

   if((t > 0) && std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
      return true;
   else
   return false;
}

template <class R, class B>
inline typename boost::enable_if_c<boost::is_integral<R>::value>::type eval_convert_to(R* result, const B& backend)
{
   typedef typename calculate_next_larger_type<R, B>::type next_type;
   next_type n;
   eval_convert_to(&n, backend);
   if(!boost::is_unsigned<R>::value && std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (n > (next_type)(std::numeric_limits<R>::max)()))
   {
      *result = (std::numeric_limits<R>::max)();
   }
   else if (std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (n < (next_type)(std::numeric_limits<R>::min)()))
   {
      *result = (std::numeric_limits<R>::min)();
   }
   else
      *result = static_cast<R>(n);
}

template <class R, class B>
inline typename boost::disable_if_c<boost::is_integral<R>::value>::type eval_convert_to(R* result, const B& backend)
{
   typedef typename calculate_next_larger_type<R, B>::type next_type;
   next_type n;
   eval_convert_to(&n, backend);
   if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && ((n > (next_type)(std::numeric_limits<R>::max)() || (n < (next_type)-(std::numeric_limits<R>::max)()) )))
   {
      *result = n > 0 ? (std::numeric_limits<R>::max)() : -(std::numeric_limits<R>::max)();
   }
   else
      *result = static_cast<R>(n);
}

template <class R, class B>
inline void last_chance_eval_convert_to(terminal<R>* result, const B& backend, const mpl::false_&)
{




   if (std::numeric_limits<R>::is_integer && !std::numeric_limits<R>::is_signed && (eval_get_sign(backend) < 0))
      ::boost::exception_detail::throw_exception_(std::range_error("Attempt to convert negative value to an unsigned integer results in undefined behaviour"),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/default_ops.hpp",972);
   try
   {
      result->value = boost::lexical_cast<R>(backend.str(0, std::ios_base::fmtflags(0)));
   }
   catch (const bad_lexical_cast&)
   {
      if (eval_get_sign(backend) < 0)
      {
         *result = std::numeric_limits<R>::is_integer && std::numeric_limits<R>::is_signed ? (std::numeric_limits<R>::min)() : -(std::numeric_limits<R>::max)();
      }
      else
         *result = (std::numeric_limits<R>::max)();
   }
}

template <class R, class B>
inline void last_chance_eval_convert_to(terminal<R>* result, const B& backend, const mpl::true_&)
{




   if (std::numeric_limits<R>::is_integer && !std::numeric_limits<R>::is_signed && (eval_get_sign(backend) < 0))
      ::boost::exception_detail::throw_exception_(std::range_error("Attempt to convert negative value to an unsigned integer results in undefined behaviour"),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/default_ops.hpp",996);
   try
   {
      B t(backend);
      R mask = ~static_cast<R>(0u);
      eval_bitwise_and(t, mask);
      result->value = boost::lexical_cast<R>(t.str(0, std::ios_base::fmtflags(0)));
   }
   catch (const bad_lexical_cast&)
   {
      if (eval_get_sign(backend) < 0)
      {
         *result = std::numeric_limits<R>::is_integer && std::numeric_limits<R>::is_signed ? (std::numeric_limits<R>::min)() : -(std::numeric_limits<R>::max)();
      }
      else
         *result = (std::numeric_limits<R>::max)();
   }
}

template <class R, class B>
inline void eval_convert_to(terminal<R>* result, const B& backend)
{
   typedef mpl::bool_<boost::is_unsigned<R>::value && number_category<B>::value == number_kind_integer> tag_type;
   last_chance_eval_convert_to(result, backend, tag_type());
}

template <class B1, class B2, expression_template_option et>
inline void eval_convert_to(terminal<number<B1, et> >* result, const B2& backend)
{




   boost::multiprecision::detail::generic_interconvert(result->value.backend(), backend, number_category<B1>(), number_category<B2>());
}

template <class B>
inline void eval_convert_to(std::string* result, const B& backend)
{
   *result = backend.str(0, std::ios_base::fmtflags(0));
}

template <class B>
inline void eval_convert_to(std::complex<float>* result, const B& backend)
{
   typedef typename scalar_result_from_possible_complex<multiprecision::number<B> >::type scalar_type;
   scalar_type re, im;
   eval_real(re.backend(), backend);
   eval_imag(im.backend(), backend);

   *result = std::complex<float>(re.template convert_to<float>(), im.template convert_to<float>());
}

template <class B>
inline void eval_convert_to(std::complex<double>* result, const B& backend)
{
   typedef typename scalar_result_from_possible_complex<multiprecision::number<B> >::type scalar_type;
   scalar_type re, im;
   eval_real(re.backend(), backend);
   eval_imag(im.backend(), backend);

   *result = std::complex<double>(re.template convert_to<double>(), im.template convert_to<double>());
}

template <class B>
inline void eval_convert_to(std::complex<long double>* result, const B& backend)
{
   typedef typename scalar_result_from_possible_complex<multiprecision::number<B> >::type scalar_type;
   scalar_type re, im;
   eval_real(re.backend(), backend);
   eval_imag(im.backend(), backend);

   *result = std::complex<long double>(re.template convert_to<long double>(), im.template convert_to<long double>());
}




template <class T>
void eval_abs(T& result, const T& arg)
{
   typedef typename T::signed_types type_list;
   typedef typename mpl::front<type_list>::type front;
   result = arg;
   if(arg.compare(front(0)) < 0)
      result.negate();
}
template <class T>
void eval_fabs(T& result, const T& arg)
{
   static_assert(number_category<T>::value == number_kind_floating_point, "The fabs function is only valid for floating point types.");
   typedef typename T::signed_types type_list;
   typedef typename mpl::front<type_list>::type front;
   result = arg;
   if(arg.compare(front(0)) < 0)
      result.negate();
}

template <class Backend>
inline int eval_fpclassify(const Backend& arg)
{
   static_assert(number_category<Backend>::value == number_kind_floating_point, "The fpclassify function is only valid for floating point types.");
   return eval_is_zero(arg) ? 3 : 4;
}

template <class T>
inline void eval_fmod(T& result, const T& a, const T& b)
{
   static_assert(number_category<T>::value == number_kind_floating_point, "The fmod function is only valid for floating point types.");
   if((&result == &a) || (&result == &b))
   {
      T temp;
      eval_fmod(temp, a, b);
      result = temp;
      return;
   }
   switch(eval_fpclassify(a))
   {
   case 3:
      result = a;
      return;
   case 2:
   case 1:
      result = std::numeric_limits<number<T> >::quiet_NaN().backend();
      (*__error()) = 33;
      return;
   }
   switch(eval_fpclassify(b))
   {
   case 3:
   case 1:
      result = std::numeric_limits<number<T> >::quiet_NaN().backend();
      (*__error()) = 33;
      return;
   }
   T n;
   eval_divide(result, a, b);
   if(eval_get_sign(result) < 0)
      eval_ceil(n, result);
   else
      eval_floor(n, result);
   eval_multiply(n, b);
   eval_subtract(result, a, n);
}
template<class T, class A>
inline typename enable_if<is_arithmetic<A>, void>::type eval_fmod(T& result, const T& x, const A& a)
{
   typedef typename boost::multiprecision::detail::canonical<A, T>::type canonical_type;
   typedef typename mpl::if_<is_same<A, canonical_type>, T, canonical_type>::type cast_type;
   cast_type c;
   c = a;
   eval_fmod(result, x, c);
}

template<class T, class A>
inline typename enable_if<is_arithmetic<A>, void>::type eval_fmod(T& result, const A& x, const T& a)
{
   typedef typename boost::multiprecision::detail::canonical<A, T>::type canonical_type;
   typedef typename mpl::if_<is_same<A, canonical_type>, T, canonical_type>::type cast_type;
   cast_type c;
   c = x;
   eval_fmod(result, c, a);
}

template <class T>
void eval_round(T& result, const T& a);

template <class T>
inline void eval_remquo(T& result, const T& a, const T& b, int* pi)
{
   static_assert(number_category<T>::value == number_kind_floating_point, "The remquo function is only valid for floating point types.");
   if((&result == &a) || (&result == &b))
   {
      T temp;
      eval_remquo(temp, a, b, pi);
      result = temp;
      return;
   }
   T n;
   eval_divide(result, a, b);
   eval_round(n, result);
   eval_convert_to(pi, n);
   eval_multiply(n, b);
   eval_subtract(result, a, n);
}
template<class T, class A>
inline typename enable_if<is_arithmetic<A>, void>::type eval_remquo(T& result, const T& x, const A& a, int* pi)
{
   typedef typename boost::multiprecision::detail::canonical<A, T>::type canonical_type;
   typedef typename mpl::if_<is_same<A, canonical_type>, T, canonical_type>::type cast_type;
   cast_type c;
   c = a;
   eval_remquo(result, x, c, pi);
}
template<class T, class A>
inline typename enable_if<is_arithmetic<A>, void>::type eval_remquo(T& result, const A& x, const T& a, int* pi)
{
   typedef typename boost::multiprecision::detail::canonical<A, T>::type canonical_type;
   typedef typename mpl::if_<is_same<A, canonical_type>, T, canonical_type>::type cast_type;
   cast_type c;
   c = x;
   eval_remquo(result, c, a, pi);
}
template <class T, class U, class V>
inline void eval_remainder(T& result, const U& a, const V& b)
{
   int i;
   eval_remquo(result, a, b, &i);
}

template <class B>
bool eval_gt(const B& a, const B& b);
template <class T, class U>
bool eval_gt(const T& a, const U& b);
template <class B>
bool eval_lt(const B& a, const B& b);
template <class T, class U>
bool eval_lt(const T& a, const U& b);

template<class T>
inline void eval_fdim(T& result, const T& a, const T& b)
{
   typedef typename boost::multiprecision::detail::canonical<unsigned, T>::type ui_type;
   static const ui_type zero = 0u;
   switch(eval_fpclassify(b))
   {
   case 1:
   case 2:
      result = zero;
      return;
   }
   switch(eval_fpclassify(a))
   {
   case 1:
      result = zero;
      return;
   case 2:
      result = a;
      return;
   }
   if(eval_gt(a, b))
   {
      eval_subtract(result, a, b);
   }
   else
      result = zero;
}

template<class T, class A>
inline typename boost::enable_if_c<boost::is_arithmetic<A>::value>::type eval_fdim(T& result, const T& a, const A& b)
{
   typedef typename boost::multiprecision::detail::canonical<unsigned, T>::type ui_type;
   typedef typename boost::multiprecision::detail::canonical<A, T>::type arithmetic_type;
   static const ui_type zero = 0u;
   arithmetic_type canonical_b = b;
   switch((::boost::math::fpclassify)(b))
   {
   case 1:
   case 2:
      result = zero;
      return;
   }
   switch(eval_fpclassify(a))
   {
   case 1:
      result = zero;
      return;
   case 2:
      result = a;
      return;
   }
   if(eval_gt(a, canonical_b))
   {
      eval_subtract(result, a, canonical_b);
   }
   else
      result = zero;
}

template<class T, class A>
inline typename boost::enable_if_c<boost::is_arithmetic<A>::value>::type eval_fdim(T& result, const A& a, const T& b)
{
   typedef typename boost::multiprecision::detail::canonical<unsigned, T>::type ui_type;
   typedef typename boost::multiprecision::detail::canonical<A, T>::type arithmetic_type;
   static const ui_type zero = 0u;
   arithmetic_type canonical_a = a;
   switch(eval_fpclassify(b))
   {
   case 1:
   case 2:
      result = zero;
      return;
   }
   switch((::boost::math::fpclassify)(a))
   {
   case 1:
      result = zero;
      return;
   case 2:
      result = std::numeric_limits<number<T> >::infinity().backend();
      return;
   }
   if(eval_gt(canonical_a, b))
   {
      eval_subtract(result, canonical_a, b);
   }
   else
      result = zero;
}

template <class T>
inline void eval_trunc(T& result, const T& a)
{
   static_assert(number_category<T>::value == number_kind_floating_point, "The trunc function is only valid for floating point types.");
   switch(eval_fpclassify(a))
   {
   case 1:
      (*__error()) = 33;

   case 3:
   case 2:
      result = a;
      return;
   }
   if(eval_get_sign(a) < 0)
      eval_ceil(result, a);
   else
      eval_floor(result, a);
}

template <class T>
inline void eval_modf(T& result, T const& arg, T* pipart)
{
   typedef typename boost::multiprecision::detail::canonical<unsigned, T>::type ui_type;
   int c = eval_fpclassify(arg);
   if(c == (int)1)
   {
      if(pipart)
         *pipart = arg;
      result = arg;
      return;
   }
   else if(c == (int)2)
   {
      if(pipart)
         *pipart = arg;
      result = ui_type(0u);
      return;
   }
   if(pipart)
   {
      eval_trunc(*pipart, arg);
      eval_subtract(result, arg, *pipart);
   }
   else
   {
      T ipart;
      eval_trunc(ipart, arg);
      eval_subtract(result, arg, ipart);
   }
}

template <class T>
inline void eval_round(T& result, const T& a)
{
   static_assert(number_category<T>::value == number_kind_floating_point, "The round function is only valid for floating point types.");
   typedef typename boost::multiprecision::detail::canonical<float, T>::type fp_type;
   int c = eval_fpclassify(a);
   if(c == (int)1)
   {
      result = a;
      (*__error()) = 33;
      return;
   }
   if((c == 3) || (c == (int)2))
   {
      result = a;
   }
   else if(eval_get_sign(a) < 0)
   {
      eval_subtract(result, a, fp_type(0.5f));
      eval_ceil(result, result);
   }
   else
   {
      eval_add(result, a, fp_type(0.5f));
      eval_floor(result, result);
   }
}

template <class B>
void eval_lcm(B& result, const B& a, const B& b);
template <class B>
void eval_gcd(B& result, const B& a, const B& b);

template <class T, class Arithmetic>
inline typename enable_if<is_integral<Arithmetic> >::type eval_gcd(T& result, const T& a, const Arithmetic& b)
{
   typedef typename boost::multiprecision::detail::canonical<Arithmetic, T>::type si_type;
   using default_ops::eval_gcd;
   T t;
   t = static_cast<si_type>(b);
   eval_gcd(result, a, t);
}
template <class T, class Arithmetic>
inline typename enable_if<is_integral<Arithmetic> >::type eval_gcd(T& result, const Arithmetic& a, const T& b)
{
   eval_gcd(result, b, a);
}
template <class T, class Arithmetic>
inline typename enable_if<is_integral<Arithmetic> >::type eval_lcm(T& result, const T& a, const Arithmetic& b)
{
   typedef typename boost::multiprecision::detail::canonical<Arithmetic, T>::type si_type;
   using default_ops::eval_lcm;
   T t;
   t = static_cast<si_type>(b);
   eval_lcm(result, a, t);
}
template <class T, class Arithmetic>
inline typename enable_if<is_integral<Arithmetic> >::type eval_lcm(T& result, const Arithmetic& a, const T& b)
{
   eval_lcm(result, b, a);
}

template <class T>
inline unsigned eval_lsb(const T& val)
{
   typedef typename boost::multiprecision::detail::canonical<unsigned, T>::type ui_type;
   int c = eval_get_sign(val);
   if(c == 0)
   {
      ::boost::exception_detail::throw_exception_(std::range_error("No bits were set in the operand."),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/default_ops.hpp",1427);
   }
   if(c < 0)
   {
      ::boost::exception_detail::throw_exception_(std::range_error("Testing individual bits in negative values is not supported - results are undefined."),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/default_ops.hpp",1431);
   }
   unsigned result = 0;
   T mask, t;
   mask = ui_type(1);
   do
   {
      eval_bitwise_and(t, mask, val);
      ++result;
      eval_left_shift(mask, 1);
   }
   while(eval_is_zero(t));

   return --result;
}

template <class T>
inline int eval_msb(const T& val)
{
   int c = eval_get_sign(val);
   if(c == 0)
   {
      ::boost::exception_detail::throw_exception_(std::range_error("No bits were set in the operand."),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/default_ops.hpp",1453);
   }
   if(c < 0)
   {
      ::boost::exception_detail::throw_exception_(std::range_error("Testing individual bits in negative values is not supported - results are undefined."),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/default_ops.hpp",1457);
   }
   unsigned result = 0;
   T t(val);
   while(!eval_is_zero(t))
   {
      eval_right_shift(t, 1);
      ++result;
   }
   return --result;
}

template <class T>
inline bool eval_bit_test(const T& val, unsigned index)
{
   typedef typename boost::multiprecision::detail::canonical<unsigned, T>::type ui_type;
   T mask, t;
   mask = ui_type(1);
   eval_left_shift(mask, index);
   eval_bitwise_and(t, mask, val);
   return !eval_is_zero(t);
}

template <class T>
inline void eval_bit_set(T& val, unsigned index)
{
   typedef typename boost::multiprecision::detail::canonical<unsigned, T>::type ui_type;
   T mask;
   mask = ui_type(1);
   eval_left_shift(mask, index);
   eval_bitwise_or(val, mask);
}

template <class T>
inline void eval_bit_flip(T& val, unsigned index)
{
   typedef typename boost::multiprecision::detail::canonical<unsigned, T>::type ui_type;
   T mask;
   mask = ui_type(1);
   eval_left_shift(mask, index);
   eval_bitwise_xor(val, mask);
}

template <class T>
inline void eval_bit_unset(T& val, unsigned index)
{
   typedef typename boost::multiprecision::detail::canonical<unsigned, T>::type ui_type;
   T mask, t;
   mask = ui_type(1);
   eval_left_shift(mask, index);
   eval_bitwise_and(t, mask, val);
   if(!eval_is_zero(t))
      eval_bitwise_xor(val, mask);
}

template <class B>
void eval_integer_sqrt(B& s, B& r, const B& x)
{







   typedef typename boost::multiprecision::detail::canonical<unsigned char, B>::type ui_type;

   s = ui_type(0u);
   if(eval_get_sign(x) == 0)
   {
      r = ui_type(0u);
      return;
   }
   int g = eval_msb(x);
   if(g <= 1)
   {
      s = ui_type(1);
      eval_subtract(r, x, s);
      return;
   }

   B t;
   r = x;
   g /= 2;
   int org_g = g;
   eval_bit_set(s, g);
   eval_bit_set(t, 2 * g);
   eval_subtract(r, x, t);
   --g;
   if(eval_get_sign(r) == 0)
      return;
   int msbr = eval_msb(r);
   do
   {
      if(msbr >= org_g + g + 1)
      {
         t = s;
         eval_left_shift(t, g + 1);
         eval_bit_set(t, 2 * g);
         if(t.compare(r) <= 0)
         {
            (__builtin_expect(!(g >= 0), 0) ? __assert_rtn(__func__, "./boost/multiprecision/detail/default_ops.hpp", 1566, "g >= 0") : (void)0);
            eval_bit_set(s, g);
            eval_subtract(r, t);
            if(eval_get_sign(r) == 0)
               return;
            msbr = eval_msb(r);
         }
      }
      --g;
   }
   while(g >= 0);
}

template <class B>
inline void eval_conj(B& result, const B& val)
{
   result = val;
}
template <class B>
inline void eval_proj(B& result, const B& val)
{
   result = val;
}




template <class T>
typename enable_if_c<sizeof(T) == 0>::type eval_floor();
template <class T>
typename enable_if_c<sizeof(T) == 0>::type eval_ceil();
template <class T>
typename enable_if_c<sizeof(T) == 0>::type eval_trunc();
template <class T>
typename enable_if_c<sizeof(T) == 0>::type eval_sqrt();
template <class T>
typename enable_if_c<sizeof(T) == 0>::type eval_ldexp();
template <class T>
typename enable_if_c<sizeof(T) == 0>::type eval_frexp();

template <class T>
typename enable_if_c<sizeof(T) == 0>::type eval_asinh();
template <class T>
typename enable_if_c<sizeof(T) == 0>::type eval_acosh();
template <class T>
typename enable_if_c<sizeof(T) == 0>::type eval_atanh();





template <class B>
inline typename B::exponent_type eval_ilogb(const B& val)
{
   static_assert(!std::numeric_limits<number<B> >::is_specialized || (std::numeric_limits<number<B> >::radix == 2), "The default implementation of ilogb requires a base 2 number type");
   typename B::exponent_type e;
   switch(eval_fpclassify(val))
   {
   case 1:

      return (-2147483647 - 1) > 0 ? (std::numeric_limits<typename B::exponent_type>::max)() : (std::numeric_limits<typename B::exponent_type>::min)();



   case 2:
      return (std::numeric_limits<typename B::exponent_type>::max)();
   case 3:
      return (std::numeric_limits<typename B::exponent_type>::min)();
   }
   B result;
   eval_frexp(result, val, &e);
   return e - 1;
}

template <class T>
int eval_signbit(const T& val);

template <class B>
inline void eval_logb(B& result, const B& val)
{
   switch(eval_fpclassify(val))
   {
   case 1:
      result = val;
      (*__error()) = 33;
      return;
   case 3:
      result = std::numeric_limits<number<B> >::infinity().backend();
      result.negate();
      (*__error()) = 34;
      return;
   case 2:
      result = val;
      if(eval_signbit(val))
         result.negate();
      return;
   }
   typedef typename boost::mpl::if_c<boost::is_same<boost::intmax_t, long>::value, boost::long_long_type, boost::intmax_t>::type max_t;
   result = static_cast<max_t>(eval_ilogb(val));
}
template <class B, class A>
inline void eval_scalbn(B& result, const B& val, A e)
{
   static_assert(!std::numeric_limits<number<B> >::is_specialized || (std::numeric_limits<number<B> >::radix == 2), "The default implementation of scalbn requires a base 2 number type");
   eval_ldexp(result, val, static_cast<typename B::exponent_type>(e));
}
template <class B, class A>
inline void eval_scalbln(B& result, const B& val, A e)
{
   eval_scalbn(result, val, e);
}

template <class T>
inline bool is_arg_nan(const T& val, mpl::true_ const&, const mpl::false_&)
{
   return eval_fpclassify(val) == 1;
}
template <class T>
inline bool is_arg_nan(const T& val, mpl::false_ const&, const mpl::true_&)
{
   return (boost::math::isnan)(val);
}
template <class T>
inline bool is_arg_nan(const T&, mpl::false_ const&, const mpl::false_&)
{
   return false;
}

template <class T>
inline bool is_arg_nan(const T& val)
{
   return is_arg_nan(val, mpl::bool_<boost::multiprecision::detail::is_backend<T>::value>(), is_floating_point<T>());
}

template <class T, class U, class V>
inline void eval_fmax(T& result, const U& a, const V& b)
{
   if(is_arg_nan(a))
      result = number<T>::canonical_value(b);
   else if(is_arg_nan(b))
      result = number<T>::canonical_value(a);
   else if(eval_lt(number<T>::canonical_value(a), number<T>::canonical_value(b)))
      result = number<T>::canonical_value(b);
   else
      result = number<T>::canonical_value(a);
}
template <class T, class U, class V>
inline void eval_fmin(T& result, const U& a, const V& b)
{
   if(is_arg_nan(a))
      result = number<T>::canonical_value(b);
   else if(is_arg_nan(b))
      result = number<T>::canonical_value(a);
   else if(eval_lt(number<T>::canonical_value(a), number<T>::canonical_value(b)))
      result = number<T>::canonical_value(a);
   else
      result = number<T>::canonical_value(b);
}

template <class R, class T, class U>
inline void eval_hypot(R& result, const T& a, const U& b)
{



   R x, y;
   x = number<R>::canonical_value(a);
   y = number<R>::canonical_value(b);
   if(eval_get_sign(x) < 0)
      x.negate();
   if(eval_get_sign(y) < 0)
      y.negate();



   int c1 = eval_fpclassify(x);
   int c2 = eval_fpclassify(y);

   if(c1 == 3)
   {
      result = y;
      return;
   }
   if(c2 == 3)
   {
      result = x;
      return;
   }
   if(c1 == 2)
   {
      result = x;
      return;
   }
   if((c2 == 2) || (c2 == 1))
   {
      result = y;
      return;
   }
   if(c1 == 1)
   {
      result = x;
      return;
   }

   if(eval_gt(y, x))
      x.swap(y);

   eval_multiply(result, x, std::numeric_limits<number<R> >::epsilon().backend());

   if(eval_gt(result, y))
   {
      result = x;
      return;
   }

   R rat;
   eval_divide(rat, y, x);
   eval_multiply(result, rat, rat);
   eval_increment(result);
   eval_sqrt(rat, result);
   eval_multiply(result, rat, x);
}

template <class R, class T>
inline void eval_nearbyint(R& result, const T& a)
{
   eval_round(result, a);
}
template <class R, class T>
inline void eval_rint(R& result, const T& a)
{
   eval_nearbyint(result, a);
}

template <class T>
inline int eval_signbit(const T& val)
{
   return eval_get_sign(val) < 0 ? 1 : 0;
}




template <class To, class From>
inline void eval_real(To& to, const From& from)
{
   to = from;
}
template <class To, class From>
inline void eval_imag(To& to, const From& )
{
   typedef typename mpl::front<typename To::unsigned_types>::type ui_type;
   to = ui_type(0);
}

} namespace default_ops_adl {

template <class To, class From>
inline void eval_set_real_imp(To& to, const From& from)
{
   typedef typename component_type<number<To> >::type to_component_type;
   typename to_component_type::backend_type to_component;
   to_component = from;
   eval_set_real(to, to_component);
}
template <class To, class From>
inline void eval_set_imag_imp(To& to, const From& from)
{
   typedef typename component_type<number<To> >::type to_component_type;
   typename to_component_type::backend_type to_component;
   to_component = from;
   eval_set_imag(to, to_component);
}

} namespace default_ops{

template <class To, class From>
inline typename enable_if_c<number_category<To>::value == number_kind_complex>::type eval_set_real(To& to, const From& from)
{
   default_ops_adl::eval_set_real_imp(to, from);
}
template <class To, class From>
inline typename disable_if_c<number_category<To>::value == number_kind_complex>::type eval_set_real(To& to, const From& from)
{
   to = from;
}

template <class To, class From>
inline void eval_set_imag(To& to, const From& from)
{
   default_ops_adl::eval_set_imag_imp(to, from);
}

template <class T>
inline void eval_set_real(T& to, const T& from)
{
   to = from;
}
template <class T>
void eval_set_imag(T&, const T&)
{
   static_assert(sizeof(T) == 2147483647, "eval_set_imag needs to be specialised for each specific backend");
}














template <class T>
void calc_log2(T& num, unsigned digits)
{
   typedef typename boost::multiprecision::detail::canonical<boost::uint32_t, T>::type ui_type;
   typedef typename mpl::front<typename T::signed_types>::type si_type;




   static const char* string_val = "0."
        "6931471805599453094172321214581765680755001343602552541206800094933936219696947156058633269964186875"
        "4200148102057068573368552023575813055703267075163507596193072757082837143519030703862389167347112335"
        "0115364497955239120475172681574932065155524734139525882950453007095326366642654104239157814952043740"
        "4303855008019441706416715186447128399681717845469570262716310645461502572074024816377733896385506952"
        "6066834113727387372292895649354702576265209885969320196505855476470330679365443254763274495125040606"
        "9438147104689946506220167720424524529612687946546193165174681392672504103802546259656869144192871608"
        "2938031727143677826548775664850856740776484514644399404614226031930967354025744460703080960850474866"
        "3852313818167675143866747664789088143714198549423151997354880375165861275352916610007105355824987941"
        "4729509293113897155998205654392871700072180857610252368892132449713893203784393530887748259701715591"
        "0708823683627589842589185353024363421436706118923678919237231467232172053401649256872747782344535347"
        "6481149418642386776774406069562657379600867076257199184734022651462837904883062033061144630073719489";



   if(digits < 3640)
   {
      num = string_val;
      return;
   }
   num = static_cast<ui_type>(1180509120uL);
   T denom, next_term, temp;
   denom = static_cast<ui_type>(1277337600uL);
   next_term = static_cast<ui_type>(120uL);
   si_type sign = -1;

   ui_type limit = digits / 3 + 1;

   for(ui_type n = 6; n < limit; ++n)
   {
      temp = static_cast<ui_type>(2);
      eval_multiply(temp, ui_type(2 * n));
      eval_multiply(temp, ui_type(2 * n + 1));
      eval_multiply(num, temp);
      eval_multiply(denom, temp);
      sign = -sign;
      eval_multiply(next_term, n);
      eval_multiply(temp, next_term, next_term);
      if(sign < 0)
         temp.negate();
      eval_add(num, temp);
   }
   eval_multiply(denom, ui_type(4));
   eval_multiply(num, ui_type(3));
                            ;
                          ;
   eval_divide(num, denom);
                          ;
}

template <class T>
void calc_e(T& result, unsigned digits)
{
   typedef typename mpl::front<typename T::unsigned_types>::type ui_type;



   const char* string_val = "2."
         "7182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664274"
         "2746639193200305992181741359662904357290033429526059563073813232862794349076323382988075319525101901"
         "1573834187930702154089149934884167509244761460668082264800168477411853742345442437107539077744992069"
         "5517027618386062613313845830007520449338265602976067371132007093287091274437470472306969772093101416"
         "9283681902551510865746377211125238978442505695369677078544996996794686445490598793163688923009879312"
         "7736178215424999229576351482208269895193668033182528869398496465105820939239829488793320362509443117"
         "3012381970684161403970198376793206832823764648042953118023287825098194558153017567173613320698112509"
         "9618188159304169035159888851934580727386673858942287922849989208680582574927961048419844436346324496"
         "8487560233624827041978623209002160990235304369941849146314093431738143640546253152096183690888707016"
         "7683964243781405927145635490613031072085103837505101157477041718986106873969655212671546889570350354"
         "0212340784981933432106817012100562788023519303322474501585390473041995777709350366041699732972508869";



   if(digits < 3640)
   {
      result = string_val;
      return;
   }

   T lim;
   lim = ui_type(1);
   eval_ldexp(lim, lim, digits);




   result = ui_type(2);
   T denom;
   denom = ui_type(1);
   ui_type i = 2;
   do{
      eval_multiply(denom, i);
      eval_multiply(result, i);
      eval_add(result, ui_type(1));
      ++i;
   }while(denom.compare(lim) <= 0);
   eval_divide(result, denom);
}

template <class T>
void calc_pi(T& result, unsigned digits)
{
   typedef typename mpl::front<typename T::unsigned_types>::type ui_type;
   typedef typename mpl::front<typename T::float_types>::type real_type;



   const char* string_val = "3."
         "1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679"
         "8214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196"
         "4428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273"
         "7245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094"
         "3305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912"
         "9833673362440656643086021394946395224737190702179860943702770539217176293176752384674818467669405132"
         "0005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235"
         "4201995611212902196086403441815981362977477130996051870721134999999837297804995105973173281609631859"
         "5024459455346908302642522308253344685035261931188171010003137838752886587533208381420617177669147303"
         "5982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989"
         "3809525720106548586327886593615338182796823030195203530185296899577362259941389124972177528347913152";



   if(digits < 3640)
   {
      result = string_val;
      return;
   }

   T a;
   a = ui_type(1);
   T b;
   T A(a);
   T B;
   B = real_type(0.5f);
   T D;
   D = real_type(0.25f);

   T lim;
   lim = ui_type(1);
   eval_ldexp(lim, lim, -(int)digits);
   unsigned k = 1;

   do
   {
      eval_add(result, A, B);
      eval_ldexp(result, result, -2);
      eval_sqrt(b, B);
      eval_add(a, b);
      eval_ldexp(a, a, -1);
      eval_multiply(A, a, a);
      eval_subtract(B, A, result);
      eval_ldexp(B, B, 1);
      eval_subtract(result, A, B);
      bool neg = eval_get_sign(result) < 0;
      if(neg)
         result.negate();
      if(result.compare(lim) <= 0)
         break;
      if(neg)
         result.negate();
      eval_ldexp(result, result, k - 1);
      eval_subtract(D, result);
      ++k;
      eval_ldexp(lim, lim, 1);
   }
   while(true);

   eval_divide(result, B, D);
}

template <class T, const T& (*F)(void)>
struct constant_initializer
{
   static void do_nothing()
   {
      init.do_nothing();
   }
private:
   struct initializer
   {
      initializer()
      {
         F();
      }
      void do_nothing()const{}
   };
   static const initializer init;
};

template <class T, const T& (*F)(void)>
typename constant_initializer<T, F>::initializer const constant_initializer<T, F>::init;

template <class T>
const T& get_constant_ln2()
{
   static thread_local T result;
   static thread_local long digits = 0;
   if ((digits != boost::multiprecision::detail::digits2<number<T> >::value()))
   {

      calc_log2(result, boost::multiprecision::detail::digits2<number<T, et_on> >::value());
      digits = boost::multiprecision::detail::digits2<number<T> >::value();
   }

   return result;
}

template <class T>
const T& get_constant_e()
{
   static thread_local T result;
   static thread_local long digits = 0;
   if ((digits != boost::multiprecision::detail::digits2<number<T> >::value()))
   {

      calc_e(result, boost::multiprecision::detail::digits2<number<T, et_on> >::value());
      digits = boost::multiprecision::detail::digits2<number<T> >::value();
   }

   return result;
}

template <class T>
const T& get_constant_pi()
{
   static thread_local T result;
   static thread_local long digits = 0;
   if ((digits != boost::multiprecision::detail::digits2<number<T> >::value()))
   {

      calc_pi(result, boost::multiprecision::detail::digits2<number<T, et_on> >::value());
      digits = boost::multiprecision::detail::digits2<number<T> >::value();
   }

   return result;
}

template <class T>
const T& get_constant_one_over_epsilon()
{
   static thread_local T result;
   static thread_local long digits = 0;
   if ((digits != boost::multiprecision::detail::digits2<number<T> >::value()))
   {

      typedef typename mpl::front<typename T::unsigned_types>::type ui_type;
      result = static_cast<ui_type>(1u);
      eval_divide(result, std::numeric_limits<number<T> >::epsilon().backend());
   }

   return result;
}
namespace detail{

template<typename T, typename U>
inline void pow_imp(T& result, const T& t, const U& p, const mpl::false_&)
{






   typedef typename boost::multiprecision::detail::canonical<U, T>::type int_type;

   if(&result == &t)
   {
      T temp;
      pow_imp(temp, t, p, mpl::false_());
      result = temp;
      return;
   }


   if(U(p % U(2)) != U(0))
   {
      result = t;
   }
   else
      result = int_type(1);

   U p2(p);


   T x(t);

   while(U(p2 /= 2) != U(0))
   {

      eval_multiply(x, x);

      const bool has_binary_power = (U(p2 % U(2)) != U(0));

      if(has_binary_power)
      {

         eval_multiply(result, x);
      }
   }
}

template<typename T, typename U>
inline void pow_imp(T& result, const T& t, const U& p, const mpl::true_&)
{

   typedef typename boost::multiprecision::detail::canonical<U, T>::type int_type;
   typedef typename make_unsigned<U>::type ui_type;

   if(p < 0)
   {
      T temp;
      temp = static_cast<int_type>(1);
      T denom;
      pow_imp(denom, t, static_cast<ui_type>(-p), mpl::false_());
      eval_divide(result, temp, denom);
      return;
   }
   pow_imp(result, t, static_cast<ui_type>(p), mpl::false_());
}

}

template<typename T, typename U>
inline typename enable_if_c<is_integral<U>::value>::type eval_pow(T& result, const T& t, const U& p)
{
   detail::pow_imp(result, t, p, boost::is_signed<U>());
}

template <class T>
void hyp0F0(T& H0F0, const T& x)
{




   typedef typename mpl::front<typename T::unsigned_types>::type ui_type;

   (__builtin_expect(!(&H0F0 != &x), 0) ? __assert_rtn(__func__, "./boost/multiprecision/detail/functions/pow.hpp", 105, "&H0F0 != &x") : (void)0);
   long tol = boost::multiprecision::detail::digits2<number<T, et_on> >::value();
   T t;

   T x_pow_n_div_n_fact(x);

   eval_add(H0F0, x_pow_n_div_n_fact, ui_type(1));

   T lim;
   eval_ldexp(lim, H0F0, 1 - tol);
   if(eval_get_sign(lim) < 0)
      lim.negate();

   ui_type n;

   const unsigned series_limit =
      boost::multiprecision::detail::digits2<number<T, et_on> >::value() < 100
      ? 100 : boost::multiprecision::detail::digits2<number<T, et_on> >::value();

   for(n = 2; n < series_limit; ++n)
   {
      eval_multiply(x_pow_n_div_n_fact, x);
      eval_divide(x_pow_n_div_n_fact, n);
      eval_add(H0F0, x_pow_n_div_n_fact);
      bool neg = eval_get_sign(x_pow_n_div_n_fact) < 0;
      if(neg)
         x_pow_n_div_n_fact.negate();
      if(lim.compare(x_pow_n_div_n_fact) > 0)
         break;
      if(neg)
         x_pow_n_div_n_fact.negate();
   }
   if(n >= series_limit)
      ::boost::exception_detail::throw_exception_(std::runtime_error("H0F0 failed to converge"),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/functions/pow.hpp",138);
}

template <class T>
void hyp1F0(T& H1F0, const T& a, const T& x)
{





   typedef typename boost::multiprecision::detail::canonical<int, T>::type si_type;

   (__builtin_expect(!(&H1F0 != &x), 0) ? __assert_rtn(__func__, "./boost/multiprecision/detail/functions/pow.hpp", 151, "&H1F0 != &x") : (void)0);
   (__builtin_expect(!(&H1F0 != &a), 0) ? __assert_rtn(__func__, "./boost/multiprecision/detail/functions/pow.hpp", 152, "&H1F0 != &a") : (void)0);

   T x_pow_n_div_n_fact(x);
   T pochham_a (a);
   T ap (a);

   eval_multiply(H1F0, pochham_a, x_pow_n_div_n_fact);
   eval_add(H1F0, si_type(1));
   T lim;
   eval_ldexp(lim, H1F0, 1 - boost::multiprecision::detail::digits2<number<T, et_on> >::value());
   if(eval_get_sign(lim) < 0)
      lim.negate();

   si_type n;
   T term, part;

   const si_type series_limit =
      boost::multiprecision::detail::digits2<number<T, et_on> >::value() < 100
      ? 100 : boost::multiprecision::detail::digits2<number<T, et_on> >::value();

   for(n = 2; n < series_limit; n++)
   {
      eval_multiply(x_pow_n_div_n_fact, x);
      eval_divide(x_pow_n_div_n_fact, n);
      eval_increment(ap);
      eval_multiply(pochham_a, ap);
      eval_multiply(term, pochham_a, x_pow_n_div_n_fact);
      eval_add(H1F0, term);
      if(eval_get_sign(term) < 0)
         term.negate();
      if(lim.compare(term) >= 0)
         break;
   }
   if(n >= series_limit)
      ::boost::exception_detail::throw_exception_(std::runtime_error("H1F0 failed to converge"),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/functions/pow.hpp",186);
}

template <class T>
void eval_exp(T& result, const T& x)
{
   static_assert(number_category<T>::value == number_kind_floating_point, "The exp function is only valid for floating point types.");
   if(&x == &result)
   {
      T temp;
      eval_exp(temp, x);
      result = temp;
      return;
   }
   typedef typename boost::multiprecision::detail::canonical<unsigned, T>::type ui_type;
   typedef typename boost::multiprecision::detail::canonical<int, T>::type si_type;
   typedef typename T::exponent_type exp_type;
   typedef typename boost::multiprecision::detail::canonical<exp_type, T>::type canonical_exp_type;


   int type = eval_fpclassify(x);
   bool isneg = eval_get_sign(x) < 0;
   if(type == (int)1)
   {
      result = x;
      (*__error()) = 33;
      return;
   }
   else if(type == (int)2)
   {
      if(isneg)
         result = ui_type(0u);
      else
         result = x;
      return;
   }
   else if(type == (int)3)
   {
      result = ui_type(1);
      return;
   }


   T xx = x;
   T exp_series;
   if(isneg)
      xx.negate();


   if(xx.compare(si_type(1)) <= 0)
   {



      T lim;
      if(std::numeric_limits<number<T, et_on> >::is_specialized)
         lim = std::numeric_limits<number<T, et_on> >::epsilon().backend();
      else
      {
         result = ui_type(1);
         eval_ldexp(lim, result, 1 - boost::multiprecision::detail::digits2<number<T, et_on> >::value());
      }
      unsigned k = 2;
      exp_series = xx;
      result = si_type(1);
      if(isneg)
         eval_subtract(result, exp_series);
      else
         eval_add(result, exp_series);
      eval_multiply(exp_series, xx);
      eval_divide(exp_series, ui_type(k));
      eval_add(result, exp_series);
      while(exp_series.compare(lim) > 0)
      {
         ++k;
         eval_multiply(exp_series, xx);
         eval_divide(exp_series, ui_type(k));
         if(isneg && (k&1))
            eval_subtract(result, exp_series);
         else
            eval_add(result, exp_series);
      }
      return;
   }


   typename boost::multiprecision::detail::canonical<boost::intmax_t, T>::type ll;
   eval_trunc(exp_series, x);
   eval_convert_to(&ll, exp_series);
   if(x.compare(ll) == 0)
   {
      detail::pow_imp(result, get_constant_e<T>(), ll, mpl::true_());
      return;
   }
   else if(exp_series.compare(x) == 0)
   {



      if(isneg)
         result = ui_type(0);
      else
         result = std::numeric_limits<number<T> >::has_infinity ? std::numeric_limits<number<T> >::infinity().backend() : (std::numeric_limits<number<T> >::max)().backend();
      return;
   }
   eval_divide(result, xx, get_constant_ln2<T>());
   exp_type n;
   eval_convert_to(&n, result);

   if (n == (std::numeric_limits<exp_type>::max)())
   {

      if (isneg)
         result = ui_type(0);
      else
         result = std::numeric_limits<number<T> >::has_infinity ? std::numeric_limits<number<T> >::infinity().backend() : (std::numeric_limits<number<T> >::max)().backend();
      return;
   }


   const si_type p2 = static_cast<si_type>(si_type(1) << 11);

   eval_multiply(exp_series, get_constant_ln2<T>(), static_cast<canonical_exp_type>(n));
   eval_subtract(exp_series, xx);
   eval_divide(exp_series, p2);
   exp_series.negate();
   hyp0F0(result, exp_series);

   detail::pow_imp(exp_series, result, p2, mpl::true_());
   result = ui_type(1);
   eval_ldexp(result, result, n);
   eval_multiply(exp_series, result);

   if(isneg)
      eval_divide(result, ui_type(1), exp_series);
   else
      result = exp_series;
}

template <class T>
void eval_log(T& result, const T& arg)
{
   static_assert(number_category<T>::value == number_kind_floating_point, "The log function is only valid for floating point types.");






   typedef typename boost::multiprecision::detail::canonical<unsigned, T>::type ui_type;
   typedef typename T::exponent_type exp_type;
   typedef typename boost::multiprecision::detail::canonical<exp_type, T>::type canonical_exp_type;
   typedef typename mpl::front<typename T::float_types>::type fp_type;
   int s = eval_signbit(arg);
   switch(eval_fpclassify(arg))
   {
   case 1:
      result = arg;
      (*__error()) = 33;
      return;
   case 2:
      if(s) break;
      result = arg;
      return;
   case 3:
      result = std::numeric_limits<number<T> >::has_infinity ? std::numeric_limits<number<T> >::infinity().backend() : (std::numeric_limits<number<T> >::max)().backend();
      result.negate();
      (*__error()) = 34;
      return;
   }
   if(s)
   {
      result = std::numeric_limits<number<T> >::quiet_NaN().backend();
      (*__error()) = 33;
      return;
   }

   exp_type e;
   T t;
   eval_frexp(t, arg, &e);
   bool alternate = false;

   if(t.compare(fp_type(2) / fp_type(3)) <= 0)
   {
      alternate = true;
      eval_ldexp(t, t, 1);
      --e;
   }

   eval_multiply(result, get_constant_ln2<T>(), canonical_exp_type(e));
                             ;
   eval_subtract(t, ui_type(1));
   if(!alternate)
      t.negate();
   T pow = t;
   T lim;
   T t2;

   if(alternate)
      eval_add(result, t);
   else
      eval_subtract(result, t);

   if(std::numeric_limits<number<T, et_on> >::is_specialized)
      eval_multiply(lim, result, std::numeric_limits<number<T, et_on> >::epsilon().backend());
   else
      eval_ldexp(lim, result, 1 - boost::multiprecision::detail::digits2<number<T, et_on> >::value());
   if(eval_get_sign(lim) < 0)
      lim.negate();
                          ;

   ui_type k = 1;
   do
   {
      ++k;
      eval_multiply(pow, t);
      eval_divide(t2, pow, k);
                            ;
      if(alternate && ((k & 1) != 0))
         eval_add(result, t2);
      else
         eval_subtract(result, t2);
                                ;
   }while(lim.compare(t2) < 0);
}

template <class T>
const T& get_constant_log10()
{
   static thread_local T result;
   static thread_local long digits = 0;
   if ((digits != boost::multiprecision::detail::digits2<number<T> >::value()))
   {

      typedef typename boost::multiprecision::detail::canonical<unsigned, T>::type ui_type;
      T ten;
      ten = ui_type(10u);
      eval_log(result, ten);
      digits = boost::multiprecision::detail::digits2<number<T> >::value();
   }

   return result;
}

template <class T>
void eval_log10(T& result, const T& arg)
{
   static_assert(number_category<T>::value == number_kind_floating_point, "The log10 function is only valid for floating point types.");
   eval_log(result, arg);
   eval_divide(result, get_constant_log10<T>());
}

template <class R, class T>
inline void eval_log2(R& result, const T& a)
{
   eval_log(result, a);
   eval_divide(result, get_constant_ln2<R>());
}

template<typename T>
inline void eval_pow(T& result, const T& x, const T& a)
{
   static_assert(number_category<T>::value == number_kind_floating_point, "The pow function is only valid for floating point types.");
   typedef typename boost::multiprecision::detail::canonical<int, T>::type si_type;
   typedef typename mpl::front<typename T::float_types>::type fp_type;

   if((&result == &x) || (&result == &a))
   {
      T t;
      eval_pow(t, x, a);
      result = t;
      return;
   }

   if((a.compare(si_type(1)) == 0) || (x.compare(si_type(1)) == 0))
   {
      result = x;
      return;
   }
   if(a.compare(si_type(0)) == 0)
   {
      result = si_type(1);
      return;
   }

   int type = eval_fpclassify(x);

   switch(type)
   {
   case 3:
      switch(eval_fpclassify(a))
      {
      case 3:
         result = si_type(1);
         break;
      case 1:
         result = a;
         break;
      case 4:
      {

         try
         {
            typename boost::multiprecision::detail::canonical<boost::intmax_t, T>::type i;
            eval_convert_to(&i, a);
            if(a.compare(i) == 0)
            {
               if(eval_signbit(a))
               {
                  if(i & 1)
                  {
                     result = std::numeric_limits<number<T> >::infinity().backend();
                     if(eval_signbit(x))
                        result.negate();
                     (*__error()) = 34;
                  }
                  else
                  {
                     result = std::numeric_limits<number<T> >::infinity().backend();
                     (*__error()) = 34;
                  }
               }
               else if(i & 1)
               {
                  result = x;
               }
               else
                  result = si_type(0);
               return;
            }
         }
         catch(const std::exception&)
         {

         }
      }
      default:
         if(eval_signbit(a))
         {
            result = std::numeric_limits<number<T> >::infinity().backend();
            (*__error()) = 34;
         }
         else
            result = x;
         break;
      }
      return;
   case 1:
      result = x;
      (*__error()) = 34;
      return;
   default: ;
   }

   int s = eval_get_sign(a);
   if(s == 0)
   {
      result = si_type(1);
      return;
   }

   if(s < 0)
   {
      T t, da;
      t = a;
      t.negate();
      eval_pow(da, x, t);
      eval_divide(result, si_type(1), da);
      return;
   }

   typename boost::multiprecision::detail::canonical<boost::intmax_t, T>::type an;
   typename boost::multiprecision::detail::canonical<boost::intmax_t, T>::type max_an =
      std::numeric_limits<typename boost::multiprecision::detail::canonical<boost::intmax_t, T>::type>::is_specialized ?
      (std::numeric_limits<typename boost::multiprecision::detail::canonical<boost::intmax_t, T>::type>::max)() :
      static_cast<typename boost::multiprecision::detail::canonical<boost::intmax_t, T>::type>(1) << (sizeof(typename boost::multiprecision::detail::canonical<boost::intmax_t, T>::type) * 8 - 2);
   typename boost::multiprecision::detail::canonical<boost::intmax_t, T>::type min_an =
      std::numeric_limits<typename boost::multiprecision::detail::canonical<boost::intmax_t, T>::type>::is_specialized ?
      (std::numeric_limits<typename boost::multiprecision::detail::canonical<boost::intmax_t, T>::type>::min)() :
      -min_an;


   T fa;

   try
   {

      eval_convert_to(&an, a);
      if(a.compare(an) == 0)
      {
         detail::pow_imp(result, x, an, mpl::true_());
         return;
      }

   }
   catch(const std::exception&)
   {

      an = (std::numeric_limits<boost::intmax_t>::max)();
   }

   if((eval_get_sign(x) < 0))
   {
      typename boost::multiprecision::detail::canonical<boost::uintmax_t, T>::type aun;

      try
      {

         eval_convert_to(&aun, a);
         if(a.compare(aun) == 0)
         {
            fa = x;
            fa.negate();
            eval_pow(result, fa, a);
            if(aun & 1u)
               result.negate();
            return;
         }

      }
      catch(const std::exception&)
      {

      }

      eval_floor(result, a);

      if((x.compare(si_type(-1)) == 0) && (eval_fpclassify(a) == 2))
      {
         result = si_type(1);
      }
      else if(a.compare(result) == 0)
      {

         if(x.compare(si_type(-1)) < 0)
         {
            result = std::numeric_limits<number<T, et_on> >::infinity().backend();
         }
         else
         {
            result = si_type(0);
         }
      }
      else if(type == 2)
      {
         result = std::numeric_limits<number<T, et_on> >::infinity().backend();
      }
      else if(std::numeric_limits<number<T, et_on> >::has_quiet_NaN)
      {
         result = std::numeric_limits<number<T, et_on> >::quiet_NaN().backend();
         (*__error()) = 33;
      }
      else
      {
         ::boost::exception_detail::throw_exception_(std::domain_error("Result of pow is undefined or non-real and there is no NaN for this number type."),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/functions/pow.hpp",659);
      }
      return;
   }

   T t, da;

   eval_subtract(da, a, an);

   if((x.compare(fp_type(0.5)) >= 0) && (x.compare(fp_type(0.9)) < 0) && (an < max_an) && (an > min_an))
   {
      if(a.compare(fp_type(1e-5f)) <= 0)
      {

         eval_log(t, x);
         eval_multiply(t, a);
         hyp0F0(result, t);
         return;
      }
      else
      {


         if(an)
         {
            da.negate();
            t = si_type(1);
            eval_subtract(t, x);
            hyp1F0(result, da, t);
            detail::pow_imp(t, x, an, mpl::true_());
            eval_multiply(result, t);
         }
         else
         {
            da = a;
            da.negate();
            t = si_type(1);
            eval_subtract(t, x);
            hyp1F0(result, da, t);
         }
      }
   }
   else
   {


      if(an)
      {
         eval_log(t, x);
         eval_multiply(t, da);
         eval_exp(result, t);
         detail::pow_imp(t, x, an, mpl::true_());
         eval_multiply(result, t);
      }
      else
      {
         eval_log(t, x);
         eval_multiply(t, a);
         eval_exp(result, t);
      }
   }
}

template<class T, class A>



inline typename enable_if_c<is_compatible_arithmetic_type<A, number<T> >::value && !is_integral<A>::value, void>::type

   eval_pow(T& result, const T& x, const A& a)
{


   typedef typename boost::multiprecision::detail::canonical<A, T>::type canonical_type;
   typedef typename mpl::if_<is_same<A, canonical_type>, T, canonical_type>::type cast_type;
   cast_type c;
   c = a;
   eval_pow(result, x, c);
}

template<class T, class A>



inline typename enable_if_c<is_compatible_arithmetic_type<A, number<T> >::value, void>::type

   eval_pow(T& result, const A& x, const T& a)
{
   typedef typename boost::multiprecision::detail::canonical<A, T>::type canonical_type;
   typedef typename mpl::if_<is_same<A, canonical_type>, T, canonical_type>::type cast_type;
   cast_type c;
   c = x;
   eval_pow(result, c, a);
}

template <class T>
void eval_exp2(T& result, const T& arg)
{
   static_assert(number_category<T>::value == number_kind_floating_point, "The log function is only valid for floating point types.");


   typename boost::multiprecision::detail::canonical<typename T::exponent_type, T>::type i;
   T temp;
   try {
      eval_trunc(temp, arg);
      eval_convert_to(&i, temp);
      if(arg.compare(i) == 0)
      {
         temp = static_cast<typename mpl::front<typename T::unsigned_types>::type>(1u);
         eval_ldexp(result, temp, i);
         return;
      }
   }
   catch(const boost::math::rounding_error&)
   { }
   catch(const std::runtime_error&)
   { }

   temp = static_cast<typename mpl::front<typename T::unsigned_types>::type>(2u);
   eval_pow(result, temp, arg);
}

namespace detail{

   template <class T>
   void small_sinh_series(T x, T& result)
   {
      typedef typename boost::multiprecision::detail::canonical<unsigned, T>::type ui_type;
      bool neg = eval_get_sign(x) < 0;
      if(neg)
         x.negate();
      T p(x);
      T mult(x);
      eval_multiply(mult, x);
      result = x;
      ui_type k = 1;

      T lim(x);
      eval_ldexp(lim, lim, 1 - boost::multiprecision::detail::digits2<number<T, et_on> >::value());

      do
      {
         eval_multiply(p, mult);
         eval_divide(p, ++k);
         eval_divide(p, ++k);
         eval_add(result, p);
      }while(p.compare(lim) >= 0);
      if(neg)
         result.negate();
   }

   template <class T>
   void sinhcosh(const T& x, T* p_sinh, T* p_cosh)
   {
      typedef typename boost::multiprecision::detail::canonical<unsigned, T>::type ui_type;
      typedef typename mpl::front<typename T::float_types>::type fp_type;

      switch(eval_fpclassify(x))
      {
      case 1:
         (*__error()) = 33;

      case 2:
         if(p_sinh)
            *p_sinh = x;
         if(p_cosh)
         {
            *p_cosh = x;
            if(eval_get_sign(x) < 0)
               p_cosh->negate();
         }
         return;
      case 3:
         if(p_sinh)
            *p_sinh = x;
         if(p_cosh)
            *p_cosh = ui_type(1);
         return;
      default: ;
      }

      bool small_sinh = eval_get_sign(x) < 0 ? x.compare(fp_type(-0.5)) > 0 : x.compare(fp_type(0.5)) < 0;

      if(p_cosh || !small_sinh)
      {
         T e_px, e_mx;
         eval_exp(e_px, x);
         eval_divide(e_mx, ui_type(1), e_px);
         if(eval_signbit(e_mx) != eval_signbit(e_px))
            e_mx.negate();

         if(p_sinh)
         {
            if(small_sinh)
            {
               small_sinh_series(x, *p_sinh);
            }
            else
            {
               eval_subtract(*p_sinh, e_px, e_mx);
               eval_ldexp(*p_sinh, *p_sinh, -1);
            }
         }
         if(p_cosh)
         {
            eval_add(*p_cosh, e_px, e_mx);
            eval_ldexp(*p_cosh, *p_cosh, -1);
         }
      }
      else
      {
         small_sinh_series(x, *p_sinh);
      }
   }

}

template <class T>
inline void eval_sinh(T& result, const T& x)
{
   static_assert(number_category<T>::value == number_kind_floating_point, "The sinh function is only valid for floating point types.");
   detail::sinhcosh(x, &result, static_cast<T*>(0));
}

template <class T>
inline void eval_cosh(T& result, const T& x)
{
   static_assert(number_category<T>::value == number_kind_floating_point, "The cosh function is only valid for floating point types.");
   detail::sinhcosh(x, static_cast<T*>(0), &result);
}

template <class T>
inline void eval_tanh(T& result, const T& x)
{
   static_assert(number_category<T>::value == number_kind_floating_point, "The tanh function is only valid for floating point types.");
  T c;
  detail::sinhcosh(x, &result, &c);
  if((eval_fpclassify(result) == 2) && (eval_fpclassify(c) == 2))
  {
     bool s = eval_signbit(result) != eval_signbit(c);
     result = static_cast<typename mpl::front<typename T::unsigned_types>::type>(1u);
     if(s)
        result.negate();
     return;
  }
  eval_divide(result, c);
}
template <class T>
void hyp0F1(T& result, const T& b, const T& x)
{
   typedef typename boost::multiprecision::detail::canonical<boost::int32_t, T>::type si_type;
   typedef typename boost::multiprecision::detail::canonical<boost::uint32_t, T>::type ui_type;





   T x_pow_n_div_n_fact(x);
   T pochham_b (b);
   T bp (b);

   eval_divide(result, x_pow_n_div_n_fact, pochham_b);
   eval_add(result, ui_type(1));

   si_type n;

   T tol;
   tol = ui_type(1);
   eval_ldexp(tol, tol, 1 - boost::multiprecision::detail::digits2<number<T, et_on> >::value());
   eval_multiply(tol, result);
   if(eval_get_sign(tol) < 0)
      tol.negate();
   T term;

   const int series_limit =
      boost::multiprecision::detail::digits2<number<T, et_on> >::value() < 100
      ? 100 : boost::multiprecision::detail::digits2<number<T, et_on> >::value();

   for(n = 2; n < series_limit; ++n)
   {
      eval_multiply(x_pow_n_div_n_fact, x);
      eval_divide(x_pow_n_div_n_fact, n);
      eval_increment(bp);
      eval_multiply(pochham_b, bp);

      eval_divide(term, x_pow_n_div_n_fact, pochham_b);
      eval_add(result, term);

      bool neg_term = eval_get_sign(term) < 0;
      if(neg_term)
         term.negate();
      if(term.compare(tol) <= 0)
         break;
   }

   if(n >= series_limit)
      ::boost::exception_detail::throw_exception_(std::runtime_error("H0F1 Failed to Converge"),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/functions/trig.hpp",69);
}


template <class T>
void eval_sin(T& result, const T& x)
{
   static_assert(number_category<T>::value == number_kind_floating_point, "The sin function is only valid for floating point types.");
   if(&result == &x)
   {
      T temp;
      eval_sin(temp, x);
      result = temp;
      return;
   }

   typedef typename boost::multiprecision::detail::canonical<boost::int32_t, T>::type si_type;
   typedef typename boost::multiprecision::detail::canonical<boost::uint32_t, T>::type ui_type;
   typedef typename mpl::front<typename T::float_types>::type fp_type;

   switch(eval_fpclassify(x))
   {
   case 2:
   case 1:
      if(std::numeric_limits<number<T, et_on> >::has_quiet_NaN)
      {
         result = std::numeric_limits<number<T, et_on> >::quiet_NaN().backend();
         (*__error()) = 33;
      }
      else
         ::boost::exception_detail::throw_exception_(std::domain_error("Result is undefined or complex and there is no NaN for this number type."),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/functions/trig.hpp",99);
      return;
   case 3:
      result = x;
      return;
   default: ;
   }


   T xx = x;




   bool b_negate_sin = false;

   if(eval_get_sign(x) < 0)
   {
      xx.negate();
      b_negate_sin = !b_negate_sin;
   }

   T n_pi, t;

   if(xx.compare(get_constant_pi<T>()) > 0)
   {
      eval_divide(n_pi, xx, get_constant_pi<T>());
      eval_trunc(n_pi, n_pi);
      t = ui_type(2);
      eval_fmod(t, n_pi, t);
      const bool b_n_pi_is_even = eval_get_sign(t) == 0;
      eval_multiply(n_pi, get_constant_pi<T>());
      if (n_pi.compare(get_constant_one_over_epsilon<T>()) > 0)
      {
         result = ui_type(0);
         return;
      }
      else
         eval_subtract(xx, n_pi);

                                                                      ;
                                                                        ;


      if(!b_n_pi_is_even)
      {
         b_negate_sin = !b_negate_sin;
      }
   }


   eval_ldexp(t, get_constant_pi<T>(), -1);
   if(xx.compare(t) > 0)
   {
      eval_subtract(xx, get_constant_pi<T>(), xx);
                                                                      ;
   }

   eval_subtract(t, xx);
   const bool b_zero = eval_get_sign(xx) == 0;
   const bool b_pi_half = eval_get_sign(t) == 0;


   const bool b_near_zero = xx.compare(fp_type(1e-1)) < 0;
   const bool b_near_pi_half = t.compare(fp_type(1e-1)) < 0;;

   if(b_zero)
   {
      result = ui_type(0);
   }
   else if(b_pi_half)
   {
      result = ui_type(1);
   }
   else if(b_near_zero)
   {
      eval_multiply(t, xx, xx);
      eval_divide(t, si_type(-4));
      T t2;
      t2 = fp_type(1.5);
      hyp0F1(result, t2, t);
                                                                          ;
      eval_multiply(result, xx);
   }
   else if(b_near_pi_half)
   {
      eval_multiply(t, t);
      eval_divide(t, si_type(-4));
      T t2;
      t2 = fp_type(0.5);
      hyp0F1(result, t2, t);
                                                                          ;
   }
   else
   {





      static const si_type n_scale = 9;
      static const si_type n_three_pow_scale = static_cast<si_type>(19683L);

      eval_divide(xx, n_three_pow_scale);


      eval_multiply(t, xx, xx);
      eval_divide(t, si_type(-4));
      T t2;
      t2 = fp_type(1.5);
      hyp0F1(result, t2, t);
                                                                          ;
      eval_multiply(result, xx);


      for(boost::int32_t k = static_cast<boost::int32_t>(0); k < n_scale; k++)
      {

         eval_multiply(t2, result, ui_type(3));
         eval_multiply(t, result, result);
         eval_multiply(t, result);
         eval_multiply(t, ui_type(4));
         eval_subtract(result, t2, t);
      }
   }

   if(b_negate_sin)
      result.negate();
}

template <class T>
void eval_cos(T& result, const T& x)
{
   static_assert(number_category<T>::value == number_kind_floating_point, "The cos function is only valid for floating point types.");
   if(&result == &x)
   {
      T temp;
      eval_cos(temp, x);
      result = temp;
      return;
   }

   typedef typename boost::multiprecision::detail::canonical<boost::int32_t, T>::type si_type;
   typedef typename boost::multiprecision::detail::canonical<boost::uint32_t, T>::type ui_type;
   typedef typename mpl::front<typename T::float_types>::type fp_type;

   switch(eval_fpclassify(x))
   {
   case 2:
   case 1:
      if(std::numeric_limits<number<T, et_on> >::has_quiet_NaN)
      {
         result = std::numeric_limits<number<T, et_on> >::quiet_NaN().backend();
         (*__error()) = 33;
      }
      else
         ::boost::exception_detail::throw_exception_(std::domain_error("Result is undefined or complex and there is no NaN for this number type."),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/functions/trig.hpp",255);
      return;
   case 3:
      result = ui_type(1);
      return;
   default: ;
   }


   T xx = x;




   bool b_negate_cos = false;

   if(eval_get_sign(x) < 0)
   {
      xx.negate();
   }

   T n_pi, t;

   if(xx.compare(get_constant_pi<T>()) > 0)
   {
      eval_divide(t, xx, get_constant_pi<T>());
      eval_trunc(n_pi, t);
                                                                        ;
      eval_multiply(t, n_pi, get_constant_pi<T>());
                                                                     ;







      if (n_pi.compare(get_constant_one_over_epsilon<T>()) > 0)
      {
         result = ui_type(1);
         return;
      }
      else
         eval_subtract(xx, t);
                                                                      ;


      t = ui_type(2);
      eval_fmod(t, n_pi, t);
      const bool b_n_pi_is_even = eval_get_sign(t) == 0;

      if(!b_n_pi_is_even)
      {
         b_negate_cos = !b_negate_cos;
      }
   }


   eval_ldexp(t, get_constant_pi<T>(), -1);
   int com = xx.compare(t);
   if(com > 0)
   {
      eval_subtract(xx, get_constant_pi<T>(), xx);
      b_negate_cos = !b_negate_cos;
                                                                      ;
   }

   const bool b_zero = eval_get_sign(xx) == 0;
   const bool b_pi_half = com == 0;


   const bool b_near_zero = xx.compare(fp_type(1e-1)) < 0;

   if(b_zero)
   {
      result = si_type(1);
   }
   else if(b_pi_half)
   {
      result = si_type(0);
   }
   else if(b_near_zero)
   {
      eval_multiply(t, xx, xx);
      eval_divide(t, si_type(-4));
      n_pi = fp_type(0.5f);
      hyp0F1(result, n_pi, t);
                                                                          ;
   }
   else
   {
      eval_subtract(t, xx);
      eval_sin(result, t);
   }
   if(b_negate_cos)
      result.negate();
}

template <class T>
void eval_tan(T& result, const T& x)
{
   static_assert(number_category<T>::value == number_kind_floating_point, "The tan function is only valid for floating point types.");
   if(&result == &x)
   {
      T temp;
      eval_tan(temp, x);
      result = temp;
      return;
   }
   T t;
   eval_sin(result, x);
   eval_cos(t, x);
   eval_divide(result, t);
}

template <class T>
void hyp2F1(T& result, const T& a, const T& b, const T& c, const T& x)
{




   typedef typename boost::multiprecision::detail::canonical<boost::uint32_t, T>::type ui_type;

   T x_pow_n_div_n_fact(x);
   T pochham_a (a);
   T pochham_b (b);
   T pochham_c (c);
   T ap (a);
   T bp (b);
   T cp (c);

   eval_multiply(result, pochham_a, pochham_b);
   eval_divide(result, pochham_c);
   eval_multiply(result, x_pow_n_div_n_fact);
   eval_add(result, ui_type(1));

   T lim;
   eval_ldexp(lim, result, 1 - boost::multiprecision::detail::digits2<number<T, et_on> >::value());

   if(eval_get_sign(lim) < 0)
      lim.negate();

   ui_type n;
   T term;

   const unsigned series_limit =
      boost::multiprecision::detail::digits2<number<T, et_on> >::value() < 100
      ? 100 : boost::multiprecision::detail::digits2<number<T, et_on> >::value();

   for(n = 2; n < series_limit; ++n)
   {
      eval_multiply(x_pow_n_div_n_fact, x);
      eval_divide(x_pow_n_div_n_fact, n);

      eval_increment(ap);
      eval_multiply(pochham_a, ap);
      eval_increment(bp);
      eval_multiply(pochham_b, bp);
      eval_increment(cp);
      eval_multiply(pochham_c, cp);

      eval_multiply(term, pochham_a, pochham_b);
      eval_divide(term, pochham_c);
      eval_multiply(term, x_pow_n_div_n_fact);
      eval_add(result, term);

      if(eval_get_sign(term) < 0)
         term.negate();
      if(lim.compare(term) >= 0)
         break;
   }
   if(n > series_limit)
      ::boost::exception_detail::throw_exception_(std::runtime_error("H2F1 failed to converge."),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/functions/trig.hpp",428);
}

template <class T>
void eval_asin(T& result, const T& x)
{
   static_assert(number_category<T>::value == number_kind_floating_point, "The asin function is only valid for floating point types.");
   typedef typename boost::multiprecision::detail::canonical<boost::uint32_t, T>::type ui_type;
   typedef typename mpl::front<typename T::float_types>::type fp_type;

   if(&result == &x)
   {
      T t(x);
      eval_asin(result, t);
      return;
   }

   switch(eval_fpclassify(x))
   {
   case 1:
   case 2:
      if(std::numeric_limits<number<T, et_on> >::has_quiet_NaN)
      {
         result = std::numeric_limits<number<T, et_on> >::quiet_NaN().backend();
         (*__error()) = 33;
      }
      else
         ::boost::exception_detail::throw_exception_(std::domain_error("Result is undefined or complex and there is no NaN for this number type."),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/functions/trig.hpp",455);
      return;
   case 3:
      result = x;
      return;
   default: ;
   }

   const bool b_neg = eval_get_sign(x) < 0;

   T xx(x);
   if(b_neg)
      xx.negate();

   int c = xx.compare(ui_type(1));
   if(c > 0)
   {
      if(std::numeric_limits<number<T, et_on> >::has_quiet_NaN)
      {
         result = std::numeric_limits<number<T, et_on> >::quiet_NaN().backend();
         (*__error()) = 33;
      }
      else
         ::boost::exception_detail::throw_exception_(std::domain_error("Result is undefined or complex and there is no NaN for this number type."),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/functions/trig.hpp",478);
      return;
   }
   else if(c == 0)
   {
      result = get_constant_pi<T>();
      eval_ldexp(result, result, -1);
      if(b_neg)
         result.negate();
      return;
   }

   if(xx.compare(fp_type(1e-4)) < 0)
   {

      eval_multiply(xx, xx);
      T t1, t2;
      t1 = fp_type(0.5f);
      t2 = fp_type(1.5f);
      hyp2F1(result, t1, t1, t2, xx);
      eval_multiply(result, x);
      return;
   }
   else if(xx.compare(fp_type(1 - 1e-4f)) > 0)
   {
      T dx1;
      T t1, t2;
      eval_subtract(dx1, ui_type(1), xx);
      t1 = fp_type(0.5f);
      t2 = fp_type(1.5f);
      eval_ldexp(dx1, dx1, -1);
      hyp2F1(result, t1, t1, t2, dx1);
      eval_ldexp(dx1, dx1, 2);
      eval_sqrt(t1, dx1);
      eval_multiply(result, t1);
      eval_ldexp(t1, get_constant_pi<T>(), -1);
      result.negate();
      eval_add(result, t1);
      if(b_neg)
         result.negate();
      return;
   }

   typedef typename boost::multiprecision::detail::canonical<long double, T>::type guess_type;




   guess_type dd;
   eval_convert_to(&dd, xx);

   result = (guess_type)(std::asin(dd));






   boost::intmax_t current_precision = eval_ilogb(result);
   boost::intmax_t target_precision = current_precision - 1 - (std::numeric_limits<number<T> >::digits * 2) / 3;


   while(current_precision > target_precision)
   {
      T sine, cosine;
      eval_sin(sine, result);
      eval_cos(cosine, result);
      eval_subtract(sine, xx);
      eval_divide(sine, cosine);
      eval_subtract(result, sine);
      current_precision = eval_ilogb(sine);
      if(current_precision <= (std::numeric_limits<typename T::exponent_type>::min)() + 1)
         break;
   }
   if(b_neg)
      result.negate();
}

template <class T>
inline void eval_acos(T& result, const T& x)
{
   static_assert(number_category<T>::value == number_kind_floating_point, "The acos function is only valid for floating point types.");
   typedef typename boost::multiprecision::detail::canonical<boost::uint32_t, T>::type ui_type;

   switch(eval_fpclassify(x))
   {
   case 1:
   case 2:
      if(std::numeric_limits<number<T, et_on> >::has_quiet_NaN)
      {
         result = std::numeric_limits<number<T, et_on> >::quiet_NaN().backend();
         (*__error()) = 33;
      }
      else
         ::boost::exception_detail::throw_exception_(std::domain_error("Result is undefined or complex and there is no NaN for this number type."),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/functions/trig.hpp",572);
      return;
   case 3:
      result = get_constant_pi<T>();
      eval_ldexp(result, result, -1);
      return;
   }

   eval_abs(result, x);
   int c = result.compare(ui_type(1));

   if(c > 0)
   {
      if(std::numeric_limits<number<T, et_on> >::has_quiet_NaN)
      {
         result = std::numeric_limits<number<T, et_on> >::quiet_NaN().backend();
         (*__error()) = 33;
      }
      else
         ::boost::exception_detail::throw_exception_(std::domain_error("Result is undefined or complex and there is no NaN for this number type."),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/functions/trig.hpp",591);
      return;
   }
   else if(c == 0)
   {
      if(eval_get_sign(x) < 0)
         result = get_constant_pi<T>();
      else
         result = ui_type(0);
      return;
   }

   eval_asin(result, x);
   T t;
   eval_ldexp(t, get_constant_pi<T>(), -1);
   eval_subtract(result, t);
   result.negate();
}

template <class T>
void eval_atan(T& result, const T& x)
{
   static_assert(number_category<T>::value == number_kind_floating_point, "The atan function is only valid for floating point types.");
   typedef typename boost::multiprecision::detail::canonical<boost::int32_t, T>::type si_type;
   typedef typename boost::multiprecision::detail::canonical<boost::uint32_t, T>::type ui_type;
   typedef typename mpl::front<typename T::float_types>::type fp_type;

   switch(eval_fpclassify(x))
   {
   case 1:
      result = x;
      (*__error()) = 33;
      return;
   case 3:
      result = x;
      return;
   case 2:
      if(eval_get_sign(x) < 0)
      {
         eval_ldexp(result, get_constant_pi<T>(), -1);
         result.negate();
      }
      else
         eval_ldexp(result, get_constant_pi<T>(), -1);
      return;
   default: ;
   }

   const bool b_neg = eval_get_sign(x) < 0;

   T xx(x);
   if(b_neg)
      xx.negate();

   if(xx.compare(fp_type(0.1)) < 0)
   {
      T t1, t2, t3;
      t1 = ui_type(1);
      t2 = fp_type(0.5f);
      t3 = fp_type(1.5f);
      eval_multiply(xx, xx);
      xx.negate();
      hyp2F1(result, t1, t2, t3, xx);
      eval_multiply(result, x);
      return;
   }

   if(xx.compare(fp_type(10)) > 0)
   {
      T t1, t2, t3;
      t1 = fp_type(0.5f);
      t2 = ui_type(1u);
      t3 = fp_type(1.5f);
      eval_multiply(xx, xx);
      eval_divide(xx, si_type(-1), xx);
      hyp2F1(result, t1, t2, t3, xx);
      eval_divide(result, x);
      if(!b_neg)
         result.negate();
      eval_ldexp(t1, get_constant_pi<T>(), -1);
      eval_add(result, t1);
      if(b_neg)
         result.negate();
      return;
   }



   fp_type d;
   eval_convert_to(&d, xx);
   result = fp_type(std::atan(d));






   boost::intmax_t current_precision = eval_ilogb(result);
   boost::intmax_t target_precision = current_precision - 1 - (std::numeric_limits<number<T> >::digits * 2) / 3;

   T s, c, t;
   while(current_precision > target_precision)
   {
      eval_sin(s, result);
      eval_cos(c, result);
      eval_multiply(t, xx, c);
      eval_subtract(t, s);
      eval_multiply(s, t, c);
      eval_add(result, s);
      current_precision = eval_ilogb(s);
      if(current_precision <= (std::numeric_limits<typename T::exponent_type>::min)() + 1)
         break;
   }
   if(b_neg)
      result.negate();
}

template <class T>
void eval_atan2(T& result, const T& y, const T& x)
{
   static_assert(number_category<T>::value == number_kind_floating_point, "The atan2 function is only valid for floating point types.");
   if(&result == &y)
   {
      T temp(y);
      eval_atan2(result, temp, x);
      return;
   }
   else if(&result == &x)
   {
      T temp(x);
      eval_atan2(result, y, temp);
      return;
   }

   typedef typename boost::multiprecision::detail::canonical<boost::uint32_t, T>::type ui_type;

   switch(eval_fpclassify(y))
   {
   case 1:
      result = y;
      (*__error()) = 33;
      return;
   case 3:
      {
         if(eval_signbit(x))
         {
            result = get_constant_pi<T>();
            if(eval_signbit(y))
               result.negate();
         }
         else
         {
            result = y;
         }
         return;
      }
   case 2:
      {
         if(eval_fpclassify(x) == 2)
         {
            if(eval_signbit(x))
            {

               eval_ldexp(result, get_constant_pi<T>(), -2);
               eval_subtract(result, get_constant_pi<T>());
               if(eval_get_sign(y) >= 0)
                  result.negate();
            }
            else
            {

               eval_ldexp(result, get_constant_pi<T>(), -2);
               if(eval_get_sign(y) < 0)
                  result.negate();
            }
         }
         else
         {
            eval_ldexp(result, get_constant_pi<T>(), -1);
            if(eval_get_sign(y) < 0)
               result.negate();
         }
         return;
      }
   }

   switch(eval_fpclassify(x))
   {
   case 1:
      result = x;
      (*__error()) = 33;
      return;
   case 3:
      {
         eval_ldexp(result, get_constant_pi<T>(), -1);
         if(eval_get_sign(y) < 0)
            result.negate();
         return;
      }
   case 2:
      if(eval_get_sign(x) > 0)
         result = ui_type(0);
      else
         result = get_constant_pi<T>();
      if(eval_get_sign(y) < 0)
         result.negate();
      return;
   }

   T xx;
   eval_divide(xx, y, x);
   if(eval_get_sign(xx) < 0)
      xx.negate();

   eval_atan(result, xx);


   const bool y_neg = eval_get_sign(y) < 0;
   const bool x_neg = eval_get_sign(x) < 0;

   if(y_neg != x_neg)
      result.negate();

   if(x_neg)
   {
      if(y_neg)
         eval_subtract(result, get_constant_pi<T>());
      else
         eval_add(result, get_constant_pi<T>());
   }
}
template<class T, class A>
inline typename enable_if<is_arithmetic<A>, void>::type eval_atan2(T& result, const T& x, const A& a)
{
   typedef typename boost::multiprecision::detail::canonical<A, T>::type canonical_type;
   typedef typename mpl::if_<is_same<A, canonical_type>, T, canonical_type>::type cast_type;
   cast_type c;
   c = a;
   eval_atan2(result, x, c);
}

template<class T, class A>
inline typename enable_if<is_arithmetic<A>, void>::type eval_atan2(T& result, const A& x, const T& a)
{
   typedef typename boost::multiprecision::detail::canonical<A, T>::type canonical_type;
   typedef typename mpl::if_<is_same<A, canonical_type>, T, canonical_type>::type cast_type;
   cast_type c;
   c = x;
   eval_atan2(result, c, a);
}

}




template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
inline int fpclassify (const multiprecision::number<Backend, ExpressionTemplates>& arg)
{
   using multiprecision::default_ops::eval_fpclassify;
   return eval_fpclassify(arg.backend());
}
template <class tag, class A1, class A2, class A3, class A4>
inline int fpclassify (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
{
   typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
   return fpclassify (value_type(arg));
}
template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
inline bool isfinite (const multiprecision::number<Backend, ExpressionTemplates>& arg)
{
   int v = fpclassify (arg);
   return (v != (int)2) && (v != (int)1);
}
template <class tag, class A1, class A2, class A3, class A4>
inline bool isfinite (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
{
   typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
   return isfinite (value_type(arg));
}
template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
inline bool isnan (const multiprecision::number<Backend, ExpressionTemplates>& arg)
{
   return fpclassify (arg) == (int)1;
}
template <class tag, class A1, class A2, class A3, class A4>
inline bool isnan (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
{
   typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
   return isnan (value_type(arg));
}
template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
inline bool isinf (const multiprecision::number<Backend, ExpressionTemplates>& arg)
{
   return fpclassify (arg) == (int)2;
}
template <class tag, class A1, class A2, class A3, class A4>
inline bool isinf (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
{
   typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
   return isinf (value_type(arg));
}
template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
inline bool isnormal (const multiprecision::number<Backend, ExpressionTemplates>& arg)
{
   return fpclassify (arg) == (int)4;
}
template <class tag, class A1, class A2, class A3, class A4>
inline bool isnormal (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
{
   typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
   return isnormal (value_type(arg));
}




template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
inline int sign (const multiprecision::number<Backend, ExpressionTemplates>& arg)
{
   return arg.sign();
}
template <class tag, class A1, class A2, class A3, class A4>
inline int sign (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
{
   typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
   return sign (value_type(arg));
}

template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
inline int signbit (const multiprecision::number<Backend, ExpressionTemplates>& arg)
{
   using default_ops::eval_signbit;
   return eval_signbit(arg.backend());
}
template <class tag, class A1, class A2, class A3, class A4>
inline int signbit (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
{
   typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
   return signbit (value_type(arg));
}
template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
inline multiprecision::number<Backend, ExpressionTemplates> changesign (const multiprecision::number<Backend, ExpressionTemplates>& arg)
{
   return -arg;
}
template <class tag, class A1, class A2, class A3, class A4>
inline typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type changesign (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
{
   typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
   return changesign (value_type(arg));
}
template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
inline multiprecision::number<Backend, ExpressionTemplates> copysign (const multiprecision::number<Backend, ExpressionTemplates>& a, const multiprecision::number<Backend, ExpressionTemplates>& b)
{
   return (boost::multiprecision::signbit)(a) != (boost::multiprecision::signbit)(b) ? (boost::multiprecision::changesign)(a) : a;
}
template <class Backend, multiprecision::expression_template_option ExpressionTemplates, class tag, class A1, class A2, class A3, class A4>
inline multiprecision::number<Backend, ExpressionTemplates> copysign (const multiprecision::number<Backend, ExpressionTemplates>& a, const multiprecision::detail::expression<tag, A1, A2, A3, A4>& b)
{
   return copysign (a, multiprecision::number<Backend, ExpressionTemplates>(b));
}
template <class tag, class A1, class A2, class A3, class A4, class Backend, multiprecision::expression_template_option ExpressionTemplates>
inline multiprecision::number<Backend, ExpressionTemplates> copysign (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& a, const multiprecision::number<Backend, ExpressionTemplates>& b)
{
   return copysign (multiprecision::number<Backend, ExpressionTemplates>(a), b);
}
template <class tag, class A1, class A2, class A3, class A4, class tagb, class A1b, class A2b, class A3b, class A4b>
inline typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type copysign (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& a, const multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>& b)
{
   typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
   return copysign (value_type(a), value_type(b));
}



template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
inline typename scalar_result_from_possible_complex<multiprecision::number<Backend, ExpressionTemplates> >::type
   real(const multiprecision::number<Backend, ExpressionTemplates>& a)
{
   using default_ops::eval_real;
   typedef typename scalar_result_from_possible_complex<multiprecision::number<Backend, ExpressionTemplates> >::type result_type;
   boost::multiprecision::detail::scoped_default_precision<result_type> precision_guard(a);
   result_type result;
   eval_real(result.backend(), a.backend());
   return result;
}
template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
inline typename scalar_result_from_possible_complex<multiprecision::number<Backend, ExpressionTemplates> >::type
   imag(const multiprecision::number<Backend, ExpressionTemplates>& a)
{
   using default_ops::eval_imag;
   typedef typename scalar_result_from_possible_complex<multiprecision::number<Backend, ExpressionTemplates> >::type result_type;
   boost::multiprecision::detail::scoped_default_precision<result_type> precision_guard(a);
   result_type result;
   eval_imag(result.backend(), a.backend());
   return result;
}

template <class tag, class A1, class A2, class A3, class A4>
inline typename scalar_result_from_possible_complex<typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type>::type
   real(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
{
   typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
   detail::scoped_default_precision<value_type> precision_guard(arg);
   return real(value_type(arg));
}

template <class tag, class A1, class A2, class A3, class A4>
inline typename scalar_result_from_possible_complex<typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type>::type
   imag(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
{
   typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
   detail::scoped_default_precision<value_type> precision_guard(arg);
   return imag(value_type(arg));
}





template <class T, expression_template_option ExpressionTemplates>
inline typename boost::lazy_enable_if_c<number_category<T>::value == number_kind_complex, component_type<number<T, ExpressionTemplates> > >::type
   abs(const number<T, ExpressionTemplates>& v)
{
   return std::move(boost::math::hypot(real(v), imag(v)));
}
template <class tag, class A1, class A2, class A3, class A4>
inline typename boost::lazy_enable_if_c<number_category<typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value == number_kind_complex, component_type<typename detail::expression<tag, A1, A2, A3, A4>::result_type> >::type
   abs(const detail::expression<tag, A1, A2, A3, A4>& v)
{
   typedef typename detail::expression<tag, A1, A2, A3, A4>::result_type number_type;
   return std::move(abs(static_cast<number_type>(v)));
}

template <class T, expression_template_option ExpressionTemplates>
inline typename enable_if_c<number_category<T>::value == number_kind_complex, typename scalar_result_from_possible_complex<number<T, ExpressionTemplates> >::type>::type
arg(const number<T, ExpressionTemplates>& v)
{
   return std::move(atan2(imag(v), real(v)));
}
template <class T, expression_template_option ExpressionTemplates>
inline typename enable_if_c<number_category<T>::value == number_kind_floating_point, typename scalar_result_from_possible_complex<number<T, ExpressionTemplates> >::type>::type
arg(const number<T, ExpressionTemplates>&)
{
   return 0;
}
template <class tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<number_category<typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value == number_kind_complex || number_category<typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value == number_kind_floating_point, typename scalar_result_from_possible_complex<typename detail::expression<tag, A1, A2, A3, A4>::result_type>::type>::type
arg(const detail::expression<tag, A1, A2, A3, A4>& v)
{
   typedef typename detail::expression<tag, A1, A2, A3, A4>::result_type number_type;
   return std::move(arg(static_cast<number_type>(v)));
}

template <class T, expression_template_option ExpressionTemplates>
inline typename boost::lazy_enable_if_c<number_category<T>::value == number_kind_complex, component_type<number<T, ExpressionTemplates> > >::type
norm(const number<T, ExpressionTemplates>& v)
{
   typename component_type<number<T, ExpressionTemplates> >::type a(real(v)), b(imag(v));
   return std::move(a * a + b * b);
}
template <class T, expression_template_option ExpressionTemplates>
inline typename boost::enable_if_c<number_category<T>::value != number_kind_complex, typename scalar_result_from_possible_complex<number<T, ExpressionTemplates> >::type >::type
norm(const number<T, ExpressionTemplates>& v)
{
   return v * v;
}
template <class tag, class A1, class A2, class A3, class A4>
inline typename scalar_result_from_possible_complex<typename detail::expression<tag, A1, A2, A3, A4>::result_type>::type
norm(const detail::expression<tag, A1, A2, A3, A4>& v)
{
   typedef typename detail::expression<tag, A1, A2, A3, A4>::result_type number_type;
   return std::move(norm(static_cast<number_type>(v)));
}

template <class Backend, expression_template_option ExpressionTemplates>
typename complex_result_from_scalar<number<Backend, ExpressionTemplates> >::type polar(number<Backend, ExpressionTemplates> const& r, number<Backend, ExpressionTemplates> const& theta)
{
   return typename complex_result_from_scalar<number<Backend, ExpressionTemplates> >::type(number<Backend, ExpressionTemplates>(r * cos(theta)), number<Backend, ExpressionTemplates>(r * sin(theta)));
}

template <class tag, class A1, class A2, class A3, class A4, class Backend, expression_template_option ExpressionTemplates>
typename enable_if_c<boost::is_same<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, ExpressionTemplates> >::value,
   typename complex_result_from_scalar<number<Backend, ExpressionTemplates> >::type>::type
      polar(detail::expression<tag, A1, A2, A3, A4> const& r, number<Backend, ExpressionTemplates> const& theta)
{
   return typename complex_result_from_scalar<number<Backend, ExpressionTemplates> >::type(number<Backend, ExpressionTemplates>(r * cos(theta)), number<Backend, ExpressionTemplates>(r * sin(theta)));
}

template <class Backend, expression_template_option ExpressionTemplates, class tag, class A1, class A2, class A3, class A4>
typename enable_if_c<boost::is_same<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, ExpressionTemplates> >::value,
   typename complex_result_from_scalar<number<Backend, ExpressionTemplates> >::type>::type
      polar(number<Backend, ExpressionTemplates> const& r, detail::expression<tag, A1, A2, A3, A4> const& theta)
{
   return typename complex_result_from_scalar<number<Backend, ExpressionTemplates> >::type(number<Backend, ExpressionTemplates>(r * cos(theta)), number<Backend, ExpressionTemplates>(r * sin(theta)));
}

template <class tag, class A1, class A2, class A3, class A4, class tagb, class A1b, class A2b, class A3b, class A4b>
typename enable_if_c<boost::is_same<typename detail::expression<tag, A1, A2, A3, A4>::result_type, typename detail::expression<tagb, A1b, A2b, A3b, A4b>::result_type >::value,
   typename complex_result_from_scalar<typename detail::expression<tag, A1, A2, A3, A4>::result_type >::type>::type
      polar(detail::expression<tag, A1, A2, A3, A4> const& r, detail::expression<tagb, A1b, A2b, A3b, A4b> const& theta)
{
   typedef typename detail::expression<tag, A1, A2, A3, A4>::result_type scalar_type;
   return typename complex_result_from_scalar<scalar_type>::type(scalar_type(r * cos(theta)), scalar_type(r * sin(theta)));
}



template <class Scalar, class Backend, expression_template_option ExpressionTemplates>
typename boost::enable_if_c<boost::is_arithmetic<Scalar>::value, typename complex_result_from_scalar<number<Backend, ExpressionTemplates> >::type>::type
   polar(Scalar const& r, number<Backend, ExpressionTemplates> const& theta)
{
   return typename complex_result_from_scalar<number<Backend, ExpressionTemplates> >::type(number<Backend, ExpressionTemplates>(r * cos(theta)), number<Backend, ExpressionTemplates>(r * sin(theta)));
}

template <class tag, class A1, class A2, class A3, class A4, class Scalar>
typename enable_if_c<boost::is_arithmetic<Scalar>::value,
   typename complex_result_from_scalar<typename detail::expression<tag, A1, A2, A3, A4>::result_type>::type>::type
   polar(Scalar const& r, detail::expression<tag, A1, A2, A3, A4> const& theta)
{
   typedef typename detail::expression<tag, A1, A2, A3, A4>::result_type scalar_type;
   return typename complex_result_from_scalar<scalar_type>::type(scalar_type(r * cos(theta)), scalar_type(r * sin(theta)));
}



template <class Backend, expression_template_option ExpressionTemplates>
typename complex_result_from_scalar<number<Backend, ExpressionTemplates> >::type polar(number<Backend, ExpressionTemplates> const& r)
{
   return typename complex_result_from_scalar<number<Backend, ExpressionTemplates> >::type(r);
}

template <class tag, class A1, class A2, class A3, class A4>
typename complex_result_from_scalar<typename detail::expression<tag, A1, A2, A3, A4>::result_type>::type
   polar(detail::expression<tag, A1, A2, A3, A4> const& r)
{
   return typename complex_result_from_scalar<typename detail::expression<tag, A1, A2, A3, A4>::result_type>::type(r);
}



}

namespace math {




   using boost::multiprecision::signbit;
   using boost::multiprecision::sign;
   using boost::multiprecision::copysign;
   using boost::multiprecision::changesign;
   using boost::multiprecision::fpclassify;
   using boost::multiprecision::isinf;
   using boost::multiprecision::isnan;
   using boost::multiprecision::isnormal;
   using boost::multiprecision::isfinite;

}

namespace multiprecision{

   typedef ::boost::math::policies::policy<
      ::boost::math::policies::domain_error< ::boost::math::policies::errno_on_error>,
      ::boost::math::policies::pole_error< ::boost::math::policies::errno_on_error>,
      ::boost::math::policies::overflow_error< ::boost::math::policies::errno_on_error>,
      ::boost::math::policies::evaluation_error< ::boost::math::policies::errno_on_error>,
      ::boost::math::policies::rounding_error< ::boost::math::policies::errno_on_error>
   > c99_error_policy;

   template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
   inline typename boost::enable_if_c<number_category<Backend>::value != number_kind_complex, multiprecision::number<Backend, ExpressionTemplates> >::type
      asinh (const multiprecision::number<Backend, ExpressionTemplates>& arg)
   {
      detail::scoped_default_precision<multiprecision::number<Backend, ExpressionTemplates> > precision_guard(arg);
      return boost::math::asinh(arg, c99_error_policy());
   }
   template <class tag, class A1, class A2, class A3, class A4>
   inline typename boost::enable_if_c<number_category<typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type>::value != number_kind_complex, typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type>::type
         asinh (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
   {
      typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
      detail::scoped_default_precision<value_type > precision_guard(arg);
      return asinh(value_type(arg));
   }
   template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
   inline typename boost::enable_if_c<number_category<Backend>::value != number_kind_complex, multiprecision::number<Backend, ExpressionTemplates> >::type
      acosh (const multiprecision::number<Backend, ExpressionTemplates>& arg)
   {
      detail::scoped_default_precision<multiprecision::number<Backend, ExpressionTemplates> > precision_guard(arg);
      return boost::math::acosh(arg, c99_error_policy());
   }
   template <class tag, class A1, class A2, class A3, class A4>
   inline typename boost::enable_if_c<number_category<typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type>::value != number_kind_complex, typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type>::type
      acosh (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
   {
      typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
      detail::scoped_default_precision<value_type > precision_guard(arg);
      return acosh(value_type(arg));
   }
   template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
   inline typename boost::enable_if_c<number_category<Backend>::value != number_kind_complex, multiprecision::number<Backend, ExpressionTemplates> >::type
      atanh (const multiprecision::number<Backend, ExpressionTemplates>& arg)
   {
      detail::scoped_default_precision<multiprecision::number<Backend, ExpressionTemplates> > precision_guard(arg);
      return boost::math::atanh(arg, c99_error_policy());
   }
   template <class tag, class A1, class A2, class A3, class A4>
   inline typename boost::enable_if_c<number_category<typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type>::value != number_kind_complex, typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type>::type
      atanh (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
   {
      typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
      detail::scoped_default_precision<value_type > precision_guard(arg);
      return atanh(value_type(arg));
   }
   template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
   inline multiprecision::number<Backend, ExpressionTemplates> cbrt (const multiprecision::number<Backend, ExpressionTemplates>& arg)
   {
      detail::scoped_default_precision<multiprecision::number<Backend, ExpressionTemplates> > precision_guard(arg);
      return boost::math::cbrt(arg, c99_error_policy());
   }
   template <class tag, class A1, class A2, class A3, class A4>
   inline typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type cbrt (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
   {
      typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
      detail::scoped_default_precision<value_type> precision_guard(arg);
      return cbrt(value_type(arg));
   }
   template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
   inline multiprecision::number<Backend, ExpressionTemplates> erf (const multiprecision::number<Backend, ExpressionTemplates>& arg)
   {
      detail::scoped_default_precision<multiprecision::number<Backend, ExpressionTemplates> > precision_guard(arg);
      return boost::math::erf(arg, c99_error_policy());
   }
   template <class tag, class A1, class A2, class A3, class A4>
   inline typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type erf (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
   {
      typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
      detail::scoped_default_precision<value_type> precision_guard(arg);
      return erf(value_type(arg));
   }
   template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
   inline multiprecision::number<Backend, ExpressionTemplates> erfc (const multiprecision::number<Backend, ExpressionTemplates>& arg)
   {
      detail::scoped_default_precision<multiprecision::number<Backend, ExpressionTemplates> > precision_guard(arg);
      return boost::math::erfc(arg, c99_error_policy());
   }
   template <class tag, class A1, class A2, class A3, class A4>
   inline typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type erfc (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
   {
      typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
      detail::scoped_default_precision<value_type> precision_guard(arg);
      return erfc(value_type(arg));
   }
   template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
   inline multiprecision::number<Backend, ExpressionTemplates> expm1 (const multiprecision::number<Backend, ExpressionTemplates>& arg)
   {
      detail::scoped_default_precision<multiprecision::number<Backend, ExpressionTemplates> > precision_guard(arg);
      return boost::math::expm1(arg, c99_error_policy());
   }
   template <class tag, class A1, class A2, class A3, class A4>
   inline typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type expm1 (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
   {
      typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
      detail::scoped_default_precision<value_type> precision_guard(arg);
      return expm1(value_type(arg));
   }
   template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
   inline multiprecision::number<Backend, ExpressionTemplates> lgamma (const multiprecision::number<Backend, ExpressionTemplates>& arg)
   {
      detail::scoped_default_precision<multiprecision::number<Backend, ExpressionTemplates> > precision_guard(arg);
      multiprecision::number<Backend, ExpressionTemplates> result;
      result = boost::math::lgamma(arg, c99_error_policy());
      if((boost::multiprecision::isnan)(result) && !(boost::multiprecision::isnan)(arg))
      {
         result = std::numeric_limits<multiprecision::number<Backend, ExpressionTemplates> >::infinity();
         (*__error()) = 34;
      }
      return result;
   }
   template <class tag, class A1, class A2, class A3, class A4>
   inline typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type lgamma (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
   {
      typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
      detail::scoped_default_precision<value_type> precision_guard(arg);
      return lgamma(value_type(arg));
   }
   template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
   inline multiprecision::number<Backend, ExpressionTemplates> tgamma (const multiprecision::number<Backend, ExpressionTemplates>& arg)
   {
      detail::scoped_default_precision<multiprecision::number<Backend, ExpressionTemplates> > precision_guard(arg);
      if((arg == 0) && std::numeric_limits<multiprecision::number<Backend, ExpressionTemplates> >::has_infinity)
      {
         (*__error()) = 34;
         return 1 / arg;
      }
      return boost::math::tgamma(arg, c99_error_policy());
   }
   template <class tag, class A1, class A2, class A3, class A4>
   inline typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type tgamma (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
   {
      typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
      detail::scoped_default_precision<value_type> precision_guard(arg);
      return tgamma(value_type(arg));
   }

   template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
   inline long lrint (const multiprecision::number<Backend, ExpressionTemplates>& arg)
   {
      return lround(arg);
   }
   template <class tag, class A1, class A2, class A3, class A4>
   inline long lrint (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
   {
      return lround(arg);
   }

   template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
   inline boost::long_long_type llrint (const multiprecision::number<Backend, ExpressionTemplates>& arg)
   {
      return llround(arg);
   }
   template <class tag, class A1, class A2, class A3, class A4>
   inline boost::long_long_type llrint (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
   {
      return llround(arg);
   }

   template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
   inline multiprecision::number<Backend, ExpressionTemplates> log1p (const multiprecision::number<Backend, ExpressionTemplates>& arg)
   {
      detail::scoped_default_precision<multiprecision::number<Backend, ExpressionTemplates> > precision_guard(arg);
      return boost::math::log1p(arg, c99_error_policy());
   }
   template <class tag, class A1, class A2, class A3, class A4>
   inline typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type log1p (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
   {
      typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
      detail::scoped_default_precision<value_type> precision_guard(arg);
      return log1p(value_type(arg));
   }

   template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
   inline multiprecision::number<Backend, ExpressionTemplates> nextafter (const multiprecision::number<Backend, ExpressionTemplates>& a, const multiprecision::number<Backend, ExpressionTemplates>& b)
   {
      detail::scoped_default_precision<multiprecision::number<Backend, ExpressionTemplates> > precision_guard(a, b);
      return boost::math::nextafter(a, b, c99_error_policy());
   }
   template <class Backend, multiprecision::expression_template_option ExpressionTemplates, class tag, class A1, class A2, class A3, class A4>
   inline multiprecision::number<Backend, ExpressionTemplates> nextafter (const multiprecision::number<Backend, ExpressionTemplates>& a, const multiprecision::detail::expression<tag, A1, A2, A3, A4>& b)
   {
      detail::scoped_default_precision<multiprecision::number<Backend, ExpressionTemplates> > precision_guard(a, b);
      return nextafter (a, multiprecision::number<Backend, ExpressionTemplates>(b));
   }
   template <class tag, class A1, class A2, class A3, class A4, class Backend, multiprecision::expression_template_option ExpressionTemplates>
   inline multiprecision::number<Backend, ExpressionTemplates> nextafter (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& a, const multiprecision::number<Backend, ExpressionTemplates>& b)
   {
      detail::scoped_default_precision<multiprecision::number<Backend, ExpressionTemplates> > precision_guard(a, b);
      return nextafter (multiprecision::number<Backend, ExpressionTemplates>(a), b);
   }
   template <class tag, class A1, class A2, class A3, class A4, class tagb, class A1b, class A2b, class A3b, class A4b>
   inline typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type nextafter (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& a, const multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>& b)
   {
      typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
      detail::scoped_default_precision<value_type> precision_guard(a, b);
      return nextafter (value_type(a), value_type(b));
   }
   template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
   inline multiprecision::number<Backend, ExpressionTemplates> nexttoward (const multiprecision::number<Backend, ExpressionTemplates>& a, const multiprecision::number<Backend, ExpressionTemplates>& b)
   {
      detail::scoped_default_precision<multiprecision::number<Backend, ExpressionTemplates> > precision_guard(a, b);
      return boost::math::nextafter(a, b, c99_error_policy());
   }
   template <class Backend, multiprecision::expression_template_option ExpressionTemplates, class tag, class A1, class A2, class A3, class A4>
   inline multiprecision::number<Backend, ExpressionTemplates> nexttoward (const multiprecision::number<Backend, ExpressionTemplates>& a, const multiprecision::detail::expression<tag, A1, A2, A3, A4>& b)
   {
      detail::scoped_default_precision<multiprecision::number<Backend, ExpressionTemplates> > precision_guard(a, b);
      return nexttoward (a, multiprecision::number<Backend, ExpressionTemplates>(b));
   }
   template <class tag, class A1, class A2, class A3, class A4, class Backend, multiprecision::expression_template_option ExpressionTemplates>
   inline multiprecision::number<Backend, ExpressionTemplates> nexttoward (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& a, const multiprecision::number<Backend, ExpressionTemplates>& b)
   {
      detail::scoped_default_precision<multiprecision::number<Backend, ExpressionTemplates> > precision_guard(a, b);
      return nexttoward (multiprecision::number<Backend, ExpressionTemplates>(a), b);
   }
   template <class tag, class A1, class A2, class A3, class A4, class tagb, class A1b, class A2b, class A3b, class A4b>
   inline typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type nexttoward (const multiprecision::detail::expression<tag, A1, A2, A3, A4>& a, const multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>& b)
   {
      typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type value_type;
      detail::scoped_default_precision<value_type> precision_guard(a, b);
      return nexttoward (value_type(a), value_type(b));
   }

template <class B1, class B2, class B3, expression_template_option ET1, expression_template_option ET2, expression_template_option ET3>
inline number<B1, ET1>& add(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)
{
   static_assert((is_convertible<B2, B1>::value), "No conversion to the target of a mixed precision addition exists");
   static_assert((is_convertible<B3, B1>::value), "No conversion to the target of a mixed precision addition exists");
   using default_ops::eval_add;
   eval_add(result.backend(), a.backend(), b.backend());
   return result;
}

template <class B1, class B2, class B3, expression_template_option ET1, expression_template_option ET2, expression_template_option ET3>
inline number<B1, ET1>& subtract(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)
{
   static_assert((is_convertible<B2, B1>::value), "No conversion to the target of a mixed precision addition exists");
   static_assert((is_convertible<B3, B1>::value), "No conversion to the target of a mixed precision addition exists");
   using default_ops::eval_subtract;
   eval_subtract(result.backend(), a.backend(), b.backend());
   return result;
}

template <class B1, class B2, class B3, expression_template_option ET1, expression_template_option ET2, expression_template_option ET3>
inline number<B1, ET1>& multiply(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)
{
   static_assert((is_convertible<B2, B1>::value), "No conversion to the target of a mixed precision addition exists");
   static_assert((is_convertible<B3, B1>::value), "No conversion to the target of a mixed precision addition exists");
   using default_ops::eval_multiply;
   eval_multiply(result.backend(), a.backend(), b.backend());
   return result;
}

template <class B, expression_template_option ET, class I>
inline typename enable_if_c<is_integral<I>::value, number<B, ET>&>::type
   add(number<B, ET>& result, const I& a, const I& b)
{
   using default_ops::eval_add;
   typedef typename detail::canonical<I, B>::type canonical_type;
   eval_add(result.backend(), static_cast<canonical_type>(a), static_cast<canonical_type>(b));
   return result;
}

template <class B, expression_template_option ET, class I>
inline typename enable_if_c<is_integral<I>::value, number<B, ET>&>::type
   subtract(number<B, ET>& result, const I& a, const I& b)
{
   using default_ops::eval_subtract;
   typedef typename detail::canonical<I, B>::type canonical_type;
   eval_subtract(result.backend(), static_cast<canonical_type>(a), static_cast<canonical_type>(b));
   return result;
}

template <class B, expression_template_option ET, class I>
inline typename enable_if_c<is_integral<I>::value, number<B, ET>&>::type
   multiply(number<B, ET>& result, const I& a, const I& b)
{
   using default_ops::eval_multiply;
   typedef typename detail::canonical<I, B>::type canonical_type;
   eval_multiply(result.backend(), static_cast<canonical_type>(a), static_cast<canonical_type>(b));
   return result;
}

template <class tag, class A1, class A2, class A3, class A4, class Policy>
inline typename detail::expression<tag, A1, A2, A3, A4>::result_type trunc(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
{
   typedef typename detail::expression<tag, A1, A2, A3, A4>::result_type number_type;
   return std::move(trunc(number_type(v), pol));
}

template <class Backend, expression_template_option ExpressionTemplates, class Policy>
inline number<Backend, ExpressionTemplates> trunc(const number<Backend, ExpressionTemplates>& v, const Policy&)
{
   using default_ops::eval_trunc;
   detail::scoped_default_precision<multiprecision::number<Backend, ExpressionTemplates> > precision_guard(v);
   number<Backend, ExpressionTemplates> result;
   eval_trunc(result.backend(), v.backend());
   return std::move(result);
}

template <class tag, class A1, class A2, class A3, class A4, class Policy>
inline int itrunc(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
{
   typedef typename detail::expression<tag, A1, A2, A3, A4>::result_type number_type;
   number_type r(trunc(v, pol));
   if((r > (std::numeric_limits<int>::max)()) || r < (std::numeric_limits<int>::min)() || !(boost::math::isfinite)(v))
      return boost::math::policies::raise_rounding_error("boost::multiprecision::itrunc<%1%>(%1%)", 0, number_type(v), 0, pol);
   return r.template convert_to<int>();
}
template <class tag, class A1, class A2, class A3, class A4>
inline int itrunc(const detail::expression<tag, A1, A2, A3, A4>& v)
{
   return itrunc(v, boost::math::policies::policy<>());
}
template <class Backend, expression_template_option ExpressionTemplates, class Policy>
inline int itrunc(const number<Backend, ExpressionTemplates>& v, const Policy& pol)
{
   number<Backend, ExpressionTemplates> r(trunc(v, pol));
   if((r > (std::numeric_limits<int>::max)()) || r < (std::numeric_limits<int>::min)() || !(boost::math::isfinite)(v))
      return boost::math::policies::raise_rounding_error("boost::multiprecision::itrunc<%1%>(%1%)", 0, v, 0, pol);
   return r.template convert_to<int>();
}
template <class Backend, expression_template_option ExpressionTemplates>
inline int itrunc(const number<Backend, ExpressionTemplates>& v)
{
   return itrunc(v, boost::math::policies::policy<>());
}
template <class tag, class A1, class A2, class A3, class A4, class Policy>
inline long ltrunc(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
{
   typedef typename detail::expression<tag, A1, A2, A3, A4>::result_type number_type;
   number_type r(trunc(v, pol));
   if((r > (std::numeric_limits<long>::max)()) || r < (std::numeric_limits<long>::min)() || !(boost::math::isfinite)(v))
      return boost::math::policies::raise_rounding_error("boost::multiprecision::ltrunc<%1%>(%1%)", 0, number_type(v), 0L, pol);
   return r.template convert_to<long>();
}
template <class tag, class A1, class A2, class A3, class A4>
inline long ltrunc(const detail::expression<tag, A1, A2, A3, A4>& v)
{
   return ltrunc(v, boost::math::policies::policy<>());
}
template <class T, expression_template_option ExpressionTemplates, class Policy>
inline long ltrunc(const number<T, ExpressionTemplates>& v, const Policy& pol)
{
   number<T, ExpressionTemplates> r(trunc(v, pol));
   if((r > (std::numeric_limits<long>::max)()) || r < (std::numeric_limits<long>::min)() || !(boost::math::isfinite)(v))
      return boost::math::policies::raise_rounding_error("boost::multiprecision::ltrunc<%1%>(%1%)", 0, v, 0L, pol);
   return r.template convert_to<long>();
}
template <class T, expression_template_option ExpressionTemplates>
inline long ltrunc(const number<T, ExpressionTemplates>& v)
{
   return ltrunc(v, boost::math::policies::policy<>());
}

template <class tag, class A1, class A2, class A3, class A4, class Policy>
inline boost::long_long_type lltrunc(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
{
   typedef typename detail::expression<tag, A1, A2, A3, A4>::result_type number_type;
   number_type r(trunc(v, pol));
   if((r > (std::numeric_limits<boost::long_long_type>::max)()) || r < (std::numeric_limits<boost::long_long_type>::min)() || !(boost::math::isfinite)(v))
      return boost::math::policies::raise_rounding_error("boost::multiprecision::lltrunc<%1%>(%1%)", 0, number_type(v), 0LL, pol);
   return r.template convert_to<boost::long_long_type>();
}
template <class tag, class A1, class A2, class A3, class A4>
inline boost::long_long_type lltrunc(const detail::expression<tag, A1, A2, A3, A4>& v)
{
   return lltrunc(v, boost::math::policies::policy<>());
}
template <class T, expression_template_option ExpressionTemplates, class Policy>
inline boost::long_long_type lltrunc(const number<T, ExpressionTemplates>& v, const Policy& pol)
{
   number<T, ExpressionTemplates> r(trunc(v, pol));
   if((r > (std::numeric_limits<boost::long_long_type>::max)()) || r < (std::numeric_limits<boost::long_long_type>::min)() || !(boost::math::isfinite)(v))
      return boost::math::policies::raise_rounding_error("boost::multiprecision::lltrunc<%1%>(%1%)", 0, v, 0LL, pol);
   return r.template convert_to<boost::long_long_type>();
}
template <class T, expression_template_option ExpressionTemplates>
inline boost::long_long_type lltrunc(const number<T, ExpressionTemplates>& v)
{
   return lltrunc(v, boost::math::policies::policy<>());
}

template <class tag, class A1, class A2, class A3, class A4, class Policy>
inline typename detail::expression<tag, A1, A2, A3, A4>::result_type round(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
{
   typedef typename detail::expression<tag, A1, A2, A3, A4>::result_type number_type;
   return std::move(round(static_cast<number_type>(v), pol));
}
template <class T, expression_template_option ExpressionTemplates, class Policy>
inline number<T, ExpressionTemplates> round(const number<T, ExpressionTemplates>& v, const Policy&)
{
   using default_ops::eval_round;
   detail::scoped_default_precision<multiprecision::number<T, ExpressionTemplates> > precision_guard(v);
   number<T, ExpressionTemplates> result;
   eval_round(result.backend(), v.backend());
   return std::move(result);
}

template <class tag, class A1, class A2, class A3, class A4, class Policy>
inline int iround(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
{
   typedef typename detail::expression<tag, A1, A2, A3, A4>::result_type number_type;
   number_type r(round(v, pol));
   if((r > (std::numeric_limits<int>::max)()) || r < (std::numeric_limits<int>::min)() || !(boost::math::isfinite)(v))
      return boost::math::policies::raise_rounding_error("boost::multiprecision::iround<%1%>(%1%)", 0, number_type(v), 0, pol);
   return r.template convert_to<int>();
}
template <class tag, class A1, class A2, class A3, class A4>
inline int iround(const detail::expression<tag, A1, A2, A3, A4>& v)
{
   return iround(v, boost::math::policies::policy<>());
}
template <class T, expression_template_option ExpressionTemplates, class Policy>
inline int iround(const number<T, ExpressionTemplates>& v, const Policy& pol)
{
   number<T, ExpressionTemplates> r(round(v, pol));
   if((r > (std::numeric_limits<int>::max)()) || r < (std::numeric_limits<int>::min)() || !(boost::math::isfinite)(v))
      return boost::math::policies::raise_rounding_error("boost::multiprecision::iround<%1%>(%1%)", 0, v, 0, pol);
   return r.template convert_to<int>();
}
template <class T, expression_template_option ExpressionTemplates>
inline int iround(const number<T, ExpressionTemplates>& v)
{
   return iround(v, boost::math::policies::policy<>());
}
template <class tag, class A1, class A2, class A3, class A4, class Policy>
inline long lround(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
{
   typedef typename detail::expression<tag, A1, A2, A3, A4>::result_type number_type;
   number_type r(round(v, pol));
   if((r > (std::numeric_limits<long>::max)()) || r < (std::numeric_limits<long>::min)() || !(boost::math::isfinite)(v))
      return boost::math::policies::raise_rounding_error("boost::multiprecision::lround<%1%>(%1%)", 0, number_type(v), 0L, pol);
   return r.template convert_to<long>();
}
template <class tag, class A1, class A2, class A3, class A4>
inline long lround(const detail::expression<tag, A1, A2, A3, A4>& v)
{
   return lround(v, boost::math::policies::policy<>());
}
template <class T, expression_template_option ExpressionTemplates, class Policy>
inline long lround(const number<T, ExpressionTemplates>& v, const Policy& pol)
{
   number<T, ExpressionTemplates> r(round(v, pol));
   if((r > (std::numeric_limits<long>::max)()) || r < (std::numeric_limits<long>::min)() || !(boost::math::isfinite)(v))
      return boost::math::policies::raise_rounding_error("boost::multiprecision::lround<%1%>(%1%)", 0, v, 0L, pol);
   return r.template convert_to<long>();
}
template <class T, expression_template_option ExpressionTemplates>
inline long lround(const number<T, ExpressionTemplates>& v)
{
   return lround(v, boost::math::policies::policy<>());
}

template <class tag, class A1, class A2, class A3, class A4, class Policy>
inline boost::long_long_type llround(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
{
   typedef typename detail::expression<tag, A1, A2, A3, A4>::result_type number_type;
   number_type r(round(v, pol));
   if((r > (std::numeric_limits<boost::long_long_type>::max)()) || r < (std::numeric_limits<boost::long_long_type>::min)() || !(boost::math::isfinite)(v))
      return boost::math::policies::raise_rounding_error("boost::multiprecision::iround<%1%>(%1%)", 0, number_type(v), 0LL, pol);
   return r.template convert_to<boost::long_long_type>();
}
template <class tag, class A1, class A2, class A3, class A4>
inline boost::long_long_type llround(const detail::expression<tag, A1, A2, A3, A4>& v)
{
   return llround(v, boost::math::policies::policy<>());
}
template <class T, expression_template_option ExpressionTemplates, class Policy>
inline boost::long_long_type llround(const number<T, ExpressionTemplates>& v, const Policy& pol)
{
   number<T, ExpressionTemplates> r(round(v, pol));
   if((r > (std::numeric_limits<boost::long_long_type>::max)()) || r < (std::numeric_limits<boost::long_long_type>::min)() || !(boost::math::isfinite)(v))
      return boost::math::policies::raise_rounding_error("boost::multiprecision::iround<%1%>(%1%)", 0, v, 0LL, pol);
   return r.template convert_to<boost::long_long_type>();
}
template <class T, expression_template_option ExpressionTemplates>
inline boost::long_long_type llround(const number<T, ExpressionTemplates>& v)
{
   return llround(v, boost::math::policies::policy<>());
}






template <class T, expression_template_option ExpressionTemplates>
inline typename enable_if_c<number_category<T>::value == number_kind_floating_point, number<T, ExpressionTemplates> >::type frexp(const number<T, ExpressionTemplates>& v, short* pint)
{
   using default_ops::eval_frexp;
   detail::scoped_default_precision<multiprecision::number<T, ExpressionTemplates> > precision_guard(v);
   number<T, ExpressionTemplates> result;
   eval_frexp(result.backend(), v.backend(), pint);
   return std::move(result);
}
template <class tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<number_category<typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value == number_kind_floating_point, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::type
   frexp(const detail::expression<tag, A1, A2, A3, A4>& v, short* pint)
{
   typedef typename detail::expression<tag, A1, A2, A3, A4>::result_type number_type;
   return std::move(frexp(static_cast<number_type>(v), pint));
}
template <class T, expression_template_option ExpressionTemplates>
inline typename enable_if_c<number_category<T>::value == number_kind_floating_point, number<T, ExpressionTemplates> >::type frexp(const number<T, ExpressionTemplates>& v, int* pint)
{
   using default_ops::eval_frexp;
   detail::scoped_default_precision<multiprecision::number<T, ExpressionTemplates> > precision_guard(v);
   number<T, ExpressionTemplates> result;
   eval_frexp(result.backend(), v.backend(), pint);
   return std::move(result);
}
template <class tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<number_category<typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value == number_kind_floating_point, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::type
frexp(const detail::expression<tag, A1, A2, A3, A4>& v, int* pint)
{
   typedef typename detail::expression<tag, A1, A2, A3, A4>::result_type number_type;
   return std::move(frexp(static_cast<number_type>(v), pint));
}
template <class T, expression_template_option ExpressionTemplates>
inline typename enable_if_c<number_category<T>::value == number_kind_floating_point, number<T, ExpressionTemplates> >::type frexp(const number<T, ExpressionTemplates>& v, long* pint)
{
   using default_ops::eval_frexp;
   detail::scoped_default_precision<multiprecision::number<T, ExpressionTemplates> > precision_guard(v);
   number<T, ExpressionTemplates> result;
   eval_frexp(result.backend(), v.backend(), pint);
   return std::move(result);
}
template <class tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<number_category<typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value == number_kind_floating_point, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::type
frexp(const detail::expression<tag, A1, A2, A3, A4>& v, long* pint)
{
   typedef typename detail::expression<tag, A1, A2, A3, A4>::result_type number_type;
   return std::move(frexp(static_cast<number_type>(v), pint));
}
template <class T, expression_template_option ExpressionTemplates>
inline typename enable_if_c<number_category<T>::value == number_kind_floating_point, number<T, ExpressionTemplates> >::type frexp(const number<T, ExpressionTemplates>& v, boost::long_long_type* pint)
{
   using default_ops::eval_frexp;
   detail::scoped_default_precision<multiprecision::number<T, ExpressionTemplates> > precision_guard(v);
   number<T, ExpressionTemplates> result;
   eval_frexp(result.backend(), v.backend(), pint);
   return std::move(result);
}
template <class tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<number_category<typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value == number_kind_floating_point, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::type
frexp(const detail::expression<tag, A1, A2, A3, A4>& v, boost::long_long_type* pint)
{
   typedef typename detail::expression<tag, A1, A2, A3, A4>::result_type number_type;
   return std::move(frexp(static_cast<number_type>(v), pint));
}





template <class T, expression_template_option ExpressionTemplates>
inline typename enable_if_c<number_category<T>::value == number_kind_floating_point, number<T, ExpressionTemplates> >::type modf(const number<T, ExpressionTemplates>& v, number<T, ExpressionTemplates>* pipart)
{
   using default_ops::eval_modf;
   detail::scoped_default_precision<multiprecision::number<T, ExpressionTemplates> > precision_guard(v);
   number<T, ExpressionTemplates> result;
   eval_modf(result.backend(), v.backend(), pipart ? &pipart->backend() : 0);
   return std::move(result);
}
template <class T, expression_template_option ExpressionTemplates, class tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<number_category<T>::value == number_kind_floating_point, number<T, ExpressionTemplates> >::type modf(const detail::expression<tag, A1, A2, A3, A4>& v, number<T, ExpressionTemplates>* pipart)
{
   using default_ops::eval_modf;
   detail::scoped_default_precision<multiprecision::number<T, ExpressionTemplates> > precision_guard(v);
   number<T, ExpressionTemplates> result, arg(v);
   eval_modf(result.backend(), arg.backend(), pipart ? &pipart->backend() : 0);
   return std::move(result);
}




template <class B, expression_template_option ExpressionTemplates>
inline typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, ExpressionTemplates> >::type
   sqrt(const number<B, ExpressionTemplates>& x)
{
   using default_ops::eval_integer_sqrt;
   number<B, ExpressionTemplates> s, r;
   eval_integer_sqrt(s.backend(), r.backend(), x.backend());
   return s;
}




namespace default_ops {

   struct fma_func
   {
      template <class B, class T, class U, class V>
      void operator()(B& result, const T& a, const U& b, const V& c)const
      {
         eval_multiply_add(result, a, b, c);
      }
   };


}

template <class Backend, class U, class V>
inline typename enable_if<
   mpl::and_<
      mpl::bool_<number_category<number<Backend, et_on> >::value == number_kind_floating_point>,
      mpl::or_<
         is_number<U>,
         is_number_expression<U>,
         is_arithmetic<U>
      >,
      mpl::or_<
         is_number<V>,
         is_number_expression<V>,
         is_arithmetic<V>
      >
   >,
   detail::expression<detail::function, default_ops::fma_func, number<Backend, et_on>, U, V>
>::type
fma(const number<Backend, et_on>& a, const U& b, const V& c)
{
   return detail::expression<detail::function, default_ops::fma_func, number<Backend, et_on>, U, V>(
      default_ops::fma_func(), a, b, c);
}

template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class U, class V>
inline typename enable_if<
   mpl::and_<
   mpl::bool_<number_category<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type >::value == number_kind_floating_point>,
   mpl::or_<
   is_number<U>,
   is_number_expression<U>,
   is_arithmetic<U>
   >,
   mpl::or_<
   is_number<V>,
   is_number_expression<V>,
   is_arithmetic<V>
   >
   >,
   detail::expression<detail::function, default_ops::fma_func, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, U, V>
>::type
fma(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const U& b, const V& c)
{
   return detail::expression<detail::function, default_ops::fma_func, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, U, V>(
      default_ops::fma_func(), a, b, c);
}

template <class Backend, class U, class V>
inline typename enable_if<
   mpl::and_<
   mpl::bool_<number_category<number<Backend, et_off> >::value == number_kind_floating_point>,
   mpl::or_<
   is_number<U>,
   is_number_expression<U>,
   is_arithmetic<U>
   >,
   mpl::or_<
   is_number<V>,
   is_number_expression<V>,
   is_arithmetic<V>
   >
   >,
   number<Backend, et_off>
>::type
fma(const number<Backend, et_off>& a, const U& b, const V& c)
{
   using default_ops::eval_multiply_add;
   detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(a, b, c);
   number<Backend, et_off> result;
   eval_multiply_add(result.backend(), number<Backend, et_off>::canonical_value(a), number<Backend, et_off>::canonical_value(b), number<Backend, et_off>::canonical_value(c));
   return std::move(result);
}

template <class U, class Backend, class V>
inline typename enable_if<
   mpl::and_<
      mpl::bool_<number_category<number<Backend, et_on> >::value == number_kind_floating_point>,
      is_arithmetic<U>,
      mpl::or_<
         is_number<V>,
         is_number_expression<V>,
         is_arithmetic<V>
      >
   >,
   detail::expression<detail::function, default_ops::fma_func, U, number<Backend, et_on>, V>
>::type
fma(const U& a, const number<Backend, et_on>& b, const V& c)
{
   return detail::expression<detail::function, default_ops::fma_func, U, number<Backend, et_on>, V>(
      default_ops::fma_func(), a, b, c);
}

template <class U, class tag, class Arg1, class Arg2, class Arg3, class Arg4, class V>
inline typename enable_if<
   mpl::and_<
      mpl::bool_<number_category<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type >::value == number_kind_floating_point>,
      is_arithmetic<U>,
      mpl::or_<
         is_number<V>,
         is_number_expression<V>,
         is_arithmetic<V>
      >
   >,
   detail::expression<detail::function, default_ops::fma_func, U, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V>
>::type
fma(const U& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b, const V& c)
{
   return detail::expression<detail::function, default_ops::fma_func, U, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V>(
      default_ops::fma_func(), a, b, c);
}

template <class U, class Backend, class V>
inline typename enable_if<
   mpl::and_<
      mpl::bool_<number_category<number<Backend, et_off> >::value == number_kind_floating_point>,
      is_arithmetic<U>,
      mpl::or_<
         is_number<V>,
         is_number_expression<V>,
         is_arithmetic<V>
      >
   >,
   number<Backend, et_off>
>::type
fma(const U& a, const number<Backend, et_off>& b, const V& c)
{
   using default_ops::eval_multiply_add;
   detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(a, b, c);
   number<Backend, et_off> result;
   eval_multiply_add(result.backend(), number<Backend, et_off>::canonical_value(a), number<Backend, et_off>::canonical_value(b), number<Backend, et_off>::canonical_value(c));
   return std::move(result);
}

template <class U, class V, class Backend>
inline typename enable_if<
   mpl::and_<
   mpl::bool_<number_category<number<Backend, et_on> >::value == number_kind_floating_point>,
      is_arithmetic<U>,
      is_arithmetic<V>
   >,
   detail::expression<detail::function, default_ops::fma_func, U, V, number<Backend, et_on> >
>::type
fma(const U& a, const V& b, const number<Backend, et_on>& c)
{
   return detail::expression<detail::function, default_ops::fma_func, U, V, number<Backend, et_on> >(
      default_ops::fma_func(), a, b, c);
}

template <class U, class V, class tag, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename enable_if<
   mpl::and_<
   mpl::bool_<number_category<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type >::value == number_kind_floating_point>,
      is_arithmetic<U>,
      is_arithmetic<V>
   >,
   detail::expression<detail::function, default_ops::fma_func, U, V, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >
>::type
fma(const U& a, const V& b, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& c)
{
   return detail::expression<detail::function, default_ops::fma_func, U, V, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(
      default_ops::fma_func(), a, b, c);
}

template <class U, class V, class Backend>
inline typename enable_if<
   mpl::and_<
   mpl::bool_<number_category<number<Backend, et_off> >::value == number_kind_floating_point>,
      is_arithmetic<U>,
      is_arithmetic<V>
   >,
   number<Backend, et_off>
>::type
fma(const U& a, const V& b, const number<Backend, et_off>& c)
{
   using default_ops::eval_multiply_add;
   detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(a, b, c);
   number<Backend, et_off> result;
   eval_multiply_add(result.backend(), number<Backend, et_off>::canonical_value(a), number<Backend, et_off>::canonical_value(b), number<Backend, et_off>::canonical_value(c));
   return std::move(result);
}

namespace default_ops {

   struct remquo_func
   {
      template <class B, class T, class U>
      void operator()(B& result, const T& a, const U& b, int* pi)const
      {
         eval_remquo(result, a, b, pi);
      }
   };

}

template <class Backend, class U>
inline typename enable_if_c<
   number_category<number<Backend, et_on> >::value == number_kind_floating_point,
   detail::expression<detail::function, default_ops::remquo_func, number<Backend, et_on>, U, int*>
>::type
remquo(const number<Backend, et_on>& a, const U& b, int* pi)
{
   return detail::expression<detail::function, default_ops::remquo_func, number<Backend, et_on>, U, int*>(
      default_ops::remquo_func(), a, b, pi);
}

template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class U>
inline typename enable_if_c<
   number_category<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type >::value == number_kind_floating_point,
   detail::expression<detail::function, default_ops::remquo_func, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, U, int*>
>::type
remquo(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const U& b, int* pi)
{
   return detail::expression<detail::function, default_ops::remquo_func, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, U, int*>(
      default_ops::remquo_func(), a, b, pi);
}

template <class U, class Backend>
inline typename enable_if_c<
   (number_category<number<Backend, et_on> >::value == number_kind_floating_point)
   && !is_number<U>::value && !is_number_expression<U>::value,
   detail::expression<detail::function, default_ops::remquo_func, U, number<Backend, et_on>, int*>
>::type
remquo(const U& a, const number<Backend, et_on>& b, int* pi)
{
   return detail::expression<detail::function, default_ops::remquo_func, U, number<Backend, et_on>, int*>(
      default_ops::remquo_func(), a, b, pi);
}

template <class U, class tag, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename enable_if_c<
   (number_category<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type >::value == number_kind_floating_point)
   && !is_number<U>::value && !is_number_expression<U>::value,
   detail::expression<detail::function, default_ops::remquo_func, U, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, int*>
>::type
remquo(const U& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b, int* pi)
{
   return detail::expression<detail::function, default_ops::remquo_func, U, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, int*>(
      default_ops::remquo_func(), a, b, pi);
}

template <class Backend, class U>
inline typename enable_if_c<
   number_category<number<Backend, et_on> >::value == number_kind_floating_point,
   number<Backend, et_off>
>::type
remquo(const number<Backend, et_off>& a, const U& b, int* pi)
{
   using default_ops::eval_remquo;
   detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(a, b);
   number<Backend, et_off> result;
   eval_remquo(result.backend(), a.backend(), number<Backend, et_off>::canonical_value(b), pi);
   return std::move(result);
}
template <class U, class Backend>
inline typename enable_if_c<
(number_category<number<Backend, et_on> >::value == number_kind_floating_point)
&& !is_number<U>::value && !is_number_expression<U>::value,
number<Backend, et_off>
>::type
remquo(const U& a, const number<Backend, et_off>& b, int* pi)
{
   using default_ops::eval_remquo;
   detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(a, b);
   number<Backend, et_off> result;
   eval_remquo(result.backend(), number<Backend, et_off>::canonical_value(a), b.backend(), pi);
   return std::move(result);
}


template <class B, expression_template_option ExpressionTemplates>
inline typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, ExpressionTemplates> >::type
   sqrt(const number<B, ExpressionTemplates>& x, number<B, ExpressionTemplates>& r)
{
   using default_ops::eval_integer_sqrt;
   detail::scoped_default_precision<multiprecision::number<B, ExpressionTemplates> > precision_guard(x, r);
   number<B, ExpressionTemplates> s;
   eval_integer_sqrt(s.backend(), r.backend(), x.backend());
   return s;
}
namespace detail{
template <class Backend>
struct abs_funct
{
   void operator()(Backend& result, const Backend& arg)const
   {
      using default_ops::eval_abs;
      eval_abs(result, arg);
   }
};
template <class Backend>
struct conj_funct
{
   void operator()(Backend& result, const Backend& arg)const
   {
      using default_ops::eval_conj;
      eval_conj(result, arg);
   }
};
template <class Backend>
struct proj_funct
{
   void operator()(Backend& result, const Backend& arg)const
   {
      using default_ops::eval_proj;
      eval_proj(result, arg);
   }
};

}

template <class tag, class A1, class A2, class A3, class A4>
inline typename boost::disable_if_c<number_category<typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value == number_kind_complex,
   detail::expression<
    detail::function
  , detail::abs_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>
  , detail::expression<tag, A1, A2, A3, A4> > >::type
abs(const detail::expression<tag, A1, A2, A3, A4>& arg)
{
    return detail::expression<
    detail::function
  , detail::abs_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>
  , detail::expression<tag, A1, A2, A3, A4>
> (
        detail::abs_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>()
      , arg
    );
}
template <class Backend>
inline typename disable_if_c<number_category<Backend>::value == number_kind_complex,
   detail::expression<
    detail::function
  , detail::abs_funct<Backend>
  , number<Backend, et_on> > >::type
abs(const number<Backend, et_on>& arg)
{
    return detail::expression<
    detail::function
  , detail::abs_funct<Backend>
  , number<Backend, et_on>
  >(
        detail::abs_funct<Backend>()
      , arg
    );
}
template <class Backend>
inline typename disable_if_c<number_category<Backend>::value == number_kind_complex, number<Backend, et_off> >::type
abs(const number<Backend, et_off>& arg)
{
   detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg);
   number<Backend, et_off> result;
   using default_ops::eval_abs;
   eval_abs(result.backend(), arg.backend());
   return std::move(result);
}

template <class tag, class A1, class A2, class A3, class A4>
inline detail::expression<
    detail::function
  , detail::conj_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>
  , detail::expression<tag, A1, A2, A3, A4> >
conj(const detail::expression<tag, A1, A2, A3, A4>& arg)
{
    return detail::expression<
    detail::function
  , detail::conj_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>
  , detail::expression<tag, A1, A2, A3, A4>
> (
        detail::conj_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>()
      , arg
    );
}
template <class Backend>
inline detail::expression<
    detail::function
  , detail::conj_funct<Backend>
  , number<Backend, et_on> >
conj(const number<Backend, et_on>& arg)
{
    return detail::expression<
    detail::function
  , detail::conj_funct<Backend>
  , number<Backend, et_on>
  >(
        detail::conj_funct<Backend>()
      , arg
    );
}
template <class Backend>
inline number<Backend, et_off>
conj(const number<Backend, et_off>& arg)
{
   detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg);
   number<Backend, et_off> result;
   using default_ops::eval_conj;
   eval_conj(result.backend(), arg.backend());
   return std::move(result);
}

template <class tag, class A1, class A2, class A3, class A4>
inline detail::expression<
    detail::function
  , detail::proj_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>
  , detail::expression<tag, A1, A2, A3, A4> >
proj(const detail::expression<tag, A1, A2, A3, A4>& arg)
{
    return detail::expression<
    detail::function
  , detail::proj_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>
  , detail::expression<tag, A1, A2, A3, A4>
> (
        detail::proj_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>()
      , arg
    );
}
template <class Backend>
inline detail::expression<
    detail::function
  , detail::proj_funct<Backend>
  , number<Backend, et_on> >
proj(const number<Backend, et_on>& arg)
{
    return detail::expression<
    detail::function
  , detail::proj_funct<Backend>
  , number<Backend, et_on>
  >(
        detail::proj_funct<Backend>()
      , arg
    );
}
template <class Backend>
inline number<Backend, et_off>
proj(const number<Backend, et_off>& arg)
{
   detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg);
   number<Backend, et_off> result;
   using default_ops::eval_proj;
   eval_proj(result.backend(), arg.backend());
   return std::move(result);
}

namespace detail{template <class Backend> struct number_kind_floating_pointfabs_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_fabs; eval_fabs(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_fabs; Backend temp; eval_fabs(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointfabs_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type fabs(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointfabs_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointfabs_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointfabs_funct<Backend> , number<Backend, et_on> > >::type fabs(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointfabs_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointfabs_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type fabs(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_fabs; eval_fabs(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointsqrt_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_sqrt; eval_sqrt(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_sqrt; Backend temp; eval_sqrt(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointsqrt_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type sqrt(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointsqrt_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointsqrt_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointsqrt_funct<Backend> , number<Backend, et_on> > >::type sqrt(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointsqrt_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointsqrt_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type sqrt(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_sqrt; eval_sqrt(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointfloor_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_floor; eval_floor(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_floor; Backend temp; eval_floor(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointfloor_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type floor(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointfloor_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointfloor_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointfloor_funct<Backend> , number<Backend, et_on> > >::type floor(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointfloor_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointfloor_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type floor(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_floor; eval_floor(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointceil_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_ceil; eval_ceil(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_ceil; Backend temp; eval_ceil(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointceil_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type ceil(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointceil_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointceil_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointceil_funct<Backend> , number<Backend, et_on> > >::type ceil(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointceil_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointceil_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type ceil(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_ceil; eval_ceil(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointtrunc_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_trunc; eval_trunc(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_trunc; Backend temp; eval_trunc(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointtrunc_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type trunc(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointtrunc_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointtrunc_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointtrunc_funct<Backend> , number<Backend, et_on> > >::type trunc(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointtrunc_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointtrunc_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type trunc(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_trunc; eval_trunc(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointround_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_round; eval_round(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_round; Backend temp; eval_round(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointround_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type round(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointround_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointround_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointround_funct<Backend> , number<Backend, et_on> > >::type round(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointround_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointround_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type round(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_round; eval_round(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointexp_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_exp; eval_exp(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_exp; Backend temp; eval_exp(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointexp_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type exp(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointexp_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointexp_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointexp_funct<Backend> , number<Backend, et_on> > >::type exp(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointexp_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointexp_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type exp(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_exp; eval_exp(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointexp2_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_exp2; eval_exp2(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_exp2; Backend temp; eval_exp2(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointexp2_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type exp2(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointexp2_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointexp2_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointexp2_funct<Backend> , number<Backend, et_on> > >::type exp2(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointexp2_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointexp2_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type exp2(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_exp2; eval_exp2(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointlog_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_log; eval_log(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_log; Backend temp; eval_log(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointlog_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type log(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointlog_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointlog_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointlog_funct<Backend> , number<Backend, et_on> > >::type log(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointlog_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointlog_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type log(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_log; eval_log(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointlog10_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_log10; eval_log10(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_log10; Backend temp; eval_log10(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointlog10_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type log10(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointlog10_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointlog10_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointlog10_funct<Backend> , number<Backend, et_on> > >::type log10(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointlog10_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointlog10_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type log10(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_log10; eval_log10(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointcos_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_cos; eval_cos(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_cos; Backend temp; eval_cos(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointcos_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type cos(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointcos_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointcos_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointcos_funct<Backend> , number<Backend, et_on> > >::type cos(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointcos_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointcos_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type cos(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_cos; eval_cos(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointsin_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_sin; eval_sin(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_sin; Backend temp; eval_sin(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointsin_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type sin(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointsin_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointsin_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointsin_funct<Backend> , number<Backend, et_on> > >::type sin(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointsin_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointsin_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type sin(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_sin; eval_sin(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointtan_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_tan; eval_tan(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_tan; Backend temp; eval_tan(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointtan_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type tan(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointtan_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointtan_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointtan_funct<Backend> , number<Backend, et_on> > >::type tan(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointtan_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointtan_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type tan(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_tan; eval_tan(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointasin_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_asin; eval_asin(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_asin; Backend temp; eval_asin(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointasin_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type asin(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointasin_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointasin_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointasin_funct<Backend> , number<Backend, et_on> > >::type asin(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointasin_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointasin_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type asin(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_asin; eval_asin(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointacos_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_acos; eval_acos(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_acos; Backend temp; eval_acos(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointacos_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type acos(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointacos_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointacos_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointacos_funct<Backend> , number<Backend, et_on> > >::type acos(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointacos_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointacos_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type acos(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_acos; eval_acos(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointatan_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_atan; eval_atan(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_atan; Backend temp; eval_atan(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointatan_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type atan(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointatan_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointatan_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointatan_funct<Backend> , number<Backend, et_on> > >::type atan(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointatan_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointatan_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type atan(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_atan; eval_atan(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointcosh_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_cosh; eval_cosh(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_cosh; Backend temp; eval_cosh(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointcosh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type cosh(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointcosh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointcosh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointcosh_funct<Backend> , number<Backend, et_on> > >::type cosh(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointcosh_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointcosh_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type cosh(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_cosh; eval_cosh(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointsinh_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_sinh; eval_sinh(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_sinh; Backend temp; eval_sinh(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointsinh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type sinh(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointsinh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointsinh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointsinh_funct<Backend> , number<Backend, et_on> > >::type sinh(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointsinh_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointsinh_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type sinh(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_sinh; eval_sinh(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointtanh_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_tanh; eval_tanh(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_tanh; Backend temp; eval_tanh(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointtanh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type tanh(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointtanh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointtanh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointtanh_funct<Backend> , number<Backend, et_on> > >::type tanh(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointtanh_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointtanh_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type tanh(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_tanh; eval_tanh(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointlog2_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_log2; eval_log2(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_log2; Backend temp; eval_log2(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointlog2_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type log2(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointlog2_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointlog2_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointlog2_funct<Backend> , number<Backend, et_on> > >::type log2(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointlog2_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointlog2_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type log2(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_log2; eval_log2(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointnearbyint_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_nearbyint; eval_nearbyint(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_nearbyint; Backend temp; eval_nearbyint(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointnearbyint_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type nearbyint(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointnearbyint_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointnearbyint_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointnearbyint_funct<Backend> , number<Backend, et_on> > >::type nearbyint(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointnearbyint_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointnearbyint_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type nearbyint(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_nearbyint; eval_nearbyint(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointrint_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_rint; eval_rint(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_rint; Backend temp; eval_rint(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointrint_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type rint(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointrint_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointrint_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointrint_funct<Backend> , number<Backend, et_on> > >::type rint(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointrint_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointrint_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type rint(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_rint; eval_rint(result.backend(), arg.backend()); return std::move(result);}

namespace detail{template <class Backend> struct number_kind_floating_pointldexp_funct{ template <class Arg> void operator()(Backend& result, Backend const& arg, Arg a)const { using default_ops:: eval_ldexp; eval_ldexp(result, arg, a); }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointldexp_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , short> >::type ldexp(const detail::expression<tag, A1, A2, A3, A4>& arg, short const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointldexp_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , short >( detail::number_kind_floating_pointldexp_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointldexp_funct<Backend> , number<Backend, et_on> , short> >::type ldexp(const number<Backend, et_on>& arg, short const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointldexp_funct<Backend> , number<Backend, et_on> , short >( detail::number_kind_floating_pointldexp_funct<Backend>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type ldexp(const number<Backend, et_off>& arg, short const& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_ldexp; eval_ldexp(result.backend(), arg.backend(), a); return std::move(result);}

template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointldexp_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , int> >::type ldexp(const detail::expression<tag, A1, A2, A3, A4>& arg, int const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointldexp_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , int >( detail::number_kind_floating_pointldexp_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointldexp_funct<Backend> , number<Backend, et_on> , int> >::type ldexp(const number<Backend, et_on>& arg, int const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointldexp_funct<Backend> , number<Backend, et_on> , int >( detail::number_kind_floating_pointldexp_funct<Backend>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type ldexp(const number<Backend, et_off>& arg, int const& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_ldexp; eval_ldexp(result.backend(), arg.backend(), a); return std::move(result);}

template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointldexp_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , long> >::type ldexp(const detail::expression<tag, A1, A2, A3, A4>& arg, long const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointldexp_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , long >( detail::number_kind_floating_pointldexp_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointldexp_funct<Backend> , number<Backend, et_on> , long> >::type ldexp(const number<Backend, et_on>& arg, long const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointldexp_funct<Backend> , number<Backend, et_on> , long >( detail::number_kind_floating_pointldexp_funct<Backend>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type ldexp(const number<Backend, et_off>& arg, long const& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_ldexp; eval_ldexp(result.backend(), arg.backend(), a); return std::move(result);}

template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointldexp_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , boost::long_long_type> >::type ldexp(const detail::expression<tag, A1, A2, A3, A4>& arg, boost::long_long_type const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointldexp_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , boost::long_long_type >( detail::number_kind_floating_pointldexp_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointldexp_funct<Backend> , number<Backend, et_on> , boost::long_long_type> >::type ldexp(const number<Backend, et_on>& arg, boost::long_long_type const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointldexp_funct<Backend> , number<Backend, et_on> , boost::long_long_type >( detail::number_kind_floating_pointldexp_funct<Backend>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type ldexp(const number<Backend, et_off>& arg, boost::long_long_type const& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_ldexp; eval_ldexp(result.backend(), arg.backend(), a); return std::move(result);}

namespace detail{template <class Backend> struct number_kind_floating_pointpow_funct{ void operator()(Backend& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_pow; eval_pow(result, arg, a); } template <class Arithmetic> void operator()(Backend& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_pow; eval_pow(result, arg, number<Backend>::canonical_value(a)); } template <class Arithmetic> void operator()(Backend& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_pow; eval_pow(result, number<Backend>::canonical_value(arg), a); } template <class U> void operator()(U& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_pow; Backend r; eval_pow(r, arg, a); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_pow; Backend r; eval_pow(r, arg, number<Backend>::canonical_value(a)); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_pow; Backend r; eval_pow(r, number<Backend>::canonical_value(arg), a); result = r; }};}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointpow_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> > >::type pow(const number<Backend, et_on>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointpow_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> >( detail::number_kind_floating_pointpow_funct<Backend>() , arg, a );}template <class Backend, class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_floating_pointpow_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> > >::type pow(const number<Backend, et_on>& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointpow_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_floating_pointpow_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_floating_pointpow_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> > >::type pow(const detail::expression<tag, A1, A2, A3, A4>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointpow_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> >( detail::number_kind_floating_pointpow_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class tagb, class A1b, class A2b, class A3b, class A4b> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point) && (number_category<detail::expression<tagb, A1b, A2b, A3b, A4b> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointpow_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> > >::type pow(const detail::expression<tag, A1, A2, A3, A4>& arg, const detail::expression<tagb, A1b, A2b, A3b, A4b>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointpow_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> >( detail::number_kind_floating_pointpow_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointpow_funct<Backend> , number<Backend, et_on> , Arithmetic > >::type pow(const number<Backend, et_on>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_floating_pointpow_funct<Backend> , number<Backend, et_on> , Arithmetic >( detail::number_kind_floating_pointpow_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointpow_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic > >::type pow(const detail::expression<tag, A1, A2, A3, A4>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_floating_pointpow_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic >( detail::number_kind_floating_pointpow_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointpow_funct<Backend> , Arithmetic , number<Backend, et_on> > >::type pow(const Arithmetic& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointpow_funct<Backend> , Arithmetic , number<Backend, et_on> >( detail::number_kind_floating_pointpow_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointpow_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> > >::type pow(const Arithmetic& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointpow_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_floating_pointpow_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c<(number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type pow(const number<Backend, et_off>& arg, const number<Backend, et_off>& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_pow; eval_pow(result.backend(), arg.backend(), a.backend()); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type pow(const number<Backend, et_off>& arg, const Arithmetic& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_pow; eval_pow(result.backend(), arg.backend(), number<Backend, et_off>::canonical_value(a)); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type pow(const Arithmetic& a, const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_pow; eval_pow(result.backend(), number<Backend, et_off>::canonical_value(a), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointfmod_funct{ void operator()(Backend& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_fmod; eval_fmod(result, arg, a); } template <class Arithmetic> void operator()(Backend& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_fmod; eval_fmod(result, arg, number<Backend>::canonical_value(a)); } template <class Arithmetic> void operator()(Backend& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_fmod; eval_fmod(result, number<Backend>::canonical_value(arg), a); } template <class U> void operator()(U& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_fmod; Backend r; eval_fmod(r, arg, a); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_fmod; Backend r; eval_fmod(r, arg, number<Backend>::canonical_value(a)); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_fmod; Backend r; eval_fmod(r, number<Backend>::canonical_value(arg), a); result = r; }};}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointfmod_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> > >::type fmod(const number<Backend, et_on>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmod_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> >( detail::number_kind_floating_pointfmod_funct<Backend>() , arg, a );}template <class Backend, class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_floating_pointfmod_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> > >::type fmod(const number<Backend, et_on>& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmod_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_floating_pointfmod_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_floating_pointfmod_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> > >::type fmod(const detail::expression<tag, A1, A2, A3, A4>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmod_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> >( detail::number_kind_floating_pointfmod_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class tagb, class A1b, class A2b, class A3b, class A4b> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point) && (number_category<detail::expression<tagb, A1b, A2b, A3b, A4b> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointfmod_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> > >::type fmod(const detail::expression<tag, A1, A2, A3, A4>& arg, const detail::expression<tagb, A1b, A2b, A3b, A4b>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmod_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> >( detail::number_kind_floating_pointfmod_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointfmod_funct<Backend> , number<Backend, et_on> , Arithmetic > >::type fmod(const number<Backend, et_on>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmod_funct<Backend> , number<Backend, et_on> , Arithmetic >( detail::number_kind_floating_pointfmod_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointfmod_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic > >::type fmod(const detail::expression<tag, A1, A2, A3, A4>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmod_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic >( detail::number_kind_floating_pointfmod_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointfmod_funct<Backend> , Arithmetic , number<Backend, et_on> > >::type fmod(const Arithmetic& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmod_funct<Backend> , Arithmetic , number<Backend, et_on> >( detail::number_kind_floating_pointfmod_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointfmod_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> > >::type fmod(const Arithmetic& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmod_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_floating_pointfmod_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c<(number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type fmod(const number<Backend, et_off>& arg, const number<Backend, et_off>& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_fmod; eval_fmod(result.backend(), arg.backend(), a.backend()); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type fmod(const number<Backend, et_off>& arg, const Arithmetic& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_fmod; eval_fmod(result.backend(), arg.backend(), number<Backend, et_off>::canonical_value(a)); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type fmod(const Arithmetic& a, const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_fmod; eval_fmod(result.backend(), number<Backend, et_off>::canonical_value(a), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointfmax_funct{ void operator()(Backend& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_fmax; eval_fmax(result, arg, a); } template <class Arithmetic> void operator()(Backend& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_fmax; eval_fmax(result, arg, number<Backend>::canonical_value(a)); } template <class Arithmetic> void operator()(Backend& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_fmax; eval_fmax(result, number<Backend>::canonical_value(arg), a); } template <class U> void operator()(U& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_fmax; Backend r; eval_fmax(r, arg, a); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_fmax; Backend r; eval_fmax(r, arg, number<Backend>::canonical_value(a)); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_fmax; Backend r; eval_fmax(r, number<Backend>::canonical_value(arg), a); result = r; }};}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointfmax_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> > >::type fmax(const number<Backend, et_on>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmax_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> >( detail::number_kind_floating_pointfmax_funct<Backend>() , arg, a );}template <class Backend, class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_floating_pointfmax_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> > >::type fmax(const number<Backend, et_on>& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmax_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_floating_pointfmax_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_floating_pointfmax_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> > >::type fmax(const detail::expression<tag, A1, A2, A3, A4>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmax_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> >( detail::number_kind_floating_pointfmax_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class tagb, class A1b, class A2b, class A3b, class A4b> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point) && (number_category<detail::expression<tagb, A1b, A2b, A3b, A4b> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointfmax_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> > >::type fmax(const detail::expression<tag, A1, A2, A3, A4>& arg, const detail::expression<tagb, A1b, A2b, A3b, A4b>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmax_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> >( detail::number_kind_floating_pointfmax_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointfmax_funct<Backend> , number<Backend, et_on> , Arithmetic > >::type fmax(const number<Backend, et_on>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmax_funct<Backend> , number<Backend, et_on> , Arithmetic >( detail::number_kind_floating_pointfmax_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointfmax_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic > >::type fmax(const detail::expression<tag, A1, A2, A3, A4>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmax_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic >( detail::number_kind_floating_pointfmax_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointfmax_funct<Backend> , Arithmetic , number<Backend, et_on> > >::type fmax(const Arithmetic& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmax_funct<Backend> , Arithmetic , number<Backend, et_on> >( detail::number_kind_floating_pointfmax_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointfmax_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> > >::type fmax(const Arithmetic& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmax_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_floating_pointfmax_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c<(number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type fmax(const number<Backend, et_off>& arg, const number<Backend, et_off>& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_fmax; eval_fmax(result.backend(), arg.backend(), a.backend()); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type fmax(const number<Backend, et_off>& arg, const Arithmetic& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_fmax; eval_fmax(result.backend(), arg.backend(), number<Backend, et_off>::canonical_value(a)); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type fmax(const Arithmetic& a, const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_fmax; eval_fmax(result.backend(), number<Backend, et_off>::canonical_value(a), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointfmin_funct{ void operator()(Backend& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_fmin; eval_fmin(result, arg, a); } template <class Arithmetic> void operator()(Backend& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_fmin; eval_fmin(result, arg, number<Backend>::canonical_value(a)); } template <class Arithmetic> void operator()(Backend& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_fmin; eval_fmin(result, number<Backend>::canonical_value(arg), a); } template <class U> void operator()(U& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_fmin; Backend r; eval_fmin(r, arg, a); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_fmin; Backend r; eval_fmin(r, arg, number<Backend>::canonical_value(a)); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_fmin; Backend r; eval_fmin(r, number<Backend>::canonical_value(arg), a); result = r; }};}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointfmin_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> > >::type fmin(const number<Backend, et_on>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmin_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> >( detail::number_kind_floating_pointfmin_funct<Backend>() , arg, a );}template <class Backend, class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_floating_pointfmin_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> > >::type fmin(const number<Backend, et_on>& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmin_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_floating_pointfmin_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_floating_pointfmin_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> > >::type fmin(const detail::expression<tag, A1, A2, A3, A4>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmin_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> >( detail::number_kind_floating_pointfmin_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class tagb, class A1b, class A2b, class A3b, class A4b> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point) && (number_category<detail::expression<tagb, A1b, A2b, A3b, A4b> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointfmin_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> > >::type fmin(const detail::expression<tag, A1, A2, A3, A4>& arg, const detail::expression<tagb, A1b, A2b, A3b, A4b>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmin_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> >( detail::number_kind_floating_pointfmin_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointfmin_funct<Backend> , number<Backend, et_on> , Arithmetic > >::type fmin(const number<Backend, et_on>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmin_funct<Backend> , number<Backend, et_on> , Arithmetic >( detail::number_kind_floating_pointfmin_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointfmin_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic > >::type fmin(const detail::expression<tag, A1, A2, A3, A4>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmin_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic >( detail::number_kind_floating_pointfmin_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointfmin_funct<Backend> , Arithmetic , number<Backend, et_on> > >::type fmin(const Arithmetic& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmin_funct<Backend> , Arithmetic , number<Backend, et_on> >( detail::number_kind_floating_pointfmin_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointfmin_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> > >::type fmin(const Arithmetic& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfmin_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_floating_pointfmin_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c<(number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type fmin(const number<Backend, et_off>& arg, const number<Backend, et_off>& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_fmin; eval_fmin(result.backend(), arg.backend(), a.backend()); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type fmin(const number<Backend, et_off>& arg, const Arithmetic& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_fmin; eval_fmin(result.backend(), arg.backend(), number<Backend, et_off>::canonical_value(a)); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type fmin(const Arithmetic& a, const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_fmin; eval_fmin(result.backend(), number<Backend, et_off>::canonical_value(a), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointatan2_funct{ void operator()(Backend& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_atan2; eval_atan2(result, arg, a); } template <class Arithmetic> void operator()(Backend& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_atan2; eval_atan2(result, arg, number<Backend>::canonical_value(a)); } template <class Arithmetic> void operator()(Backend& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_atan2; eval_atan2(result, number<Backend>::canonical_value(arg), a); } template <class U> void operator()(U& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_atan2; Backend r; eval_atan2(r, arg, a); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_atan2; Backend r; eval_atan2(r, arg, number<Backend>::canonical_value(a)); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_atan2; Backend r; eval_atan2(r, number<Backend>::canonical_value(arg), a); result = r; }};}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointatan2_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> > >::type atan2(const number<Backend, et_on>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointatan2_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> >( detail::number_kind_floating_pointatan2_funct<Backend>() , arg, a );}template <class Backend, class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_floating_pointatan2_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> > >::type atan2(const number<Backend, et_on>& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointatan2_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_floating_pointatan2_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_floating_pointatan2_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> > >::type atan2(const detail::expression<tag, A1, A2, A3, A4>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointatan2_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> >( detail::number_kind_floating_pointatan2_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class tagb, class A1b, class A2b, class A3b, class A4b> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point) && (number_category<detail::expression<tagb, A1b, A2b, A3b, A4b> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointatan2_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> > >::type atan2(const detail::expression<tag, A1, A2, A3, A4>& arg, const detail::expression<tagb, A1b, A2b, A3b, A4b>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointatan2_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> >( detail::number_kind_floating_pointatan2_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointatan2_funct<Backend> , number<Backend, et_on> , Arithmetic > >::type atan2(const number<Backend, et_on>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_floating_pointatan2_funct<Backend> , number<Backend, et_on> , Arithmetic >( detail::number_kind_floating_pointatan2_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointatan2_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic > >::type atan2(const detail::expression<tag, A1, A2, A3, A4>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_floating_pointatan2_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic >( detail::number_kind_floating_pointatan2_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointatan2_funct<Backend> , Arithmetic , number<Backend, et_on> > >::type atan2(const Arithmetic& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointatan2_funct<Backend> , Arithmetic , number<Backend, et_on> >( detail::number_kind_floating_pointatan2_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointatan2_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> > >::type atan2(const Arithmetic& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointatan2_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_floating_pointatan2_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c<(number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type atan2(const number<Backend, et_off>& arg, const number<Backend, et_off>& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_atan2; eval_atan2(result.backend(), arg.backend(), a.backend()); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type atan2(const number<Backend, et_off>& arg, const Arithmetic& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_atan2; eval_atan2(result.backend(), arg.backend(), number<Backend, et_off>::canonical_value(a)); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type atan2(const Arithmetic& a, const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_atan2; eval_atan2(result.backend(), number<Backend, et_off>::canonical_value(a), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointfdim_funct{ void operator()(Backend& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_fdim; eval_fdim(result, arg, a); } template <class Arithmetic> void operator()(Backend& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_fdim; eval_fdim(result, arg, number<Backend>::canonical_value(a)); } template <class Arithmetic> void operator()(Backend& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_fdim; eval_fdim(result, number<Backend>::canonical_value(arg), a); } template <class U> void operator()(U& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_fdim; Backend r; eval_fdim(r, arg, a); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_fdim; Backend r; eval_fdim(r, arg, number<Backend>::canonical_value(a)); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_fdim; Backend r; eval_fdim(r, number<Backend>::canonical_value(arg), a); result = r; }};}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointfdim_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> > >::type fdim(const number<Backend, et_on>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfdim_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> >( detail::number_kind_floating_pointfdim_funct<Backend>() , arg, a );}template <class Backend, class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_floating_pointfdim_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> > >::type fdim(const number<Backend, et_on>& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfdim_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_floating_pointfdim_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_floating_pointfdim_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> > >::type fdim(const detail::expression<tag, A1, A2, A3, A4>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfdim_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> >( detail::number_kind_floating_pointfdim_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class tagb, class A1b, class A2b, class A3b, class A4b> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point) && (number_category<detail::expression<tagb, A1b, A2b, A3b, A4b> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointfdim_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> > >::type fdim(const detail::expression<tag, A1, A2, A3, A4>& arg, const detail::expression<tagb, A1b, A2b, A3b, A4b>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfdim_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> >( detail::number_kind_floating_pointfdim_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointfdim_funct<Backend> , number<Backend, et_on> , Arithmetic > >::type fdim(const number<Backend, et_on>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfdim_funct<Backend> , number<Backend, et_on> , Arithmetic >( detail::number_kind_floating_pointfdim_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointfdim_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic > >::type fdim(const detail::expression<tag, A1, A2, A3, A4>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfdim_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic >( detail::number_kind_floating_pointfdim_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointfdim_funct<Backend> , Arithmetic , number<Backend, et_on> > >::type fdim(const Arithmetic& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfdim_funct<Backend> , Arithmetic , number<Backend, et_on> >( detail::number_kind_floating_pointfdim_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointfdim_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> > >::type fdim(const Arithmetic& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointfdim_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_floating_pointfdim_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c<(number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type fdim(const number<Backend, et_off>& arg, const number<Backend, et_off>& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_fdim; eval_fdim(result.backend(), arg.backend(), a.backend()); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type fdim(const number<Backend, et_off>& arg, const Arithmetic& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_fdim; eval_fdim(result.backend(), arg.backend(), number<Backend, et_off>::canonical_value(a)); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type fdim(const Arithmetic& a, const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_fdim; eval_fdim(result.backend(), number<Backend, et_off>::canonical_value(a), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointhypot_funct{ void operator()(Backend& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_hypot; eval_hypot(result, arg, a); } template <class Arithmetic> void operator()(Backend& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_hypot; eval_hypot(result, arg, number<Backend>::canonical_value(a)); } template <class Arithmetic> void operator()(Backend& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_hypot; eval_hypot(result, number<Backend>::canonical_value(arg), a); } template <class U> void operator()(U& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_hypot; Backend r; eval_hypot(r, arg, a); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_hypot; Backend r; eval_hypot(r, arg, number<Backend>::canonical_value(a)); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_hypot; Backend r; eval_hypot(r, number<Backend>::canonical_value(arg), a); result = r; }};}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointhypot_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> > >::type hypot(const number<Backend, et_on>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointhypot_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> >( detail::number_kind_floating_pointhypot_funct<Backend>() , arg, a );}template <class Backend, class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_floating_pointhypot_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> > >::type hypot(const number<Backend, et_on>& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointhypot_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_floating_pointhypot_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_floating_pointhypot_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> > >::type hypot(const detail::expression<tag, A1, A2, A3, A4>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointhypot_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> >( detail::number_kind_floating_pointhypot_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class tagb, class A1b, class A2b, class A3b, class A4b> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point) && (number_category<detail::expression<tagb, A1b, A2b, A3b, A4b> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointhypot_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> > >::type hypot(const detail::expression<tag, A1, A2, A3, A4>& arg, const detail::expression<tagb, A1b, A2b, A3b, A4b>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointhypot_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> >( detail::number_kind_floating_pointhypot_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointhypot_funct<Backend> , number<Backend, et_on> , Arithmetic > >::type hypot(const number<Backend, et_on>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_floating_pointhypot_funct<Backend> , number<Backend, et_on> , Arithmetic >( detail::number_kind_floating_pointhypot_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointhypot_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic > >::type hypot(const detail::expression<tag, A1, A2, A3, A4>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_floating_pointhypot_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic >( detail::number_kind_floating_pointhypot_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointhypot_funct<Backend> , Arithmetic , number<Backend, et_on> > >::type hypot(const Arithmetic& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointhypot_funct<Backend> , Arithmetic , number<Backend, et_on> >( detail::number_kind_floating_pointhypot_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointhypot_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> > >::type hypot(const Arithmetic& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointhypot_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_floating_pointhypot_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c<(number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type hypot(const number<Backend, et_off>& arg, const number<Backend, et_off>& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_hypot; eval_hypot(result.backend(), arg.backend(), a.backend()); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type hypot(const number<Backend, et_off>& arg, const Arithmetic& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_hypot; eval_hypot(result.backend(), arg.backend(), number<Backend, et_off>::canonical_value(a)); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type hypot(const Arithmetic& a, const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_hypot; eval_hypot(result.backend(), number<Backend, et_off>::canonical_value(a), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointremainder_funct{ void operator()(Backend& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_remainder; eval_remainder(result, arg, a); } template <class Arithmetic> void operator()(Backend& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_remainder; eval_remainder(result, arg, number<Backend>::canonical_value(a)); } template <class Arithmetic> void operator()(Backend& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_remainder; eval_remainder(result, number<Backend>::canonical_value(arg), a); } template <class U> void operator()(U& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_remainder; Backend r; eval_remainder(r, arg, a); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_remainder; Backend r; eval_remainder(r, arg, number<Backend>::canonical_value(a)); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_remainder; Backend r; eval_remainder(r, number<Backend>::canonical_value(arg), a); result = r; }};}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointremainder_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> > >::type remainder(const number<Backend, et_on>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointremainder_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> >( detail::number_kind_floating_pointremainder_funct<Backend>() , arg, a );}template <class Backend, class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_floating_pointremainder_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> > >::type remainder(const number<Backend, et_on>& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointremainder_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_floating_pointremainder_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_floating_pointremainder_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> > >::type remainder(const detail::expression<tag, A1, A2, A3, A4>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointremainder_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> >( detail::number_kind_floating_pointremainder_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class tagb, class A1b, class A2b, class A3b, class A4b> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point) && (number_category<detail::expression<tagb, A1b, A2b, A3b, A4b> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointremainder_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> > >::type remainder(const detail::expression<tag, A1, A2, A3, A4>& arg, const detail::expression<tagb, A1b, A2b, A3b, A4b>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointremainder_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> >( detail::number_kind_floating_pointremainder_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointremainder_funct<Backend> , number<Backend, et_on> , Arithmetic > >::type remainder(const number<Backend, et_on>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_floating_pointremainder_funct<Backend> , number<Backend, et_on> , Arithmetic >( detail::number_kind_floating_pointremainder_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointremainder_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic > >::type remainder(const detail::expression<tag, A1, A2, A3, A4>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_floating_pointremainder_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic >( detail::number_kind_floating_pointremainder_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointremainder_funct<Backend> , Arithmetic , number<Backend, et_on> > >::type remainder(const Arithmetic& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointremainder_funct<Backend> , Arithmetic , number<Backend, et_on> >( detail::number_kind_floating_pointremainder_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointremainder_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> > >::type remainder(const Arithmetic& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_floating_pointremainder_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_floating_pointremainder_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c<(number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type remainder(const number<Backend, et_off>& arg, const number<Backend, et_off>& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_remainder; eval_remainder(result.backend(), arg.backend(), a.backend()); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type remainder(const number<Backend, et_off>& arg, const Arithmetic& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_remainder; eval_remainder(result.backend(), arg.backend(), number<Backend, et_off>::canonical_value(a)); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type remainder(const Arithmetic& a, const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_remainder; eval_remainder(result.backend(), number<Backend, et_off>::canonical_value(a), arg.backend()); return std::move(result);}

namespace detail{template <class Backend> struct number_kind_floating_pointlogb_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_logb; eval_logb(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_logb; Backend temp; eval_logb(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointlogb_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type logb(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointlogb_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_floating_pointlogb_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, detail::expression< detail::function , detail::number_kind_floating_pointlogb_funct<Backend> , number<Backend, et_on> > >::type logb(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_floating_pointlogb_funct<Backend> , number<Backend, et_on> >( detail::number_kind_floating_pointlogb_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_floating_point, number<Backend, et_off> >::type logb(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_logb; eval_logb(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointscalbn_funct{ template <class Arg> void operator()(Backend& result, Backend const& arg, Arg a)const { using default_ops:: eval_scalbn; eval_scalbn(result, arg, a); }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointscalbn_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , short> >::type scalbn(const detail::expression<tag, A1, A2, A3, A4>& arg, short const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointscalbn_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , short >( detail::number_kind_floating_pointscalbn_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointscalbn_funct<Backend> , number<Backend, et_on> , short> >::type scalbn(const number<Backend, et_on>& arg, short const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointscalbn_funct<Backend> , number<Backend, et_on> , short >( detail::number_kind_floating_pointscalbn_funct<Backend>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type scalbn(const number<Backend, et_off>& arg, short const& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_scalbn; eval_scalbn(result.backend(), arg.backend(), a); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_floating_pointscalbln_funct{ template <class Arg> void operator()(Backend& result, Backend const& arg, Arg a)const { using default_ops:: eval_scalbln; eval_scalbln(result, arg, a); }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointscalbln_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , short> >::type scalbln(const detail::expression<tag, A1, A2, A3, A4>& arg, short const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointscalbln_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , short >( detail::number_kind_floating_pointscalbln_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointscalbln_funct<Backend> , number<Backend, et_on> , short> >::type scalbln(const number<Backend, et_on>& arg, short const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointscalbln_funct<Backend> , number<Backend, et_on> , short >( detail::number_kind_floating_pointscalbln_funct<Backend>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type scalbln(const number<Backend, et_off>& arg, short const& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_scalbln; eval_scalbln(result.backend(), arg.backend(), a); return std::move(result);}
template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointscalbn_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , int> >::type scalbn(const detail::expression<tag, A1, A2, A3, A4>& arg, int const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointscalbn_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , int >( detail::number_kind_floating_pointscalbn_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointscalbn_funct<Backend> , number<Backend, et_on> , int> >::type scalbn(const number<Backend, et_on>& arg, int const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointscalbn_funct<Backend> , number<Backend, et_on> , int >( detail::number_kind_floating_pointscalbn_funct<Backend>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type scalbn(const number<Backend, et_off>& arg, int const& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_scalbn; eval_scalbn(result.backend(), arg.backend(), a); return std::move(result);}
template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointscalbln_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , int> >::type scalbln(const detail::expression<tag, A1, A2, A3, A4>& arg, int const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointscalbln_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , int >( detail::number_kind_floating_pointscalbln_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointscalbln_funct<Backend> , number<Backend, et_on> , int> >::type scalbln(const number<Backend, et_on>& arg, int const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointscalbln_funct<Backend> , number<Backend, et_on> , int >( detail::number_kind_floating_pointscalbln_funct<Backend>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type scalbln(const number<Backend, et_off>& arg, int const& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_scalbln; eval_scalbln(result.backend(), arg.backend(), a); return std::move(result);}
template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointscalbn_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , long> >::type scalbn(const detail::expression<tag, A1, A2, A3, A4>& arg, long const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointscalbn_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , long >( detail::number_kind_floating_pointscalbn_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointscalbn_funct<Backend> , number<Backend, et_on> , long> >::type scalbn(const number<Backend, et_on>& arg, long const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointscalbn_funct<Backend> , number<Backend, et_on> , long >( detail::number_kind_floating_pointscalbn_funct<Backend>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type scalbn(const number<Backend, et_off>& arg, long const& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_scalbn; eval_scalbn(result.backend(), arg.backend(), a); return std::move(result);}
template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointscalbln_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , long> >::type scalbln(const detail::expression<tag, A1, A2, A3, A4>& arg, long const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointscalbln_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , long >( detail::number_kind_floating_pointscalbln_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointscalbln_funct<Backend> , number<Backend, et_on> , long> >::type scalbln(const number<Backend, et_on>& arg, long const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointscalbln_funct<Backend> , number<Backend, et_on> , long >( detail::number_kind_floating_pointscalbln_funct<Backend>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type scalbln(const number<Backend, et_off>& arg, long const& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_scalbln; eval_scalbln(result.backend(), arg.backend(), a); return std::move(result);}
template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointscalbn_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , boost::long_long_type> >::type scalbn(const detail::expression<tag, A1, A2, A3, A4>& arg, boost::long_long_type const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointscalbn_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , boost::long_long_type >( detail::number_kind_floating_pointscalbn_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointscalbn_funct<Backend> , number<Backend, et_on> , boost::long_long_type> >::type scalbn(const number<Backend, et_on>& arg, boost::long_long_type const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointscalbn_funct<Backend> , number<Backend, et_on> , boost::long_long_type >( detail::number_kind_floating_pointscalbn_funct<Backend>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type scalbn(const number<Backend, et_off>& arg, boost::long_long_type const& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_scalbn; eval_scalbn(result.backend(), arg.backend(), a); return std::move(result);}
template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointscalbln_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , boost::long_long_type> >::type scalbln(const detail::expression<tag, A1, A2, A3, A4>& arg, boost::long_long_type const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointscalbln_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , boost::long_long_type >( detail::number_kind_floating_pointscalbln_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), detail::expression< detail::function , detail::number_kind_floating_pointscalbln_funct<Backend> , number<Backend, et_on> , boost::long_long_type> >::type scalbln(const number<Backend, et_on>& arg, boost::long_long_type const& a){ return detail::expression< detail::function , detail::number_kind_floating_pointscalbln_funct<Backend> , number<Backend, et_on> , boost::long_long_type >( detail::number_kind_floating_pointscalbln_funct<Backend>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_floating_point), number<Backend, et_off> >::type scalbln(const number<Backend, et_off>& arg, boost::long_long_type const& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_scalbln; eval_scalbln(result.backend(), arg.backend(), a); return std::move(result);}




namespace detail{template <class Backend> struct number_kind_complexexp_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_exp; eval_exp(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_exp; Backend temp; eval_exp(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexexp_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type exp(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_complexexp_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_complexexp_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexexp_funct<Backend> , number<Backend, et_on> > >::type exp(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_complexexp_funct<Backend> , number<Backend, et_on> >( detail::number_kind_complexexp_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_complex, number<Backend, et_off> >::type exp(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_exp; eval_exp(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_complexlog_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_log; eval_log(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_log; Backend temp; eval_log(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexlog_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type log(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_complexlog_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_complexlog_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexlog_funct<Backend> , number<Backend, et_on> > >::type log(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_complexlog_funct<Backend> , number<Backend, et_on> >( detail::number_kind_complexlog_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_complex, number<Backend, et_off> >::type log(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_log; eval_log(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_complexlog10_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_log10; eval_log10(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_log10; Backend temp; eval_log10(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexlog10_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type log10(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_complexlog10_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_complexlog10_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexlog10_funct<Backend> , number<Backend, et_on> > >::type log10(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_complexlog10_funct<Backend> , number<Backend, et_on> >( detail::number_kind_complexlog10_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_complex, number<Backend, et_off> >::type log10(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_log10; eval_log10(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_complexpow_funct{ void operator()(Backend& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_pow; eval_pow(result, arg, a); } template <class Arithmetic> void operator()(Backend& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_pow; eval_pow(result, arg, number<Backend>::canonical_value(a)); } template <class Arithmetic> void operator()(Backend& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_pow; eval_pow(result, number<Backend>::canonical_value(arg), a); } template <class U> void operator()(U& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_pow; Backend r; eval_pow(r, arg, a); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_pow; Backend r; eval_pow(r, arg, number<Backend>::canonical_value(a)); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_pow; Backend r; eval_pow(r, number<Backend>::canonical_value(arg), a); result = r; }};}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexpow_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> > >::type pow(const number<Backend, et_on>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_complexpow_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> >( detail::number_kind_complexpow_funct<Backend>() , arg, a );}template <class Backend, class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<Backend>::value == number_kind_complex) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_complexpow_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> > >::type pow(const number<Backend, et_on>& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_complexpow_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_complexpow_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_complex) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_complexpow_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> > >::type pow(const detail::expression<tag, A1, A2, A3, A4>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_complexpow_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> >( detail::number_kind_complexpow_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class tagb, class A1b, class A2b, class A3b, class A4b> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_complex) && (number_category<detail::expression<tagb, A1b, A2b, A3b, A4b> >::value == number_kind_complex), detail::expression< detail::function , detail::number_kind_complexpow_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> > >::type pow(const detail::expression<tag, A1, A2, A3, A4>& arg, const detail::expression<tagb, A1b, A2b, A3b, A4b>& a){ return detail::expression< detail::function , detail::number_kind_complexpow_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> >( detail::number_kind_complexpow_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_complex), detail::expression< detail::function , detail::number_kind_complexpow_funct<Backend> , number<Backend, et_on> , Arithmetic > >::type pow(const number<Backend, et_on>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_complexpow_funct<Backend> , number<Backend, et_on> , Arithmetic >( detail::number_kind_complexpow_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_complex), detail::expression< detail::function , detail::number_kind_complexpow_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic > >::type pow(const detail::expression<tag, A1, A2, A3, A4>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_complexpow_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic >( detail::number_kind_complexpow_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_complex), detail::expression< detail::function , detail::number_kind_complexpow_funct<Backend> , Arithmetic , number<Backend, et_on> > >::type pow(const Arithmetic& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_complexpow_funct<Backend> , Arithmetic , number<Backend, et_on> >( detail::number_kind_complexpow_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_complex), detail::expression< detail::function , detail::number_kind_complexpow_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> > >::type pow(const Arithmetic& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_complexpow_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_complexpow_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c<(number_category<Backend>::value == number_kind_complex), number<Backend, et_off> >::type pow(const number<Backend, et_off>& arg, const number<Backend, et_off>& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_pow; eval_pow(result.backend(), arg.backend(), a.backend()); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_complex), number<Backend, et_off> >::type pow(const number<Backend, et_off>& arg, const Arithmetic& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_pow; eval_pow(result.backend(), arg.backend(), number<Backend, et_off>::canonical_value(a)); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_complex), number<Backend, et_off> >::type pow(const Arithmetic& a, const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_pow; eval_pow(result.backend(), number<Backend, et_off>::canonical_value(a), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_complexsqrt_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_sqrt; eval_sqrt(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_sqrt; Backend temp; eval_sqrt(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexsqrt_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type sqrt(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_complexsqrt_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_complexsqrt_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexsqrt_funct<Backend> , number<Backend, et_on> > >::type sqrt(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_complexsqrt_funct<Backend> , number<Backend, et_on> >( detail::number_kind_complexsqrt_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_complex, number<Backend, et_off> >::type sqrt(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_sqrt; eval_sqrt(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_complexsin_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_sin; eval_sin(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_sin; Backend temp; eval_sin(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexsin_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type sin(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_complexsin_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_complexsin_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexsin_funct<Backend> , number<Backend, et_on> > >::type sin(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_complexsin_funct<Backend> , number<Backend, et_on> >( detail::number_kind_complexsin_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_complex, number<Backend, et_off> >::type sin(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_sin; eval_sin(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_complexcos_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_cos; eval_cos(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_cos; Backend temp; eval_cos(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexcos_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type cos(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_complexcos_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_complexcos_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexcos_funct<Backend> , number<Backend, et_on> > >::type cos(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_complexcos_funct<Backend> , number<Backend, et_on> >( detail::number_kind_complexcos_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_complex, number<Backend, et_off> >::type cos(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_cos; eval_cos(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_complextan_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_tan; eval_tan(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_tan; Backend temp; eval_tan(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complextan_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type tan(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_complextan_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_complextan_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complextan_funct<Backend> , number<Backend, et_on> > >::type tan(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_complextan_funct<Backend> , number<Backend, et_on> >( detail::number_kind_complextan_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_complex, number<Backend, et_off> >::type tan(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_tan; eval_tan(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_complexasin_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_asin; eval_asin(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_asin; Backend temp; eval_asin(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexasin_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type asin(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_complexasin_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_complexasin_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexasin_funct<Backend> , number<Backend, et_on> > >::type asin(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_complexasin_funct<Backend> , number<Backend, et_on> >( detail::number_kind_complexasin_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_complex, number<Backend, et_off> >::type asin(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_asin; eval_asin(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_complexacos_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_acos; eval_acos(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_acos; Backend temp; eval_acos(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexacos_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type acos(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_complexacos_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_complexacos_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexacos_funct<Backend> , number<Backend, et_on> > >::type acos(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_complexacos_funct<Backend> , number<Backend, et_on> >( detail::number_kind_complexacos_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_complex, number<Backend, et_off> >::type acos(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_acos; eval_acos(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_complexatan_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_atan; eval_atan(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_atan; Backend temp; eval_atan(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexatan_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type atan(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_complexatan_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_complexatan_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexatan_funct<Backend> , number<Backend, et_on> > >::type atan(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_complexatan_funct<Backend> , number<Backend, et_on> >( detail::number_kind_complexatan_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_complex, number<Backend, et_off> >::type atan(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_atan; eval_atan(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_complexsinh_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_sinh; eval_sinh(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_sinh; Backend temp; eval_sinh(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexsinh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type sinh(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_complexsinh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_complexsinh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexsinh_funct<Backend> , number<Backend, et_on> > >::type sinh(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_complexsinh_funct<Backend> , number<Backend, et_on> >( detail::number_kind_complexsinh_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_complex, number<Backend, et_off> >::type sinh(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_sinh; eval_sinh(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_complexcosh_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_cosh; eval_cosh(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_cosh; Backend temp; eval_cosh(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexcosh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type cosh(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_complexcosh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_complexcosh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexcosh_funct<Backend> , number<Backend, et_on> > >::type cosh(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_complexcosh_funct<Backend> , number<Backend, et_on> >( detail::number_kind_complexcosh_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_complex, number<Backend, et_off> >::type cosh(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_cosh; eval_cosh(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_complextanh_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_tanh; eval_tanh(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_tanh; Backend temp; eval_tanh(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complextanh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type tanh(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_complextanh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_complextanh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complextanh_funct<Backend> , number<Backend, et_on> > >::type tanh(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_complextanh_funct<Backend> , number<Backend, et_on> >( detail::number_kind_complextanh_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_complex, number<Backend, et_off> >::type tanh(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_tanh; eval_tanh(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_complexasinh_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_asinh; eval_asinh(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_asinh; Backend temp; eval_asinh(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexasinh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type asinh(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_complexasinh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_complexasinh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexasinh_funct<Backend> , number<Backend, et_on> > >::type asinh(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_complexasinh_funct<Backend> , number<Backend, et_on> >( detail::number_kind_complexasinh_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_complex, number<Backend, et_off> >::type asinh(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_asinh; eval_asinh(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_complexacosh_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_acosh; eval_acosh(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_acosh; Backend temp; eval_acosh(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexacosh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type acosh(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_complexacosh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_complexacosh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexacosh_funct<Backend> , number<Backend, et_on> > >::type acosh(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_complexacosh_funct<Backend> , number<Backend, et_on> >( detail::number_kind_complexacosh_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_complex, number<Backend, et_off> >::type acosh(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_acosh; eval_acosh(result.backend(), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_complexatanh_funct{ void operator()(Backend& result, const Backend& arg)const { using default_ops::eval_atanh; eval_atanh(result, arg); } template <class U> void operator()(U& result, const Backend& arg)const { using default_ops::eval_atanh; Backend temp; eval_atanh(temp, arg); result = temp; }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexatanh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > >::type atanh(const detail::expression<tag, A1, A2, A3, A4>& arg){ return detail::expression< detail::function , detail::number_kind_complexatanh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> > ( detail::number_kind_complexatanh_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg );}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_complex, detail::expression< detail::function , detail::number_kind_complexatanh_funct<Backend> , number<Backend, et_on> > >::type atanh(const number<Backend, et_on>& arg){ return detail::expression< detail::function , detail::number_kind_complexatanh_funct<Backend> , number<Backend, et_on> >( detail::number_kind_complexatanh_funct<Backend>() , arg );}template <class Backend> inline typename boost::enable_if_c< boost::multiprecision::number_category<Backend>::value == number_kind_complex, number<Backend, et_off> >::type atanh(const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops::eval_atanh; eval_atanh(result.backend(), arg.backend()); return std::move(result);}




namespace detail{template <class Backend> struct number_kind_integergcd_funct{ void operator()(Backend& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_gcd; eval_gcd(result, arg, a); } template <class Arithmetic> void operator()(Backend& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_gcd; eval_gcd(result, arg, number<Backend>::canonical_value(a)); } template <class Arithmetic> void operator()(Backend& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_gcd; eval_gcd(result, number<Backend>::canonical_value(arg), a); } template <class U> void operator()(U& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_gcd; Backend r; eval_gcd(r, arg, a); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_gcd; Backend r; eval_gcd(r, arg, number<Backend>::canonical_value(a)); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_gcd; Backend r; eval_gcd(r, number<Backend>::canonical_value(arg), a); result = r; }};}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_integer, detail::expression< detail::function , detail::number_kind_integergcd_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> > >::type gcd(const number<Backend, et_on>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_integergcd_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> >( detail::number_kind_integergcd_funct<Backend>() , arg, a );}template <class Backend, class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<Backend>::value == number_kind_integer) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_integergcd_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> > >::type gcd(const number<Backend, et_on>& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_integergcd_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_integergcd_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_integer) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_integergcd_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> > >::type gcd(const detail::expression<tag, A1, A2, A3, A4>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_integergcd_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> >( detail::number_kind_integergcd_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class tagb, class A1b, class A2b, class A3b, class A4b> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_integer) && (number_category<detail::expression<tagb, A1b, A2b, A3b, A4b> >::value == number_kind_integer), detail::expression< detail::function , detail::number_kind_integergcd_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> > >::type gcd(const detail::expression<tag, A1, A2, A3, A4>& arg, const detail::expression<tagb, A1b, A2b, A3b, A4b>& a){ return detail::expression< detail::function , detail::number_kind_integergcd_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> >( detail::number_kind_integergcd_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_integer), detail::expression< detail::function , detail::number_kind_integergcd_funct<Backend> , number<Backend, et_on> , Arithmetic > >::type gcd(const number<Backend, et_on>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_integergcd_funct<Backend> , number<Backend, et_on> , Arithmetic >( detail::number_kind_integergcd_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_integer), detail::expression< detail::function , detail::number_kind_integergcd_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic > >::type gcd(const detail::expression<tag, A1, A2, A3, A4>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_integergcd_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic >( detail::number_kind_integergcd_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_integer), detail::expression< detail::function , detail::number_kind_integergcd_funct<Backend> , Arithmetic , number<Backend, et_on> > >::type gcd(const Arithmetic& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_integergcd_funct<Backend> , Arithmetic , number<Backend, et_on> >( detail::number_kind_integergcd_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_integer), detail::expression< detail::function , detail::number_kind_integergcd_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> > >::type gcd(const Arithmetic& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_integergcd_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_integergcd_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c<(number_category<Backend>::value == number_kind_integer), number<Backend, et_off> >::type gcd(const number<Backend, et_off>& arg, const number<Backend, et_off>& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_gcd; eval_gcd(result.backend(), arg.backend(), a.backend()); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_integer), number<Backend, et_off> >::type gcd(const number<Backend, et_off>& arg, const Arithmetic& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_gcd; eval_gcd(result.backend(), arg.backend(), number<Backend, et_off>::canonical_value(a)); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_integer), number<Backend, et_off> >::type gcd(const Arithmetic& a, const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_gcd; eval_gcd(result.backend(), number<Backend, et_off>::canonical_value(a), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_integerlcm_funct{ void operator()(Backend& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_lcm; eval_lcm(result, arg, a); } template <class Arithmetic> void operator()(Backend& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_lcm; eval_lcm(result, arg, number<Backend>::canonical_value(a)); } template <class Arithmetic> void operator()(Backend& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_lcm; eval_lcm(result, number<Backend>::canonical_value(arg), a); } template <class U> void operator()(U& result, const Backend& arg, const Backend& a)const { using default_ops:: eval_lcm; Backend r; eval_lcm(r, arg, a); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Backend& arg, const Arithmetic& a)const { using default_ops:: eval_lcm; Backend r; eval_lcm(r, arg, number<Backend>::canonical_value(a)); result = r; } template <class U, class Arithmetic> void operator()(U& result, const Arithmetic& arg, const Backend& a)const { using default_ops:: eval_lcm; Backend r; eval_lcm(r, number<Backend>::canonical_value(arg), a); result = r; }};}template <class Backend> inline typename enable_if_c<number_category<Backend>::value == number_kind_integer, detail::expression< detail::function , detail::number_kind_integerlcm_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> > >::type lcm(const number<Backend, et_on>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_integerlcm_funct<Backend> , number<Backend, et_on> , number<Backend, et_on> >( detail::number_kind_integerlcm_funct<Backend>() , arg, a );}template <class Backend, class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<Backend>::value == number_kind_integer) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_integerlcm_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> > >::type lcm(const number<Backend, et_on>& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_integerlcm_funct<Backend> , number<Backend, et_on> , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_integerlcm_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_integer) && (boost::is_convertible<typename detail::expression<tag, A1, A2, A3, A4>::result_type, number<Backend, et_on> >::value), detail::expression< detail::function , detail::number_kind_integerlcm_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> > >::type lcm(const detail::expression<tag, A1, A2, A3, A4>& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_integerlcm_funct<Backend> , detail::expression<tag, A1, A2, A3, A4> , number<Backend, et_on> >( detail::number_kind_integerlcm_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class tagb, class A1b, class A2b, class A3b, class A4b> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_integer) && (number_category<detail::expression<tagb, A1b, A2b, A3b, A4b> >::value == number_kind_integer), detail::expression< detail::function , detail::number_kind_integerlcm_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> > >::type lcm(const detail::expression<tag, A1, A2, A3, A4>& arg, const detail::expression<tagb, A1b, A2b, A3b, A4b>& a){ return detail::expression< detail::function , detail::number_kind_integerlcm_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , detail::expression<tagb, A1b, A2b, A3b, A4b> >( detail::number_kind_integerlcm_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_integer), detail::expression< detail::function , detail::number_kind_integerlcm_funct<Backend> , number<Backend, et_on> , Arithmetic > >::type lcm(const number<Backend, et_on>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_integerlcm_funct<Backend> , number<Backend, et_on> , Arithmetic >( detail::number_kind_integerlcm_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_integer), detail::expression< detail::function , detail::number_kind_integerlcm_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic > >::type lcm(const detail::expression<tag, A1, A2, A3, A4>& arg, const Arithmetic& a){ return detail::expression< detail::function , detail::number_kind_integerlcm_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , Arithmetic >( detail::number_kind_integerlcm_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_on> >::value && (number_category<Backend>::value == number_kind_integer), detail::expression< detail::function , detail::number_kind_integerlcm_funct<Backend> , Arithmetic , number<Backend, et_on> > >::type lcm(const Arithmetic& arg, const number<Backend, et_on>& a){ return detail::expression< detail::function , detail::number_kind_integerlcm_funct<Backend> , Arithmetic , number<Backend, et_on> >( detail::number_kind_integerlcm_funct<Backend>() , arg, a );}template <class tag, class A1, class A2, class A3, class A4, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, typename detail::expression<tag, A1, A2, A3, A4>::result_type>::value && (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_integer), detail::expression< detail::function , detail::number_kind_integerlcm_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> > >::type lcm(const Arithmetic& arg, const detail::expression<tag, A1, A2, A3, A4>& a){ return detail::expression< detail::function , detail::number_kind_integerlcm_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , Arithmetic , detail::expression<tag, A1, A2, A3, A4> >( detail::number_kind_integerlcm_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c<(number_category<Backend>::value == number_kind_integer), number<Backend, et_off> >::type lcm(const number<Backend, et_off>& arg, const number<Backend, et_off>& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_lcm; eval_lcm(result.backend(), arg.backend(), a.backend()); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_integer), number<Backend, et_off> >::type lcm(const number<Backend, et_off>& arg, const Arithmetic& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_lcm; eval_lcm(result.backend(), arg.backend(), number<Backend, et_off>::canonical_value(a)); return std::move(result);}template <class Backend, class Arithmetic> inline typename enable_if_c< is_compatible_arithmetic_type<Arithmetic, number<Backend, et_off> >::value && (number_category<Backend>::value == number_kind_integer), number<Backend, et_off> >::type lcm(const Arithmetic& a, const number<Backend, et_off>& arg){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg); number<Backend, et_off> result; using default_ops:: eval_lcm; eval_lcm(result.backend(), number<Backend, et_off>::canonical_value(a), arg.backend()); return std::move(result);}
namespace detail{template <class Backend> struct number_kind_integerpow_funct{ template <class Arg> void operator()(Backend& result, Backend const& arg, Arg a)const { using default_ops:: eval_pow; eval_pow(result, arg, a); }};}template <class tag, class A1, class A2, class A3, class A4> inline typename enable_if_c< (number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_integer), detail::expression< detail::function , detail::number_kind_integerpow_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , unsigned> >::type pow(const detail::expression<tag, A1, A2, A3, A4>& arg, unsigned const& a){ return detail::expression< detail::function , detail::number_kind_integerpow_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type> , detail::expression<tag, A1, A2, A3, A4> , unsigned >( detail::number_kind_integerpow_funct<typename detail::backend_type<detail::expression<tag, A1, A2, A3, A4> >::type>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_integer), detail::expression< detail::function , detail::number_kind_integerpow_funct<Backend> , number<Backend, et_on> , unsigned> >::type pow(const number<Backend, et_on>& arg, unsigned const& a){ return detail::expression< detail::function , detail::number_kind_integerpow_funct<Backend> , number<Backend, et_on> , unsigned >( detail::number_kind_integerpow_funct<Backend>() , arg, a );}template <class Backend> inline typename enable_if_c< (number_category<Backend>::value == number_kind_integer), number<Backend, et_off> >::type pow(const number<Backend, et_off>& arg, unsigned const& a){ detail::scoped_default_precision<multiprecision::number<Backend, et_off> > precision_guard(arg, a); number<Backend, et_off> result; using default_ops:: eval_pow; eval_pow(result.backend(), arg.backend(), a); return std::move(result);}







template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
inline typename enable_if_c<number_category<Backend>::value == number_kind_floating_point, typename Backend::exponent_type>::type
   ilogb(const multiprecision::number<Backend, ExpressionTemplates>& val)
{
   using default_ops::eval_ilogb;
   return eval_ilogb(val.backend());
}

template <class tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<number_category<detail::expression<tag, A1, A2, A3, A4> >::value == number_kind_floating_point, typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type::backend_type::exponent_type>::type
ilogb(const detail::expression<tag, A1, A2, A3, A4>& val)
{
   using default_ops::eval_ilogb;
   typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type arg(val);
   return eval_ilogb(arg.backend());
}

}

namespace math{



namespace detail{
   template <class T> T sinc_pi_imp(T);
   template <class T> T sinhc_pi_imp(T);
}
template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
inline multiprecision::number<Backend, ExpressionTemplates> sinc_pi(const multiprecision::number<Backend, ExpressionTemplates>& x)
{
   boost::multiprecision::detail::scoped_default_precision<multiprecision::number<Backend, ExpressionTemplates> > precision_guard(x);
   return std::move(detail::sinc_pi_imp(x));
}

template <class Backend, multiprecision::expression_template_option ExpressionTemplates, class Policy>
inline multiprecision::number<Backend, ExpressionTemplates> sinc_pi(const multiprecision::number<Backend, ExpressionTemplates>& x, const Policy&)
{
   boost::multiprecision::detail::scoped_default_precision<multiprecision::number<Backend, ExpressionTemplates> > precision_guard(x);
   return std::move(detail::sinc_pi_imp(x));
}

template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
inline multiprecision::number<Backend, ExpressionTemplates> sinhc_pi(const multiprecision::number<Backend, ExpressionTemplates>& x)
{
   boost::multiprecision::detail::scoped_default_precision<multiprecision::number<Backend, ExpressionTemplates> > precision_guard(x);
   return std::move(detail::sinhc_pi_imp(x));
}

template <class Backend, multiprecision::expression_template_option ExpressionTemplates, class Policy>
inline multiprecision::number<Backend, ExpressionTemplates> sinhc_pi(const multiprecision::number<Backend, ExpressionTemplates>& x, const Policy&)
{
   boost::multiprecision::detail::scoped_default_precision<multiprecision::number<Backend, ExpressionTemplates> > precision_guard(x);
   return std::move(boost::math::sinhc_pi(x));
}

using boost::multiprecision::gcd;
using boost::multiprecision::lcm;




}

namespace integer {

using boost::multiprecision::gcd;
using boost::multiprecision::lcm;

}

}





namespace boost{
namespace multiprecision{






template <class B>
inline number<B, et_off> operator - (const number<B, et_off>& v)
{
   static_assert(is_signed_number<B>::value, "Negating an unsigned type results in ill-defined behavior.");
   detail::scoped_default_precision<multiprecision::number<B, et_off> > precision_guard(v);
   number<B, et_off> result(v);
   result.backend().negate();
   return result;
}
template <class B>
inline number<B, et_off> operator ~ (const number<B, et_off>& v)
{
   detail::scoped_default_precision<multiprecision::number<B, et_off> > precision_guard(v);
   number<B, et_off> result;
   eval_complement(result.backend(), v.backend());
   return result;
}



template <class B>
inline number<B, et_off> operator + (const number<B, et_off>& a, const number<B, et_off>& b)
{
   detail::scoped_default_precision<multiprecision::number<B, et_off> > precision_guard(a, b);
   number<B, et_off> result;
   using default_ops::eval_add;
   eval_add(result.backend(), a.backend(), b.backend());
   return result;
}
template <class B, class V>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_off> >, number<B, et_off> >::type
   operator + (const number<B, et_off>& a, const V& b)
{
   detail::scoped_default_precision<multiprecision::number<B, et_off> > precision_guard(a);
   number<B, et_off> result;
   using default_ops::eval_add;
   eval_add(result.backend(), a.backend(), number<B, et_off>::canonical_value(b));
   return result;
}
template <class V, class B>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_off> >, number<B, et_off> >::type
   operator + (const V& a, const number<B, et_off>& b)
{
   detail::scoped_default_precision<multiprecision::number<B, et_off> > precision_guard(b);
   number<B, et_off> result;
   using default_ops::eval_add;
   eval_add(result.backend(), b.backend(), number<B, et_off>::canonical_value(a));
   return result;
}



template <class B>
inline number<B, et_off> operator - (const number<B, et_off>& a, const number<B, et_off>& b)
{
   detail::scoped_default_precision<multiprecision::number<B, et_off> > precision_guard(a, b);
   number<B, et_off> result;
   using default_ops::eval_subtract;
   eval_subtract(result.backend(), a.backend(), b.backend());
   return result;
}
template <class B, class V>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_off> >, number<B, et_off> >::type
   operator - (const number<B, et_off>& a, const V& b)
{
   detail::scoped_default_precision<multiprecision::number<B, et_off> > precision_guard(a);
   number<B, et_off> result;
   using default_ops::eval_subtract;
   eval_subtract(result.backend(), a.backend(), number<B, et_off>::canonical_value(b));
   return result;
}
template <class V, class B>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_off> >, number<B, et_off> >::type
   operator - (const V& a, const number<B, et_off>& b)
{
   detail::scoped_default_precision<multiprecision::number<B, et_off> > precision_guard(b);
   number<B, et_off> result;
   using default_ops::eval_subtract;
   eval_subtract(result.backend(), number<B, et_off>::canonical_value(a), b.backend());
   return result;
}



template <class B>
inline number<B, et_off> operator * (const number<B, et_off>& a, const number<B, et_off>& b)
{
   detail::scoped_default_precision<multiprecision::number<B, et_off> > precision_guard(a, b);
   number<B, et_off> result;
   using default_ops::eval_multiply;
   eval_multiply(result.backend(), a.backend(), b.backend());
   return result;
}
template <class B, class V>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_off> >, number<B, et_off> >::type
   operator * (const number<B, et_off>& a, const V& b)
{
   detail::scoped_default_precision<multiprecision::number<B, et_off> > precision_guard(a);
   number<B, et_off> result;
   using default_ops::eval_multiply;
   eval_multiply(result.backend(), a.backend(), number<B, et_off>::canonical_value(b));
   return result;
}
template <class V, class B>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_off> >, number<B, et_off> >::type
   operator * (const V& a, const number<B, et_off>& b)
{
   detail::scoped_default_precision<multiprecision::number<B, et_off> > precision_guard(b);
   number<B, et_off> result;
   using default_ops::eval_multiply;
   eval_multiply(result.backend(), b.backend(), number<B, et_off>::canonical_value(a));
   return result;
}



template <class B>
inline number<B, et_off> operator / (const number<B, et_off>& a, const number<B, et_off>& b)
{
   detail::scoped_default_precision<multiprecision::number<B, et_off> > precision_guard(a, b);
   number<B, et_off> result;
   using default_ops::eval_divide;
   eval_divide(result.backend(), a.backend(), b.backend());
   return result;
}
template <class B, class V>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_off> >, number<B, et_off> >::type
   operator / (const number<B, et_off>& a, const V& b)
{
   detail::scoped_default_precision<multiprecision::number<B, et_off> > precision_guard(a);
   number<B, et_off> result;
   using default_ops::eval_divide;
   eval_divide(result.backend(), a.backend(), number<B, et_off>::canonical_value(b));
   return result;
}
template <class V, class B>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_off> >, number<B, et_off> >::type
   operator / (const V& a, const number<B, et_off>& b)
{
   detail::scoped_default_precision<multiprecision::number<B, et_off> > precision_guard(b);
   number<B, et_off> result;
   using default_ops::eval_divide;
   eval_divide(result.backend(), number<B, et_off>::canonical_value(a), b.backend());
   return result;
}



template <class B>
inline typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator % (const number<B, et_off>& a, const number<B, et_off>& b)
{
   detail::scoped_default_precision<multiprecision::number<B, et_off> > precision_guard(a, b);
   number<B, et_off> result;
   using default_ops::eval_modulus;
   eval_modulus(result.backend(), a.backend(), b.backend());
   return result;
}
template <class B, class V>
inline typename enable_if_c<is_compatible_arithmetic_type<V, number<B, et_off> >::value && (number_category<B>::value == number_kind_integer), number<B, et_off> >::type
   operator % (const number<B, et_off>& a, const V& b)
{
   detail::scoped_default_precision<multiprecision::number<B, et_off> > precision_guard(a);
   number<B, et_off> result;
   using default_ops::eval_modulus;
   eval_modulus(result.backend(), a.backend(), number<B, et_off>::canonical_value(b));
   return result;
}
template <class V, class B>
inline typename enable_if_c<is_compatible_arithmetic_type<V, number<B, et_off> >::value && (number_category<B>::value == number_kind_integer), number<B, et_off> >::type
   operator % (const V& a, const number<B, et_off>& b)
{
   detail::scoped_default_precision<multiprecision::number<B, et_off> > precision_guard(b);
   number<B, et_off> result;
   using default_ops::eval_modulus;
   eval_modulus(result.backend(), number<B, et_off>::canonical_value(a), b.backend());
   return result;
}



template <class B>
inline typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator | (const number<B, et_off>& a, const number<B, et_off>& b)
{
   number<B, et_off> result;
   using default_ops::eval_bitwise_or;
   eval_bitwise_or(result.backend(), a.backend(), b.backend());
   return result;
}
template <class B, class V>
inline typename enable_if_c<is_compatible_arithmetic_type<V, number<B, et_off> >::value && (number_category<B>::value == number_kind_integer), number<B, et_off> >::type
   operator | (const number<B, et_off>& a, const V& b)
{
   number<B, et_off> result;
   using default_ops::eval_bitwise_or;
   eval_bitwise_or(result.backend(), a.backend(), number<B, et_off>::canonical_value(b));
   return result;
}
template <class V, class B>
inline typename enable_if_c<is_compatible_arithmetic_type<V, number<B, et_off> >::value && (number_category<B>::value == number_kind_integer), number<B, et_off> >::type
   operator | (const V& a, const number<B, et_off>& b)
{
   number<B, et_off> result;
   using default_ops::eval_bitwise_or;
   eval_bitwise_or(result.backend(), b.backend(), number<B, et_off>::canonical_value(a));
   return result;
}



template <class B>
inline typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator ^ (const number<B, et_off>& a, const number<B, et_off>& b)
{
   number<B, et_off> result;
   using default_ops::eval_bitwise_xor;
   eval_bitwise_xor(result.backend(), a.backend(), b.backend());
   return result;
}
template <class B, class V>
inline typename enable_if_c<is_compatible_arithmetic_type<V, number<B, et_off> >::value && (number_category<B>::value == number_kind_integer), number<B, et_off> >::type
   operator ^ (const number<B, et_off>& a, const V& b)
{
   number<B, et_off> result;
   using default_ops::eval_bitwise_xor;
   eval_bitwise_xor(result.backend(), a.backend(), number<B, et_off>::canonical_value(b));
   return result;
}
template <class V, class B>
inline typename enable_if_c<is_compatible_arithmetic_type<V, number<B, et_off> >::value && (number_category<B>::value == number_kind_integer), number<B, et_off> >::type
   operator ^ (const V& a, const number<B, et_off>& b)
{
   number<B, et_off> result;
   using default_ops::eval_bitwise_xor;
   eval_bitwise_xor(result.backend(), b.backend(), number<B, et_off>::canonical_value(a));
   return result;
}



template <class B>
inline typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator & (const number<B, et_off>& a, const number<B, et_off>& b)
{
   number<B, et_off> result;
   using default_ops::eval_bitwise_and;
   eval_bitwise_and(result.backend(), a.backend(), b.backend());
   return result;
}
template <class B, class V>
inline typename enable_if_c<is_compatible_arithmetic_type<V, number<B, et_off> >::value && (number_category<B>::value == number_kind_integer), number<B, et_off> >::type
   operator & (const number<B, et_off>& a, const V& b)
{
   number<B, et_off> result;
   using default_ops::eval_bitwise_and;
   eval_bitwise_and(result.backend(), a.backend(), number<B, et_off>::canonical_value(b));
   return result;
}
template <class V, class B>
inline typename enable_if_c<is_compatible_arithmetic_type<V, number<B, et_off> >::value && (number_category<B>::value == number_kind_integer), number<B, et_off> >::type
   operator & (const V& a, const number<B, et_off>& b)
{
   number<B, et_off> result;
   using default_ops::eval_bitwise_and;
   eval_bitwise_and(result.backend(), b.backend(), number<B, et_off>::canonical_value(a));
   return result;
}



template <class B, class I>
inline typename enable_if_c<is_integral<I>::value && (number_category<B>::value == number_kind_integer), number<B, et_off> >::type
   operator << (const number<B, et_off>& a, const I& b)
{
   number<B, et_off> result(a);
   using default_ops::eval_left_shift;
   detail::check_shift_range(b, mpl::bool_<(sizeof(I) > sizeof(std::size_t))>(), is_signed<I>());
   eval_left_shift(result.backend(), b);
   return result;
}
template <class B, class I>
inline typename enable_if_c<is_integral<I>::value && (number_category<B>::value == number_kind_integer), number<B, et_off> >::type
   operator >> (const number<B, et_off>& a, const I& b)
{
   number<B, et_off> result(a);
   using default_ops::eval_right_shift;
   detail::check_shift_range(b, mpl::bool_<(sizeof(I) > sizeof(std::size_t))>(), is_signed<I>());
   eval_right_shift(result.backend(), b);
   return result;
}
}}








namespace boost{ namespace multiprecision{
template <class B, expression_template_option ExpressionTemplates>
inline constexpr const number<B, ExpressionTemplates> operator + (const number<B, ExpressionTemplates>& v) { return v; }
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4>
inline constexpr const detail::expression<tag, Arg1, Arg2, Arg3, Arg4> operator + (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v) { return v; }
template <class B>
inline detail::expression<detail::negate, number<B, et_on> > operator - (const number<B, et_on>& v)
{
   static_assert(is_signed_number<B>::value, "Negating an unsigned type results in ill-defined behavior.");
   return detail::expression<detail::negate, number<B, et_on> >(v);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4>
inline detail::expression<detail::negate, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > operator - (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v)
{
   static_assert((is_signed_number<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value), "Negating an unsigned type results in ill-defined behavior.");
   return detail::expression<detail::negate, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(v);
}
template <class B>
inline typename enable_if_c<number_category<B>::value == number_kind_integer,
   detail::expression<detail::complement_immediates, number<B, et_on> > >::type
      operator ~ (const number<B, et_on>& v) { return detail::expression<detail::complement_immediates, number<B, et_on> >(v); }
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename enable_if_c<number_category<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value == number_kind_integer,
   detail::expression<detail::bitwise_complement, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > >::type
      operator ~ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v) { return detail::expression<detail::bitwise_complement, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(v); }



template <class B>
inline detail::expression<detail::add_immediates, number<B, et_on>, number<B, et_on> >
   operator + (const number<B, et_on>& a, const number<B, et_on>& b)
{
   return detail::expression<detail::add_immediates, number<B, et_on>, number<B, et_on> >(a, b);
}
template <class B, class V>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_on> >, detail::expression<detail::add_immediates, number<B, et_on>, V > >::type
   operator + (const number<B, et_on>& a, const V& b)
{
   return detail::expression<detail::add_immediates, number<B, et_on>, V >(a, b);
}
template <class V, class B>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_on> >, detail::expression<detail::add_immediates, V, number<B, et_on> > >::type
   operator + (const V& a, const number<B, et_on>& b)
{
   return detail::expression<detail::add_immediates, V, number<B, et_on> >(a, b);
}
template <class B, expression_template_option ET, class tag, class Arg1, class Arg2, class Arg3, class Arg4>
inline detail::expression<detail::plus, number<B, ET>, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >
   operator + (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::plus, number<B, ET>, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class B, expression_template_option ET>
inline detail::expression<detail::plus, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, ET> >
   operator + (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
{
   return detail::expression<detail::plus, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, ET> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class tag2, class Arg1b, class Arg2b, class Arg3b, class Arg4b>
inline detail::expression<detail::plus, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b> >
   operator + (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
{
   return detail::expression<detail::plus, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class V>
inline typename enable_if<is_compatible_arithmetic_type<V, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>, detail::expression<detail::plus, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V > >::type
   operator + (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
{
   return detail::expression<detail::plus, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V >(a, b);
}
template <class V, class tag, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename enable_if<is_compatible_arithmetic_type<V, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>, detail::expression<detail::plus, V, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > >::type
   operator + (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::plus, V, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(a, b);
}



template <class V, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename enable_if<is_compatible_arithmetic_type<V, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::result_type>,
   detail::expression<detail::multiply_add, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::left_type, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::right_type, V> >::type
   operator + (const V& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::multiply_add, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::left_type, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::right_type, V>(b.left(), b.right(), a);
}
template <class Arg1, class Arg2, class Arg3, class Arg4, class V>
inline typename enable_if<is_compatible_arithmetic_type<V, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::result_type>,
   detail::expression<detail::multiply_add, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::left_type, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::right_type, V> >::type
   operator + (const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
{
   return detail::expression<detail::multiply_add, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::left_type, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::right_type, V>(a.left(), a.right(), b);
}
template <class B, expression_template_option ET, class Arg1, class Arg2, class Arg3, class Arg4>
inline detail::expression<detail::multiply_add, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::left_type, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::right_type, number<B, ET> >
   operator + (const number<B, ET>& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::multiply_add, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::left_type, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::right_type, number<B, ET> >(b.left(), b.right(), a);
}
template <class Arg1, class Arg2, class Arg3, class Arg4, class B, expression_template_option ET>
inline detail::expression<detail::multiply_add, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::left_type, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::right_type, number<B, ET> >
   operator + (const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
{
   return detail::expression<detail::multiply_add, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::left_type, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::right_type, number<B, ET> >(a.left(), a.right(), b);
}



template <class V, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename enable_if<is_compatible_arithmetic_type<V, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::result_type>,
   detail::expression<detail::negate, detail::expression<detail::multiply_subtract, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::left_type, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::right_type, V> > >::type
   operator - (const V& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::negate, detail::expression<detail::multiply_subtract, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::left_type, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::right_type, V> >
      (detail::expression<detail::multiply_subtract, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::left_type, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::right_type, V>(b.left(), b.right(), a));
}
template <class Arg1, class Arg2, class Arg3, class Arg4, class V>
inline typename enable_if<is_compatible_arithmetic_type<V, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::result_type>,
   detail::expression<detail::multiply_subtract, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::left_type, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::right_type, V> >::type
   operator - (const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
{
   return detail::expression<detail::multiply_subtract, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::left_type, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::right_type, V>(a.left(), a.right(), b);
}
template <class B, expression_template_option ET, class Arg1, class Arg2, class Arg3, class Arg4>
inline detail::expression<detail::negate, detail::expression<detail::multiply_subtract, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::left_type, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::right_type, number<B, ET> > >
   operator - (const number<B, ET>& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::negate, detail::expression<detail::multiply_subtract, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::left_type, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::right_type, number<B, ET> > >
      (detail::expression<detail::multiply_subtract, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::left_type, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::right_type, number<B, ET> >(b.left(), b.right(), a));
}
template <class Arg1, class Arg2, class Arg3, class Arg4, class B, expression_template_option ET>
inline detail::expression<detail::multiply_subtract, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::left_type, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::right_type, number<B, ET> >
   operator - (const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
{
   return detail::expression<detail::multiply_subtract, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::left_type, typename detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>::right_type, number<B, ET> >(a.left(), a.right(), b);
}



template <class B, expression_template_option ET, class Arg1, class Arg2, class Arg3, class Arg4>
inline detail::expression<detail::minus, number<B, ET>, Arg1>
   operator + (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::minus, number<B, ET>, Arg1>(a, b.left_ref());
}
template <class Arg1, class Arg2, class Arg3, class Arg4, class B, expression_template_option ET>
inline detail::expression<detail::minus, number<B, ET>, Arg1>
   operator + (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
{
   return detail::expression<detail::minus, number<B, ET>, Arg1>(b, a.left_ref());
}
template <class B>
inline detail::expression<detail::subtract_immediates, number<B, et_on>, number<B, et_on> >
   operator + (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
{
   return detail::expression<detail::subtract_immediates, number<B, et_on>, number<B, et_on> >(a, b.left_ref());
}
template <class B>
inline detail::expression<detail::subtract_immediates, number<B, et_on>, number<B, et_on> >
   operator + (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
{
   return detail::expression<detail::subtract_immediates, number<B, et_on>, number<B, et_on> >(b, a.left_ref());
}
template <class B, class V>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_on> >, detail::expression<detail::subtract_immediates, V, number<B, et_on> > >::type
   operator + (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
{
   return detail::expression<detail::subtract_immediates, V, number<B, et_on> >(b, a.left_ref());
}
template <class B, class B2, expression_template_option ET>
inline typename enable_if<is_compatible_arithmetic_type<number<B2, ET>, number<B, et_on> >, detail::expression<detail::subtract_immediates, number<B2, ET>, number<B, et_on> > >::type
   operator + (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
{
   return detail::expression<detail::subtract_immediates, number<B2, ET>, number<B, et_on> >(b, a.left_ref());
}
template <class B2, expression_template_option ET, class B>
inline typename enable_if<is_compatible_arithmetic_type<number<B2, ET>, number<B, et_on> >, detail::expression<detail::subtract_immediates, number<B2, ET>, number<B, et_on> > >::type
   operator + (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
{
   return detail::expression<detail::subtract_immediates, number<B2, ET>, number<B, et_on> >(a, b.left_ref());
}
template <class B>
inline detail::expression<detail::negate, detail::expression<detail::add_immediates, number<B, et_on>, number<B, et_on> > >
   operator + (const detail::expression<detail::negate, number<B, et_on> >& a, const detail::expression<detail::negate, number<B, et_on> >& b)
{
   return detail::expression<detail::negate, detail::expression<detail::add_immediates, number<B, et_on>, number<B, et_on> > >(detail::expression<detail::add_immediates, number<B, et_on>, number<B, et_on> >(a.left_ref(), b.left_ref()));
}



template <class B>
inline detail::expression<detail::subtract_immediates, number<B, et_on>, number<B, et_on> >
   operator - (const number<B, et_on>& a, const number<B, et_on>& b)
{
   return detail::expression<detail::subtract_immediates, number<B, et_on>, number<B, et_on> >(a, b);
}
template <class B, class V>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_on> >, detail::expression<detail::subtract_immediates, number<B, et_on>, V > >::type
   operator - (const number<B, et_on>& a, const V& b)
{
   return detail::expression<detail::subtract_immediates, number<B, et_on>, V >(a, b);
}
template <class V, class B>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_on> >, detail::expression<detail::subtract_immediates, V, number<B, et_on> > >::type
   operator - (const V& a, const number<B, et_on>& b)
{
   return detail::expression<detail::subtract_immediates, V, number<B, et_on> >(a, b);
}
template <class B, expression_template_option ET, class tag, class Arg1, class Arg2, class Arg3, class Arg4>
inline detail::expression<detail::minus, number<B, ET>, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >
   operator - (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::minus, number<B, ET>, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class B, expression_template_option ET>
inline detail::expression<detail::minus, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, ET> >
   operator - (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
{
   return detail::expression<detail::minus, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, ET> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class tag2, class Arg1b, class Arg2b, class Arg3b, class Arg4b>
inline detail::expression<detail::minus, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b> >
   operator - (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
{
   return detail::expression<detail::minus, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class V>
inline typename enable_if<is_compatible_arithmetic_type<V, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>, detail::expression<detail::minus, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V > >::type
   operator - (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
{
   return detail::expression<detail::minus, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V >(a, b);
}
template <class V, class tag, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename enable_if<is_compatible_arithmetic_type<V, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>, detail::expression<detail::minus, V, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > >::type
   operator - (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::minus, V, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(a, b);
}



template <class B, expression_template_option ET, class Arg1, class Arg2, class Arg3, class Arg4>
inline detail::expression<detail::plus, number<B, ET>, Arg1>
   operator - (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::plus, number<B, ET>, Arg1>(a, b.left_ref());
}
template <class Arg1, class Arg2, class Arg3, class Arg4, class B, expression_template_option ET>
inline detail::expression<detail::negate, detail::expression<detail::plus, number<B, ET>, Arg1> >
   operator - (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
{
   return detail::expression<detail::negate, detail::expression<detail::plus, number<B, ET>, Arg1> >(
      detail::expression<detail::plus, number<B, ET>, Arg1>(b, a.left_ref()));
}
template <class B>
inline detail::expression<detail::add_immediates, number<B, et_on>, number<B, et_on> >
   operator - (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
{
   return detail::expression<detail::add_immediates, number<B, et_on>, number<B, et_on> >(a, b.left_ref());
}
template <class B>
inline detail::expression<detail::negate, detail::expression<detail::add_immediates, number<B, et_on>, number<B, et_on> > >
   operator - (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
{
   return detail::expression<detail::negate, detail::expression<detail::add_immediates, number<B, et_on>, number<B, et_on> > >(
      detail::expression<detail::add_immediates, number<B, et_on>, number<B, et_on> >(b, a.left_ref()));
}
template <class B, class V>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_on> >, detail::expression<detail::negate, detail::expression<detail::add_immediates, number<B, et_on>, V > > >::type
   operator - (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
{
   return detail::expression<detail::negate, detail::expression<detail::add_immediates, number<B, et_on>, V > >(detail::expression<detail::add_immediates, number<B, et_on>, V >(a.left_ref(), b));
}
template <class B, class B2, expression_template_option ET>
inline typename enable_if<is_compatible_arithmetic_type<number<B2, ET>, number<B, et_on> >, detail::expression<detail::negate, detail::expression<detail::add_immediates, number<B, et_on>, number<B2, ET> > > >::type
   operator - (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
{
   return detail::expression<detail::negate, detail::expression<detail::add_immediates, number<B, et_on>, number<B2, ET> > >(detail::expression<detail::add_immediates, number<B, et_on>, number<B2, ET> >(a.left_ref(), b));
}
template <class V, class B>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_on> >, detail::expression<detail::add_immediates, V, number<B, et_on> > >::type
   operator - (const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)
{
   return detail::expression<detail::add_immediates, V, number<B, et_on> >(a, b.left_ref());
}
template <class B2, expression_template_option ET, class B>
inline typename enable_if<is_compatible_arithmetic_type<number<B2, ET>, number<B, et_on> >, detail::expression<detail::add_immediates, number<B2, ET>, number<B, et_on> > >::type
   operator - (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
{
   return detail::expression<detail::add_immediates, number<B2, ET>, number<B, et_on> >(a, b.left_ref());
}



template <class B>
inline detail::expression<detail::multiply_immediates, number<B, et_on>, number<B, et_on> >
   operator * (const number<B, et_on>& a, const number<B, et_on>& b)
{
   return detail::expression<detail::multiply_immediates, number<B, et_on>, number<B, et_on> >(a, b);
}
template <class B, class V>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_on> >, detail::expression<detail::multiply_immediates, number<B, et_on>, V > >::type
   operator * (const number<B, et_on>& a, const V& b)
{
   return detail::expression<detail::multiply_immediates, number<B, et_on>, V >(a, b);
}
template <class V, class B>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_on> >, detail::expression<detail::multiply_immediates, V, number<B, et_on> > >::type
   operator * (const V& a, const number<B, et_on>& b)
{
   return detail::expression<detail::multiply_immediates, V, number<B, et_on> >(a, b);
}
template <class B, expression_template_option ET, class tag, class Arg1, class Arg2, class Arg3, class Arg4>
inline detail::expression<detail::multiplies, number<B, ET>, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >
   operator * (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::multiplies, number<B, ET>, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class B, expression_template_option ET>
inline detail::expression<detail::multiplies, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, ET> >
   operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
{
   return detail::expression<detail::multiplies, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, ET> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class tag2, class Arg1b, class Arg2b, class Arg3b, class Arg4b>
inline detail::expression<detail::multiplies, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b> >
   operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
{
   return detail::expression<detail::multiplies, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class V>
inline typename enable_if<is_compatible_arithmetic_type<V, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>, detail::expression<detail::multiplies, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V > >::type
   operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
{
   return detail::expression<detail::multiplies, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V >(a, b);
}
template <class V, class tag, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename enable_if<is_compatible_arithmetic_type<V, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>, detail::expression<detail::multiplies, V, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > >::type
   operator * (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::multiplies, V, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(a, b);
}



template <class B, expression_template_option ET, class Arg1, class Arg2, class Arg3, class Arg4>
inline detail::expression<detail::negate, detail::expression<detail::multiplies, number<B, ET>, Arg1> >
   operator * (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::negate, detail::expression<detail::multiplies, number<B, ET>, Arg1> >(
      detail::expression<detail::multiplies, number<B, ET>, Arg1> (a, b.left_ref()));
}
template <class Arg1, class Arg2, class Arg3, class Arg4, class B, expression_template_option ET>
inline detail::expression<detail::negate, detail::expression<detail::multiplies, number<B, ET>, Arg1> >
   operator * (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
{
   return detail::expression<detail::negate, detail::expression<detail::multiplies, number<B, ET>, Arg1> >(
      detail::expression<detail::multiplies, number<B, ET>, Arg1>(b, a.left_ref()));
}
template <class B>
inline detail::expression<detail::negate, detail::expression<detail::multiply_immediates, number<B, et_on>, number<B, et_on> > >
   operator * (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
{
   return detail::expression<detail::negate, detail::expression<detail::multiply_immediates, number<B, et_on>, number<B, et_on> > >(
      detail::expression<detail::multiply_immediates, number<B, et_on>, number<B, et_on> >(a, b.left_ref()));
}
template <class B>
inline detail::expression<detail::negate, detail::expression<detail::multiply_immediates, number<B, et_on>, number<B, et_on> > >
   operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
{
   return detail::expression<detail::negate, detail::expression<detail::multiply_immediates, number<B, et_on>, number<B, et_on> > >(
      detail::expression<detail::multiply_immediates, number<B, et_on>, number<B, et_on> >(b, a.left_ref()));
}
template <class B, class V>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_on> >, detail::expression<detail::negate, detail::expression<detail::multiply_immediates, number<B, et_on>, V > > >::type
   operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
{
   return detail::expression<detail::negate, detail::expression<detail::multiply_immediates, number<B, et_on>, V > > (
      detail::expression<detail::multiply_immediates, number<B, et_on>, V >(a.left_ref(), b));
}
template <class B, class B2, expression_template_option ET>
inline typename enable_if<is_compatible_arithmetic_type<number<B2, ET>, number<B, et_on> >, detail::expression<detail::negate, detail::expression<detail::multiply_immediates, number<B, et_on>, number<B2, ET> > > >::type
   operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
{
   return detail::expression<detail::negate, detail::expression<detail::multiply_immediates, number<B, et_on>, number<B2, ET> > > (
      detail::expression<detail::multiply_immediates, number<B, et_on>, number<B2, ET> >(a.left_ref(), b));
}
template <class V, class B>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_on> >, detail::expression<detail::negate, detail::expression<detail::multiply_immediates, number<B, et_on>, V > > >::type
   operator * (const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)
{
   return detail::expression<detail::negate, detail::expression<detail::multiply_immediates, number<B, et_on>, V > >(
      detail::expression<detail::multiply_immediates, number<B, et_on>, V >(b.left_ref(), a));
}
template <class B2, expression_template_option ET, class B>
inline typename enable_if<is_compatible_arithmetic_type<number<B2, ET>, number<B, et_on> >, detail::expression<detail::negate, detail::expression<detail::multiply_immediates, number<B, et_on>, number<B2, ET> > > >::type
   operator * (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
{
   return detail::expression<detail::negate, detail::expression<detail::multiply_immediates, number<B, et_on>, number<B2, ET> > >(
      detail::expression<detail::multiply_immediates, number<B, et_on>, number<B2, ET> >(b.left_ref(), a));
}



template <class B>
inline detail::expression<detail::divide_immediates, number<B, et_on>, number<B, et_on> >
   operator / (const number<B, et_on>& a, const number<B, et_on>& b)
{
   return detail::expression<detail::divide_immediates, number<B, et_on>, number<B, et_on> >(a, b);
}
template <class B, class V>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_on> >, detail::expression<detail::divide_immediates, number<B, et_on>, V > >::type
   operator / (const number<B, et_on>& a, const V& b)
{
   return detail::expression<detail::divide_immediates, number<B, et_on>, V >(a, b);
}
template <class V, class B>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_on> >, detail::expression<detail::divide_immediates, V, number<B, et_on> > >::type
   operator / (const V& a, const number<B, et_on>& b)
{
   return detail::expression<detail::divide_immediates, V, number<B, et_on> >(a, b);
}
template <class B, expression_template_option ET, class tag, class Arg1, class Arg2, class Arg3, class Arg4>
inline detail::expression<detail::divides, number<B, ET>, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >
   operator / (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::divides, number<B, ET>, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class B, expression_template_option ET>
inline detail::expression<detail::divides, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, ET> >
   operator / (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
{
   return detail::expression<detail::divides, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, ET> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class tag2, class Arg1b, class Arg2b, class Arg3b, class Arg4b>
inline detail::expression<detail::divides, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b> >
   operator / (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
{
   return detail::expression<detail::divides, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class V>
inline typename enable_if<is_compatible_arithmetic_type<V, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>, detail::expression<detail::divides, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V > >::type
   operator / (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
{
   return detail::expression<detail::divides, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V >(a, b);
}
template <class V, class tag, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename enable_if<is_compatible_arithmetic_type<V, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>, detail::expression<detail::divides, V, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > >::type
   operator / (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::divides, V, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(a, b);
}



template <class B, expression_template_option ET, class Arg1, class Arg2, class Arg3, class Arg4>
inline detail::expression<detail::negate, detail::expression<detail::divides, number<B, ET>, Arg1> >
   operator / (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::negate, detail::expression<detail::divides, number<B, ET>, Arg1> >(
      detail::expression<detail::divides, number<B, ET>, Arg1>(a, b.left_ref()));
}
template <class Arg1, class Arg2, class Arg3, class Arg4, class B, expression_template_option ET>
inline detail::expression<detail::negate, detail::expression<detail::divides, Arg1, number<B, ET> > >
   operator / (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
{
   return detail::expression<detail::negate, detail::expression<detail::divides, Arg1, number<B, ET> > >(
      detail::expression<detail::divides, Arg1, number<B, ET> >(a.left_ref(), b));
}
template <class B>
inline detail::expression<detail::negate, detail::expression<detail::divide_immediates, number<B, et_on>, number<B, et_on> > >
   operator / (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
{
   return detail::expression<detail::negate, detail::expression<detail::divide_immediates, number<B, et_on>, number<B, et_on> > >(
      detail::expression<detail::divide_immediates, number<B, et_on>, number<B, et_on> >(a, b.left_ref()));
}
template <class B>
inline detail::expression<detail::negate, detail::expression<detail::divide_immediates, number<B, et_on>, number<B, et_on> > >
   operator / (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
{
   return detail::expression<detail::negate, detail::expression<detail::divide_immediates, number<B, et_on>, number<B, et_on> > >(
      detail::expression<detail::divide_immediates, number<B, et_on>, number<B, et_on> >(a.left_ref(), b));
}
template <class B, class V>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_on> >, detail::expression<detail::negate, detail::expression<detail::divide_immediates, number<B, et_on>, V > > >::type
   operator / (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
{
   return detail::expression<detail::negate, detail::expression<detail::divide_immediates, number<B, et_on>, V > >(
      detail::expression<detail::divide_immediates, number<B, et_on>, V>(a.left_ref(), b));
}
template <class B, class B2, expression_template_option ET>
inline typename enable_if<is_compatible_arithmetic_type<number<B2, ET>, number<B, et_on> >, detail::expression<detail::negate, detail::expression<detail::divide_immediates, number<B, et_on>, number<B2, ET> > > >::type
   operator / (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
{
   return detail::expression<detail::negate, detail::expression<detail::divide_immediates, number<B, et_on>, number<B2, ET> > >(
      detail::expression<detail::divide_immediates, number<B, et_on>, number<B2, ET> >(a.left_ref(), b));
}
template <class V, class B>
inline typename enable_if<is_compatible_arithmetic_type<V, number<B, et_on> >, detail::expression<detail::negate, detail::expression<detail::divide_immediates, V, number<B, et_on> > > >::type
   operator / (const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)
{
   return detail::expression<detail::negate, detail::expression<detail::divide_immediates, V, number<B, et_on> > >(
      detail::expression<detail::divide_immediates, V, number<B, et_on> >(a, b.left_ref()));
}
template <class B2, expression_template_option ET, class B>
inline typename enable_if<is_compatible_arithmetic_type<number<B2, ET>, number<B, et_on> >, detail::expression<detail::negate, detail::expression<detail::divide_immediates, number<B2, ET>, number<B, et_on> > > >::type
   operator / (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
{
   return detail::expression<detail::negate, detail::expression<detail::divide_immediates, number<B2, ET>, number<B, et_on> > >(
      detail::expression<detail::divide_immediates, number<B2, ET>, number<B, et_on> >(a, b.left_ref()));
}



template <class B>
inline typename enable_if_c<number_category<B>::value == number_kind_integer,
   detail::expression<detail::modulus_immediates, number<B, et_on>, number<B, et_on> > >::type
      operator % (const number<B, et_on>& a, const number<B, et_on>& b)
{
   return detail::expression<detail::modulus_immediates, number<B, et_on>, number<B, et_on> >(a, b);
}
template <class B, class V>
inline typename enable_if_c<is_compatible_arithmetic_type<V, number<B, et_on> >::value && (number_category<B>::value == number_kind_integer),
   detail::expression<detail::modulus_immediates, number<B, et_on>, V > >::type
   operator % (const number<B, et_on>& a, const V& b)
{
   return detail::expression<detail::modulus_immediates, number<B, et_on>, V >(a, b);
}
template <class V, class B>
inline typename enable_if_c<is_compatible_arithmetic_type<V, number<B, et_on> >::value && (number_category<B>::value == number_kind_integer),
   detail::expression<detail::modulus_immediates, V, number<B, et_on> > >::type
      operator % (const V& a, const number<B, et_on>& b)
{
   return detail::expression<detail::modulus_immediates, V, number<B, et_on> >(a, b);
}
template <class B, class tag, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename enable_if_c<number_category<B>::value == number_kind_integer,
   detail::expression<detail::modulus, number<B, et_on>, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > >::type
      operator % (const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::modulus, number<B, et_on>, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class B>
inline typename enable_if_c<number_category<B>::value == number_kind_integer,
   detail::expression<detail::modulus, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, et_on> > >::type
      operator % (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)
{
   return detail::expression<detail::modulus, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, et_on> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class tag2, class Arg1b, class Arg2b, class Arg3b, class Arg4b>
inline typename enable_if_c<number_category<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value == number_kind_integer,
   detail::expression<detail::modulus, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b> > >::type
      operator % (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
{
   return detail::expression<detail::modulus, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class V>
inline typename enable_if_c<is_compatible_arithmetic_type<V, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value
   && (number_category<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value == number_kind_integer),
   detail::expression<detail::modulus, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V > >::type
      operator % (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
{
   return detail::expression<detail::modulus, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V >(a, b);
}
template <class V, class tag, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename enable_if_c<is_compatible_arithmetic_type<V, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value
   && (number_category<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value == number_kind_integer),
   detail::expression<detail::modulus, V, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > >::type
      operator % (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::modulus, V, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(a, b);
}



template <class B, class I>
inline typename enable_if_c<is_integral<I>::value && (number_category<B>::value == number_kind_integer), detail::expression<detail::shift_left, number<B, et_on>, I > >::type
   operator << (const number<B, et_on>& a, const I& b)
{
   return detail::expression<detail::shift_left, number<B, et_on>, I>(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class I>
inline typename enable_if_c<is_integral<I>::value && (number_category<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value == number_kind_integer),
   detail::expression<detail::shift_left, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, I> >::type
      operator << (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const I& b)
{
   return detail::expression<detail::shift_left, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, I>(a, b);
}



template <class B, class I>
inline typename enable_if_c<is_integral<I>::value && (number_category<B>::value == number_kind_integer),
   detail::expression<detail::shift_right, number<B, et_on>, I > >::type
      operator >> (const number<B, et_on>& a, const I& b)
{
   return detail::expression<detail::shift_right, number<B, et_on>, I>(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class I>
inline typename enable_if_c<is_integral<I>::value
   && (number_category<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value == number_kind_integer),
   detail::expression<detail::shift_right, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, I> >::type
      operator >> (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const I& b)
{
   return detail::expression<detail::shift_right, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, I>(a, b);
}



template <class B>
inline typename enable_if_c<number_category<B>::value == number_kind_integer,
   detail::expression<detail::bitwise_and_immediates, number<B, et_on>, number<B, et_on> > >::type
      operator & (const number<B, et_on>& a, const number<B, et_on>& b)
{
   return detail::expression<detail::bitwise_and_immediates, number<B, et_on>, number<B, et_on> >(a, b);
}
template <class B, class V>
inline typename enable_if_c<is_compatible_arithmetic_type<V, number<B, et_on> >::value
   && (number_category<B>::value == number_kind_integer),
   detail::expression<detail::bitwise_and_immediates, number<B, et_on>, V > >::type
      operator & (const number<B, et_on>& a, const V& b)
{
   return detail::expression<detail::bitwise_and_immediates, number<B, et_on>, V >(a, b);
}
template <class V, class B>
inline typename enable_if_c<is_compatible_arithmetic_type<V, number<B, et_on> >::value
   && (number_category<B>::value == number_kind_integer),
   detail::expression<detail::bitwise_and_immediates, V, number<B, et_on> > >::type
      operator & (const V& a, const number<B, et_on>& b)
{
   return detail::expression<detail::bitwise_and_immediates, V, number<B, et_on> >(a, b);
}
template <class B, class tag, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename enable_if_c<number_category<B>::value == number_kind_integer,
   detail::expression<detail::bitwise_and, number<B, et_on>, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > >::type
      operator & (const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::bitwise_and, number<B, et_on>, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class B>
inline typename enable_if_c<number_category<B>::value == number_kind_integer,
   detail::expression<detail::bitwise_and, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, et_on> > >::type
      operator & (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)
{
   return detail::expression<detail::bitwise_and, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, et_on> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class tag2, class Arg1b, class Arg2b, class Arg3b, class Arg4b>
inline typename enable_if_c<number_category<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value == number_kind_integer,
   detail::expression<detail::bitwise_and, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b> > >::type
      operator & (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
{
   return detail::expression<detail::bitwise_and, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class V>
inline typename enable_if_c<is_compatible_arithmetic_type<V, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value
   && (number_category<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value == number_kind_integer),
   detail::expression<detail::bitwise_and, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V > >::type
      operator & (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
{
   return detail::expression<detail::bitwise_and, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V >(a, b);
}
template <class V, class tag, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename enable_if_c<is_compatible_arithmetic_type<V, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value
   && (number_category<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value == number_kind_integer),
   detail::expression<detail::bitwise_and, V, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > >::type
      operator & (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::bitwise_and, V, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(a, b);
}



template <class B>
inline typename enable_if_c<number_category<B>::value == number_kind_integer,
   detail::expression<detail::bitwise_or_immediates, number<B, et_on>, number<B, et_on> > >::type
   operator| (const number<B, et_on>& a, const number<B, et_on>& b)
{
   return detail::expression<detail::bitwise_or_immediates, number<B, et_on>, number<B, et_on> >(a, b);
}
template <class B, class V>
inline typename enable_if_c<is_compatible_arithmetic_type<V, number<B, et_on> >::value
   && (number_category<B>::value == number_kind_integer),
   detail::expression<detail::bitwise_or_immediates, number<B, et_on>, V > >::type
      operator| (const number<B, et_on>& a, const V& b)
{
   return detail::expression<detail::bitwise_or_immediates, number<B, et_on>, V >(a, b);
}
template <class V, class B>
inline typename enable_if_c<is_compatible_arithmetic_type<V, number<B, et_on> >::value
   && (number_category<B>::value == number_kind_integer),
   detail::expression<detail::bitwise_or_immediates, V, number<B, et_on> > >::type
      operator| (const V& a, const number<B, et_on>& b)
{
   return detail::expression<detail::bitwise_or_immediates, V, number<B, et_on> >(a, b);
}
template <class B, class tag, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename enable_if_c<number_category<B>::value == number_kind_integer,
   detail::expression<detail::bitwise_or, number<B, et_on>, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > >::type
      operator| (const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::bitwise_or, number<B, et_on>, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class B>
inline typename enable_if_c<number_category<B>::value == number_kind_integer,
   detail::expression<detail::bitwise_or, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, et_on> > >::type
      operator| (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)
{
   return detail::expression<detail::bitwise_or, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, et_on> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class tag2, class Arg1b, class Arg2b, class Arg3b, class Arg4b>
inline typename enable_if_c<number_category<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value == number_kind_integer,
   detail::expression<detail::bitwise_or, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b> > >::type
      operator| (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
{
   return detail::expression<detail::bitwise_or, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class V>
inline typename enable_if_c<is_compatible_arithmetic_type<V, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value
   && (number_category<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value == number_kind_integer),
   detail::expression<detail::bitwise_or, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V > >::type
      operator| (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
{
   return detail::expression<detail::bitwise_or, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V >(a, b);
}
template <class V, class tag, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename enable_if_c<is_compatible_arithmetic_type<V, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value
   && (number_category<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value == number_kind_integer),
   detail::expression<detail::bitwise_or, V, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > >::type
      operator| (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::bitwise_or, V, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(a, b);
}



template <class B>
inline typename enable_if_c<number_category<B>::value == number_kind_integer,
   detail::expression<detail::bitwise_xor_immediates, number<B, et_on>, number<B, et_on> > >::type
      operator^ (const number<B, et_on>& a, const number<B, et_on>& b)
{
   return detail::expression<detail::bitwise_xor_immediates, number<B, et_on>, number<B, et_on> >(a, b);
}
template <class B, class V>
inline typename enable_if_c<is_compatible_arithmetic_type<V, number<B, et_on> >::value
   && (number_category<B>::value == number_kind_integer),
   detail::expression<detail::bitwise_xor_immediates, number<B, et_on>, V > >::type
      operator^ (const number<B, et_on>& a, const V& b)
{
   return detail::expression<detail::bitwise_xor_immediates, number<B, et_on>, V >(a, b);
}
template <class V, class B>
inline typename enable_if_c<is_compatible_arithmetic_type<V, number<B, et_on> >::value
   && (number_category<B>::value == number_kind_integer),
   detail::expression<detail::bitwise_xor_immediates, V, number<B, et_on> > >::type
      operator^ (const V& a, const number<B, et_on>& b)
{
   return detail::expression<detail::bitwise_xor_immediates, V, number<B, et_on> >(a, b);
}
template <class B, class tag, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename enable_if_c<number_category<B>::value == number_kind_integer,
   detail::expression<detail::bitwise_xor, number<B, et_on>, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > >::type
      operator^ (const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::bitwise_xor, number<B, et_on>, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class B>
inline typename enable_if_c<number_category<B>::value == number_kind_integer,
   detail::expression<detail::bitwise_xor, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, et_on> > >::type
      operator^ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)
{
   return detail::expression<detail::bitwise_xor, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, et_on> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class tag2, class Arg1b, class Arg2b, class Arg3b, class Arg4b>
inline typename enable_if_c<number_category<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value == number_kind_integer,
   detail::expression<detail::bitwise_xor, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b> > >::type
      operator^ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
{
   return detail::expression<detail::bitwise_xor, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b> >(a, b);
}
template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class V>
inline typename enable_if_c<is_compatible_arithmetic_type<V, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value
   && (number_category<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value == number_kind_integer),
   detail::expression<detail::bitwise_xor, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V > >::type
      operator^ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
{
   return detail::expression<detail::bitwise_xor, detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V >(a, b);
}
template <class V, class tag, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename enable_if_c<is_compatible_arithmetic_type<V, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value
   && (number_category<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::value == number_kind_integer), detail::expression<detail::bitwise_xor, V, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > >::type
   operator^ (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
{
   return detail::expression<detail::bitwise_xor, V, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(a, b);
}

}}











namespace boost{ namespace multiprecision{ namespace detail{

   template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_signed_types { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::signed_types>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
   template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_unsigned_types { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::unsigned_types>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
   template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_float_types { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::float_types>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };

   template <class T>
   struct is_backend
   {
      static const bool value = has_signed_types<T>::value && has_unsigned_types<T>::value && has_float_types<T>::value;
   };

   template <class Backend>
   struct other_backend
   {
      typedef typename boost::conditional<
         boost::is_same<number<Backend>, number<Backend, et_on> >::value,
         number<Backend, et_off>, number<Backend, et_on> >::type type;
   };

   template <class B, class V>
   struct number_from_backend
   {
      typedef typename boost::conditional <
         boost::is_convertible<V, number<B> >::value,
         number<B>,
         typename other_backend<B>::type > ::type type;
   };

   template <bool b, class T, class U>
   struct is_first_backend_imp{ static const bool value = false; };
   template <class T, class U>
   struct is_first_backend_imp<true, T, U>{ static const bool value = is_convertible<U, number<T, et_on> >::value || is_convertible<U, number<T, et_off> >::value; };

   template <class T, class U>
   struct is_first_backend : is_first_backend_imp<is_backend<T>::value, T, U> {};

   template <bool b, class T, class U>
   struct is_second_backend_imp{ static const bool value = false; };
   template <class T, class U>
   struct is_second_backend_imp<true, T, U>{ static const bool value = (is_convertible<T, number<U, et_on> >::value || is_convertible<T, number<U, et_off> >::value) && !is_first_backend<T, U>::value; };

   template <class T, class U>
   struct is_second_backend : is_second_backend_imp<is_backend<U>::value, T, U> {};

}
}
}

namespace boost{ namespace multiprecision{
template <class Backend>
inline typename boost::enable_if_c < boost::multiprecision::detail::is_backend<Backend>::value, const number<Backend, et_on>&>::type
   (min)(const number<Backend, et_on>& a, const number<Backend, et_on>& b)
{
   return a < b ? a : b;
}
template <class Backend, class tag, class A1, class A2, class A3, class A4>
inline typename boost::enable_if_c < boost::multiprecision::detail::is_backend<Backend>::value, const number<Backend, et_on> >::type
   (min)(const number<Backend, et_on>& a, const detail::expression<tag, A1, A2, A3, A4>& b)
{
   number<Backend, et_on> t(b);
   if(a < t)
      return a;
   return std::move(t);
}
template <class tag, class A1, class A2, class A3, class A4, class Backend>
inline typename boost::enable_if_c < boost::multiprecision::detail::is_backend<Backend>::value, const number<Backend, et_on> >::type
   (min)(const detail::expression<tag, A1, A2, A3, A4>& a, const number<Backend, et_on>& b)
{
   number<Backend, et_on> t(a);
   if(t < b)
      return std::move(t);
   return b;
}
template <class tag, class A1, class A2, class A3, class A4, class tagb, class A1b, class A2b, class A3b, class A4b>
inline typename detail::expression<tag, A1, A2, A3, A4>::result_type
      (min)(const detail::expression<tag, A1, A2, A3, A4>& a, const detail::expression<tagb, A1b, A2b, A3b, A4b>& b)
{
   typename detail::expression<tag, A1, A2, A3, A4>::result_type t1(a), t2(b);
   if(t1 < t2)
      return std::move(t1);
   return std::move(t2);
}
template <class tag, class A1, class A2, class A3, class A4>
inline typename detail::expression<tag, A1, A2, A3, A4>::result_type (min)(const detail::expression<tag, A1, A2, A3, A4>& a, const detail::expression<tag, A1, A2, A3, A4>& b)
{
   typename detail::expression<tag, A1, A2, A3, A4>::result_type t1(a), t2(b);
   if(t1 < t2)
      return std::move(t1);
   return std::move(t2);
}

template <class Backend>
inline typename boost::enable_if_c < boost::multiprecision::detail::is_backend<Backend>::value, const number<Backend, et_on>&>::type
   (max)(const number<Backend, et_on>& a, const number<Backend, et_on>& b)
{
   return a > b ? a : b;
}
template <class Backend, class tag, class A1, class A2, class A3, class A4>
inline typename boost::enable_if_c < boost::multiprecision::detail::is_backend<Backend>::value, const number<Backend, et_on> >::type
   (max)(const number<Backend, et_on>& a, const detail::expression<tag, A1, A2, A3, A4>& b)
{
   number<Backend, et_on> t(b);
   if(a > t)
      return a;
   return std::move(t);
}
template <class tag, class A1, class A2, class A3, class A4, class Backend>
inline typename boost::enable_if_c < boost::multiprecision::detail::is_backend<Backend>::value, const number<Backend, et_on> >::type
   (max)(const detail::expression<tag, A1, A2, A3, A4>& a, const number<Backend, et_on>& b)
{
   number<Backend, et_on> t(a);
   if(t > b)
      return std::move(t);
   return b;
}
template <class tag, class A1, class A2, class A3, class A4, class tagb, class A1b, class A2b, class A3b, class A4b>
inline typename detail::expression<tag, A1, A2, A3, A4>::result_type
      (max)(const detail::expression<tag, A1, A2, A3, A4>& a, const detail::expression<tagb, A1b, A2b, A3b, A4b>& b)
{
   typename detail::expression<tag, A1, A2, A3, A4>::result_type t1(a), t2(b);
   if(t1 > t2)
      return std::move(t1);
   return std::move(t2);
}
template <class tag, class A1, class A2, class A3, class A4>
inline typename detail::expression<tag, A1, A2, A3, A4>::result_type (max)(const detail::expression<tag, A1, A2, A3, A4>& a, const detail::expression<tag, A1, A2, A3, A4>& b)
{
   typename detail::expression<tag, A1, A2, A3, A4>::result_type t1(a), t2(b);
   if(t1 > t2)
      return std::move(t1);
   return std::move(t2);
}

}}






namespace boost{ namespace multiprecision{ namespace detail{

template <class To, class From>
inline To do_cast(const From & from)
{
   return static_cast<To>(from);
}
template <class To, class B, ::boost::multiprecision::expression_template_option et>
inline To do_cast(const number<B, et>& from)
{
   return from.template convert_to<To>();
}

template <class To, class From>
void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_floating_point>& , const mpl::int_<number_kind_integer>& )
{
   using default_ops::eval_get_sign;
   using default_ops::eval_bitwise_and;
   using default_ops::eval_convert_to;
   using default_ops::eval_right_shift;
   using default_ops::eval_ldexp;
   using default_ops::eval_add;
   using default_ops::eval_is_zero;

   typedef typename canonical<unsigned char, From>::type l_limb_type;

   typedef typename canonical<l_limb_type, To>::type to_type;
   From t(from);
   bool is_neg = eval_get_sign(t) < 0;
   if(is_neg)
      t.negate();

   l_limb_type limb;
   l_limb_type mask = static_cast<l_limb_type>(~static_cast<l_limb_type>(0));
   From fl;
   eval_bitwise_and(fl, t, mask);
   eval_convert_to(&limb, fl);
   to = static_cast<to_type>(limb);
   eval_right_shift(t, std::numeric_limits<l_limb_type>::digits);



   To l;
   unsigned shift = std::numeric_limits<l_limb_type>::digits;
   while(!eval_is_zero(t))
   {
      eval_bitwise_and(fl, t, mask);
      eval_convert_to(&limb, fl);
      l = static_cast<to_type>(limb);
      eval_right_shift(t, std::numeric_limits<l_limb_type>::digits);
      eval_ldexp(l, l, shift);
      eval_add(to, l);
      shift += std::numeric_limits<l_limb_type>::digits;
   }



   if(is_neg)
      to.negate();
}

template <class To, class From>
void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_integer>& , const mpl::int_<number_kind_integer>& )
{
   using default_ops::eval_get_sign;
   using default_ops::eval_bitwise_and;
   using default_ops::eval_convert_to;
   using default_ops::eval_right_shift;
   using default_ops::eval_left_shift;
   using default_ops::eval_bitwise_or;
   using default_ops::eval_is_zero;

   typedef typename canonical<unsigned char, From>::type limb_type;

   typedef typename canonical<limb_type, To>::type to_type;
   From t(from);
   bool is_neg = eval_get_sign(t) < 0;
   if(is_neg)
      t.negate();

   limb_type limb;
   limb_type mask = static_cast<limb_type>(~static_cast<limb_type>(0));
   From fl;
   eval_bitwise_and(fl, t, mask);
   eval_convert_to(&limb, fl);
   to = static_cast<to_type>(limb);
   eval_right_shift(t, std::numeric_limits<limb_type>::digits);



   To l;
   unsigned shift = std::numeric_limits<limb_type>::digits;
   while(!eval_is_zero(t))
   {
      eval_bitwise_and(fl, t, mask);
      eval_convert_to(&limb, fl);
      l = static_cast<to_type>(limb);
      eval_right_shift(t, std::numeric_limits<limb_type>::digits);
      eval_left_shift(l, shift);
      eval_bitwise_or(to, l);
      shift += std::numeric_limits<limb_type>::digits;
   }



   if(is_neg)
      to.negate();
}

template <class To, class From>
void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_floating_point>& , const mpl::int_<number_kind_floating_point>& )
{
   if(std::numeric_limits<number<From> >::radix != 2)
   {
      to = from.str(0, std::ios_base::fmtflags()).c_str();
      return;
   }


   typedef typename canonical<unsigned char, To>::type ui_type;

   using default_ops::eval_fpclassify;
   using default_ops::eval_add;
   using default_ops::eval_subtract;
   using default_ops::eval_convert_to;
   using default_ops::eval_get_sign;
   using default_ops::eval_is_zero;




   int c = eval_fpclassify(from);

   if(c == (int)3)
   {
      to = ui_type(0);
      return;
   }
   else if(c == (int)1)
   {
      to = static_cast<const char*>("nan");
      return;
   }
   else if(c == (int)2)
   {
      to = static_cast<const char*>("inf");
      if(eval_get_sign(from) < 0)
         to.negate();
      return;
   }

   typename From::exponent_type e;
   From f, term;
   to = ui_type(0);

   eval_frexp(f, from, &e);

   static const int shift = std::numeric_limits<boost::intmax_t>::digits - 1;

   while(!eval_is_zero(f))
   {

      eval_ldexp(f, f, shift);
      eval_floor(term, f);
      e -= shift;
      eval_ldexp(to, to, shift);
      typename boost::multiprecision::detail::canonical<boost::intmax_t, To>::type ll;
      eval_convert_to(&ll, term);
      eval_add(to, ll);
      eval_subtract(f, term);
   }
   typedef typename To::exponent_type to_exponent;
   if((e > (std::numeric_limits<to_exponent>::max)()) || (e < (std::numeric_limits<to_exponent>::min)()))
   {
      to = static_cast<const char*>("inf");
      if(eval_get_sign(from) < 0)
         to.negate();
      return;
   }
   eval_ldexp(to, to, static_cast<to_exponent>(e));



}

template <class To, class From>
void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_rational>& , const mpl::int_<number_kind_rational>& )
{
   typedef typename component_type<number<To> >::type to_component_type;

   number<From> t(from);
   to_component_type n(numerator(t)), d(denominator(t));
   using default_ops::assign_components;
   assign_components(to, n.backend(), d.backend());
}

template <class To, class From>
void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_rational>& , const mpl::int_<number_kind_integer>& )
{
   typedef typename component_type<number<To> >::type to_component_type;

   number<From> t(from);
   to_component_type n(t), d(1);
   using default_ops::assign_components;
   assign_components(to, n.backend(), d.backend());
}

template <class R, class LargeInteger>
R safe_convert_to_float(const LargeInteger& i)
{
   using std::ldexp;
   if(!i)
      return R(0);
   if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::max_exponent)
   {
      LargeInteger val(i);
      if(val.sign() < 0)
         val = -val;
      unsigned mb = msb(val);
      if(mb >= std::numeric_limits<R>::max_exponent)
      {
         int scale_factor = (int)mb + 1 - std::numeric_limits<R>::max_exponent;
         (__builtin_expect(!(scale_factor >= 1), 0) ? __assert_rtn(__func__, "./boost/multiprecision/detail/generic_interconvert.hpp", 247, "scale_factor >= 1") : (void)0);
         val >>= scale_factor;
         R result = val.template convert_to<R>();
         if(std::numeric_limits<R>::digits == 0 || std::numeric_limits<R>::digits >= std::numeric_limits<R>::max_exponent)
         {






            LargeInteger remainder(i);
            remainder &= (LargeInteger(1) << scale_factor) - 1;
            result += ldexp(safe_convert_to_float<R>(remainder), -scale_factor);
         }
         return i.sign() < 0 ? static_cast<R>(-result) : result;
      }
   }
   return i.template convert_to<R>();
}

template <class To, class Integer>
inline typename disable_if_c<is_number<To>::value || is_floating_point<To>::value>::type
   generic_convert_rational_to_float_imp(To& result, const Integer& n, const Integer& d, const mpl::true_&)
{





   using default_ops::eval_divide;
   number<To> fn(safe_convert_to_float<number<To> >(n)), fd(safe_convert_to_float<number<To> >(d));
   eval_divide(result, fn.backend(), fd.backend());
}
template <class To, class Integer>
inline typename enable_if_c<is_number<To>::value || is_floating_point<To>::value>::type
   generic_convert_rational_to_float_imp(To& result, const Integer& n, const Integer& d, const mpl::true_&)
{





   To fd(safe_convert_to_float<To>(d));
   result = safe_convert_to_float<To>(n);
   result /= fd;
}

template <class To, class Integer>
typename enable_if_c<is_number<To>::value || is_floating_point<To>::value>::type
   generic_convert_rational_to_float_imp(To& result, Integer& num, Integer& denom, const mpl::false_&)
{





   if(num == 0)
   {
      result = 0;
      return;
   }
   bool s = false;
   if(num < 0)
   {
      s = true;
      num = -num;
   }
   int denom_bits = msb(denom);
   int shift = std::numeric_limits<To>::digits + denom_bits - msb(num);
   if(shift > 0)
      num <<= shift;
   else if(shift < 0)
      denom <<= boost::multiprecision::detail::unsigned_abs(shift);
   Integer q, r;
   divide_qr(num, denom, q, r);
   int q_bits = msb(q);
   if(q_bits == std::numeric_limits<To>::digits - 1)
   {



      r <<= 1;
      int c = r.compare(denom);
      if(c > 0)
         ++q;
      else if((c == 0) && (q & 1u))
      {
         ++q;
      }
   }
   else
   {
      (__builtin_expect(!(q_bits == std::numeric_limits<To>::digits), 0) ? __assert_rtn(__func__, "./boost/multiprecision/detail/generic_interconvert.hpp", 340, "q_bits == std::numeric_limits<To>::digits") : (void)0);



      if(q & 1u)
      {
         if(r || (q & 2u))
            ++q;
      }
   }
   using std::ldexp;
   result = do_cast<To>(q);
   result = ldexp(result, -shift);
   if(s)
      result = -result;
}
template <class To, class Integer>
inline typename disable_if_c<is_number<To>::value || is_floating_point<To>::value>::type
   generic_convert_rational_to_float_imp(To& result, Integer& num, Integer& denom, const mpl::false_& tag)
{
   number<To> t;
   generic_convert_rational_to_float_imp(t, num, denom, tag);
   result = t.backend();
}

template <class To, class From>
inline void generic_convert_rational_to_float(To& result, const From& f)
{







   typedef typename mpl::if_c<is_number<From>::value, From, number<From> >::type actual_from_type;
   typedef typename mpl::if_c<is_number<To>::value || is_floating_point<To>::value, To, number<To> >::type actual_to_type;
   typedef typename component_type<actual_from_type>::type integer_type;
   typedef mpl::bool_<!std::numeric_limits<integer_type>::is_specialized
                      || std::numeric_limits<integer_type>::is_bounded
                      || !std::numeric_limits<actual_to_type>::is_specialized
                      || !std::numeric_limits<actual_to_type>::is_bounded
                      || (std::numeric_limits<actual_to_type>::radix != 2)> dispatch_tag;

   integer_type n(numerator(static_cast<actual_from_type>(f))), d(denominator(static_cast<actual_from_type>(f)));
   generic_convert_rational_to_float_imp(result, n, d, dispatch_tag());
}

template <class To, class From>
inline void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_floating_point>& , const mpl::int_<number_kind_rational>& )
{
   generic_convert_rational_to_float(to, from);
}

template <class To, class From>
void generic_interconvert_float2rational(To& to, const From& from, const mpl::int_<2>& )
{
   typedef typename mpl::front<typename To::unsigned_types>::type ui_type;
   static const int shift = std::numeric_limits<boost::long_long_type>::digits;
   typename From::exponent_type e;
   typename component_type<number<To> >::type num, denom;
   number<From> val(from);
   val = frexp(val, &e);
   while(val)
   {
      val = ldexp(val, shift);
      e -= shift;
      boost::long_long_type ll = boost::math::lltrunc(val);
      val -= ll;
      num <<= shift;
      num += ll;
   }
   denom = ui_type(1u);
   if(e < 0)
      denom <<= -e;
   else if(e > 0)
      num <<= e;
   assign_components(to, num.backend(), denom.backend());
}

template <class To, class From, int Radix>
void generic_interconvert_float2rational(To& to, const From& from, const mpl::int_<Radix>& )
{





   typedef typename mpl::front<typename To::unsigned_types>::type ui_type;
   typename From::exponent_type e;
   typename component_type<number<To> >::type num, denom;
   number<From> val(from);

   if (!val)
   {
      to = ui_type(0u);
      return;
   }

   e = ilogb(val);
   val = scalbn(val, -e);
   while(val)
   {
      boost::long_long_type ll = boost::math::lltrunc(val);
      val -= ll;
      val = scalbn(val, 1);
      num *= Radix;
      num += ll;
      --e;
   }
   ++e;
   denom = ui_type(Radix);
   denom = pow(denom, abs(e));
   if(e > 0)
   {
      num *= denom;
      denom = 1;
   }
   assign_components(to, num.backend(), denom.backend());
}

template <class To, class From>
void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_rational>& , const mpl::int_<number_kind_floating_point>& )
{
   generic_interconvert_float2rational(to, from, mpl::int_<std::numeric_limits<number<From> >::radix>());
}

template <class To, class From>
void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_integer>& , const mpl::int_<number_kind_rational>& )
{
   number<From> t(from);
   number<To> result(numerator(t) / denominator(t));
   to = result.backend();
}

template <class To, class From>
void generic_interconvert_float2int(To& to, const From& from, const mpl::int_<2>& )
{
   typedef typename From::exponent_type exponent_type;
   static const exponent_type shift = std::numeric_limits<boost::long_long_type>::digits;
   exponent_type e;
   number<To> num(0u);
   number<From> val(from);
   val = frexp(val, &e);
   while(e > 0)
   {
      int s = (std::min)(e, shift);
      val = ldexp(val, s);
      e -= s;
      boost::long_long_type ll = boost::math::lltrunc(val);
      val -= ll;
      num <<= s;
      num += ll;
   }
   to = num.backend();
}

template <class To, class From, int Radix>
void generic_interconvert_float2int(To& to, const From& from, const mpl::int_<Radix>& )
{





   typename From::exponent_type e;
   number<To> num(0u);
   number<From> val(from);
   e = ilogb(val);
   val = scalbn(val, -e);
   while(e >= 0)
   {
      boost::long_long_type ll = boost::math::lltrunc(val);
      val -= ll;
      val = scalbn(val, 1);
      num *= Radix;
      num += ll;
      --e;
   }
   to = num.backend();
}

template <class To, class From>
void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_integer>& , const mpl::int_<number_kind_floating_point>& )
{
   generic_interconvert_float2int(to, from, mpl::int_<std::numeric_limits<number<From> >::radix>());
}

template <class To, class From, class tag>
void generic_interconvert_complex_to_scalar(To& to, const From& from, const mpl::true_&, const tag&)
{

   eval_real(to, from);

   To im;
   eval_imag(im, from);
   if(!eval_is_zero(im))
      ::boost::exception_detail::throw_exception_(std::runtime_error("Could not convert imaginary number to scalar."),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/generic_interconvert.hpp",537);
}
template <class To, class From>
void generic_interconvert_complex_to_scalar(To& to, const From& from, const mpl::false_&, const mpl::true_&)
{
   typedef typename component_type<number<From> >::type component_number;
   typedef typename component_number::backend_type component_backend;



   component_backend r;
   generic_interconvert_complex_to_scalar(r, from, mpl::true_(), mpl::true_());
   to = r;
}
template <class To, class From>
void generic_interconvert_complex_to_scalar(To& to, const From& from, const mpl::false_&, const mpl::false_&)
{
   typedef typename component_type<number<From> >::type component_number;
   typedef typename component_number::backend_type component_backend;



   component_backend r;
   generic_interconvert_complex_to_scalar(r, from, mpl::true_(), mpl::true_());
   generic_interconvert(to, r, mpl::int_<number_category<To>::value>(), mpl::int_<number_category<To>::value>());
}

template <class To, class From>
void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_floating_point>& , const mpl::int_<number_kind_complex>& )
{
   typedef typename component_type<number<From> >::type component_number;
   typedef typename component_number::backend_type component_backend;

   generic_interconvert_complex_to_scalar(to, from, mpl::bool_<boost::is_same<component_backend, To>::value>(), mpl::bool_<boost::is_constructible<To, const component_backend&>::value>());
}
template <class To, class From>
void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_integer>& , const mpl::int_<number_kind_complex>& )
{
   typedef typename component_type<number<From> >::type component_number;
   typedef typename component_number::backend_type component_backend;

   generic_interconvert_complex_to_scalar(to, from, mpl::bool_<boost::is_same<component_backend, To>::value>(), mpl::bool_<boost::is_constructible<To, const component_backend&>::value>());
}

}
}
}
namespace boost{ namespace multiprecision{

namespace default_ops{






template <class B>
inline bool eval_eq(const B& a, const B& b)
{
   return a.compare(b) == 0;
}
template <class T, class U>
inline bool eval_eq_imp(const T& a, const U& b, const mpl::true_&)
{
   typename boost::multiprecision::detail::number_from_backend<T, U>::type t(b);
   return eval_eq(a, t.backend());
}
template <class T, class U>
inline bool eval_eq_imp(const T& a, const U& b, const mpl::false_&)
{
   typename boost::multiprecision::detail::number_from_backend<U, T>::type t(a);
   return eval_eq(t.backend(), b);
}
template <class T, class U>
inline bool eval_eq(const T& a, const U& b)
{
   typedef mpl::bool_<boost::multiprecision::detail::is_first_backend<T, U>::value> tag_type;
   return eval_eq_imp(a, b, tag_type());
}

template <class B>
inline bool eval_lt(const B& a, const B& b)
{
   return a.compare(b) < 0;
}
template <class T, class U>
inline bool eval_lt_imp(const T& a, const U& b, const mpl::true_&)
{
   typename boost::multiprecision::detail::number_from_backend<T, U>::type t(b);
   return eval_lt(a, t.backend());
}
template <class T, class U>
inline bool eval_lt_imp(const T& a, const U& b, const mpl::false_&)
{
   typename boost::multiprecision::detail::number_from_backend<U, T>::type t(a);
   return eval_lt(t.backend(), b);
}
template <class T, class U>
inline bool eval_lt(const T& a, const U& b)
{
   typedef mpl::bool_<boost::multiprecision::detail::is_first_backend<T, U>::value> tag_type;
   return eval_lt_imp(a, b, tag_type());
}

template <class B>
inline bool eval_gt(const B& a, const B& b)
{
   return a.compare(b) > 0;
}
template <class T, class U>
inline bool eval_gt_imp(const T& a, const U& b, const mpl::true_&)
{
   typename boost::multiprecision::detail::number_from_backend<T, U>::type t(b);
   return eval_gt(a, t.backend());
}
template <class T, class U>
inline bool eval_gt_imp(const T& a, const U& b, const mpl::false_&)
{
   typename boost::multiprecision::detail::number_from_backend<U, T>::type t(a);
   return eval_gt(t.backend(), b);
}
template <class T, class U>
inline bool eval_gt(const T& a, const U& b)
{
   typedef mpl::bool_<boost::multiprecision::detail::is_first_backend<T, U>::value> tag_type;
   return eval_gt_imp(a, b, tag_type());
}

}

namespace detail{

template <class Num, class Val>
struct is_valid_mixed_compare : public mpl::false_ {};

template <class B, expression_template_option ET, class Val>
struct is_valid_mixed_compare<number<B, ET>, Val> : public is_convertible<Val, number<B, ET> > {};

template <class B, expression_template_option ET>
struct is_valid_mixed_compare<number<B, ET>, number<B, ET> > : public mpl::false_ {};

template <class B, expression_template_option ET, class tag, class Arg1, class Arg2, class Arg3, class Arg4>
struct is_valid_mixed_compare<number<B, ET>, expression<tag, Arg1, Arg2, Arg3, Arg4> >
   : public mpl::bool_<is_convertible<expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, ET> >::value> {};

template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class B, expression_template_option ET>
struct is_valid_mixed_compare<expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, ET> >
   : public mpl::bool_<is_convertible<expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, ET> >::value> {};

template <class Backend, expression_template_option ExpressionTemplates>
inline constexpr typename boost::enable_if_c<number_category<Backend>::value != number_kind_floating_point, bool>::type is_unordered_value(const number<Backend, ExpressionTemplates>&)
{
   return false;
}
template <class Backend, expression_template_option ExpressionTemplates>
inline

constexpr

 typename boost::enable_if_c<number_category<Backend>::value == number_kind_floating_point, bool>::type is_unordered_value(const number<Backend, ExpressionTemplates>& a)
{
   using default_ops::eval_fpclassify;
   return eval_fpclassify(a.backend()) == 1;
}

template <class Arithmetic>
inline constexpr typename boost::enable_if_c<number_category<Arithmetic>::value != number_kind_floating_point, bool>::type is_unordered_value(const Arithmetic&)
{
   return false;
}
template <class Arithmetic>
inline constexpr typename boost::enable_if_c<number_category<Arithmetic>::value == number_kind_floating_point, bool>::type is_unordered_value(const Arithmetic& a)
{
   return (boost::math::isnan)(a);
}

template <class T, class U>
inline constexpr bool is_unordered_comparison(const T& a, const U& b)
{
   return is_unordered_value(a) || is_unordered_value(b);
}

}

template <class Backend, expression_template_option ExpressionTemplates, class Backend2, expression_template_option ExpressionTemplates2>
inline bool operator == (const number<Backend, ExpressionTemplates>& a, const number<Backend2, ExpressionTemplates2>& b)
{
   using default_ops::eval_eq;
   if(detail::is_unordered_comparison(a, b)) return false;
   return eval_eq(a.backend(), b.backend());
}
template <class Backend, expression_template_option ExpressionTemplates, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value, bool>::type
   operator == (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
{
   using default_ops::eval_eq;
   if(detail::is_unordered_comparison(a, b)) return false;
   return eval_eq(a.backend(), number<Backend, ExpressionTemplates>::canonical_value(b));
}
template <class Arithmetic, class Backend, expression_template_option ExpressionTemplates>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value, bool>::type
   operator == (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
{
   using default_ops::eval_eq;
   if(detail::is_unordered_comparison(a, b)) return false;
   return eval_eq(b.backend(), number<Backend, ExpressionTemplates>::canonical_value(a));
}
template <class Arithmetic, class Tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value, bool>::type
   operator == (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
{
   typedef typename detail::expression<Tag, A1, A2, A3, A4>::result_type result_type;
   using default_ops::eval_eq;
   result_type t(b);
   if(detail::is_unordered_comparison(a, t)) return false;
   return eval_eq(t.backend(), result_type::canonical_value(a));
}
template <class Tag, class A1, class A2, class A3, class A4, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value, bool>::type
   operator == (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
{
   typedef typename detail::expression<Tag, A1, A2, A3, A4>::result_type result_type;
   using default_ops::eval_eq;
   result_type t(a);
   if(detail::is_unordered_comparison(t, b)) return false;
   return eval_eq(t.backend(), result_type::canonical_value(b));
}
template <class Tag, class A1, class A2, class A3, class A4, class Tagb, class A1b, class A2b, class A3b, class A4b>
inline typename enable_if<is_same<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, typename detail::expression<Tagb, A1b, A2b, A3b, A4b>::result_type>, bool>::type
   operator == (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
{
   using default_ops::eval_eq;
   typename detail::expression<Tag, A1, A2, A3, A4>::result_type t(a);
   typename detail::expression<Tagb, A1b, A2b, A3b, A4b>::result_type t2(b);
   if(detail::is_unordered_comparison(t, t2)) return false;
   return eval_eq(t.backend(), t2.backend());
}

template <class Backend, expression_template_option ExpressionTemplates, class Backend2, expression_template_option ExpressionTemplates2>
inline bool operator != (const number<Backend, ExpressionTemplates>& a, const number<Backend2, ExpressionTemplates2>& b)
{
   using default_ops::eval_eq;
   if(detail::is_unordered_comparison(a, b)) return true;
   return !eval_eq(a.backend(), b.backend());
}
template <class Backend, expression_template_option ExpressionTemplates, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value, bool>::type
   operator != (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
{
   using default_ops::eval_eq;
   if(detail::is_unordered_comparison(a, b)) return true;
   return !eval_eq(a.backend(), number<Backend, et_on>::canonical_value(b));
}
template <class Arithmetic, class Backend, expression_template_option ExpressionTemplates>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value, bool>::type
   operator != (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
{
   using default_ops::eval_eq;
   if(detail::is_unordered_comparison(a, b)) return true;
   return !eval_eq(b.backend(), number<Backend, et_on>::canonical_value(a));
}
template <class Arithmetic, class Tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value, bool>::type
   operator != (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
{
   typedef typename detail::expression<Tag, A1, A2, A3, A4>::result_type result_type;
   using default_ops::eval_eq;
   result_type t(b);
   if(detail::is_unordered_comparison(a, t)) return true;
   return !eval_eq(t.backend(), result_type::canonical_value(a));
}
template <class Tag, class A1, class A2, class A3, class A4, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value, bool>::type
   operator != (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
{
   typedef typename detail::expression<Tag, A1, A2, A3, A4>::result_type result_type;
   using default_ops::eval_eq;
   result_type t(a);
   if(detail::is_unordered_comparison(t, b)) return true;
   return !eval_eq(t.backend(), result_type::canonical_value(b));
}
template <class Tag, class A1, class A2, class A3, class A4, class Tagb, class A1b, class A2b, class A3b, class A4b>
inline typename enable_if<is_same<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, typename detail::expression<Tagb, A1b, A2b, A3b, A4b>::result_type>, bool>::type
   operator != (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
{
   using default_ops::eval_eq;
   typename detail::expression<Tag, A1, A2, A3, A4>::result_type t(a);
   typename detail::expression<Tagb, A1b, A2b, A3b, A4b>::result_type t2(b);
   if(detail::is_unordered_comparison(t, t2)) return true;
   return !eval_eq(t.backend(), t2.backend());
}

template <class Backend, expression_template_option ExpressionTemplates, class Backend2, expression_template_option ExpressionTemplates2>
inline typename boost::enable_if_c<(number_category<Backend>::value != number_kind_complex) && (number_category<Backend2>::value != number_kind_complex), bool>::type
   operator < (const number<Backend, ExpressionTemplates>& a, const number<Backend2, ExpressionTemplates2>& b)
{
   using default_ops::eval_lt;
   if(detail::is_unordered_comparison(a, b)) return false;
   return eval_lt(a.backend(), b.backend());
}
template <class Backend, expression_template_option ExpressionTemplates, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value && (number_category<Backend>::value != number_kind_complex), bool>::type
   operator < (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
{
   using default_ops::eval_lt;
   if(detail::is_unordered_comparison(a, b)) return false;
   return eval_lt(a.backend(), number<Backend, ExpressionTemplates>::canonical_value(b));
}
template <class Arithmetic, class Backend, expression_template_option ExpressionTemplates>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value && (number_category<Backend>::value != number_kind_complex), bool>::type
   operator < (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
{
   using default_ops::eval_gt;
   if(detail::is_unordered_comparison(a, b)) return false;
   return eval_gt(b.backend(), number<Backend, ExpressionTemplates>::canonical_value(a));
}
template <class Arithmetic, class Tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value && (number_category<typename detail::expression<Tag, A1, A2, A3, A4>::result_type>::value != number_kind_complex), bool>::type
   operator < (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
{
   typedef typename detail::expression<Tag, A1, A2, A3, A4>::result_type result_type;
   using default_ops::eval_gt;
   result_type t(b);
   if(detail::is_unordered_comparison(a, t)) return false;
   return eval_gt(t.backend(), result_type::canonical_value(a));
}
template <class Tag, class A1, class A2, class A3, class A4, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value && (number_category<typename detail::expression<Tag, A1, A2, A3, A4>::result_type>::value != number_kind_complex), bool>::type
   operator < (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
{
   typedef typename detail::expression<Tag, A1, A2, A3, A4>::result_type result_type;
   using default_ops::eval_lt;
   result_type t(a);
   if(detail::is_unordered_comparison(t, b)) return false;
   return eval_lt(t.backend(), result_type::canonical_value(b));
}
template <class Tag, class A1, class A2, class A3, class A4, class Tagb, class A1b, class A2b, class A3b, class A4b>
inline typename enable_if_c<is_same<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, typename detail::expression<Tagb, A1b, A2b, A3b, A4b>::result_type>::value && (number_category<typename detail::expression<Tag, A1, A2, A3, A4>::result_type>::value != number_kind_complex), bool>::type
   operator < (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
{
   using default_ops::eval_lt;
   typename detail::expression<Tag, A1, A2, A3, A4>::result_type t(a);
   typename detail::expression<Tagb, A1b, A2b, A3b, A4b>::result_type t2(b);
   if(detail::is_unordered_comparison(t, t2)) return false;
   return eval_lt(t.backend(), t2.backend());
}

template <class Backend, expression_template_option ExpressionTemplates, class Backend2, expression_template_option ExpressionTemplates2>
inline typename boost::enable_if_c<(number_category<Backend>::value != number_kind_complex) && (number_category<Backend2>::value != number_kind_complex), bool>::type
   operator > (const number<Backend, ExpressionTemplates>& a, const number<Backend2, ExpressionTemplates2>& b)
{
   using default_ops::eval_gt;
   if(detail::is_unordered_comparison(a, b)) return false;
   return eval_gt(a.backend(), b.backend());
}
template <class Backend, expression_template_option ExpressionTemplates, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value && (number_category<Backend>::value != number_kind_complex), bool>::type
   operator > (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
{
   using default_ops::eval_gt;
   if(detail::is_unordered_comparison(a, b)) return false;
   return eval_gt(a.backend(), number<Backend, ExpressionTemplates>::canonical_value(b));
}
template <class Arithmetic, class Backend, expression_template_option ExpressionTemplates>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value && (number_category<Backend>::value != number_kind_complex), bool>::type
   operator > (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
{
   using default_ops::eval_lt;
   if(detail::is_unordered_comparison(a, b)) return false;
   return eval_lt(b.backend(), number<Backend, ExpressionTemplates>::canonical_value(a));
}
template <class Arithmetic, class Tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value && (number_category<typename detail::expression<Tag, A1, A2, A3, A4>::result_type>::value != number_kind_complex), bool>::type
   operator > (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
{
   typedef typename detail::expression<Tag, A1, A2, A3, A4>::result_type result_type;
   using default_ops::eval_lt;
   result_type t(b);
   if(detail::is_unordered_comparison(a, t)) return false;
   return a > t;
}
template <class Tag, class A1, class A2, class A3, class A4, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value && (number_category<typename detail::expression<Tag, A1, A2, A3, A4>::result_type>::value != number_kind_complex), bool>::type
   operator > (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
{
   typedef typename detail::expression<Tag, A1, A2, A3, A4>::result_type result_type;
   using default_ops::eval_gt;
   result_type t(a);
   if(detail::is_unordered_comparison(t, b)) return false;
   return t > b;
}
template <class Tag, class A1, class A2, class A3, class A4, class Tagb, class A1b, class A2b, class A3b, class A4b>
inline typename enable_if_c<is_same<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, typename detail::expression<Tagb, A1b, A2b, A3b, A4b>::result_type>::value && (number_category<typename detail::expression<Tag, A1, A2, A3, A4>::result_type>::value != number_kind_complex), bool>::type
   operator > (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
{
   using default_ops::eval_gt;
   typename detail::expression<Tag, A1, A2, A3, A4>::result_type t(a);
   typename detail::expression<Tagb, A1b, A2b, A3b, A4b>::result_type t2(b);
   if(detail::is_unordered_comparison(t, t2)) return false;
   return t > t2;
}

template <class Backend, expression_template_option ExpressionTemplates, class Backend2, expression_template_option ExpressionTemplates2>
inline typename boost::enable_if_c<(number_category<Backend>::value != number_kind_complex) && (number_category<Backend2>::value != number_kind_complex), bool>::type
   operator <= (const number<Backend, ExpressionTemplates>& a, const number<Backend2, ExpressionTemplates2>& b)
{
   using default_ops::eval_gt;
   if(detail::is_unordered_comparison(a, b)) return false;
   return !eval_gt(a.backend(), b.backend());
}
template <class Backend, expression_template_option ExpressionTemplates, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value && (number_category<Backend>::value != number_kind_complex), bool>::type
   operator <= (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
{
   using default_ops::eval_gt;
   if(detail::is_unordered_comparison(a, b)) return false;
   return !eval_gt(a.backend(), number<Backend, ExpressionTemplates>::canonical_value(b));
}
template <class Arithmetic, class Backend, expression_template_option ExpressionTemplates>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value && (number_category<Backend>::value != number_kind_complex), bool>::type
   operator <= (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
{
   using default_ops::eval_lt;
   if(detail::is_unordered_comparison(a, b)) return false;
   return !eval_lt(b.backend(), number<Backend, ExpressionTemplates>::canonical_value(a));
}
template <class Arithmetic, class Tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value && (number_category<typename detail::expression<Tag, A1, A2, A3, A4>::result_type>::value != number_kind_complex), bool>::type
   operator <= (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
{
   typedef typename detail::expression<Tag, A1, A2, A3, A4>::result_type result_type;
   using default_ops::eval_lt;
   if(detail::is_unordered_value(a) || detail::is_unordered_value(b))
      return false;
   result_type t(b);
   if(detail::is_unordered_comparison(a, t)) return false;
   return !eval_lt(t.backend(), result_type::canonical_value(a));
}
template <class Tag, class A1, class A2, class A3, class A4, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value && (number_category<typename detail::expression<Tag, A1, A2, A3, A4>::result_type>::value != number_kind_complex), bool>::type
   operator <= (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
{
   typedef typename detail::expression<Tag, A1, A2, A3, A4>::result_type result_type;
   using default_ops::eval_gt;
   result_type t(a);
   if(detail::is_unordered_comparison(t, b)) return false;
   return !eval_gt(t.backend(), result_type::canonical_value(b));
}
template <class Tag, class A1, class A2, class A3, class A4, class Tagb, class A1b, class A2b, class A3b, class A4b>
inline typename enable_if_c<is_same<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, typename detail::expression<Tagb, A1b, A2b, A3b, A4b>::result_type>::value && (number_category<typename detail::expression<Tag, A1, A2, A3, A4>::result_type>::value != number_kind_complex), bool>::type
   operator <= (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
{
   using default_ops::eval_gt;
   typename detail::expression<Tag, A1, A2, A3, A4>::result_type t(a);
   typename detail::expression<Tagb, A1b, A2b, A3b, A4b>::result_type t2(b);
   if(detail::is_unordered_comparison(t, t2)) return false;
   return !eval_gt(t.backend(), t2.backend());
}

template <class Backend, expression_template_option ExpressionTemplates, class Backend2, expression_template_option ExpressionTemplates2>
inline typename boost::enable_if_c<(number_category<Backend>::value != number_kind_complex) && (number_category<Backend2>::value != number_kind_complex), bool>::type
   operator >= (const number<Backend, ExpressionTemplates>& a, const number<Backend2, ExpressionTemplates2>& b)
{
   using default_ops::eval_lt;
   if(detail::is_unordered_comparison(a, b)) return false;
   return !eval_lt(a.backend(), b.backend());
}
template <class Backend, expression_template_option ExpressionTemplates, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value && (number_category<Backend>::value != number_kind_complex), bool>::type
   operator >= (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
{
   using default_ops::eval_lt;
   if(detail::is_unordered_comparison(a, b)) return false;
   return !eval_lt(a.backend(), number<Backend, ExpressionTemplates>::canonical_value(b));
}
template <class Arithmetic, class Backend, expression_template_option ExpressionTemplates>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value && (number_category<Backend>::value != number_kind_complex), bool>::type
   operator >= (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
{
   using default_ops::eval_gt;
   if(detail::is_unordered_comparison(a, b)) return false;
   return !eval_gt(b.backend(), number<Backend, ExpressionTemplates>::canonical_value(a));
}
template <class Arithmetic, class Tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value && (number_category<typename detail::expression<Tag, A1, A2, A3, A4>::result_type>::value != number_kind_complex), bool>::type
   operator >= (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
{
   typedef typename detail::expression<Tag, A1, A2, A3, A4>::result_type result_type;
   using default_ops::eval_gt;
   result_type t(b);
   if(detail::is_unordered_comparison(a, t)) return false;
   return !eval_gt(t.backend(), result_type::canonical_value(a));
}
template <class Tag, class A1, class A2, class A3, class A4, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value && (number_category<typename detail::expression<Tag, A1, A2, A3, A4>::result_type>::value != number_kind_complex), bool>::type
   operator >= (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
{
   typedef typename detail::expression<Tag, A1, A2, A3, A4>::result_type result_type;
   using default_ops::eval_lt;
   result_type t(a);
   if(detail::is_unordered_comparison(t, b)) return false;
   return !eval_lt(t.backend(), result_type::canonical_value(b));
}
template <class Tag, class A1, class A2, class A3, class A4, class Tagb, class A1b, class A2b, class A3b, class A4b>
inline typename enable_if_c<is_same<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, typename detail::expression<Tagb, A1b, A2b, A3b, A4b>::result_type>::value && (number_category<typename detail::expression<Tag, A1, A2, A3, A4>::result_type>::value != number_kind_complex), bool>::type
   operator >= (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
{
   using default_ops::eval_lt;
   typename detail::expression<Tag, A1, A2, A3, A4>::result_type t(a);
   typename detail::expression<Tagb, A1b, A2b, A3b, A4b>::result_type t2(b);
   if(detail::is_unordered_comparison(t, t2)) return false;
   return !eval_lt(t.backend(), t2.backend());
}




template <class Backend, expression_template_option ExpressionTemplates, class Backend2, expression_template_option ExpressionTemplates2>
inline bool isgreater (const number<Backend, ExpressionTemplates>& a, const number<Backend2, ExpressionTemplates2>& b) { return a > b; }

template <class Backend, expression_template_option ExpressionTemplates, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value, bool>::type
   isgreater (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b) { return a > b; }

template <class Arithmetic, class Backend, expression_template_option ExpressionTemplates>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value, bool>::type
   isgreater (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b) { return a > b; }

template <class Arithmetic, class Tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value, bool>::type
   isgreater (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b) { return a > b; }

template <class Tag, class A1, class A2, class A3, class A4, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value, bool>::type
   isgreater (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b) { return a > b; }

template <class Tag, class A1, class A2, class A3, class A4, class Tagb, class A1b, class A2b, class A3b, class A4b>
inline typename enable_if<is_same<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, typename detail::expression<Tagb, A1b, A2b, A3b, A4b>::result_type>, bool>::type
   isgreater (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b) { return a > b; }

template <class Backend, expression_template_option ExpressionTemplates, class Backend2, expression_template_option ExpressionTemplates2>
inline bool isgreaterequal (const number<Backend, ExpressionTemplates>& a, const number<Backend2, ExpressionTemplates2>& b) { return a >= b; }

template <class Backend, expression_template_option ExpressionTemplates, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value, bool>::type
   isgreaterequal (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b) { return a >= b; }

template <class Arithmetic, class Backend, expression_template_option ExpressionTemplates>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value, bool>::type
   isgreaterequal (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b) { return a >= b; }

template <class Arithmetic, class Tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value, bool>::type
   isgreaterequal (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b) { return a >= b; }

template <class Tag, class A1, class A2, class A3, class A4, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value, bool>::type
   isgreaterequal (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b) { return a >= b; }

template <class Tag, class A1, class A2, class A3, class A4, class Tagb, class A1b, class A2b, class A3b, class A4b>
inline typename enable_if<is_same<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, typename detail::expression<Tagb, A1b, A2b, A3b, A4b>::result_type>, bool>::type
   isgreaterequal (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b) { return a >= b; }

template <class Backend, expression_template_option ExpressionTemplates, class Backend2, expression_template_option ExpressionTemplates2>
inline bool islessequal (const number<Backend, ExpressionTemplates>& a, const number<Backend2, ExpressionTemplates2>& b) { return a <= b; }

template <class Backend, expression_template_option ExpressionTemplates, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value, bool>::type
islessequal (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b) { return a <= b; }

template <class Arithmetic, class Backend, expression_template_option ExpressionTemplates>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value, bool>::type
islessequal (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b) { return a <= b; }

template <class Arithmetic, class Tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value, bool>::type
islessequal (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b) { return a <= b; }

template <class Tag, class A1, class A2, class A3, class A4, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value, bool>::type
islessequal (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b) { return a <= b; }

template <class Tag, class A1, class A2, class A3, class A4, class Tagb, class A1b, class A2b, class A3b, class A4b>
inline typename enable_if<is_same<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, typename detail::expression<Tagb, A1b, A2b, A3b, A4b>::result_type>, bool>::type
islessequal (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b) { return a <= b; }

template <class Backend, expression_template_option ExpressionTemplates, class Backend2, expression_template_option ExpressionTemplates2>
inline bool isless (const number<Backend, ExpressionTemplates>& a, const number<Backend2, ExpressionTemplates2>& b) { return a < b; }

template <class Backend, expression_template_option ExpressionTemplates, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value, bool>::type
isless (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b) { return a < b; }

template <class Arithmetic, class Backend, expression_template_option ExpressionTemplates>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value, bool>::type
isless (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b) { return a < b; }

template <class Arithmetic, class Tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value, bool>::type
isless (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b) { return a < b; }

template <class Tag, class A1, class A2, class A3, class A4, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value, bool>::type
isless (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b) { return a < b; }

template <class Tag, class A1, class A2, class A3, class A4, class Tagb, class A1b, class A2b, class A3b, class A4b>
inline typename enable_if<is_same<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, typename detail::expression<Tagb, A1b, A2b, A3b, A4b>::result_type>, bool>::type
isless (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b) { return a < b; }

template <class Backend, expression_template_option ExpressionTemplates, class Backend2, expression_template_option ExpressionTemplates2>
inline bool islessgreater (const number<Backend, ExpressionTemplates>& a, const number<Backend2, ExpressionTemplates2>& b)
{
   if(detail::is_unordered_comparison(a, b)) return false;
   return a != b;
}

template <class Backend, expression_template_option ExpressionTemplates, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value, bool>::type
islessgreater (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
{
   if(detail::is_unordered_comparison(a, b)) return false;
   return a != b;
}

template <class Arithmetic, class Backend, expression_template_option ExpressionTemplates>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value, bool>::type
islessgreater (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
{
   if(detail::is_unordered_comparison(a, b)) return false;
   return a != b;
}

template <class Arithmetic, class Tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value, bool>::type
islessgreater (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& bb)
{
   typename detail::expression<Tag, A1, A2, A3, A4>::result_type b(bb);
   return islessgreater (a, b);
}

template <class Tag, class A1, class A2, class A3, class A4, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value, bool>::type
islessgreater (const detail::expression<Tag, A1, A2, A3, A4>& aa, const Arithmetic& b)
{
   typename detail::expression<Tag, A1, A2, A3, A4>::result_type a(aa);
   return islessgreater (a, b);
}

template <class Tag, class A1, class A2, class A3, class A4, class Tagb, class A1b, class A2b, class A3b, class A4b>
inline typename enable_if<is_same<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, typename detail::expression<Tagb, A1b, A2b, A3b, A4b>::result_type>, bool>::type
islessgreater (const detail::expression<Tag, A1, A2, A3, A4>& aa, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& bb)
{
   typename detail::expression<Tag, A1, A2, A3, A4>::result_type a(aa);
   typename detail::expression<Tagb, A1b, A2b, A3b, A4b>::result_type b(bb);
   return islessgreater (a, b);
}

template <class Backend, expression_template_option ExpressionTemplates, class Backend2, expression_template_option ExpressionTemplates2>
inline bool isunordered (const number<Backend, ExpressionTemplates>& a, const number<Backend2, ExpressionTemplates2>& b) { return detail::is_unordered_comparison(a, b); }

template <class Backend, expression_template_option ExpressionTemplates, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value, bool>::type
isunordered (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b) { return detail::is_unordered_comparison(a, b); }

template <class Arithmetic, class Backend, expression_template_option ExpressionTemplates>
inline typename enable_if_c<detail::is_valid_mixed_compare<number<Backend, ExpressionTemplates>, Arithmetic>::value, bool>::type
isunordered (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b) { return detail::is_unordered_comparison(a, b); }

template <class Arithmetic, class Tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value, bool>::type
isunordered (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& bb)
{
   typename detail::expression<Tag, A1, A2, A3, A4>::result_type b(bb);
   return detail::is_unordered_comparison(a, b);
}

template <class Tag, class A1, class A2, class A3, class A4, class Arithmetic>
inline typename enable_if_c<detail::is_valid_mixed_compare<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, Arithmetic>::value, bool>::type
isunordered (const detail::expression<Tag, A1, A2, A3, A4>& aa, const Arithmetic& b)
{
   typename detail::expression<Tag, A1, A2, A3, A4>::result_type a(aa);
   return detail::is_unordered_comparison(a, b);
}

template <class Tag, class A1, class A2, class A3, class A4, class Tagb, class A1b, class A2b, class A3b, class A4b>
inline typename enable_if<is_same<typename detail::expression<Tag, A1, A2, A3, A4>::result_type, typename detail::expression<Tagb, A1b, A2b, A3b, A4b>::result_type>, bool>::type
isunordered (const detail::expression<Tag, A1, A2, A3, A4>& aa, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& bb)
{
   typename detail::expression<Tag, A1, A2, A3, A4>::result_type a(aa);
   typename detail::expression<Tagb, A1b, A2b, A3b, A4b>::result_type b(bb);
   return detail::is_unordered_comparison(a, b);
}

}}


namespace boost {
   namespace multiprecision {
      namespace detail {

         template <int N>
         struct dummy_size {};

         template<typename S, typename T>
         struct has_generic_interconversion
         {
            typedef typename mpl::if_c <
               is_number<S>::value && is_number<T>::value,
               typename mpl::if_c <
               number_category<S>::value == number_kind_integer,
               typename mpl::if_c<
               number_category<T>::value == number_kind_integer
               || number_category<T>::value == number_kind_floating_point
               || number_category<T>::value == number_kind_rational
               || number_category<T>::value == number_kind_fixed_point,
               mpl::true_,
               mpl::false_
               >::type,
               typename mpl::if_c<
               number_category<S>::value == number_kind_rational,
               typename mpl::if_c<
               number_category<T>::value == number_kind_rational
               || number_category<T>::value == number_kind_rational,
               mpl::true_,
               mpl::false_
               >::type,
               typename mpl::if_c<
               number_category<T>::value == number_kind_floating_point,
               mpl::true_,
               mpl::false_
               >::type
               >::type
               > ::type,
               mpl::false_
            > ::type type;
         };

         template<typename S, typename T>
         struct is_explicitly_convertible_imp
         {

            template<typename S1, typename T1>
            static type_traits::yes_type selector(dummy_size<sizeof(static_cast<T1>(declval<S1>()))>*);

            template<typename S1, typename T1>
            static type_traits::no_type selector(...);

            static const bool value = sizeof(selector<S, T>(0)) == sizeof(type_traits::yes_type);

            typedef boost::integral_constant<bool, value> type;




         };

template<typename From, typename To>
struct is_explicitly_convertible : public is_explicitly_convertible_imp<From, To>::type
{
};
}}}



namespace boost{ namespace multiprecision{ namespace detail{


template <class From, class To>
struct is_lossy_conversion
{
   typedef typename mpl::if_c<
      ((number_category<From>::value == number_kind_floating_point) && (number_category<To>::value == number_kind_integer))

      || ((number_category<From>::value == number_kind_rational) && (number_category<To>::value == number_kind_integer))
      || ((number_category<From>::value == number_kind_fixed_point) && (number_category<To>::value == number_kind_integer))
      || (number_category<From>::value == number_kind_unknown)
      || (number_category<To>::value == number_kind_unknown),
      mpl::true_,
      mpl::false_
   >::type type;
   static const bool value = type::value;
};

template<typename From, typename To>
struct is_restricted_conversion
{
   typedef typename mpl::if_c<
      ((is_explicitly_convertible<From, To>::value && !is_convertible<From, To>::value)
      || is_lossy_conversion<From, To>::value),
      mpl::true_,
      mpl::false_
   >::type type;
   static const bool value = type::value;
};

}}}
namespace boost
{
    template <class T> struct hash;

    template <class T> void hash_combine(std::size_t& seed, T const& v);

    template <class It> std::size_t hash_range(It, It);
    template <class It> void hash_range(std::size_t&, It, It);





}

namespace boost {
    namespace hash_detail {
        template <typename Float>
        struct call_ldexp {
            typedef Float float_type;
            inline Float operator()(Float x, int y) const {
                return std::ldexp(x, y);
            }
        };

        template <typename Float>
        struct call_frexp {
            typedef Float float_type;
            inline Float operator()(Float x, int* y) const {
                return std::frexp(x, y);
            }
        };

        template <typename Float>
        struct select_hash_type
        {
            typedef Float type;
        };
    }
}
namespace boost
{
    namespace hash_detail
    {
        template <class T>
        struct limits : std::numeric_limits<T> {};
    }
}

namespace boost {

 namespace detail {

     namespace static_log2_impl {
     typedef boost::static_log2_argument_type argument_type;
     typedef boost::static_log2_result_type result_type;

     template <result_type n>
     struct choose_initial_n {

         static const bool c = (argument_type(1) << n << n) != 0;
         static const result_type value = !c*n + choose_initial_n<2*c*n>::value;




     };

     template <>
     struct choose_initial_n<0> {
         static const result_type value = 0;
     };




     const result_type n_zero = 16;
     const result_type initial_n = choose_initial_n<n_zero>::value;
     template <argument_type x, result_type n = initial_n>
     struct static_log2_impl {

         static const bool c = (x >> n) > 0;
         static const result_type value = c*n + (static_log2_impl< (x>>c*n), n/2 >::value);




     };

     template <>
     struct static_log2_impl<1, 0> {
        static const result_type value = 0;
     };

     }
 }







 template <static_log2_argument_type x>
 struct static_log2 {

     static const static_log2_result_type value = detail::static_log2_impl::static_log2_impl<x>::value;




 };


 template <>
 struct static_log2<0> { };

}
namespace boost
{
    namespace hash_detail
    {
        inline void hash_float_combine(std::size_t& seed, std::size_t value)
        {
            seed ^= value + (seed<<6) + (seed>>2);
        }







        inline std::size_t hash_binary(char* ptr, std::size_t length)
        {
            std::size_t seed = 0;

            if (length >= sizeof(std::size_t)) {
                std::memcpy(&seed, ptr, sizeof(std::size_t));
                length -= sizeof(std::size_t);
                ptr += sizeof(std::size_t);

                while(length >= sizeof(std::size_t)) {
                    std::size_t buffer = 0;
                    std::memcpy(&buffer, ptr, sizeof(std::size_t));
                    hash_float_combine(seed, buffer);
                    length -= sizeof(std::size_t);
                    ptr += sizeof(std::size_t);
                }
            }

            if (length > 0) {
                std::size_t buffer = 0;
                std::memcpy(&buffer, ptr, length);
                hash_float_combine(seed, buffer);
            }

            return seed;
        }

        template <typename Float, unsigned digits, unsigned max_exponent>
        struct enable_binary_hash
        {
            static const bool value = std::numeric_limits<Float>::is_iec559 && std::numeric_limits<Float>::digits == digits && std::numeric_limits<Float>::radix == 2 && std::numeric_limits<Float>::max_exponent == max_exponent;




        };

        template <typename Float>
        inline std::size_t float_hash_impl(Float v,
            typename boost::enable_if_c<
                enable_binary_hash<Float, 24, 128>::value,
                std::size_t>::type)
        {
            return hash_binary((char*) &v, 4);
        }


        template <typename Float>
        inline std::size_t float_hash_impl(Float v,
            typename boost::enable_if_c<
                enable_binary_hash<Float, 53, 1024>::value,
                std::size_t>::type)
        {
            return hash_binary((char*) &v, 8);
        }

        template <typename Float>
        inline std::size_t float_hash_impl(Float v,
            typename boost::enable_if_c<
                enable_binary_hash<Float, 64, 16384>::value,
                std::size_t>::type)
        {
            return hash_binary((char*) &v, 10);
        }

        template <typename Float>
        inline std::size_t float_hash_impl(Float v,
            typename boost::enable_if_c<
                enable_binary_hash<Float, 113, 16384>::value,
                std::size_t>::type)
        {
            return hash_binary((char*) &v, 16);
        }






        template <class T>
        inline std::size_t float_hash_impl2(T v)
        {
            boost::hash_detail::call_frexp<T> frexp;
            boost::hash_detail::call_ldexp<T> ldexp;

            int exp = 0;

            v = frexp(v, &exp);



            if(v < 0) {
                v = -v;
                exp += limits<T>::max_exponent -
                    limits<T>::min_exponent;
            }

            v = ldexp(v, limits<std::size_t>::digits);
            std::size_t seed = static_cast<std::size_t>(v);
            v -= static_cast<T>(seed);


            std::size_t const length
                = (limits<T>::digits *
                        boost::static_log2<limits<T>::radix>::value
                        + limits<std::size_t>::digits - 1)
                / limits<std::size_t>::digits;

            for(std::size_t i = 0; i != length; ++i)
            {
                v = ldexp(v, limits<std::size_t>::digits);
                std::size_t part = static_cast<std::size_t>(v);
                v -= static_cast<T>(part);
                hash_float_combine(seed, part);
            }

            hash_float_combine(seed, static_cast<std::size_t>(exp));

            return seed;
        }


        template <class T>
        inline std::size_t float_hash_impl(T v, ...)
        {
            typedef typename select_hash_type<T>::type type;
            return float_hash_impl2(static_cast<type>(v));
        }

    }
}
namespace boost
{
    namespace hash_detail
    {
        template <class T>
        inline bool is_zero(T v)
        {







            return std::equal_to<T>()(v, 0);

        }

        template <class T>
        inline std::size_t float_hash_value(T v)
        {
            return boost::hash_detail::is_zero(v) ? 0 : float_hash_impl(v, 0);
        }
    }
}
















namespace boost
{
    namespace hash_detail
    {
        template <typename T>
        struct hash_base : std::unary_function<T, std::size_t> {};


        struct enable_hash_value { typedef std::size_t type; };

        template <typename T> struct basic_numbers {};
        template <typename T> struct long_numbers;
        template <typename T> struct ulong_numbers;
        template <typename T> struct float_numbers {};

        template <> struct basic_numbers<bool> :
            boost::hash_detail::enable_hash_value {};
        template <> struct basic_numbers<char> :
            boost::hash_detail::enable_hash_value {};
        template <> struct basic_numbers<unsigned char> :
            boost::hash_detail::enable_hash_value {};
        template <> struct basic_numbers<signed char> :
            boost::hash_detail::enable_hash_value {};
        template <> struct basic_numbers<short> :
            boost::hash_detail::enable_hash_value {};
        template <> struct basic_numbers<unsigned short> :
            boost::hash_detail::enable_hash_value {};
        template <> struct basic_numbers<int> :
            boost::hash_detail::enable_hash_value {};
        template <> struct basic_numbers<unsigned int> :
            boost::hash_detail::enable_hash_value {};
        template <> struct basic_numbers<long> :
            boost::hash_detail::enable_hash_value {};
        template <> struct basic_numbers<unsigned long> :
            boost::hash_detail::enable_hash_value {};


        template <> struct basic_numbers<wchar_t> :
            boost::hash_detail::enable_hash_value {};



        template <> struct basic_numbers<char16_t> :
            boost::hash_detail::enable_hash_value {};



        template <> struct basic_numbers<char32_t> :
            boost::hash_detail::enable_hash_value {};





        template <typename T> struct long_numbers2 {};
        template <typename T> struct ulong_numbers2 {};
        template <typename T> struct long_numbers : long_numbers2<T> {};
        template <typename T> struct ulong_numbers : ulong_numbers2<T> {};


        template <> struct long_numbers<boost::long_long_type> :
            boost::hash_detail::enable_hash_value {};
        template <> struct ulong_numbers<boost::ulong_long_type> :
            boost::hash_detail::enable_hash_value {};



        template <> struct long_numbers2<boost::int128_type> :
            boost::hash_detail::enable_hash_value {};
        template <> struct ulong_numbers2<boost::uint128_type> :
            boost::hash_detail::enable_hash_value {};


        template <> struct float_numbers<float> :
            boost::hash_detail::enable_hash_value {};
        template <> struct float_numbers<double> :
            boost::hash_detail::enable_hash_value {};
        template <> struct float_numbers<long double> :
            boost::hash_detail::enable_hash_value {};
    }

    template <typename T>
    typename boost::hash_detail::basic_numbers<T>::type hash_value(T);
    template <typename T>
    typename boost::hash_detail::long_numbers<T>::type hash_value(T);
    template <typename T>
    typename boost::hash_detail::ulong_numbers<T>::type hash_value(T);

    template <typename T>
    typename boost::enable_if<boost::is_enum<T>, std::size_t>::type
        hash_value(T);


    template <class T> std::size_t hash_value(T* const&);





    template< class T, unsigned N >
    std::size_t hash_value(const T (&x)[N]);

    template< class T, unsigned N >
    std::size_t hash_value(T (&x)[N]);


    template <class Ch, class A>
    std::size_t hash_value(
        std::basic_string<Ch, std::char_traits<Ch>, A> const&);


    template <class Ch>
    std::size_t hash_value(
        std::basic_string_view<Ch, std::char_traits<Ch> > const&);


    template <typename T>
    typename boost::hash_detail::float_numbers<T>::type hash_value(T);


    template <typename T>
    std::size_t hash_value(std::optional<T> const&);



    std::size_t hash_value(std::monostate);
    template <typename... Types>
    std::size_t hash_value(std::variant<Types...> const&);



    std::size_t hash_value(std::type_index);



    std::size_t hash_value(std::error_code const&);
    std::size_t hash_value(std::error_condition const&);




    namespace hash_detail
    {
        template <class T>
        inline std::size_t hash_value_signed(T val)
        {
             const unsigned int size_t_bits = std::numeric_limits<std::size_t>::digits;

             const int length = (std::numeric_limits<T>::digits - 1)
                 / static_cast<int>(size_t_bits);

             std::size_t seed = 0;
             T positive = val < 0 ? -1 - val : val;


             for(unsigned int i = length * size_t_bits; i > 0; i -= size_t_bits)
             {
                 seed ^= (std::size_t) (positive >> i) + (seed<<6) + (seed>>2);
             }
             seed ^= (std::size_t) val + (seed<<6) + (seed>>2);

             return seed;
        }

        template <class T>
        inline std::size_t hash_value_unsigned(T val)
        {
             const unsigned int size_t_bits = std::numeric_limits<std::size_t>::digits;

             const int length = (std::numeric_limits<T>::digits - 1)
                 / static_cast<int>(size_t_bits);

             std::size_t seed = 0;


             for(unsigned int i = length * size_t_bits; i > 0; i -= size_t_bits)
             {
                 seed ^= (std::size_t) (val >> i) + (seed<<6) + (seed>>2);
             }
             seed ^= (std::size_t) val + (seed<<6) + (seed>>2);

             return seed;
        }

        template <typename SizeT>
        inline void hash_combine_impl(SizeT& seed, SizeT value)
        {
            seed ^= value + 0x9e3779b9 + (seed<<6) + (seed>>2);
        }

        inline void hash_combine_impl(boost::uint32_t& h1,
                boost::uint32_t k1)
        {
            const uint32_t c1 = 0xcc9e2d51;
            const uint32_t c2 = 0x1b873593;

            k1 *= c1;
            k1 = (k1 << 15) | (k1 >> (32 - 15));
            k1 *= c2;

            h1 ^= k1;
            h1 = (h1 << 13) | (h1 >> (32 - 13));
            h1 = h1*5+0xe6546b64;
        }







        inline void hash_combine_impl(boost::uint64_t& h,
                boost::uint64_t k)
        {
            const boost::uint64_t m = (0xc6a4a7935bd1e995ULL);
            const int r = 47;

            k *= m;
            k ^= k >> r;
            k *= m;

            h ^= k;
            h *= m;



            h += 0xe6546b64;
        }


    }

    template <typename T>
    typename boost::hash_detail::basic_numbers<T>::type hash_value(T v)
    {
        return static_cast<std::size_t>(v);
    }

    template <typename T>
    typename boost::hash_detail::long_numbers<T>::type hash_value(T v)
    {
        return hash_detail::hash_value_signed(v);
    }

    template <typename T>
    typename boost::hash_detail::ulong_numbers<T>::type hash_value(T v)
    {
        return hash_detail::hash_value_unsigned(v);
    }

    template <typename T>
    typename boost::enable_if<boost::is_enum<T>, std::size_t>::type
        hash_value(T v)
    {
        return static_cast<std::size_t>(v);
    }



    template <class T> std::size_t hash_value(T* const& v)



    {






        std::size_t x = static_cast<std::size_t>(
           reinterpret_cast<std::ptrdiff_t>(v));

        return x + (x >> 3);
    }
    template <class T>
    inline void hash_combine(std::size_t& seed, T const& v)
    {
        boost::hash<T> hasher;
        return boost::hash_detail::hash_combine_impl(seed, hasher(v));
    }





    template <class It>
    inline std::size_t hash_range(It first, It last)
    {
        std::size_t seed = 0;

        for(; first != last; ++first)
        {
            hash_combine(seed, *first);
        }

        return seed;
    }

    template <class It>
    inline void hash_range(std::size_t& seed, It first, It last)
    {
        for(; first != last; ++first)
        {
            hash_combine(seed, *first);
        }
    }
    template< class T, unsigned N >
    inline std::size_t hash_value(const T (&x)[N])
    {
        return hash_range(x, x + N);
    }

    template< class T, unsigned N >
    inline std::size_t hash_value(T (&x)[N])
    {
        return hash_range(x, x + N);
    }


    template <class Ch, class A>
    inline std::size_t hash_value(
        std::basic_string<Ch, std::char_traits<Ch>, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }


    template <class Ch>
    inline std::size_t hash_value(
        std::basic_string_view<Ch, std::char_traits<Ch> > const& v)
    {
        return hash_range(v.begin(), v.end());
    }


    template <typename T>
    typename boost::hash_detail::float_numbers<T>::type hash_value(T v)
    {
        return boost::hash_detail::float_hash_value(v);
    }


    template <typename T>
    inline std::size_t hash_value(std::optional<T> const& v) {
        if (!v) {

            return 0x12345678;
        } else {
            boost::hash<T> hf;
            return hf(*v);
        }
    }



    inline std::size_t hash_value(std::monostate) {
        return 0x87654321;
    }

    template <typename... Types>
    inline std::size_t hash_value(std::variant<Types...> const& v) {
        std::size_t seed = 0;
        hash_combine(seed, v.index());
        std::visit([&seed](auto&& x) { hash_combine(seed, x); }, v);
        return seed;
    }




    inline std::size_t hash_value(std::type_index v)
    {
        return v.hash_code();
    }



    inline std::size_t hash_value(std::error_code const& v) {
        std::size_t seed = 0;
        hash_combine(seed, v.value());
        hash_combine(seed, &v.category());
        return seed;
    }

    inline std::size_t hash_value(std::error_condition const& v) {
        std::size_t seed = 0;
        hash_combine(seed, v.value());
        hash_combine(seed, &v.category());
        return seed;
    }
    template <> struct hash<bool> : public boost::hash_detail::hash_base<bool> { std::size_t operator()(bool v) const { return boost::hash_value(v); } };
    template <> struct hash<char> : public boost::hash_detail::hash_base<char> { std::size_t operator()(char v) const { return boost::hash_value(v); } };
    template <> struct hash<signed char> : public boost::hash_detail::hash_base<signed char> { std::size_t operator()(signed char v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned char> : public boost::hash_detail::hash_base<unsigned char> { std::size_t operator()(unsigned char v) const { return boost::hash_value(v); } };

    template <> struct hash<wchar_t> : public boost::hash_detail::hash_base<wchar_t> { std::size_t operator()(wchar_t v) const { return boost::hash_value(v); } };


    template <> struct hash<char16_t> : public boost::hash_detail::hash_base<char16_t> { std::size_t operator()(char16_t v) const { return boost::hash_value(v); } };


    template <> struct hash<char32_t> : public boost::hash_detail::hash_base<char32_t> { std::size_t operator()(char32_t v) const { return boost::hash_value(v); } };

    template <> struct hash<short> : public boost::hash_detail::hash_base<short> { std::size_t operator()(short v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned short> : public boost::hash_detail::hash_base<unsigned short> { std::size_t operator()(unsigned short v) const { return boost::hash_value(v); } };
    template <> struct hash<int> : public boost::hash_detail::hash_base<int> { std::size_t operator()(int v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned int> : public boost::hash_detail::hash_base<unsigned int> { std::size_t operator()(unsigned int v) const { return boost::hash_value(v); } };
    template <> struct hash<long> : public boost::hash_detail::hash_base<long> { std::size_t operator()(long v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned long> : public boost::hash_detail::hash_base<unsigned long> { std::size_t operator()(unsigned long v) const { return boost::hash_value(v); } };

    template <> struct hash<float> : public boost::hash_detail::hash_base<float> { std::size_t operator()(float v) const { return boost::hash_value(v); } };
    template <> struct hash<double> : public boost::hash_detail::hash_base<double> { std::size_t operator()(double v) const { return boost::hash_value(v); } };
    template <> struct hash<long double> : public boost::hash_detail::hash_base<long double> { std::size_t operator()(long double v) const { return boost::hash_value(v); } };

    template <> struct hash<std::string> : public boost::hash_detail::hash_base<std::string> { std::size_t operator()(std::string const& v) const { return boost::hash_value(v); } };

    template <> struct hash<std::wstring> : public boost::hash_detail::hash_base<std::wstring> { std::size_t operator()(std::wstring const& v) const { return boost::hash_value(v); } };


    template <> struct hash<std::basic_string<char16_t> > : public boost::hash_detail::hash_base<std::basic_string<char16_t> > { std::size_t operator()(std::basic_string<char16_t> const& v) const { return boost::hash_value(v); } };


    template <> struct hash<std::basic_string<char32_t> > : public boost::hash_detail::hash_base<std::basic_string<char32_t> > { std::size_t operator()(std::basic_string<char32_t> const& v) const { return boost::hash_value(v); } };



    template <> struct hash<std::string_view> : public boost::hash_detail::hash_base<std::string_view> { std::size_t operator()(std::string_view const& v) const { return boost::hash_value(v); } };

    template <> struct hash<std::wstring_view> : public boost::hash_detail::hash_base<std::wstring_view> { std::size_t operator()(std::wstring_view const& v) const { return boost::hash_value(v); } };


    template <> struct hash<std::basic_string_view<char16_t> > : public boost::hash_detail::hash_base<std::basic_string_view<char16_t> > { std::size_t operator()(std::basic_string_view<char16_t> const& v) const { return boost::hash_value(v); } };


    template <> struct hash<std::basic_string_view<char32_t> > : public boost::hash_detail::hash_base<std::basic_string_view<char32_t> > { std::size_t operator()(std::basic_string_view<char32_t> const& v) const { return boost::hash_value(v); } };




    template <> struct hash<boost::long_long_type> : public boost::hash_detail::hash_base<boost::long_long_type> { std::size_t operator()(boost::long_long_type v) const { return boost::hash_value(v); } };
    template <> struct hash<boost::ulong_long_type> : public boost::hash_detail::hash_base<boost::ulong_long_type> { std::size_t operator()(boost::ulong_long_type v) const { return boost::hash_value(v); } };



    template <> struct hash<boost::int128_type> : public boost::hash_detail::hash_base<boost::int128_type> { std::size_t operator()(boost::int128_type v) const { return boost::hash_value(v); } };
    template <> struct hash<boost::uint128_type> : public boost::hash_detail::hash_base<boost::uint128_type> { std::size_t operator()(boost::uint128_type v) const { return boost::hash_value(v); } };



    template <typename T>
    struct hash<std::optional<T> > : public boost::hash_detail::hash_base<std::optional<T> > { std::size_t operator()(std::optional<T> const& v) const { return boost::hash_value(v); } };
    template <> struct hash<std::type_index> : public boost::hash_detail::hash_base<std::type_index> { std::size_t operator()(std::type_index v) const { return boost::hash_value(v); } };
    template <class T>
    struct hash<T*>
        : public boost::hash_detail::hash_base<T*>
    {
        std::size_t operator()(T* v) const
        {

            return boost::hash_value(v);






        }
    };
}

namespace boost
{
    template <class A, class B>
    std::size_t hash_value(std::pair<A, B> const&);
    template <class T, class A>
    std::size_t hash_value(std::vector<T, A> const&);
    template <class T, class A>
    std::size_t hash_value(std::list<T, A> const& v);
    template <class T, class A>
    std::size_t hash_value(std::deque<T, A> const& v);
    template <class K, class C, class A>
    std::size_t hash_value(std::set<K, C, A> const& v);
    template <class K, class C, class A>
    std::size_t hash_value(std::multiset<K, C, A> const& v);
    template <class K, class T, class C, class A>
    std::size_t hash_value(std::map<K, T, C, A> const& v);
    template <class K, class T, class C, class A>
    std::size_t hash_value(std::multimap<K, T, C, A> const& v);

    template <class T>
    std::size_t hash_value(std::complex<T> const&);

    template <class A, class B>
    std::size_t hash_value(std::pair<A, B> const& v)
    {
        std::size_t seed = 0;
        boost::hash_combine(seed, v.first);
        boost::hash_combine(seed, v.second);
        return seed;
    }

    inline std::size_t hash_range(
        std::vector<bool>::iterator first,
        std::vector<bool>::iterator last)
    {
        std::size_t seed = 0;

        for(; first != last; ++first)
        {
            hash_combine<bool>(seed, *first);
        }

        return seed;
    }

    inline std::size_t hash_range(
        std::vector<bool>::const_iterator first,
        std::vector<bool>::const_iterator last)
    {
        std::size_t seed = 0;

        for(; first != last; ++first)
        {
            hash_combine<bool>(seed, *first);
        }

        return seed;
    }

    inline void hash_range(
        std::size_t& seed,
        std::vector<bool>::iterator first,
        std::vector<bool>::iterator last)
    {
        for(; first != last; ++first)
        {
            hash_combine<bool>(seed, *first);
        }
    }

    inline void hash_range(
        std::size_t& seed,
        std::vector<bool>::const_iterator first,
        std::vector<bool>::const_iterator last)
    {
        for(; first != last; ++first)
        {
            hash_combine<bool>(seed, *first);
        }
    }

    template <class T, class A>
    std::size_t hash_value(std::vector<T, A> const& v)
    {
        return boost::hash_range(v.begin(), v.end());
    }

    template <class T, class A>
    std::size_t hash_value(std::list<T, A> const& v)
    {
        return boost::hash_range(v.begin(), v.end());
    }

    template <class T, class A>
    std::size_t hash_value(std::deque<T, A> const& v)
    {
        return boost::hash_range(v.begin(), v.end());
    }

    template <class K, class C, class A>
    std::size_t hash_value(std::set<K, C, A> const& v)
    {
        return boost::hash_range(v.begin(), v.end());
    }

    template <class K, class C, class A>
    std::size_t hash_value(std::multiset<K, C, A> const& v)
    {
        return boost::hash_range(v.begin(), v.end());
    }

    template <class K, class T, class C, class A>
    std::size_t hash_value(std::map<K, T, C, A> const& v)
    {
        return boost::hash_range(v.begin(), v.end());
    }

    template <class K, class T, class C, class A>
    std::size_t hash_value(std::multimap<K, T, C, A> const& v)
    {
        return boost::hash_range(v.begin(), v.end());
    }

    template <class T>
    std::size_t hash_value(std::complex<T> const& v)
    {
        boost::hash<T> hasher;
        std::size_t seed = hasher(v.imag());
        seed ^= hasher(v.real()) + (seed<<6) + (seed>>2);
        return seed;
    }


    template <class T, std::size_t N>
    std::size_t hash_value(std::array<T, N> const& v)
    {
        return boost::hash_range(v.begin(), v.end());
    }



    namespace hash_detail {
        template <std::size_t I, typename T>
        inline typename boost::enable_if_c<(I == std::tuple_size<T>::value),
                void>::type
            hash_combine_tuple(std::size_t&, T const&)
        {
        }

        template <std::size_t I, typename T>
        inline typename boost::enable_if_c<(I < std::tuple_size<T>::value),
                void>::type
            hash_combine_tuple(std::size_t& seed, T const& v)
        {
            boost::hash_combine(seed, std::get<I>(v));
            boost::hash_detail::hash_combine_tuple<I + 1>(seed, v);
        }

        template <typename T>
        inline std::size_t hash_tuple(T const& v)
        {
            std::size_t seed = 0;
            boost::hash_detail::hash_combine_tuple<0>(seed, v);
            return seed;
        }
    }


    template <typename... T>
    inline std::size_t hash_value(std::tuple<T...> const& v)
    {
        return boost::hash_detail::hash_tuple(v);
    }
    template <typename T>
    inline std::size_t hash_value(std::shared_ptr<T> const& x) {
        return boost::hash_value(x.get());
    }

    template <typename T, typename Deleter>
    inline std::size_t hash_value(std::unique_ptr<T, Deleter> const& x) {
        return boost::hash_value(x.get());
    }
    template <class T> struct hash
        : boost::hash_detail::hash_base<T>
    {

        std::size_t operator()(T const& val) const
        {
            return hash_value(val);
        }






    };
}







namespace boost{ namespace multiprecision{
template <class Backend, expression_template_option ExpressionTemplates>
class number
{
   typedef number<Backend, ExpressionTemplates> self_type;
public:
   typedef Backend backend_type;
   typedef typename component_type<self_type>::type value_type;
   inline constexpr number() noexcept((noexcept(Backend()))) {}
   inline constexpr number(const number& e) noexcept((noexcept(Backend(std::declval<Backend const&>())))) : m_backend(e.m_backend){}
   template <class V>
   inline number(const V& v, typename boost::enable_if_c<
            (boost::is_arithmetic<V>::value || is_same<std::string, V>::value || is_convertible<V, const char*>::value)
            && !is_convertible<typename detail::canonical<V, Backend>::type, Backend>::value
            && !detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value



         >::type* = 0)
   {
      m_backend = canonical_value(v);
   }
   template <class V>
   inline constexpr number(const V& v, typename boost::enable_if_c<
            is_convertible<typename detail::canonical<V, Backend>::type, Backend>::value
            && !detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value
   >::type* = 0)

          noexcept((noexcept(Backend(std::declval<typename detail::canonical<V, Backend>::type const&>()))))

      : m_backend(canonical_value(v)) {}
   template <class V>
   inline constexpr number(const V& v, unsigned digits10, typename boost::enable_if_c<
      (boost::is_arithmetic<V>::value || is_same<std::string, V>::value || is_convertible<V, const char*>::value)
      && !detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value
      && (boost::multiprecision::number_category<Backend>::value != boost::multiprecision::number_kind_complex)
      && (boost::multiprecision::number_category<Backend>::value != boost::multiprecision::number_kind_rational)



   >::type* = 0)
      : m_backend(canonical_value(v), digits10) {}
   inline constexpr number(const number& e, unsigned digits10)
      noexcept((noexcept(Backend(std::declval<Backend const&>(), std::declval<unsigned>()))))
      : m_backend(e.m_backend, digits10){}
   template <class V>
   explicit inline number(const V& v, typename boost::enable_if_c<
            (boost::is_arithmetic<V>::value || is_same<std::string, V>::value || is_convertible<V, const char*>::value)
            && !detail::is_explicitly_convertible<typename detail::canonical<V, Backend>::type, Backend>::value
            && detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value
         >::type* = 0)
         noexcept((noexcept(std::declval<Backend&>() = std::declval<typename detail::canonical<V, Backend>::type const&>())))
   {
      m_backend = canonical_value(v);
   }
   template <class V>
   explicit inline constexpr number(const V& v, typename boost::enable_if_c<
            detail::is_explicitly_convertible<typename detail::canonical<V, Backend>::type, Backend>::value
            && (detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value
                || !is_convertible<typename detail::canonical<V, Backend>::type, Backend>::value)
         >::type* = 0)
         noexcept((noexcept(Backend(std::declval<typename detail::canonical<V, Backend>::type const&>()))))
      : m_backend(canonical_value(v)) {}
   template <class V>
   explicit inline constexpr number(const V& v, unsigned digits10, typename boost::enable_if_c<
      (boost::is_arithmetic<V>::value || is_same<std::string, V>::value || is_convertible<V, const char*>::value)
      && detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value
      && (boost::multiprecision::number_category<Backend>::value != boost::multiprecision::number_kind_complex)
      && (boost::multiprecision::number_category<Backend>::value != boost::multiprecision::number_kind_rational)
   >::type* = 0)
      : m_backend(canonical_value(v), digits10) {}

   template<expression_template_option ET>
   inline constexpr number(const number<Backend, ET>& val)
      noexcept((noexcept(Backend(std::declval<Backend const&>())))) : m_backend(val.backend()) {}

   template <class Other, expression_template_option ET>
   inline number(const number<Other, ET>& val,
         typename boost::enable_if_c<(boost::is_convertible<Other, Backend>::value && !detail::is_restricted_conversion<Other, Backend>::value)>::type* = 0)
      noexcept((noexcept(Backend(std::declval<Other const&>()))))
      : m_backend(val.backend()) {}

   template <class Other, expression_template_option ET>
   explicit number(const number<Other, ET>& val, typename boost::enable_if_c<
         (!detail::is_explicitly_convertible<Other, Backend>::value)
         >::type* = 0)
   {



      detail::scoped_default_precision<number<Backend, ExpressionTemplates> > precision_guard(val);
      using detail::generic_interconvert;
      generic_interconvert(backend(), val.backend(), number_category<Backend>(), number_category<Other>());
   }
   template <class Other, expression_template_option ET>
   explicit inline number(const number<Other, ET>& val, typename boost::enable_if_c<
         (detail::is_explicitly_convertible<Other, Backend>::value
            && (detail::is_restricted_conversion<Other, Backend>::value || !boost::is_convertible<Other, Backend>::value))
         >::type* = 0) noexcept((noexcept(Backend(std::declval<Other const&>()))))
      : m_backend(val.backend()) {}

   template <class V, class U>
   inline number(const V& v1, const U& v2,
      typename boost::enable_if_c<(is_convertible<V, value_type>::value && is_convertible<U, value_type>::value && !is_same<typename component_type<self_type>::type, self_type>::value)>::type* = 0)
   {
      using default_ops::assign_components;
      detail::scoped_default_precision<number<Backend, ExpressionTemplates> > precision_guard(v1, v2);
      assign_components(m_backend, canonical_value(detail::evaluate_if_expression(v1)), canonical_value(detail::evaluate_if_expression(v2)));
   }
   template <class V, class U>
   inline explicit number(const V& v1, const U& v2,
      typename boost::enable_if_c<
            (is_constructible<value_type, V>::value || is_convertible<V, std::string>::value)
            && (is_constructible<value_type, U>::value || is_convertible<U, std::string>::value)
            && !is_same<typename component_type<self_type>::type, self_type>::value
            && !is_same<V, self_type>::value
            && !(is_convertible<V, value_type>::value && is_convertible<U, value_type>::value)
      >::type* = 0)
   {
      using default_ops::assign_components;
      detail::scoped_default_precision<number<Backend, ExpressionTemplates> > precision_guard(v1, v2);
      assign_components(m_backend, canonical_value(detail::evaluate_if_expression(v1)), canonical_value(detail::evaluate_if_expression(v2)));
   }




   template <class Traits>
   explicit inline number(const std::basic_string_view<char, Traits>& view)
   {
      using default_ops::assign_from_string_view;
      assign_from_string_view(this->backend(), view);
   }
   template <class Traits>
   explicit inline number(const std::basic_string_view<char, Traits>& view_x, const std::basic_string_view<char, Traits>& view_y)
   {
      using default_ops::assign_from_string_view;
      assign_from_string_view(this->backend(), view_x, view_y);
   }
   template <class Traits>
   explicit inline number(const std::basic_string_view<char, Traits>& v, unsigned digits10)
      : m_backend(canonical_value(v), digits10) {}
   template <class Traits>
   number& assign(const std::basic_string_view<char, Traits>& view)
   {
      using default_ops::assign_from_string_view;
      assign_from_string_view(this->backend(), view);
      return *this;
   }


   template <class V, class U>
   inline number(const V& v1, const U& v2, unsigned digits10,
      typename boost::enable_if_c<(is_convertible<V, value_type>::value && is_convertible<U, value_type>::value && !is_same<typename component_type<self_type>::type, self_type>::value)>::type* = 0)
      : m_backend(canonical_value(detail::evaluate_if_expression(v1)), canonical_value(detail::evaluate_if_expression(v2)), digits10) {}
   template <class V, class U>
   inline explicit number(const V& v1, const U& v2, unsigned digits10,
      typename boost::enable_if_c<((is_constructible<value_type, V>::value || is_convertible<V, std::string>::value) && (is_constructible<value_type, U>::value || is_convertible<U, std::string>::value) && !is_same<typename component_type<self_type>::type, self_type>::value) && !(is_convertible<V, value_type>::value && is_convertible<U, value_type>::value)>::type* = 0)
      : m_backend(canonical_value(detail::evaluate_if_expression(v1)), canonical_value(detail::evaluate_if_expression(v2)), digits10){}


   template <class Other, expression_template_option ET>
   inline number(const number<Other, ET>& v1, const number<Other, ET>& v2, typename boost::enable_if<boost::is_convertible<Other, Backend> >::type* = 0)
   {
      using default_ops::assign_components;
      detail::scoped_default_precision<number<Backend, ExpressionTemplates> > precision_guard(v1, v2);
      assign_components(m_backend, v1.backend(), v2.backend());
   }

   template <class tag, class Arg1, class Arg2, class Arg3, class Arg4>
   typename boost::enable_if<is_convertible<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, self_type>, number&>::type operator=(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)
   {
      typedef typename is_same<number, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::type tag_type;
      detail::scoped_default_precision<number<Backend, ExpressionTemplates> > precision_guard(e);
      if constexpr (boost::multiprecision::detail::is_variable_precision<number>::value)
         if (boost::multiprecision::detail::current_precision_of(e) != boost::multiprecision::detail::current_precision_of(*this))
         {
            number t(e);
            return *this = std::move(t);
         }
      do_assign(e, tag_type());
      return *this;
   }
   template <class tag, class Arg1, class Arg2, class Arg3, class Arg4>
   number& assign(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)
   {
      typedef typename is_same<number, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>::type tag_type;
      detail::scoped_default_precision<number<Backend, ExpressionTemplates> > precision_guard(e);
      if constexpr (boost::multiprecision::detail::is_variable_precision<number>::value)
         if (boost::multiprecision::detail::current_precision_of(e) != boost::multiprecision::detail::current_precision_of(*this))
         {
            number t;
            t.assign(e);
            return *this = std::move(t);
         }
      do_assign(e, tag_type());
      return *this;
   }

   inline number& operator=(const number& e)
      noexcept((noexcept(std::declval<Backend&>() = std::declval<Backend const&>())))
   {
      m_backend = e.m_backend;
      return *this;
   }

   template <class V>
   inline typename boost::enable_if<is_convertible<V, self_type>, number<Backend, ExpressionTemplates>& >::type
      operator=(const V& v)
      noexcept((noexcept(std::declval<Backend&>() = std::declval<const typename detail::canonical<V, Backend>::type&>())))
   {
      m_backend = canonical_value(v);
      return *this;
   }
   template <class V>
   inline number<Backend, ExpressionTemplates>& assign(const V& v)
      noexcept((noexcept(std::declval<Backend&>() = std::declval<const typename detail::canonical<V, Backend>::type&>())))
   {
      m_backend = canonical_value(v);
      return *this;
   }
   template <class V>
   inline number<Backend, ExpressionTemplates>& assign(const V& v, unsigned digits10)
      noexcept((noexcept(std::declval<Backend&>() = std::declval<const typename detail::canonical<V, Backend>::type&>())))
   {
      number t(v, digits10);
      return *this = t;
   }
   template <class Other, expression_template_option ET>
   typename boost::disable_if<boost::multiprecision::detail::is_explicitly_convertible<Other, Backend>, number<Backend, ExpressionTemplates>& >::type
      assign(const number<Other, ET>& v)
   {



      using detail::generic_interconvert;
      detail::scoped_default_precision<number<Backend, ExpressionTemplates> > precision_guard(v);
      if constexpr (boost::multiprecision::detail::is_variable_precision<number>::value)
         if (boost::multiprecision::detail::current_precision_of(v) != boost::multiprecision::detail::current_precision_of(*this))
         {
            number t(v);
            return *this = std::move(t);
         }
      generic_interconvert(backend(), v.backend(), number_category<Backend>(), number_category<Other>());
      return *this;
   }

   template <class tag, class Arg1, class Arg2, class Arg3, class Arg4>
   number(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e, typename boost::enable_if_c<is_convertible<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, self_type>::value>::type* = 0)
   {
      detail::scoped_default_precision<number<Backend, ExpressionTemplates> > precision_guard(e);
      if constexpr (boost::multiprecision::detail::is_variable_precision<number>::value)
         if (boost::multiprecision::detail::current_precision_of(e) != boost::multiprecision::detail::current_precision_of(*this))
         {
            number t(e);
            *this = std::move(t);
         }
      *this = e;
   }
   template <class tag, class Arg1, class Arg2, class Arg3, class Arg4>
   explicit number(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e,
      typename boost::enable_if_c<!is_convertible<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, self_type>::value
      && boost::multiprecision::detail::is_explicitly_convertible<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, self_type>::value>::type* = 0)
   {
      detail::scoped_default_precision<number<Backend, ExpressionTemplates> > precision_guard(e);
      if constexpr (boost::multiprecision::detail::is_variable_precision<number>::value)
         if (boost::multiprecision::detail::current_precision_of(e) != boost::multiprecision::detail::current_precision_of(*this))
         {
            number t(e);
            *this = std::move(t);
         }
      assign(e);
   }


   inline constexpr number(number&& r)
      noexcept((noexcept(Backend(std::declval<Backend>()))))
      : m_backend(static_cast<Backend&&>(r.m_backend)){}
   inline number& operator=(number&& r) noexcept((noexcept(std::declval<Backend&>() = std::declval<Backend>())))
   {
      m_backend = static_cast<Backend&&>(r.m_backend);
      return *this;
   }


   number& operator+=(const self_type& val)
   {
      detail::scoped_default_precision<number<Backend, ExpressionTemplates> > precision_guard(*this, val);
      if constexpr (boost::multiprecision::detail::is_variable_precision<number>::value)
         if (boost::multiprecision::detail::current_precision_of(val) != boost::multiprecision::detail::current_precision_of(*this))
         {
            number t(*this + val);
            return *this = std::move(t);
         }
      do_add(detail::expression<detail::terminal, self_type>(val), detail::terminal());
      return *this;
   }

   template <class tag, class Arg1, class Arg2, class Arg3, class Arg4>
   typename boost::enable_if<is_convertible<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, self_type>, number&>::type operator+=(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)
   {
      detail::scoped_default_precision<number<Backend, ExpressionTemplates> > precision_guard(*this, e);


      if((contains_self(e) && !is_self(e)))
      {
         self_type temp(e);
         do_add(detail::expression<detail::terminal, self_type>(temp), detail::terminal());
      }
      else
      {
         do_add(e, tag());
      }
      return *this;
   }

   template <class Arg1, class Arg2, class Arg3, class Arg4>
   number& operator+=(const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& e)
   {
      detail::scoped_default_precision<number<Backend, ExpressionTemplates> > precision_guard(*this, e);
      if constexpr (boost::multiprecision::detail::is_variable_precision<number>::value)
         if (boost::multiprecision::detail::current_precision_of(e) != boost::multiprecision::detail::current_precision_of(*this))
         {
            number t(*this + e);
            return *this = std::move(t);
         }



      using default_ops::eval_multiply_add;
      eval_multiply_add(m_backend, canonical_value(e.left_ref()), canonical_value(e.right_ref()));
      return *this;
   }

   template <class V>
   typename boost::enable_if<boost::is_convertible<V, self_type>, number<Backend, ExpressionTemplates>& >::type
      operator+=(const V& v)
   {
      using default_ops::eval_add;
      eval_add(m_backend, canonical_value(v));
      return *this;
   }

   number& operator-=(const self_type& val)
   {
      detail::scoped_default_precision<number<Backend, ExpressionTemplates> > precision_guard(*this, val);
      if constexpr (boost::multiprecision::detail::is_variable_precision<number>::value)
         if (boost::multiprecision::detail::current_precision_of(val) != boost::multiprecision::detail::current_precision_of(*this))
         {
            number t(*this - val);
            return *this = std::move(t);
         }
      do_subtract(detail::expression<detail::terminal, self_type>(val), detail::terminal());
      return *this;
   }

   template <class tag, class Arg1, class Arg2, class Arg3, class Arg4>
   typename boost::enable_if<is_convertible<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, self_type>, number&>::type operator-=(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)
   {
      detail::scoped_default_precision<number<Backend, ExpressionTemplates> > precision_guard(*this, e);

      if(contains_self(e))
      {
         self_type temp(e);
         do_subtract(detail::expression<detail::terminal, self_type>(temp), detail::terminal());
      }
      else
      {
         do_subtract(e, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::tag_type());
      }
      return *this;
   }

   template <class V>
   typename boost::enable_if<boost::is_convertible<V, self_type>, number<Backend, ExpressionTemplates>& >::type
      operator-=(const V& v)
   {
      using default_ops::eval_subtract;
      eval_subtract(m_backend, canonical_value(v));
      return *this;
   }

   template <class Arg1, class Arg2, class Arg3, class Arg4>
   number& operator-=(const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& e)
   {
      detail::scoped_default_precision<number<Backend, ExpressionTemplates> > precision_guard(*this, e);
      if constexpr (boost::multiprecision::detail::is_variable_precision<number>::value)
         if (boost::multiprecision::detail::current_precision_of(e) != boost::multiprecision::detail::current_precision_of(*this))
         {
            number t(*this - e);
            return *this = std::move(t);
         }



      using default_ops::eval_multiply_subtract;
      eval_multiply_subtract(m_backend, canonical_value(e.left_ref()), canonical_value(e.right_ref()));
      return *this;
   }


   number& operator *= (const self_type& e)
   {
      detail::scoped_default_precision<number<Backend, ExpressionTemplates> > precision_guard(*this, e);
      if constexpr (boost::multiprecision::detail::is_variable_precision<number>::value)
         if (boost::multiprecision::detail::current_precision_of(e) != boost::multiprecision::detail::current_precision_of(*this))
         {
            number t(*this * e);
            return *this = std::move(t);
         }
      do_multiplies(detail::expression<detail::terminal, self_type>(e), detail::terminal());
      return *this;
   }

   template <class tag, class Arg1, class Arg2, class Arg3, class Arg4>
   typename boost::enable_if<is_convertible<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, self_type>, number&>::type operator*=(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)
   {
      detail::scoped_default_precision<number<Backend, ExpressionTemplates> > precision_guard(*this, e);


      if((contains_self(e) && !is_self(e)))
      {
         self_type temp(e);
         do_multiplies(detail::expression<detail::terminal, self_type>(temp), detail::terminal());
      }
      else
      {
         do_multiplies(e, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::tag_type());
      }
      return *this;
   }

   template <class V>
   typename boost::enable_if<boost::is_convertible<V, self_type>, number<Backend, ExpressionTemplates>& >::type
      operator*=(const V& v)
   {
      using default_ops::eval_multiply;
      eval_multiply(m_backend, canonical_value(v));
      return *this;
   }

   number& operator%=(const self_type& e)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The modulus operation is only valid for integer types");
      detail::scoped_default_precision<number<Backend, ExpressionTemplates> > precision_guard(*this, e);
      if constexpr (boost::multiprecision::detail::is_variable_precision<number>::value)
         if (boost::multiprecision::detail::current_precision_of(e) != boost::multiprecision::detail::current_precision_of(*this))
         {
            number t(*this % e);
            return *this = std::move(t);
         }
      do_modulus(detail::expression<detail::terminal, self_type>(e), detail::terminal());
      return *this;
   }
   template <class tag, class Arg1, class Arg2, class Arg3, class Arg4>
   typename boost::enable_if<is_convertible<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, self_type>, number&>::type operator%=(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The modulus operation is only valid for integer types");
      detail::scoped_default_precision<number<Backend, ExpressionTemplates> > precision_guard(*this, e);

      if(contains_self(e))
      {
         self_type temp(e);
         do_modulus(detail::expression<detail::terminal, self_type>(temp), detail::terminal());
      }
      else
      {
         do_modulus(e, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::tag_type());
      }
      return *this;
   }
   template <class V>
   typename boost::enable_if<boost::is_convertible<V, self_type>, number<Backend, ExpressionTemplates>& >::type
      operator%=(const V& v)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The modulus operation is only valid for integer types");
      using default_ops::eval_modulus;
      eval_modulus(m_backend, canonical_value(v));
      return *this;
   }
   inline number& operator++()
   {
      using default_ops::eval_increment;
      eval_increment(m_backend);
      return *this;
   }

   inline number& operator--()
   {
      using default_ops::eval_decrement;
      eval_decrement(m_backend);
      return *this;
   }

   inline number operator++(int)
   {
      using default_ops::eval_increment;
      self_type temp(*this);
      eval_increment(m_backend);
      return std::move(temp);
   }

   inline number operator--(int)
   {
      using default_ops::eval_decrement;
      self_type temp(*this);
      eval_decrement(m_backend);
      return std::move(temp);
   }

   template <class V>
   inline typename boost::enable_if<is_integral<V>, number&>::type operator <<= (V val)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The left-shift operation is only valid for integer types");
      detail::check_shift_range(val, mpl::bool_<(sizeof(V) > sizeof(std::size_t))>(), is_signed<V>());
      eval_left_shift(m_backend, static_cast<std::size_t>(canonical_value(val)));
      return *this;
   }

   template <class V>
   inline typename boost::enable_if<is_integral<V>, number&>::type operator >>= (V val)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The right-shift operation is only valid for integer types");
      detail::check_shift_range(val, mpl::bool_<(sizeof(V) > sizeof(std::size_t))>(), is_signed<V>());
      eval_right_shift(m_backend, static_cast<std::size_t>(canonical_value(val)));
      return *this;
   }

   inline number& operator /= (const self_type& e)
   {
      detail::scoped_default_precision<number<Backend, ExpressionTemplates> > precision_guard(*this, e);
      if constexpr (boost::multiprecision::detail::is_variable_precision<number>::value)
         if (boost::multiprecision::detail::current_precision_of(e) != boost::multiprecision::detail::current_precision_of(*this))
         {
            number t(*this / e);
            return *this = std::move(t);
         }
      do_divide(detail::expression<detail::terminal, self_type>(e), detail::terminal());
      return *this;
   }

   template <class tag, class Arg1, class Arg2, class Arg3, class Arg4>
   typename boost::enable_if<is_convertible<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, self_type>, number&>::type operator/=(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)
   {
      detail::scoped_default_precision<number<Backend, ExpressionTemplates> > precision_guard(*this, e);

      if(contains_self(e))
      {
         self_type temp(e);
         do_divide(detail::expression<detail::terminal, self_type>(temp), detail::terminal());
      }
      else
      {
         do_divide(e, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::tag_type());
      }
      return *this;
   }

   template <class V>
   inline typename boost::enable_if<boost::is_convertible<V, self_type>, number<Backend, ExpressionTemplates>& >::type
      operator/=(const V& v)
   {
      using default_ops::eval_divide;
      eval_divide(m_backend, canonical_value(v));
      return *this;
   }

   inline number& operator&=(const self_type& e)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The bitwise & operation is only valid for integer types");
      do_bitwise_and(detail::expression<detail::terminal, self_type>(e), detail::terminal());
      return *this;
   }

   template <class tag, class Arg1, class Arg2, class Arg3, class Arg4>
   typename boost::enable_if<is_convertible<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, self_type>, number&>::type operator&=(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The bitwise & operation is only valid for integer types");


      if(contains_self(e) && !is_self(e))
      {
         self_type temp(e);
         do_bitwise_and(detail::expression<detail::terminal, self_type>(temp), detail::terminal());
      }
      else
      {
         do_bitwise_and(e, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::tag_type());
      }
      return *this;
   }

   template <class V>
   inline typename boost::enable_if<boost::is_convertible<V, self_type>, number<Backend, ExpressionTemplates>& >::type
      operator&=(const V& v)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The bitwise & operation is only valid for integer types");
      using default_ops::eval_bitwise_and;
      eval_bitwise_and(m_backend, canonical_value(v));
      return *this;
   }

   inline number& operator|=(const self_type& e)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The bitwise | operation is only valid for integer types");
      do_bitwise_or(detail::expression<detail::terminal, self_type>(e), detail::terminal());
      return *this;
   }

   template <class tag, class Arg1, class Arg2, class Arg3, class Arg4>
   typename boost::enable_if<is_convertible<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, self_type>, number&>::type operator|=(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The bitwise | operation is only valid for integer types");


      if(contains_self(e) && !is_self(e))
      {
         self_type temp(e);
         do_bitwise_or(detail::expression<detail::terminal, self_type>(temp), detail::terminal());
      }
      else
      {
         do_bitwise_or(e, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::tag_type());
      }
      return *this;
   }

   template <class V>
   inline typename boost::enable_if<boost::is_convertible<V, self_type>, number<Backend, ExpressionTemplates>& >::type
      operator|=(const V& v)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The bitwise | operation is only valid for integer types");
      using default_ops::eval_bitwise_or;
      eval_bitwise_or(m_backend, canonical_value(v));
      return *this;
   }

   inline number& operator^=(const self_type& e)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The bitwise ^ operation is only valid for integer types");
      do_bitwise_xor(detail::expression<detail::terminal, self_type>(e), detail::terminal());
      return *this;
   }

   template <class tag, class Arg1, class Arg2, class Arg3, class Arg4>
   typename boost::enable_if<is_convertible<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, self_type>, number&>::type operator^=(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The bitwise ^ operation is only valid for integer types");
      if(contains_self(e))
      {
         self_type temp(e);
         do_bitwise_xor(detail::expression<detail::terminal, self_type>(temp), detail::terminal());
      }
      else
      {
         do_bitwise_xor(e, typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::tag_type());
      }
      return *this;
   }

   template <class V>
   inline typename boost::enable_if<boost::is_convertible<V, self_type>, number<Backend, ExpressionTemplates>& >::type
      operator^=(const V& v)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The bitwise ^ operation is only valid for integer types");
      using default_ops::eval_bitwise_xor;
      eval_bitwise_xor(m_backend, canonical_value(v));
      return *this;
   }



   inline void swap(self_type& other) noexcept((noexcept(std::declval<Backend>().swap(std::declval<Backend&>()))))
   {
      m_backend.swap(other.backend());
   }



   inline bool is_zero()const
   {
      using default_ops::eval_is_zero;
      return eval_is_zero(m_backend);
   }
   inline int sign()const
   {
      using default_ops::eval_get_sign;
      return eval_get_sign(m_backend);
   }



   std::string str(std::streamsize digits = 0, std::ios_base::fmtflags f = std::ios_base::fmtflags(0))const
   {
      return m_backend.str(digits, f);
   }
   template<class Archive>
   void serialize(Archive & ar, const unsigned int )
   {
      ar & m_backend;
   }
private:
   template <class T>
   void convert_to_imp(T* result)const
   {
      using default_ops::eval_convert_to;
      eval_convert_to(result, m_backend);
   }
   template <class B2, expression_template_option ET>
   void convert_to_imp(number<B2, ET>* result)const
   {
      result->assign(*this);
   }
   void convert_to_imp(std::string* result)const
   {
      *result = this->str();
   }
public:
   template <class T>
   T convert_to()const
   {
      T result;
      convert_to_imp(&result);
      return result;
   }
   template <class T, class = typename boost::disable_if_c<boost::is_constructible<T, self_type const&>::value || !boost::is_default_constructible<T>::value || (!boost::is_arithmetic<T>::value && !boost::is_complex<T>::value), T>::type>

   explicit operator T ()const
   {
      return this->template convert_to<T>();
   }
   inline explicit operator bool()const
   {
      return !is_zero();
   }
   static unsigned default_precision() noexcept
   {
      return Backend::default_precision();
   }
   static void default_precision(unsigned digits10)
   {
      Backend::default_precision(digits10);
   }
   unsigned precision()const noexcept
   {
      return m_backend.precision();
   }
   void precision(unsigned digits10)
   {
      m_backend.precision(digits10);
   }



   inline int compare(const number<Backend, ExpressionTemplates>& o)const
      noexcept((noexcept(std::declval<Backend>().compare(std::declval<Backend>()))))
   {
      return m_backend.compare(o.m_backend);
   }
   template <class V>
   inline typename boost::enable_if_c<is_arithmetic<V>::value && (number_category<Backend>::value != number_kind_complex), int>::type compare(const V& o)const
   {
      using default_ops::eval_get_sign;
      if(o == 0)
         return eval_get_sign(m_backend);
      return m_backend.compare(canonical_value(o));
   }
   template <class V>
   inline typename boost::enable_if_c<is_arithmetic<V>::value && (number_category<Backend>::value == number_kind_complex), int>::type compare(const V& o)const
   {
      using default_ops::eval_get_sign;
      return m_backend.compare(canonical_value(o));
   }




   inline Backend& backend()& noexcept { return m_backend; }
   inline constexpr const Backend& backend()const& noexcept { return m_backend; }
   inline Backend&& backend()&& noexcept { return static_cast<Backend&&>(m_backend); }
   inline Backend const&& backend()const&& noexcept { return static_cast<Backend const&&>(m_backend); }







   typename scalar_result_from_possible_complex<number<Backend, ExpressionTemplates> >::type
      real()const
   {
      using default_ops::eval_real;
      detail::scoped_default_precision<typename scalar_result_from_possible_complex<multiprecision::number<Backend, ExpressionTemplates> >::type> precision_guard(*this);
      typename scalar_result_from_possible_complex<multiprecision::number<Backend, ExpressionTemplates> >::type result;
      eval_real(result.backend(), backend());
      return result;
   }
   typename scalar_result_from_possible_complex<number<Backend, ExpressionTemplates> >::type
      imag()const
   {
      using default_ops::eval_imag;
      detail::scoped_default_precision<typename scalar_result_from_possible_complex<multiprecision::number<Backend, ExpressionTemplates> >::type> precision_guard(*this);
      typename scalar_result_from_possible_complex<multiprecision::number<Backend, ExpressionTemplates> >::type result;
      eval_imag(result.backend(), backend());
      return result;
   }
   template <class T>
   inline typename enable_if_c<boost::is_convertible<T, self_type>::value, self_type&>::type real(const T& val)
   {
      using default_ops::eval_set_real;
      eval_set_real(backend(), canonical_value(val));
      return *this;
   }
   template <class T>
   inline typename enable_if_c<boost::is_convertible<T, self_type>::value && number_category<self_type>::value == number_kind_complex, self_type&>::type imag(const T& val)
   {
      using default_ops::eval_set_imag;
      eval_set_imag(backend(), canonical_value(val));
      return *this;
   }
private:
   template <class tag, class Arg1, class Arg2, class Arg3, class Arg4>
   void do_assign(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e, const mpl::true_&)
   {
      do_assign(e, tag());
   }
   template <class tag, class Arg1, class Arg2, class Arg3, class Arg4>
   void do_assign(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e, const mpl::false_&)
   {


      typedef typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type temp_type;
      temp_type t(e);
      this->assign(t);
   }


   template <class Exp>
   void do_assign(const Exp& e, const detail::add_immediates&)
   {
      using default_ops::eval_add;
      boost::multiprecision::detail::maybe_promote_precision(this);
      eval_add(m_backend, canonical_value(e.left().value()), canonical_value(e.right().value()));
   }
   template <class Exp>
   void do_assign(const Exp& e, const detail::subtract_immediates&)
   {
      using default_ops::eval_subtract;
      boost::multiprecision::detail::maybe_promote_precision(this);
      eval_subtract(m_backend, canonical_value(e.left().value()), canonical_value(e.right().value()));
   }
   template <class Exp>
   void do_assign(const Exp& e, const detail::multiply_immediates&)
   {
      using default_ops::eval_multiply;
      boost::multiprecision::detail::maybe_promote_precision(this);
      eval_multiply(m_backend, canonical_value(e.left().value()), canonical_value(e.right().value()));
   }
   template <class Exp>
   void do_assign(const Exp& e, const detail::multiply_add&)
   {
      using default_ops::eval_multiply_add;
      boost::multiprecision::detail::maybe_promote_precision(this);
      eval_multiply_add(m_backend, canonical_value(e.left().value()), canonical_value(e.middle().value()), canonical_value(e.right().value()));
   }
   template <class Exp>
   void do_assign(const Exp& e, const detail::multiply_subtract&)
   {
      using default_ops::eval_multiply_subtract;
      boost::multiprecision::detail::maybe_promote_precision(this);
      eval_multiply_subtract(m_backend, canonical_value(e.left().value()), canonical_value(e.middle().value()), canonical_value(e.right().value()));
   }

   template <class Exp>
   void do_assign(const Exp& e, const detail::divide_immediates&)
   {
      using default_ops::eval_divide;
      boost::multiprecision::detail::maybe_promote_precision(this);
      eval_divide(m_backend, canonical_value(e.left().value()), canonical_value(e.right().value()));
   }

   template <class Exp>
   void do_assign(const Exp& e, const detail::negate&)
   {
      typedef typename Exp::left_type left_type;
      do_assign(e.left(), typename left_type::tag_type());
      m_backend.negate();
   }
   template <class Exp>
   void do_assign(const Exp& e, const detail::plus&)
   {
      typedef typename Exp::left_type left_type;
      typedef typename Exp::right_type right_type;

      static int const left_depth = left_type::depth;
      static int const right_depth = right_type::depth;

      bool bl = contains_self(e.left());
      bool br = contains_self(e.right());

      if(bl && br)
      {
         self_type temp(e);
         temp.m_backend.swap(this->m_backend);
      }
      else if(bl && is_self(e.left()))
      {

         do_add(e.right(), typename right_type::tag_type());
      }
      else if(br && is_self(e.right()))
      {

         do_add(e.left(), typename left_type::tag_type());
      }
      else if(!br && (bl || (left_depth >= right_depth)))
      {
         do_assign(e.left(), typename left_type::tag_type());
         do_add(e.right(), typename right_type::tag_type());
      }
      else
      {
         do_assign(e.right(), typename right_type::tag_type());
         do_add(e.left(), typename left_type::tag_type());
      }
   }
   template <class Exp>
   void do_assign(const Exp& e, const detail::minus&)
   {
      typedef typename Exp::left_type left_type;
      typedef typename Exp::right_type right_type;

      static int const left_depth = left_type::depth;
      static int const right_depth = right_type::depth;

      bool bl = contains_self(e.left());
      bool br = contains_self(e.right());

      if(bl && br)
      {
         self_type temp(e);
         temp.m_backend.swap(this->m_backend);
      }
      else if(bl && is_self(e.left()))
      {

         do_subtract(e.right(), typename right_type::tag_type());
      }
      else if(br && is_self(e.right()))
      {

         do_subtract(e.left(), typename left_type::tag_type());
         m_backend.negate();
      }
      else if(!br && (bl || (left_depth >= right_depth)))
      {
         do_assign(e.left(), typename left_type::tag_type());
         do_subtract(e.right(), typename right_type::tag_type());
      }
      else
      {
         do_assign(e.right(), typename right_type::tag_type());
         do_subtract(e.left(), typename left_type::tag_type());
         m_backend.negate();
      }
   }
   template <class Exp>
   void do_assign(const Exp& e, const detail::multiplies&)
   {
      typedef typename Exp::left_type left_type;
      typedef typename Exp::right_type right_type;

      static int const left_depth = left_type::depth;
      static int const right_depth = right_type::depth;

      bool bl = contains_self(e.left());
      bool br = contains_self(e.right());

      if(bl && br)
      {
         self_type temp(e);
         temp.m_backend.swap(this->m_backend);
      }
      else if(bl && is_self(e.left()))
      {

         do_multiplies(e.right(), typename right_type::tag_type());
      }
      else if(br && is_self(e.right()))
      {

         do_multiplies(e.left(), typename left_type::tag_type());
      }
      else if(!br && (bl || (left_depth >= right_depth)))
      {
         do_assign(e.left(), typename left_type::tag_type());
         do_multiplies(e.right(), typename right_type::tag_type());
      }
      else
      {
         do_assign(e.right(), typename right_type::tag_type());
         do_multiplies(e.left(), typename left_type::tag_type());
      }
   }
   template <class Exp>
   void do_assign(const Exp& e, const detail::divides&)
   {
      typedef typename Exp::left_type left_type;
      typedef typename Exp::right_type right_type;

      bool bl = contains_self(e.left());
      bool br = contains_self(e.right());

      if(bl && is_self(e.left()))
      {

         do_divide(e.right(), typename right_type::tag_type());
      }
      else if(br)
      {
         self_type temp(e);
         temp.m_backend.swap(this->m_backend);
      }
      else
      {
         do_assign(e.left(), typename left_type::tag_type());
         do_divide(e.right(), typename right_type::tag_type());
      }
   }
   template <class Exp>
   void do_assign(const Exp& e, const detail::modulus&)
   {



      static_assert(number_category<Backend>::value == number_kind_integer, "The modulus operation is only valid for integer types");

      typedef typename Exp::left_type left_type;
      typedef typename Exp::right_type right_type;

      bool bl = contains_self(e.left());
      bool br = contains_self(e.right());

      if(bl && is_self(e.left()))
      {

         do_modulus(e.right(), typename right_type::tag_type());
      }
      else if(br)
      {
         self_type temp(e);
         temp.m_backend.swap(this->m_backend);
      }
      else
      {
         do_assign(e.left(), typename left_type::tag_type());
         do_modulus(e.right(), typename right_type::tag_type());
      }
   }
   template <class Exp>
   void do_assign(const Exp& e, const detail::modulus_immediates&)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The modulus operation is only valid for integer types");
      using default_ops::eval_modulus;
      boost::multiprecision::detail::maybe_promote_precision(this);
      eval_modulus(m_backend, canonical_value(e.left().value()), canonical_value(e.right().value()));
   }

   template <class Exp>
   void do_assign(const Exp& e, const detail::bitwise_and&)
   {



      static_assert(number_category<Backend>::value == number_kind_integer, "Bitwise operations are only valid for integer types");

      typedef typename Exp::left_type left_type;
      typedef typename Exp::right_type right_type;

      static int const left_depth = left_type::depth;
      static int const right_depth = right_type::depth;

      bool bl = contains_self(e.left());
      bool br = contains_self(e.right());

      if(bl && is_self(e.left()))
      {

         do_bitwise_and(e.right(), typename right_type::tag_type());
      }
      else if(br && is_self(e.right()))
      {
         do_bitwise_and(e.left(), typename left_type::tag_type());
      }
      else if(!br && (bl || (left_depth >= right_depth)))
      {
         do_assign(e.left(), typename left_type::tag_type());
         do_bitwise_and(e.right(), typename right_type::tag_type());
      }
      else
      {
         do_assign(e.right(), typename right_type::tag_type());
         do_bitwise_and(e.left(), typename left_type::tag_type());
      }
   }
   template <class Exp>
   void do_assign(const Exp& e, const detail::bitwise_and_immediates&)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "Bitwise operations are only valid for integer types");
      using default_ops::eval_bitwise_and;
      eval_bitwise_and(m_backend, canonical_value(e.left().value()), canonical_value(e.right().value()));
   }

   template <class Exp>
   void do_assign(const Exp& e, const detail::bitwise_or&)
   {



      static_assert(number_category<Backend>::value == number_kind_integer, "Bitwise operations are only valid for integer types");

      typedef typename Exp::left_type left_type;
      typedef typename Exp::right_type right_type;

      static int const left_depth = left_type::depth;
      static int const right_depth = right_type::depth;

      bool bl = contains_self(e.left());
      bool br = contains_self(e.right());

      if(bl && is_self(e.left()))
      {

         do_bitwise_or(e.right(), typename right_type::tag_type());
      }
      else if(br && is_self(e.right()))
      {
         do_bitwise_or(e.left(), typename left_type::tag_type());
      }
      else if(!br && (bl || (left_depth >= right_depth)))
      {
         do_assign(e.left(), typename left_type::tag_type());
         do_bitwise_or(e.right(), typename right_type::tag_type());
      }
      else
      {
         do_assign(e.right(), typename right_type::tag_type());
         do_bitwise_or(e.left(), typename left_type::tag_type());
      }
   }
   template <class Exp>
   void do_assign(const Exp& e, const detail::bitwise_or_immediates&)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "Bitwise operations are only valid for integer types");
      using default_ops::eval_bitwise_or;
      eval_bitwise_or(m_backend, canonical_value(e.left().value()), canonical_value(e.right().value()));
   }

   template <class Exp>
   void do_assign(const Exp& e, const detail::bitwise_xor&)
   {



      static_assert(number_category<Backend>::value == number_kind_integer, "Bitwise operations are only valid for integer types");

      typedef typename Exp::left_type left_type;
      typedef typename Exp::right_type right_type;

      static int const left_depth = left_type::depth;
      static int const right_depth = right_type::depth;

      bool bl = contains_self(e.left());
      bool br = contains_self(e.right());

      if(bl && is_self(e.left()))
      {

         do_bitwise_xor(e.right(), typename right_type::tag_type());
      }
      else if(br && is_self(e.right()))
      {
         do_bitwise_xor(e.left(), typename left_type::tag_type());
      }
      else if(!br && (bl || (left_depth >= right_depth)))
      {
         do_assign(e.left(), typename left_type::tag_type());
         do_bitwise_xor(e.right(), typename right_type::tag_type());
      }
      else
      {
         do_assign(e.right(), typename right_type::tag_type());
         do_bitwise_xor(e.left(), typename left_type::tag_type());
      }
   }
   template <class Exp>
   void do_assign(const Exp& e, const detail::bitwise_xor_immediates&)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "Bitwise operations are only valid for integer types");
      using default_ops::eval_bitwise_xor;
      eval_bitwise_xor(m_backend, canonical_value(e.left().value()), canonical_value(e.right().value()));
   }
   template <class Exp>
   void do_assign(const Exp& e, const detail::terminal&)
   {
      if(!is_self(e))
      {
         m_backend = canonical_value(e.value());
      }
   }
   template <class Exp>
   void do_assign(const Exp& e, const detail::function&)
   {
      typedef typename Exp::arity tag_type;
      boost::multiprecision::detail::maybe_promote_precision(this);
      do_assign_function(e, tag_type());
   }
   template <class Exp>
   void do_assign(const Exp& e, const detail::shift_left&)
   {

      typedef typename Exp::left_type left_type;
      typedef typename Exp::right_type right_type;
      typedef typename right_type::arity right_arity;
      static_assert(right_arity::value == 0, "The left shift operator requires an integer value for the shift operand.");
      typedef typename right_type::result_type right_value_type;
      static_assert(is_integral<right_value_type>::value, "The left shift operator requires an integer value for the shift operand.");
      typedef typename left_type::tag_type tag_type;
      do_assign_left_shift(e.left(), canonical_value(e.right().value()), tag_type());
   }

   template <class Exp>
   void do_assign(const Exp& e, const detail::shift_right&)
   {

      typedef typename Exp::left_type left_type;
      typedef typename Exp::right_type right_type;
      typedef typename right_type::arity right_arity;
      static_assert(right_arity::value == 0, "The left shift operator requires an integer value for the shift operand.");
      typedef typename right_type::result_type right_value_type;
      static_assert(is_integral<right_value_type>::value, "The left shift operator requires an integer value for the shift operand.");
      typedef typename left_type::tag_type tag_type;
      do_assign_right_shift(e.left(), canonical_value(e.right().value()), tag_type());
   }

   template <class Exp>
   void do_assign(const Exp& e, const detail::bitwise_complement&)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The bitwise ~ operation is only valid for integer types");
      using default_ops::eval_complement;
      self_type temp(e.left());
      eval_complement(m_backend, temp.backend());
   }

   template <class Exp>
   void do_assign(const Exp& e, const detail::complement_immediates&)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The bitwise ~ operation is only valid for integer types");
      using default_ops::eval_complement;
      eval_complement(m_backend, canonical_value(e.left().value()));
   }

   template <class Exp, class Val>
   void do_assign_right_shift(const Exp& e, const Val& val, const detail::terminal&)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The right shift operation is only valid for integer types");
      using default_ops::eval_right_shift;
      detail::check_shift_range(val, mpl::bool_<(sizeof(Val) > sizeof(std::size_t))>(), is_signed<Val>());
      eval_right_shift(m_backend, canonical_value(e.value()), static_cast<std::size_t>(val));
   }

   template <class Exp, class Val>
   void do_assign_left_shift(const Exp& e, const Val& val, const detail::terminal&)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The left shift operation is only valid for integer types");
      using default_ops::eval_left_shift;
      detail::check_shift_range(val, mpl::bool_<(sizeof(Val) > sizeof(std::size_t))>(), is_signed<Val>());
      eval_left_shift(m_backend, canonical_value(e.value()), static_cast<std::size_t>(val));
   }

   template <class Exp, class Val, class Tag>
   void do_assign_right_shift(const Exp& e, const Val& val, const Tag&)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The right shift operation is only valid for integer types");
      using default_ops::eval_right_shift;
      self_type temp(e);
      detail::check_shift_range(val, mpl::bool_<(sizeof(Val) > sizeof(std::size_t))>(), is_signed<Val>());
      eval_right_shift(m_backend, temp.backend(), static_cast<std::size_t>(val));
   }

   template <class Exp, class Val, class Tag>
   void do_assign_left_shift(const Exp& e, const Val& val, const Tag&)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The left shift operation is only valid for integer types");
      using default_ops::eval_left_shift;
      self_type temp(e);
      detail::check_shift_range(val, mpl::bool_<(sizeof(Val) > sizeof(std::size_t))>(), is_signed<Val>());
      eval_left_shift(m_backend, temp.backend(), static_cast<std::size_t>(val));
   }

   template <class Exp>
   void do_assign_function(const Exp& e, const mpl::int_<1>&)
   {
      e.left().value()(&m_backend);
   }
   template <class Exp>
   void do_assign_function(const Exp& e, const mpl::int_<2>&)
   {
      typedef typename Exp::right_type right_type;
      typedef typename right_type::tag_type tag_type;
      do_assign_function_1(e.left().value(), e.right_ref(), tag_type());
   }
   template <class F, class Exp>
   void do_assign_function_1(const F& f, const Exp& val, const detail::terminal&)
   {
      f(m_backend, function_arg_value(val));
   }
   template <class F, class Exp, class Tag>
   void do_assign_function_1(const F& f, const Exp& val, const Tag&)
   {
      typename Exp::result_type t(val);
      f(m_backend, t.backend());
   }
   template <class Exp>
   void do_assign_function(const Exp& e, const mpl::int_<3>&)
   {
      typedef typename Exp::middle_type middle_type;
      typedef typename middle_type::tag_type tag_type;
      typedef typename Exp::right_type end_type;
      typedef typename end_type::tag_type end_tag;
      do_assign_function_2(e.left().value(), e.middle_ref(), e.right_ref(), tag_type(), end_tag());
   }
   template <class F, class Exp1, class Exp2>
   void do_assign_function_2(const F& f, const Exp1& val1, const Exp2& val2, const detail::terminal&, const detail::terminal&)
   {
      f(m_backend, function_arg_value(val1), function_arg_value(val2));
   }
   template <class F, class Exp1, class Exp2, class Tag1>
   void do_assign_function_2(const F& f, const Exp1& val1, const Exp2& val2, const Tag1&, const detail::terminal&)
   {
      typename Exp1::result_type temp1(val1);
      f(m_backend, std::move(temp1.backend()), function_arg_value(val2));
   }
   template <class F, class Exp1, class Exp2, class Tag2>
   void do_assign_function_2(const F& f, const Exp1& val1, const Exp2& val2, const detail::terminal&, const Tag2&)
   {
      typename Exp2::result_type temp2(val2);
      f(m_backend, function_arg_value(val1), std::move(temp2.backend()));
   }
   template <class F, class Exp1, class Exp2, class Tag1, class Tag2>
   void do_assign_function_2(const F& f, const Exp1& val1, const Exp2& val2, const Tag1&, const Tag2&)
   {
      typename Exp1::result_type temp1(val1);
      typename Exp2::result_type temp2(val2);
      f(m_backend, std::move(temp1.backend()), std::move(temp2.backend()));
   }

   template <class Exp>
   void do_assign_function(const Exp& e, const mpl::int_<4>&)
   {
      typedef typename Exp::left_middle_type left_type;
      typedef typename left_type::tag_type left_tag_type;
      typedef typename Exp::right_middle_type middle_type;
      typedef typename middle_type::tag_type middle_tag_type;
      typedef typename Exp::right_type right_type;
      typedef typename right_type::tag_type right_tag_type;
      do_assign_function_3a(e.left().value(), e.left_middle_ref(), e.right_middle_ref(), e.right_ref(), left_tag_type(), middle_tag_type(), right_tag_type());
   }
   template <class F, class Exp1, class Exp2, class Exp3, class Tag2, class Tag3>
   void do_assign_function_3a(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const detail::terminal&, const Tag2& t2, const Tag3& t3)
   {
      do_assign_function_3b(f, val1, val2, val3, t2, t3);
   }
   template <class F, class Exp1, class Exp2, class Exp3, class Tag1, class Tag2, class Tag3>
   void do_assign_function_3a(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const Tag1&, const Tag2& t2, const Tag3& t3)
   {
      typename Exp1::result_type t(val1);
      do_assign_function_3b(f, std::move(t), val2, val3, t2, t3);
   }
   template <class F, class Exp1, class Exp2, class Exp3, class Tag3>
   void do_assign_function_3b(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const detail::terminal&, const Tag3& t3)
   {
      do_assign_function_3c(f, val1, val2, val3, t3);
   }
   template <class F, class Exp1, class Exp2, class Exp3, class Tag2, class Tag3>
   void do_assign_function_3b(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const Tag2& , const Tag3& t3)
   {
      typename Exp2::result_type t(val2);
      do_assign_function_3c(f, val1, std::move(t), val3, t3);
   }
   template <class F, class Exp1, class Exp2, class Exp3>
   void do_assign_function_3c(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const detail::terminal&)
   {
      f(m_backend, function_arg_value(val1), function_arg_value(val2), function_arg_value(val3));
   }
   template <class F, class Exp1, class Exp2, class Exp3, class Tag3>
   void do_assign_function_3c(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const Tag3& )
   {
      typename Exp3::result_type t(val3);
      do_assign_function_3c(f, val1, val2, std::move(t), detail::terminal());
   }

   template <class Exp>
   void do_add(const Exp& e, const detail::terminal&)
   {
      using default_ops::eval_add;
      boost::multiprecision::detail::maybe_promote_precision(this);
      eval_add(m_backend, canonical_value(e.value()));
   }

   template <class Exp>
   void do_add(const Exp& e, const detail::negate&)
   {
      typedef typename Exp::left_type left_type;
      boost::multiprecision::detail::maybe_promote_precision(this);
      do_subtract(e.left(), typename left_type::tag_type());
   }

   template <class Exp>
   void do_add(const Exp& e, const detail::plus&)
   {
      typedef typename Exp::left_type left_type;
      typedef typename Exp::right_type right_type;
      do_add(e.left(), typename left_type::tag_type());
      do_add(e.right(), typename right_type::tag_type());
   }

   template <class Exp>
   void do_add(const Exp& e, const detail::minus&)
   {
      typedef typename Exp::left_type left_type;
      typedef typename Exp::right_type right_type;
      do_add(e.left(), typename left_type::tag_type());
      do_subtract(e.right(), typename right_type::tag_type());
   }

   template <class Exp, class unknown>
   void do_add(const Exp& e, const unknown&)
   {
      self_type temp(e);
      do_add(detail::expression<detail::terminal, self_type>(temp), detail::terminal());
   }

   template <class Exp>
   void do_add(const Exp& e, const detail::add_immediates&)
   {
      using default_ops::eval_add;
      boost::multiprecision::detail::maybe_promote_precision(this);
      eval_add(m_backend, canonical_value(e.left().value()));
      eval_add(m_backend, canonical_value(e.right().value()));
   }
   template <class Exp>
   void do_add(const Exp& e, const detail::subtract_immediates&)
   {
      using default_ops::eval_add;
      using default_ops::eval_subtract;
      boost::multiprecision::detail::maybe_promote_precision(this);
      eval_add(m_backend, canonical_value(e.left().value()));
      eval_subtract(m_backend, canonical_value(e.right().value()));
   }
   template <class Exp>
   void do_subtract(const Exp& e, const detail::terminal&)
   {
      using default_ops::eval_subtract;
      boost::multiprecision::detail::maybe_promote_precision(this);
      eval_subtract(m_backend, canonical_value(e.value()));
   }

   template <class Exp>
   void do_subtract(const Exp& e, const detail::negate&)
   {
      typedef typename Exp::left_type left_type;
      do_add(e.left(), typename left_type::tag_type());
   }

   template <class Exp>
   void do_subtract(const Exp& e, const detail::plus&)
   {
      typedef typename Exp::left_type left_type;
      typedef typename Exp::right_type right_type;
      do_subtract(e.left(), typename left_type::tag_type());
      do_subtract(e.right(), typename right_type::tag_type());
   }

   template <class Exp>
   void do_subtract(const Exp& e, const detail::minus&)
   {
      typedef typename Exp::left_type left_type;
      typedef typename Exp::right_type right_type;
      do_subtract(e.left(), typename left_type::tag_type());
      do_add(e.right(), typename right_type::tag_type());
   }
   template <class Exp>
   void do_subtract(const Exp& e, const detail::add_immediates&)
   {
      using default_ops::eval_subtract;
      boost::multiprecision::detail::maybe_promote_precision(this);
      eval_subtract(m_backend, canonical_value(e.left().value()));
      eval_subtract(m_backend, canonical_value(e.right().value()));
   }
   template <class Exp>
   void do_subtract(const Exp& e, const detail::subtract_immediates&)
   {
      using default_ops::eval_add;
      using default_ops::eval_subtract;
      eval_subtract(m_backend, canonical_value(e.left().value()));
      eval_add(m_backend, canonical_value(e.right().value()));
   }
   template <class Exp, class unknown>
   void do_subtract(const Exp& e, const unknown&)
   {
      self_type temp(e);
      do_subtract(detail::expression<detail::terminal, self_type>(temp), detail::terminal());
   }

   template <class Exp>
   void do_multiplies(const Exp& e, const detail::terminal&)
   {
      using default_ops::eval_multiply;
      boost::multiprecision::detail::maybe_promote_precision(this);
      eval_multiply(m_backend, canonical_value(e.value()));
   }

   template <class Exp>
   void do_multiplies(const Exp& e, const detail::negate&)
   {
      typedef typename Exp::left_type left_type;
      do_multiplies(e.left(), typename left_type::tag_type());
      m_backend.negate();
   }

   template <class Exp>
   void do_multiplies(const Exp& e, const detail::multiplies&)
   {
      typedef typename Exp::left_type left_type;
      typedef typename Exp::right_type right_type;
      do_multiplies(e.left(), typename left_type::tag_type());
      do_multiplies(e.right(), typename right_type::tag_type());
   }




   template <class Exp>
   typename boost::disable_if_c<boost::multiprecision::number_category<self_type>::value == boost::multiprecision::number_kind_integer || sizeof(Exp) == 1>::type
      do_multiplies(const Exp& e, const detail::divides&)
   {
      typedef typename Exp::left_type left_type;
      typedef typename Exp::right_type right_type;
      do_multiplies(e.left(), typename left_type::tag_type());
      do_divide(e.right(), typename right_type::tag_type());
   }

   template <class Exp>
   void do_multiplies(const Exp& e, const detail::multiply_immediates&)
   {
      using default_ops::eval_multiply;
      boost::multiprecision::detail::maybe_promote_precision(this);
      eval_multiply(m_backend, canonical_value(e.left().value()));
      eval_multiply(m_backend, canonical_value(e.right().value()));
   }




   template <class Exp>
   typename boost::disable_if_c<boost::multiprecision::number_category<self_type>::value == boost::multiprecision::number_kind_integer || sizeof(Exp) == 1>::type
      do_multiplies(const Exp& e, const detail::divide_immediates&)
   {
      using default_ops::eval_multiply;
      using default_ops::eval_divide;
      boost::multiprecision::detail::maybe_promote_precision(this);
      eval_multiply(m_backend, canonical_value(e.left().value()));
      eval_divide(m_backend, canonical_value(e.right().value()));
   }
   template <class Exp, class unknown>
   void do_multiplies(const Exp& e, const unknown&)
   {
      using default_ops::eval_multiply;
      boost::multiprecision::detail::maybe_promote_precision(this);
      self_type temp(e);
      eval_multiply(m_backend, temp.m_backend);
   }

   template <class Exp>
   void do_divide(const Exp& e, const detail::terminal&)
   {
      using default_ops::eval_divide;
      boost::multiprecision::detail::maybe_promote_precision(this);
      eval_divide(m_backend, canonical_value(e.value()));
   }

   template <class Exp>
   void do_divide(const Exp& e, const detail::negate&)
   {
      typedef typename Exp::left_type left_type;
      do_divide(e.left(), typename left_type::tag_type());
      m_backend.negate();
   }




   template <class Exp>
   typename boost::disable_if_c<boost::multiprecision::number_category<self_type>::value == boost::multiprecision::number_kind_integer || sizeof(Exp) == 1>::type
      do_divide(const Exp& e, const detail::multiplies&)
   {
      typedef typename Exp::left_type left_type;
      typedef typename Exp::right_type right_type;
      do_divide(e.left(), typename left_type::tag_type());
      do_divide(e.right(), typename right_type::tag_type());
   }




   template <class Exp>
   typename boost::disable_if_c<boost::multiprecision::number_category<self_type>::value == boost::multiprecision::number_kind_integer || sizeof(Exp) == 1>::type
      do_divide(const Exp& e, const detail::divides&)
   {
      typedef typename Exp::left_type left_type;
      typedef typename Exp::right_type right_type;
      do_divide(e.left(), typename left_type::tag_type());
      do_multiplies(e.right(), typename right_type::tag_type());
   }




   template <class Exp>
   typename boost::disable_if_c<boost::multiprecision::number_category<self_type>::value == boost::multiprecision::number_kind_integer || sizeof(Exp) == 1>::type
      do_divides(const Exp& e, const detail::multiply_immediates&)
   {
      using default_ops::eval_divide;
      boost::multiprecision::detail::maybe_promote_precision(this);
      eval_divide(m_backend, canonical_value(e.left().value()));
      eval_divide(m_backend, canonical_value(e.right().value()));
   }




   template <class Exp>
   typename boost::disable_if_c<boost::multiprecision::number_category<self_type>::value == boost::multiprecision::number_kind_integer || sizeof(Exp) == 1>::type
      do_divides(const Exp& e, const detail::divide_immediates&)
   {
      using default_ops::eval_multiply;
      using default_ops::eval_divide;
      boost::multiprecision::detail::maybe_promote_precision(this);
      eval_divide(m_backend, canonical_value(e.left().value()));
      mutiply(m_backend, canonical_value(e.right().value()));
   }

   template <class Exp, class unknown>
   void do_divide(const Exp& e, const unknown&)
   {
      using default_ops::eval_multiply;
      boost::multiprecision::detail::maybe_promote_precision(this);
      self_type temp(e);
      eval_divide(m_backend, temp.m_backend);
   }

   template <class Exp>
   void do_modulus(const Exp& e, const detail::terminal&)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The modulus operation is only valid for integer types");
      using default_ops::eval_modulus;
      boost::multiprecision::detail::maybe_promote_precision(this);
      eval_modulus(m_backend, canonical_value(e.value()));
   }

   template <class Exp, class Unknown>
   void do_modulus(const Exp& e, const Unknown&)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The modulus operation is only valid for integer types");
      using default_ops::eval_modulus;
      boost::multiprecision::detail::maybe_promote_precision(this);
      self_type temp(e);
      eval_modulus(m_backend, canonical_value(temp));
   }

   template <class Exp>
   void do_bitwise_and(const Exp& e, const detail::terminal&)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The bitwise & operation is only valid for integer types");
      using default_ops::eval_bitwise_and;
      eval_bitwise_and(m_backend, canonical_value(e.value()));
   }
   template <class Exp>
   void do_bitwise_and(const Exp& e, const detail::bitwise_and&)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The bitwise & operation is only valid for integer types");
      typedef typename Exp::left_type left_type;
      typedef typename Exp::right_type right_type;
      do_bitwise_and(e.left(), typename left_type::tag_type());
      do_bitwise_and(e.right(), typename right_type::tag_type());
   }
   template <class Exp, class unknown>
   void do_bitwise_and(const Exp& e, const unknown&)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The bitwise & operation is only valid for integer types");
      using default_ops::eval_bitwise_and;
      self_type temp(e);
      eval_bitwise_and(m_backend, temp.m_backend);
   }

   template <class Exp>
   void do_bitwise_or(const Exp& e, const detail::terminal&)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The bitwise | operation is only valid for integer types");
      using default_ops::eval_bitwise_or;
      eval_bitwise_or(m_backend, canonical_value(e.value()));
   }
   template <class Exp>
   void do_bitwise_or(const Exp& e, const detail::bitwise_or&)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The bitwise | operation is only valid for integer types");
      typedef typename Exp::left_type left_type;
      typedef typename Exp::right_type right_type;
      do_bitwise_or(e.left(), typename left_type::tag_type());
      do_bitwise_or(e.right(), typename right_type::tag_type());
   }
   template <class Exp, class unknown>
   void do_bitwise_or(const Exp& e, const unknown&)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The bitwise | operation is only valid for integer types");
      using default_ops::eval_bitwise_or;
      self_type temp(e);
      eval_bitwise_or(m_backend, temp.m_backend);
   }

   template <class Exp>
   void do_bitwise_xor(const Exp& e, const detail::terminal&)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The bitwise ^ operation is only valid for integer types");
      using default_ops::eval_bitwise_xor;
      eval_bitwise_xor(m_backend, canonical_value(e.value()));
   }
   template <class Exp>
   void do_bitwise_xor(const Exp& e, const detail::bitwise_xor&)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The bitwise ^ operation is only valid for integer types");
      typedef typename Exp::left_type left_type;
      typedef typename Exp::right_type right_type;
      do_bitwise_xor(e.left(), typename left_type::tag_type());
      do_bitwise_xor(e.right(), typename right_type::tag_type());
   }
   template <class Exp, class unknown>
   void do_bitwise_xor(const Exp& e, const unknown&)
   {
      static_assert(number_category<Backend>::value == number_kind_integer, "The bitwise ^ operation is only valid for integer types");
      using default_ops::eval_bitwise_xor;
      self_type temp(e);
      eval_bitwise_xor(m_backend, temp.m_backend);
   }


   template <class Exp>
   inline bool contains_self(const Exp& e)const noexcept
   {
      return contains_self(e, typename Exp::arity());
   }
   template <class Exp>
   inline bool contains_self(const Exp& e, mpl::int_<0> const&)const noexcept
   {
      return is_realy_self(e.value());
   }
   template <class Exp>
   inline bool contains_self(const Exp& e, mpl::int_<1> const&)const noexcept
   {
      typedef typename Exp::left_type child_type;
      return contains_self(e.left(), typename child_type::arity());
   }
   template <class Exp>
   inline bool contains_self(const Exp& e, mpl::int_<2> const&)const noexcept
   {
      typedef typename Exp::left_type child0_type;
      typedef typename Exp::right_type child1_type;
      return contains_self(e.left(), typename child0_type::arity())
         || contains_self(e.right(), typename child1_type::arity());
   }
   template <class Exp>
   inline bool contains_self(const Exp& e, mpl::int_<3> const&)const noexcept
   {
      typedef typename Exp::left_type child0_type;
      typedef typename Exp::middle_type child1_type;
      typedef typename Exp::right_type child2_type;
      return contains_self(e.left(), typename child0_type::arity())
         || contains_self(e.middle(), typename child1_type::arity())
         || contains_self(e.right(), typename child2_type::arity());
   }


   template <class Exp>
   inline constexpr bool is_self(const Exp& e)const noexcept
   {
      return is_self(e, typename Exp::arity());
   }
   template <class Exp>
   inline constexpr bool is_self(const Exp& e, mpl::int_<0> const&)const noexcept
   {
      return is_realy_self(e.value());
   }
   template <class Exp, int v>
   inline constexpr bool is_self(const Exp&, mpl::int_<v> const&)const noexcept
   {
      return false;
   }

   template <class Val>
   inline constexpr bool is_realy_self(const Val&)const noexcept{ return false; }
   inline constexpr bool is_realy_self(const self_type& v)const noexcept{ return &v == this; }

   static inline constexpr const Backend& function_arg_value(const self_type& v) noexcept { return v.backend(); }
   template <class Other, expression_template_option ET2>
   static inline constexpr const Other& function_arg_value(const number<Other, ET2>& v) noexcept { return v.backend(); }
   template <class V>
   static inline constexpr const V& function_arg_value(const V& v) noexcept { return v; }
   template <class A1, class A2, class A3, class A4>
   static inline const A1& function_arg_value(const detail::expression<detail::terminal, A1, A2, A3, A4>& exp) noexcept { return exp.value(); }
   template <class A2, class A3, class A4>
   static inline constexpr const Backend& function_arg_value(const detail::expression<detail::terminal, number<Backend>, A2, A3, A4>& exp) noexcept { return exp.value().backend(); }
   Backend m_backend;

public:




   static inline constexpr const Backend& canonical_value(const self_type& v) noexcept { return v.m_backend; }
   template <class B2, expression_template_option ET>
   static inline constexpr const B2& canonical_value(const number<B2, ET>& v) noexcept { return v.backend(); }
   template <class V>
   static inline constexpr typename boost::disable_if<is_same<typename detail::canonical<V, Backend>::type, V>, typename detail::canonical<V, Backend>::type>::type
      canonical_value(const V& v) noexcept { return static_cast<typename detail::canonical<V, Backend>::type>(v); }
   template <class V>
   static inline constexpr typename boost::enable_if<is_same<typename detail::canonical<V, Backend>::type, V>, const V&>::type
      canonical_value(const V& v) noexcept { return v; }
   static inline typename detail::canonical<std::string, Backend>::type canonical_value(const std::string& v) noexcept { return v.c_str(); }

};

template <class Backend, expression_template_option ExpressionTemplates>
inline std::ostream& operator << (std::ostream& os, const number<Backend, ExpressionTemplates>& r)
{
   std::streamsize d = os.precision();
   std::string s = r.str(d, os.flags());
   std::streamsize ss = os.width();
   if(ss > static_cast<std::streamsize>(s.size()))
   {
      char fill = os.fill();
      if((os.flags() & std::ios_base::left) == std::ios_base::left)
         s.append(static_cast<std::string::size_type>(ss - s.size()), fill);
      else
         s.insert(static_cast<std::string::size_type>(0), static_cast<std::string::size_type>(ss - s.size()), fill);
   }
   return os << s;
}

namespace detail{

template <class tag, class A1, class A2, class A3, class A4>
inline std::ostream& operator << (std::ostream& os, const expression<tag, A1, A2, A3, A4>& r)
{
   typedef typename expression<tag, A1, A2, A3, A4>::result_type value_type;
   value_type temp(r);
   return os << temp;
}
inline std::string read_string_while(std::istream& is, std::string const& permitted_chars)
{
   std::ios_base::iostate state = std::ios_base::goodbit;
   const std::istream::sentry sentry_check(is);
   std::string result;

   if(sentry_check)
   {
      int c = is.rdbuf()->sgetc();

      for(;; c = is.rdbuf()->snextc())
         if(std::istream::traits_type::eq_int_type(std::istream::traits_type::eof(), c))
         {
            state |= std::ios_base::eofbit;
            break;
         }
         else if(permitted_chars.find_first_of(std::istream::traits_type::to_char_type(c)) == std::string::npos)
         {


            break;
         }
         else
         {
            result.append(1, std::istream::traits_type::to_char_type(c));
         }
   }

   if(!result.size())
      state |= std::ios_base::failbit;
   is.setstate(state);
   return result;
}

}

template <class Backend, expression_template_option ExpressionTemplates>
inline std::istream& operator >> (std::istream& is, number<Backend, ExpressionTemplates>& r)
{
   bool hex_format = (is.flags() & std::ios_base::hex) == std::ios_base::hex;
   bool oct_format = (is.flags() & std::ios_base::oct) == std::ios_base::oct;
   std::string s;
   switch(boost::multiprecision::number_category<number<Backend, ExpressionTemplates> >::value)
   {
   case boost::multiprecision::number_kind_integer:
      if(oct_format)
         s = detail::read_string_while(is, "+-01234567");
      else if(hex_format)
         s = detail::read_string_while(is, "+-xXabcdefABCDEF0123456789");
      else
         s = detail::read_string_while(is, "+-0123456789");
      break;
   case boost::multiprecision::number_kind_floating_point:
      s = detail::read_string_while(is, "+-eE.0123456789infINFnanNANinfinityINFINITY");
      break;
   default:
      is >> s;
   }
   if(s.size())
   {
      if(hex_format && (number_category<Backend>::value == number_kind_integer) && ((s[0] != '0') || (s[1] != 'x')))
         s.insert(s.find_first_not_of("+-"), "0x");
      if(oct_format && (number_category<Backend>::value == number_kind_integer) && (s[0] != '0'))
         s.insert(s.find_first_not_of("+-"), "0");
      r.assign(s);
   }
   else if(!is.fail())
      is.setstate(std::istream::failbit);
   return is;
}

template <class Backend, expression_template_option ExpressionTemplates>
inline void swap(number<Backend, ExpressionTemplates>& a, number<Backend, ExpressionTemplates>& b)
   noexcept((noexcept(std::declval<number<Backend, ExpressionTemplates>&>() = std::declval<number<Backend, ExpressionTemplates>&>())))
{
   a.swap(b);
}



template <class Backend, expression_template_option ExpressionTemplates>
inline std::size_t hash_value(const number<Backend, ExpressionTemplates>& val)
{
   return hash_value(val.backend());
}

}

template <class T>
class rational;

template <class Backend, multiprecision::expression_template_option ExpressionTemplates>
inline std::istream& operator >> (std::istream& is, rational<multiprecision::number<Backend, ExpressionTemplates> >& r)
{
   std::string s1;
   multiprecision::number<Backend, ExpressionTemplates> v1, v2;
   char c;
   bool have_hex = false;
   bool hex_format = (is.flags() & std::ios_base::hex) == std::ios_base::hex;
   bool oct_format = (is.flags() & std::ios_base::oct) == std::ios_base::oct;

   while(((-1) != (c = static_cast<char>(is.peek()))) && (c == 'x' || c == 'X' || c == '-' || c == '+' || (c >= '0' && c <= '9') || (have_hex && (c >= 'a' && c <= 'f')) || (have_hex && (c >= 'A' && c <= 'F'))))
   {
      if(c == 'x' || c == 'X')
         have_hex = true;
      s1.append(1, c);
      is.get();
   }
   if(hex_format && ((s1[0] != '0') || (s1[1] != 'x')))
      s1.insert(static_cast<std::string::size_type>(0), "0x");
   if(oct_format && (s1[0] != '0'))
      s1.insert(static_cast<std::string::size_type>(0), "0");
   v1.assign(s1);
   s1.erase();
   if(c == '/')
   {
      is.get();
      while(((-1) != (c = static_cast<char>(is.peek()))) && (c == 'x' || c == 'X' || c == '-' || c == '+' || (c >= '0' && c <= '9') || (have_hex && (c >= 'a' && c <= 'f')) || (have_hex && (c >= 'A' && c <= 'F'))))
      {
         if(c == 'x' || c == 'X')
            have_hex = true;
         s1.append(1, c);
         is.get();
      }
      if(hex_format && ((s1[0] != '0') || (s1[1] != 'x')))
         s1.insert(static_cast<std::string::size_type>(0), "0x");
      if(oct_format && (s1[0] != '0'))
         s1.insert(static_cast<std::string::size_type>(0), "0");
      v2.assign(s1);
   }
   else
      v2 = 1;
   r.assign(v1, v2);
   return is;
}

template <class T, multiprecision::expression_template_option ExpressionTemplates>
inline multiprecision::number<T, ExpressionTemplates> numerator(const rational<multiprecision::number<T, ExpressionTemplates> >& a)
{
   return a.numerator();
}

template <class T, multiprecision::expression_template_option ExpressionTemplates>
inline multiprecision::number<T, ExpressionTemplates> denominator(const rational<multiprecision::number<T, ExpressionTemplates> >& a)
{
   return a.denominator();
}

template <class T, multiprecision::expression_template_option ExpressionTemplates>
inline std::size_t hash_value(const rational<multiprecision::number<T, ExpressionTemplates> >& val)
{
   std::size_t result = hash_value(val.numerator());
   boost::hash_combine(result, hash_value(val.denominator()));
   return result;
}

namespace multiprecision
{

template <class I>
struct component_type<boost::rational<I> >
{
   typedef I type;
};

}





}





namespace std {

   template <class Backend, boost::multiprecision::expression_template_option ExpressionTemplates>
   struct hash<boost::multiprecision::number<Backend, ExpressionTemplates> >
   {
      std::size_t operator()(const boost::multiprecision::number<Backend, ExpressionTemplates>& val)const { return hash_value(val); }
   };
   template <class Backend, boost::multiprecision::expression_template_option ExpressionTemplates>
   struct hash<boost::rational<boost::multiprecision::number<Backend, ExpressionTemplates> > >
   {
      std::size_t operator()(const boost::rational<boost::multiprecision::number<Backend, ExpressionTemplates> >& val)const
      {
         std::size_t result = hash_value(val.numerator());
         boost::hash_combine(result, hash_value(val.denominator()));
         return result;
      }
   };

}












namespace boost { namespace numeric { namespace ublas {

template<class V>
class sparse_vector_element;

template <class V, class Backend, multiprecision::expression_template_option ExpressionTemplates>
inline bool operator == (const sparse_vector_element<V>& a, const ::boost::multiprecision::number<Backend, ExpressionTemplates>& b)
{
   typedef typename sparse_vector_element<V>::const_reference ref_type;
   return static_cast<ref_type>(a) == b;
}

template<class X, class Y>
struct promote_traits;

template <class Backend1, boost::multiprecision::expression_template_option ExpressionTemplates1, class Backend2, boost::multiprecision::expression_template_option ExpressionTemplates2>
struct promote_traits<boost::multiprecision::number<Backend1, ExpressionTemplates1>, boost::multiprecision::number<Backend2, ExpressionTemplates2> >
{
   typedef boost::multiprecision::number<Backend1, ExpressionTemplates1> number1_t;
   typedef boost::multiprecision::number<Backend2, ExpressionTemplates2> number2_t;
   typedef typename mpl::if_c<
      is_convertible<number1_t, number2_t>::value && !is_convertible<number2_t, number1_t>::value,
      number2_t, number1_t
   >::type promote_type;
};

template <class Backend1, boost::multiprecision::expression_template_option ExpressionTemplates1, class Arithmetic>
struct promote_traits<boost::multiprecision::number<Backend1, ExpressionTemplates1>, Arithmetic>
{
   typedef boost::multiprecision::number<Backend1, ExpressionTemplates1> promote_type;
};

template <class Arithmetic, class Backend1, boost::multiprecision::expression_template_option ExpressionTemplates1>
struct promote_traits<Arithmetic, boost::multiprecision::number<Backend1, ExpressionTemplates1> >
{
   typedef boost::multiprecision::number<Backend1, ExpressionTemplates1> promote_type;
};

template <class Backend1, boost::multiprecision::expression_template_option ExpressionTemplates1, class tag, class Arg1, class Arg2, class Arg3, class Arg4>
struct promote_traits<boost::multiprecision::number<Backend1, ExpressionTemplates1>, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >
{
   typedef boost::multiprecision::number<Backend1, ExpressionTemplates1> number1_t;
   typedef boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4> expression_type;
   typedef typename expression_type::result_type number2_t;
   typedef typename promote_traits<number1_t, number2_t>::promote_type promote_type;
};

template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class Backend1, boost::multiprecision::expression_template_option ExpressionTemplates1>
struct promote_traits<boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, boost::multiprecision::number<Backend1, ExpressionTemplates1> >
{
   typedef boost::multiprecision::number<Backend1, ExpressionTemplates1> number1_t;
   typedef boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4> expression_type;
   typedef typename expression_type::result_type number2_t;
   typedef typename promote_traits<number1_t, number2_t>::promote_type promote_type;
};

template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class tagb, class Arg1b, class Arg2b, class Arg3b, class Arg4b>
struct promote_traits<boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, boost::multiprecision::detail::expression<tagb, Arg1b, Arg2b, Arg3b, Arg4b> >
{
   typedef boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4> expression1_t;
   typedef typename expression1_t::result_type number1_t;
   typedef boost::multiprecision::detail::expression<tagb, Arg1b, Arg2b, Arg3b, Arg4b> expression2_t;
   typedef typename expression2_t::result_type number2_t;
};

}}}
namespace boost{ namespace multiprecision{

namespace default_ops
{

template <class Backend>
inline void eval_qr(const Backend& x, const Backend& y, Backend& q, Backend& r)
{
   eval_divide(q, x, y);
   eval_modulus(r, x, y);
}

template <class Backend, class Integer>
inline Integer eval_integer_modulus(const Backend& x, Integer val)
{
   using boost::multiprecision::detail::abs;
   using default_ops::eval_modulus;
   using default_ops::eval_convert_to;
   typedef typename boost::multiprecision::detail::canonical<Integer, Backend>::type int_type;
   Backend t;
   eval_modulus(t, x, static_cast<int_type>(val));
   Integer result;
   eval_convert_to(&result, t);
   return abs(result);
}






template <class B>
inline void eval_gcd(B& result, const B& a, const B& b)
{
   using default_ops::eval_lsb;
   using default_ops::eval_is_zero;
   using default_ops::eval_get_sign;

   int shift;

   B u(a), v(b);

   int s = eval_get_sign(u);


   if(s < 0)
   {
      u.negate();
   }
   else if(s == 0)
   {
      result = v;
      return;
   }
   s = eval_get_sign(v);
   if(s < 0)
   {
      v.negate();
   }
   else if(s == 0)
   {
      result = u;
      return;
   }




   unsigned us = eval_lsb(u);
   unsigned vs = eval_lsb(v);
   shift = (std::min)(us, vs);
   eval_right_shift(u, us);
   eval_right_shift(v, vs);

   do
   {


      s = u.compare(v);
      if(s > 0)
         u.swap(v);
      if(s == 0)
         break;
      eval_subtract(v, u);
      vs = eval_lsb(v);
      eval_right_shift(v, vs);
   }
   while(true);

   result = u;
   eval_left_shift(result, shift);
}





template <class B>
inline void eval_lcm(B& result, const B& a, const B& b)
{
   typedef typename mpl::front<typename B::unsigned_types>::type ui_type;
   B t;
   eval_gcd(t, a, b);

   if(eval_is_zero(t))
   {
      result = static_cast<ui_type>(0);
   }
   else
   {
      eval_divide(result, a, t);
      eval_multiply(result, b);
   }
   if(eval_get_sign(result) < 0)
      result.negate();
}

}

template <class Backend, expression_template_option ExpressionTemplates>
inline typename enable_if_c<number_category<Backend>::value == number_kind_integer>::type
   divide_qr(const number<Backend, ExpressionTemplates>& x, const number<Backend, ExpressionTemplates>& y,
   number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r)
{
   using default_ops::eval_qr;
   eval_qr(x.backend(), y.backend(), q.backend(), r.backend());
}

template <class Backend, expression_template_option ExpressionTemplates, class tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<number_category<Backend>::value == number_kind_integer>::type
   divide_qr(const number<Backend, ExpressionTemplates>& x, const multiprecision::detail::expression<tag, A1, A2, A3, A4>& y,
   number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r)
{
   divide_qr(x, number<Backend, ExpressionTemplates>(y), q, r);
}

template <class tag, class A1, class A2, class A3, class A4, class Backend, expression_template_option ExpressionTemplates>
inline typename enable_if_c<number_category<Backend>::value == number_kind_integer>::type
   divide_qr(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, const number<Backend, ExpressionTemplates>& y,
   number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r)
{
   divide_qr(number<Backend, ExpressionTemplates>(x), y, q, r);
}

template <class tag, class A1, class A2, class A3, class A4, class tagb, class A1b, class A2b, class A3b, class A4b, class Backend, expression_template_option ExpressionTemplates>
inline typename enable_if_c<number_category<Backend>::value == number_kind_integer>::type
   divide_qr(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, const multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>& y,
   number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r)
{
   divide_qr(number<Backend, ExpressionTemplates>(x), number<Backend, ExpressionTemplates>(y), q, r);
}

template <class Backend, expression_template_option ExpressionTemplates, class Integer>
inline typename enable_if<mpl::and_<is_integral<Integer>, mpl::bool_<number_category<Backend>::value == number_kind_integer> >, Integer>::type
   integer_modulus(const number<Backend, ExpressionTemplates>& x, Integer val)
{
   using default_ops::eval_integer_modulus;
   return eval_integer_modulus(x.backend(), val);
}

template <class tag, class A1, class A2, class A3, class A4, class Integer>
inline typename enable_if<mpl::and_<is_integral<Integer>, mpl::bool_<number_category<typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type>::value == number_kind_integer> >, Integer>::type
   integer_modulus(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, Integer val)
{
   typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type result_type;
   return integer_modulus(result_type(x), val);
}

template <class Backend, expression_template_option ExpressionTemplates>
inline typename enable_if_c<number_category<Backend>::value == number_kind_integer, unsigned>::type
   lsb(const number<Backend, ExpressionTemplates>& x)
{
   using default_ops::eval_lsb;
   return eval_lsb(x.backend());
}

template <class tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<number_category<typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type>::value == number_kind_integer, unsigned>::type
   lsb(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x)
{
   typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type number_type;
   number_type n(x);
   using default_ops::eval_lsb;
   return eval_lsb(n.backend());
}

template <class Backend, expression_template_option ExpressionTemplates>
inline typename enable_if_c<number_category<Backend>::value == number_kind_integer, unsigned>::type
   msb(const number<Backend, ExpressionTemplates>& x)
{
   using default_ops::eval_msb;
   return eval_msb(x.backend());
}

template <class tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<number_category<typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type>::value == number_kind_integer, unsigned>::type
   msb(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x)
{
   typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type number_type;
   number_type n(x);
   using default_ops::eval_msb;
   return eval_msb(n.backend());
}

template <class Backend, expression_template_option ExpressionTemplates>
inline typename enable_if_c<number_category<Backend>::value == number_kind_integer, bool>::type
   bit_test(const number<Backend, ExpressionTemplates>& x, unsigned index)
{
   using default_ops::eval_bit_test;
   return eval_bit_test(x.backend(), index);
}

template <class tag, class A1, class A2, class A3, class A4>
inline typename enable_if_c<number_category<typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type>::value == number_kind_integer, bool>::type
   bit_test(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, unsigned index)
{
   typedef typename multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type number_type;
   number_type n(x);
   using default_ops::eval_bit_test;
   return eval_bit_test(n.backend(), index);
}

template <class Backend, expression_template_option ExpressionTemplates>
inline typename enable_if_c<number_category<Backend>::value == number_kind_integer, number<Backend, ExpressionTemplates>&>::type
   bit_set(number<Backend, ExpressionTemplates>& x, unsigned index)
{
   using default_ops::eval_bit_set;
   eval_bit_set(x.backend(), index);
   return x;
}

template <class Backend, expression_template_option ExpressionTemplates>
inline typename enable_if_c<number_category<Backend>::value == number_kind_integer, number<Backend, ExpressionTemplates>&>::type
   bit_unset(number<Backend, ExpressionTemplates>& x, unsigned index)
{
   using default_ops::eval_bit_unset;
   eval_bit_unset(x.backend(), index);
   return x;
}

template <class Backend, expression_template_option ExpressionTemplates>
inline typename enable_if_c<number_category<Backend>::value == number_kind_integer, number<Backend, ExpressionTemplates>&>::type
   bit_flip(number<Backend, ExpressionTemplates>& x, unsigned index)
{
   using default_ops::eval_bit_flip;
   eval_bit_flip(x.backend(), index);
   return x;
}

namespace default_ops{





template <class Backend>
struct double_precision_type
{
   typedef Backend type;
};





template <class Backend>
inline void check_sign_of_backend(const Backend& v, const mpl::true_)
{
   if(eval_get_sign(v) < 0)
   {
      ::boost::exception_detail::throw_exception_(std::runtime_error("powm requires a positive exponent."),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/integer_ops.hpp",281);
   }
}
template <class Backend>
inline void check_sign_of_backend(const Backend&, const mpl::false_){}



template <class Backend>
void eval_powm(Backend& result, const Backend& a, const Backend& p, const Backend& c)
{
   using default_ops::eval_bit_test;
   using default_ops::eval_get_sign;
   using default_ops::eval_multiply;
   using default_ops::eval_modulus;
   using default_ops::eval_right_shift;

   typedef typename double_precision_type<Backend>::type double_type;
   typedef typename boost::multiprecision::detail::canonical<unsigned char, double_type>::type ui_type;

   check_sign_of_backend(p, mpl::bool_<std::numeric_limits<number<Backend> >::is_signed>());

   double_type x, y(a), b(p), t;
   x = ui_type(1u);

   while(eval_get_sign(b) > 0)
   {
      if(eval_bit_test(b, 0))
      {
         eval_multiply(t, x, y);
         eval_modulus(x, t, c);
      }
      eval_multiply(t, y, y);
      eval_modulus(y, t, c);
      eval_right_shift(b, ui_type(1));
   }
   Backend x2(x);
   eval_modulus(result, x2, c);
}

template <class Backend, class Integer>
void eval_powm(Backend& result, const Backend& a, const Backend& p, Integer c)
{
   typedef typename double_precision_type<Backend>::type double_type;
   typedef typename boost::multiprecision::detail::canonical<unsigned char, double_type>::type ui_type;
   typedef typename boost::multiprecision::detail::canonical<Integer, double_type>::type i1_type;
   typedef typename boost::multiprecision::detail::canonical<Integer, Backend>::type i2_type;

   using default_ops::eval_bit_test;
   using default_ops::eval_get_sign;
   using default_ops::eval_multiply;
   using default_ops::eval_modulus;
   using default_ops::eval_right_shift;

   check_sign_of_backend(p, mpl::bool_<std::numeric_limits<number<Backend> >::is_signed>());

   if(eval_get_sign(p) < 0)
   {
      ::boost::exception_detail::throw_exception_(std::runtime_error("powm requires a positive exponent."),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/integer_ops.hpp",339);
   }

   double_type x, y(a), b(p), t;
   x = ui_type(1u);

   while(eval_get_sign(b) > 0)
   {
      if(eval_bit_test(b, 0))
      {
         eval_multiply(t, x, y);
         eval_modulus(x, t, static_cast<i1_type>(c));
      }
      eval_multiply(t, y, y);
      eval_modulus(y, t, static_cast<i1_type>(c));
      eval_right_shift(b, ui_type(1));
   }
   Backend x2(x);
   eval_modulus(result, x2, static_cast<i2_type>(c));
}

template <class Backend, class Integer>
typename enable_if<is_unsigned<Integer> >::type eval_powm(Backend& result, const Backend& a, Integer b, const Backend& c)
{
   typedef typename double_precision_type<Backend>::type double_type;
   typedef typename boost::multiprecision::detail::canonical<unsigned char, double_type>::type ui_type;

   using default_ops::eval_bit_test;
   using default_ops::eval_get_sign;
   using default_ops::eval_multiply;
   using default_ops::eval_modulus;
   using default_ops::eval_right_shift;

   double_type x, y(a), t;
   x = ui_type(1u);

   while(b > 0)
   {
      if(b & 1)
      {
         eval_multiply(t, x, y);
         eval_modulus(x, t, c);
      }
      eval_multiply(t, y, y);
      eval_modulus(y, t, c);
      b >>= 1;
   }
   Backend x2(x);
   eval_modulus(result, x2, c);
}

template <class Backend, class Integer>
typename enable_if<is_signed<Integer> >::type eval_powm(Backend& result, const Backend& a, Integer b, const Backend& c)
{
   if(b < 0)
   {
      ::boost::exception_detail::throw_exception_(std::runtime_error("powm requires a positive exponent."),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/integer_ops.hpp",395);
   }
   eval_powm(result, a, static_cast<typename make_unsigned<Integer>::type>(b), c);
}

template <class Backend, class Integer1, class Integer2>
typename enable_if<is_unsigned<Integer1> >::type eval_powm(Backend& result, const Backend& a, Integer1 b, Integer2 c)
{
   typedef typename double_precision_type<Backend>::type double_type;
   typedef typename boost::multiprecision::detail::canonical<unsigned char, double_type>::type ui_type;
   typedef typename boost::multiprecision::detail::canonical<Integer1, double_type>::type i1_type;
   typedef typename boost::multiprecision::detail::canonical<Integer2, Backend>::type i2_type;

   using default_ops::eval_bit_test;
   using default_ops::eval_get_sign;
   using default_ops::eval_multiply;
   using default_ops::eval_modulus;
   using default_ops::eval_right_shift;

   double_type x, y(a), t;
   x = ui_type(1u);

   while(b > 0)
   {
      if(b & 1)
      {
         eval_multiply(t, x, y);
         eval_modulus(x, t, static_cast<i1_type>(c));
      }
      eval_multiply(t, y, y);
      eval_modulus(y, t, static_cast<i1_type>(c));
      b >>= 1;
   }
   Backend x2(x);
   eval_modulus(result, x2, static_cast<i2_type>(c));
}

template <class Backend, class Integer1, class Integer2>
typename enable_if<is_signed<Integer1> >::type eval_powm(Backend& result, const Backend& a, Integer1 b, Integer2 c)
{
   if(b < 0)
   {
      ::boost::exception_detail::throw_exception_(std::runtime_error("powm requires a positive exponent."),__PRETTY_FUNCTION__,"./boost/multiprecision/detail/integer_ops.hpp",437);
   }
   eval_powm(result, a, static_cast<typename make_unsigned<Integer1>::type>(b), c);
}

struct powm_func
{
   template <class T, class U, class V>
   void operator()(T& result, const T& b, const U& p, const V& m)const
   {
      eval_powm(result, b, p, m);
   }
};

}

template <class T, class U, class V>
inline typename enable_if<
   mpl::and_<
      mpl::bool_<number_category<T>::value == number_kind_integer>,
      mpl::or_<
         is_number<T>,
         is_number_expression<T>
      >,
      mpl::or_<
         is_number<U>,
         is_number_expression<U>,
         is_integral<U>
      >,
      mpl::or_<
         is_number<V>,
         is_number_expression<V>,
         is_integral<V>
      >
   >,
   typename mpl::if_<
      is_no_et_number<T>,
      T,
      typename mpl::if_<
         is_no_et_number<U>,
         U,
         typename mpl::if_<
            is_no_et_number<V>,
            V,
            detail::expression<detail::function, default_ops::powm_func, T, U, V> >::type
         >::type
      >::type
   >::type
   powm(const T& b, const U& p, const V& mod)
{
   return detail::expression<detail::function, default_ops::powm_func, T, U, V>(
      default_ops::powm_func(), b, p, mod);
}

}}
  namespace boost { namespace multiprecision { namespace backends { namespace detail
  {
    template <class value_type, class my_allocator>
    struct rebind
    {

       typedef typename std::allocator_traits<my_allocator>::template rebind_alloc<value_type> type;



    };
  } } } }
namespace boost {

template<class T>
struct use_empty_value_base {
    enum {

        value = __is_empty(T) && !__is_final(T)



    };
};

struct empty_init_t { };

namespace empty_ {

template<class T, unsigned N = 0,
    bool E = boost::use_empty_value_base<T>::value>
class empty_value {
public:
    typedef T type;


    empty_value() = default;




    empty_value(boost::empty_init_t)
        : value_() { }



    template<class... Args>
    explicit empty_value(boost::empty_init_t, Args&&... args)
        : value_(std::forward<Args>(args)...) { }
    const T& get() const noexcept {
        return value_;
    }

    T& get() noexcept {
        return value_;
    }

private:
    T value_;
};


template<class T, unsigned N>
class empty_value<T, N, true>
    : T {
public:
    typedef T type;


    empty_value() = default;




    empty_value(boost::empty_init_t)
        : T() { }



    template<class... Args>
    explicit empty_value(boost::empty_init_t, Args&&... args)
        : T(std::forward<Args>(args)...) { }
    const T& get() const noexcept {
        return *this;
    }

    T& get() noexcept {
        return *this;
    }
};


}

using empty_::empty_value;

}




namespace boost{ namespace multiprecision{

namespace detail{
template <unsigned N>
struct largest_signed_type
{
   typedef typename mpl::if_c<
      1 + std::numeric_limits<boost::long_long_type>::digits == N,
      boost::long_long_type,
      typename mpl::if_c<
         1 + std::numeric_limits<long>::digits == N,
         long,
         typename mpl::if_c<
            1 + std::numeric_limits<int>::digits == N,
            int,
            typename boost::int_t<N>::exact
         >::type
      >::type
   >::type type;
};

template <unsigned N>
struct largest_unsigned_type
{
   typedef typename mpl::if_c<
      std::numeric_limits<boost::ulong_long_type>::digits == N,
      boost::ulong_long_type,
      typename mpl::if_c<
         std::numeric_limits<unsigned long>::digits == N,
         unsigned long,
         typename mpl::if_c<
            std::numeric_limits<unsigned int>::digits == N,
            unsigned int,
            typename boost::uint_t<N>::exact
         >::type
      >::type
   >::type type;
};

}



typedef detail::largest_unsigned_type<64>::type limb_type;
typedef detail::largest_signed_type<64>::type signed_limb_type;
typedef boost::uint128_type double_limb_type;
typedef boost::int128_type signed_double_limb_type;
static const limb_type max_block_10 = 1000000000000000000uLL;
static const limb_type digits_per_block_10 = 18;

inline limb_type block_multiplier(unsigned count)
{
   static const limb_type values[digits_per_block_10]
      = { 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000, 100000000000, 1000000000000, 10000000000000, 100000000000000, 1000000000000000, 10000000000000000, 100000000000000000, 1000000000000000000 };
   (__builtin_expect(!(count < digits_per_block_10), 0) ? __assert_rtn(__func__, "./boost/multiprecision/cpp_int/cpp_int_config.hpp", 79, "count < digits_per_block_10") : (void)0);
   return values[count];
}





}

template<>
class integer_traits<multiprecision::double_limb_type>
  : public std::numeric_limits<multiprecision::double_limb_type>,
    public detail::integer_traits_base<multiprecision::double_limb_type, 0, ~static_cast<multiprecision::double_limb_type>(0)>
{ };
template<>
class integer_traits<multiprecision::signed_double_limb_type>
  : public std::numeric_limits<multiprecision::signed_double_limb_type>,
    public detail::integer_traits_base<multiprecision::signed_double_limb_type, static_cast<multiprecision::signed_double_limb_type>((static_cast<multiprecision::double_limb_type>(1) << 127)), static_cast<multiprecision::signed_double_limb_type>(((~static_cast<multiprecision::double_limb_type>(0)) >> 1))>
{ };

namespace multiprecision{
static const unsigned bits_per_limb = sizeof(limb_type) * 8;

template <class T>
inline void minmax(const T& a, const T& b, T& aa, T& bb)
{
   if(a < b)
   {
      aa = a;
      bb = b;
   }
   else
   {
      aa = b;
      bb = a;
   }
}

enum cpp_integer_type
{
   signed_magnitude = 1,
   unsigned_magnitude = 0,
   signed_packed = 3,
   unsigned_packed = 2
};

enum cpp_int_check_type
{
   checked = 1,
   unchecked = 0
};

}}





namespace boost
{
namespace operators_impl
{
namespace operators_detail
{

template <typename T> class empty_base {};

}






template <class T, class U, class B = operators_detail::empty_base<T> >
struct less_than_comparable2 : B
{
     friend bool operator<=(const T& x, const U& y) { return !static_cast<bool>(x > y); }
     friend bool operator>=(const T& x, const U& y) { return !static_cast<bool>(x < y); }
     friend bool operator>(const U& x, const T& y) { return y < x; }
     friend bool operator<(const U& x, const T& y) { return y > x; }
     friend bool operator<=(const U& x, const T& y) { return !static_cast<bool>(y < x); }
     friend bool operator>=(const U& x, const T& y) { return !static_cast<bool>(y > x); }
};

template <class T, class B = operators_detail::empty_base<T> >
struct less_than_comparable1 : B
{
     friend bool operator>(const T& x, const T& y) { return y < x; }
     friend bool operator<=(const T& x, const T& y) { return !static_cast<bool>(y < x); }
     friend bool operator>=(const T& x, const T& y) { return !static_cast<bool>(x < y); }
};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct equality_comparable2 : B
{
     friend bool operator==(const U& y, const T& x) { return x == y; }
     friend bool operator!=(const U& y, const T& x) { return !static_cast<bool>(x == y); }
     friend bool operator!=(const T& y, const U& x) { return !static_cast<bool>(y == x); }
};

template <class T, class B = operators_detail::empty_base<T> >
struct equality_comparable1 : B
{
     friend bool operator!=(const T& x, const T& y) { return !static_cast<bool>(x == y); }
};
template <class T, class U, class B = operators_detail::empty_base<T> > struct multipliable2 : B { friend T operator *( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv *= rhs; return nrv; } friend T operator *( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv *= lhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct multipliable1 : B { friend T operator *( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv *= rhs; return nrv; } };
template <class T, class U, class B = operators_detail::empty_base<T> > struct addable2 : B { friend T operator +( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv += rhs; return nrv; } friend T operator +( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv += lhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct addable1 : B { friend T operator +( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv += rhs; return nrv; } };
template <class T, class U, class B = operators_detail::empty_base<T> > struct subtractable2 : B { friend T operator -( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv -= rhs; return nrv; } }; template <class T, class U, class B = operators_detail::empty_base<T> > struct subtractable2_left : B { friend T operator -( const U& lhs, const T& rhs ) { T nrv( lhs ); nrv -= rhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct subtractable1 : B { friend T operator -( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv -= rhs; return nrv; } };
template <class T, class U, class B = operators_detail::empty_base<T> > struct dividable2 : B { friend T operator /( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv /= rhs; return nrv; } }; template <class T, class U, class B = operators_detail::empty_base<T> > struct dividable2_left : B { friend T operator /( const U& lhs, const T& rhs ) { T nrv( lhs ); nrv /= rhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct dividable1 : B { friend T operator /( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv /= rhs; return nrv; } };
template <class T, class U, class B = operators_detail::empty_base<T> > struct modable2 : B { friend T operator %( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv %= rhs; return nrv; } }; template <class T, class U, class B = operators_detail::empty_base<T> > struct modable2_left : B { friend T operator %( const U& lhs, const T& rhs ) { T nrv( lhs ); nrv %= rhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct modable1 : B { friend T operator %( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv %= rhs; return nrv; } };
template <class T, class U, class B = operators_detail::empty_base<T> > struct xorable2 : B { friend T operator ^( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv ^= rhs; return nrv; } friend T operator ^( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv ^= lhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct xorable1 : B { friend T operator ^( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv ^= rhs; return nrv; } };
template <class T, class U, class B = operators_detail::empty_base<T> > struct andable2 : B { friend T operator &( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv &= rhs; return nrv; } friend T operator &( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv &= lhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct andable1 : B { friend T operator &( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv &= rhs; return nrv; } };
template <class T, class U, class B = operators_detail::empty_base<T> > struct orable2 : B { friend T operator |( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv |= rhs; return nrv; } friend T operator |( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv |= lhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct orable1 : B { friend T operator |( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv |= rhs; return nrv; } };







template <class T, class B = operators_detail::empty_base<T> >
struct incrementable : B
{
  friend T operator++(T& x, int)
  {
    incrementable_type nrv(x);
    ++x;
    return nrv;
  }
private:
  typedef T incrementable_type;
};

template <class T, class B = operators_detail::empty_base<T> >
struct decrementable : B
{
  friend T operator--(T& x, int)
  {
    decrementable_type nrv(x);
    --x;
    return nrv;
  }
private:
  typedef T decrementable_type;
};



template <class T, class P, class B = operators_detail::empty_base<T> >
struct dereferenceable : B
{
  P operator->() const
  {
    return ::boost::addressof(*static_cast<const T&>(*this));
  }
};

template <class T, class I, class R, class B = operators_detail::empty_base<T> >
struct indexable : B
{
  R operator[](I n) const
  {
    return *(static_cast<const T&>(*this) + n);
  }
};
template <class T, class U, class B = operators_detail::empty_base<T> > struct left_shiftable2 : B { friend T operator <<( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv <<= rhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct left_shiftable1 : B { friend T operator <<( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv <<= rhs; return nrv; } };
template <class T, class U, class B = operators_detail::empty_base<T> > struct right_shiftable2 : B { friend T operator >>( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv >>= rhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct right_shiftable1 : B { friend T operator >>( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv >>= rhs; return nrv; } };



template <class T, class U, class B = operators_detail::empty_base<T> >
struct equivalent2 : B
{
  friend bool operator==(const T& x, const U& y)
  {
    return !static_cast<bool>(x < y) && !static_cast<bool>(x > y);
  }
};

template <class T, class B = operators_detail::empty_base<T> >
struct equivalent1 : B
{
  friend bool operator==(const T&x, const T&y)
  {
    return !static_cast<bool>(x < y) && !static_cast<bool>(y < x);
  }
};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct partially_ordered2 : B
{
  friend bool operator<=(const T& x, const U& y)
    { return static_cast<bool>(x < y) || static_cast<bool>(x == y); }
  friend bool operator>=(const T& x, const U& y)
    { return static_cast<bool>(x > y) || static_cast<bool>(x == y); }
  friend bool operator>(const U& x, const T& y)
    { return y < x; }
  friend bool operator<(const U& x, const T& y)
    { return y > x; }
  friend bool operator<=(const U& x, const T& y)
    { return static_cast<bool>(y > x) || static_cast<bool>(y == x); }
  friend bool operator>=(const U& x, const T& y)
    { return static_cast<bool>(y < x) || static_cast<bool>(y == x); }
};

template <class T, class B = operators_detail::empty_base<T> >
struct partially_ordered1 : B
{
  friend bool operator>(const T& x, const T& y)
    { return y < x; }
  friend bool operator<=(const T& x, const T& y)
    { return static_cast<bool>(x < y) || static_cast<bool>(x == y); }
  friend bool operator>=(const T& x, const T& y)
    { return static_cast<bool>(y < x) || static_cast<bool>(x == y); }
};



template <class T, class U, class B = operators_detail::empty_base<T> >
struct totally_ordered2
    : less_than_comparable2<T, U
    , equality_comparable2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct totally_ordered1
    : less_than_comparable1<T
    , equality_comparable1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct additive2
    : addable2<T, U
    , subtractable2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct additive1
    : addable1<T
    , subtractable1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct multiplicative2
    : multipliable2<T, U
    , dividable2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct multiplicative1
    : multipliable1<T
    , dividable1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct integer_multiplicative2
    : multiplicative2<T, U
    , modable2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct integer_multiplicative1
    : multiplicative1<T
    , modable1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct arithmetic2
    : additive2<T, U
    , multiplicative2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct arithmetic1
    : additive1<T
    , multiplicative1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct integer_arithmetic2
    : additive2<T, U
    , integer_multiplicative2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct integer_arithmetic1
    : additive1<T
    , integer_multiplicative1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct bitwise2
    : xorable2<T, U
    , andable2<T, U
    , orable2<T, U, B
      > > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct bitwise1
    : xorable1<T
    , andable1<T
    , orable1<T, B
      > > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct unit_steppable
    : incrementable<T
    , decrementable<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct shiftable2
    : left_shiftable2<T, U
    , right_shiftable2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct shiftable1
    : left_shiftable1<T
    , right_shiftable1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct ring_operators2
    : additive2<T, U
    , subtractable2_left<T, U
    , multipliable2<T, U, B
      > > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct ring_operators1
    : additive1<T
    , multipliable1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct ordered_ring_operators2
    : ring_operators2<T, U
    , totally_ordered2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct ordered_ring_operators1
    : ring_operators1<T
    , totally_ordered1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct field_operators2
    : ring_operators2<T, U
    , dividable2<T, U
    , dividable2_left<T, U, B
      > > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct field_operators1
    : ring_operators1<T
    , dividable1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct ordered_field_operators2
    : field_operators2<T, U
    , totally_ordered2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct ordered_field_operators1
    : field_operators1<T
    , totally_ordered1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct euclidian_ring_operators2
    : ring_operators2<T, U
    , dividable2<T, U
    , dividable2_left<T, U
    , modable2<T, U
    , modable2_left<T, U, B
      > > > > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct euclidian_ring_operators1
    : ring_operators1<T
    , dividable1<T
    , modable1<T, B
      > > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct ordered_euclidian_ring_operators2
    : totally_ordered2<T, U
    , euclidian_ring_operators2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct ordered_euclidian_ring_operators1
    : totally_ordered1<T
    , euclidian_ring_operators1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct euclidean_ring_operators2
    : ring_operators2<T, U
    , dividable2<T, U
    , dividable2_left<T, U
    , modable2<T, U
    , modable2_left<T, U, B
      > > > > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct euclidean_ring_operators1
    : ring_operators1<T
    , dividable1<T
    , modable1<T, B
      > > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct ordered_euclidean_ring_operators2
    : totally_ordered2<T, U
    , euclidean_ring_operators2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct ordered_euclidean_ring_operators1
    : totally_ordered1<T
    , euclidean_ring_operators1<T, B
      > > {};

template <class T, class P, class B = operators_detail::empty_base<T> >
struct input_iteratable
    : equality_comparable1<T
    , incrementable<T
    , dereferenceable<T, P, B
      > > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct output_iteratable
    : incrementable<T, B
      > {};

template <class T, class P, class B = operators_detail::empty_base<T> >
struct forward_iteratable
    : input_iteratable<T, P, B
      > {};

template <class T, class P, class B = operators_detail::empty_base<T> >
struct bidirectional_iteratable
    : forward_iteratable<T, P
    , decrementable<T, B
      > > {};





template <class T, class P, class D, class R, class B = operators_detail::empty_base<T> >
struct random_access_iteratable
    : bidirectional_iteratable<T, P
    , less_than_comparable1<T
    , additive2<T, D
    , indexable<T, D, R, B
      > > > > {};
namespace operators_detail
{



struct true_t {};
struct false_t {};

}
template<class T> struct is_chained_base {
  typedef operators_detail::false_t value;
};
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct less_than_comparable; template<class T, class U, class B> struct less_than_comparable<T, U, B, operators_detail::false_t> : less_than_comparable2<T, U, B> {}; template<class T, class U> struct less_than_comparable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : less_than_comparable1<T, U> {}; template <class T, class B> struct less_than_comparable<T, T, B, operators_detail::false_t> : less_than_comparable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< less_than_comparable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< less_than_comparable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< less_than_comparable1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct equality_comparable; template<class T, class U, class B> struct equality_comparable<T, U, B, operators_detail::false_t> : equality_comparable2<T, U, B> {}; template<class T, class U> struct equality_comparable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : equality_comparable1<T, U> {}; template <class T, class B> struct equality_comparable<T, T, B, operators_detail::false_t> : equality_comparable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< equality_comparable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< equality_comparable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< equality_comparable1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct multipliable; template<class T, class U, class B> struct multipliable<T, U, B, operators_detail::false_t> : multipliable2<T, U, B> {}; template<class T, class U> struct multipliable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : multipliable1<T, U> {}; template <class T, class B> struct multipliable<T, T, B, operators_detail::false_t> : multipliable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< multipliable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< multipliable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< multipliable1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct addable; template<class T, class U, class B> struct addable<T, U, B, operators_detail::false_t> : addable2<T, U, B> {}; template<class T, class U> struct addable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : addable1<T, U> {}; template <class T, class B> struct addable<T, T, B, operators_detail::false_t> : addable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< addable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< addable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< addable1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct subtractable; template<class T, class U, class B> struct subtractable<T, U, B, operators_detail::false_t> : subtractable2<T, U, B> {}; template<class T, class U> struct subtractable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : subtractable1<T, U> {}; template <class T, class B> struct subtractable<T, T, B, operators_detail::false_t> : subtractable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< subtractable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< subtractable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< subtractable1<T, B> > { typedef operators_detail::true_t value; };
template<class T, class U, class B> struct is_chained_base< subtractable2_left<T, U, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct dividable; template<class T, class U, class B> struct dividable<T, U, B, operators_detail::false_t> : dividable2<T, U, B> {}; template<class T, class U> struct dividable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : dividable1<T, U> {}; template <class T, class B> struct dividable<T, T, B, operators_detail::false_t> : dividable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< dividable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< dividable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< dividable1<T, B> > { typedef operators_detail::true_t value; };
template<class T, class U, class B> struct is_chained_base< dividable2_left<T, U, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct modable; template<class T, class U, class B> struct modable<T, U, B, operators_detail::false_t> : modable2<T, U, B> {}; template<class T, class U> struct modable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : modable1<T, U> {}; template <class T, class B> struct modable<T, T, B, operators_detail::false_t> : modable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< modable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< modable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< modable1<T, B> > { typedef operators_detail::true_t value; };
template<class T, class U, class B> struct is_chained_base< modable2_left<T, U, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct xorable; template<class T, class U, class B> struct xorable<T, U, B, operators_detail::false_t> : xorable2<T, U, B> {}; template<class T, class U> struct xorable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : xorable1<T, U> {}; template <class T, class B> struct xorable<T, T, B, operators_detail::false_t> : xorable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< xorable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< xorable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< xorable1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct andable; template<class T, class U, class B> struct andable<T, U, B, operators_detail::false_t> : andable2<T, U, B> {}; template<class T, class U> struct andable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : andable1<T, U> {}; template <class T, class B> struct andable<T, T, B, operators_detail::false_t> : andable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< andable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< andable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< andable1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct orable; template<class T, class U, class B> struct orable<T, U, B, operators_detail::false_t> : orable2<T, U, B> {}; template<class T, class U> struct orable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : orable1<T, U> {}; template <class T, class B> struct orable<T, T, B, operators_detail::false_t> : orable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< orable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< orable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< orable1<T, B> > { typedef operators_detail::true_t value; };

template<class T, class B> struct is_chained_base< incrementable<T, B> > { typedef operators_detail::true_t value; };
template<class T, class B> struct is_chained_base< decrementable<T, B> > { typedef operators_detail::true_t value; };

template<class T, class U, class B> struct is_chained_base< dereferenceable<T, U, B> > { typedef operators_detail::true_t value; };
template<class T, class U, class V, class B> struct is_chained_base< indexable<T, U, V, B> > { typedef operators_detail::true_t value; };

template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct left_shiftable; template<class T, class U, class B> struct left_shiftable<T, U, B, operators_detail::false_t> : left_shiftable2<T, U, B> {}; template<class T, class U> struct left_shiftable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : left_shiftable1<T, U> {}; template <class T, class B> struct left_shiftable<T, T, B, operators_detail::false_t> : left_shiftable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< left_shiftable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< left_shiftable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< left_shiftable1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct right_shiftable; template<class T, class U, class B> struct right_shiftable<T, U, B, operators_detail::false_t> : right_shiftable2<T, U, B> {}; template<class T, class U> struct right_shiftable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : right_shiftable1<T, U> {}; template <class T, class B> struct right_shiftable<T, T, B, operators_detail::false_t> : right_shiftable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< right_shiftable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< right_shiftable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< right_shiftable1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct equivalent; template<class T, class U, class B> struct equivalent<T, U, B, operators_detail::false_t> : equivalent2<T, U, B> {}; template<class T, class U> struct equivalent<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : equivalent1<T, U> {}; template <class T, class B> struct equivalent<T, T, B, operators_detail::false_t> : equivalent1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< equivalent<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< equivalent2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< equivalent1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct partially_ordered; template<class T, class U, class B> struct partially_ordered<T, U, B, operators_detail::false_t> : partially_ordered2<T, U, B> {}; template<class T, class U> struct partially_ordered<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : partially_ordered1<T, U> {}; template <class T, class B> struct partially_ordered<T, T, B, operators_detail::false_t> : partially_ordered1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< partially_ordered<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< partially_ordered2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< partially_ordered1<T, B> > { typedef operators_detail::true_t value; };

template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct totally_ordered; template<class T, class U, class B> struct totally_ordered<T, U, B, operators_detail::false_t> : totally_ordered2<T, U, B> {}; template<class T, class U> struct totally_ordered<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : totally_ordered1<T, U> {}; template <class T, class B> struct totally_ordered<T, T, B, operators_detail::false_t> : totally_ordered1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< totally_ordered<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< totally_ordered2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< totally_ordered1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct additive; template<class T, class U, class B> struct additive<T, U, B, operators_detail::false_t> : additive2<T, U, B> {}; template<class T, class U> struct additive<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : additive1<T, U> {}; template <class T, class B> struct additive<T, T, B, operators_detail::false_t> : additive1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< additive<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< additive2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< additive1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct multiplicative; template<class T, class U, class B> struct multiplicative<T, U, B, operators_detail::false_t> : multiplicative2<T, U, B> {}; template<class T, class U> struct multiplicative<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : multiplicative1<T, U> {}; template <class T, class B> struct multiplicative<T, T, B, operators_detail::false_t> : multiplicative1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< multiplicative<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< multiplicative2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< multiplicative1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct integer_multiplicative; template<class T, class U, class B> struct integer_multiplicative<T, U, B, operators_detail::false_t> : integer_multiplicative2<T, U, B> {}; template<class T, class U> struct integer_multiplicative<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : integer_multiplicative1<T, U> {}; template <class T, class B> struct integer_multiplicative<T, T, B, operators_detail::false_t> : integer_multiplicative1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< integer_multiplicative<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< integer_multiplicative2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< integer_multiplicative1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct arithmetic; template<class T, class U, class B> struct arithmetic<T, U, B, operators_detail::false_t> : arithmetic2<T, U, B> {}; template<class T, class U> struct arithmetic<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : arithmetic1<T, U> {}; template <class T, class B> struct arithmetic<T, T, B, operators_detail::false_t> : arithmetic1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< arithmetic<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< arithmetic2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< arithmetic1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct integer_arithmetic; template<class T, class U, class B> struct integer_arithmetic<T, U, B, operators_detail::false_t> : integer_arithmetic2<T, U, B> {}; template<class T, class U> struct integer_arithmetic<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : integer_arithmetic1<T, U> {}; template <class T, class B> struct integer_arithmetic<T, T, B, operators_detail::false_t> : integer_arithmetic1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< integer_arithmetic<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< integer_arithmetic2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< integer_arithmetic1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct bitwise; template<class T, class U, class B> struct bitwise<T, U, B, operators_detail::false_t> : bitwise2<T, U, B> {}; template<class T, class U> struct bitwise<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : bitwise1<T, U> {}; template <class T, class B> struct bitwise<T, T, B, operators_detail::false_t> : bitwise1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< bitwise<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< bitwise2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< bitwise1<T, B> > { typedef operators_detail::true_t value; };
template<class T, class B> struct is_chained_base< unit_steppable<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct shiftable; template<class T, class U, class B> struct shiftable<T, U, B, operators_detail::false_t> : shiftable2<T, U, B> {}; template<class T, class U> struct shiftable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : shiftable1<T, U> {}; template <class T, class B> struct shiftable<T, T, B, operators_detail::false_t> : shiftable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< shiftable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< shiftable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< shiftable1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ring_operators; template<class T, class U, class B> struct ring_operators<T, U, B, operators_detail::false_t> : ring_operators2<T, U, B> {}; template<class T, class U> struct ring_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : ring_operators1<T, U> {}; template <class T, class B> struct ring_operators<T, T, B, operators_detail::false_t> : ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ring_operators<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ring_operators2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< ring_operators1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_ring_operators; template<class T, class U, class B> struct ordered_ring_operators<T, U, B, operators_detail::false_t> : ordered_ring_operators2<T, U, B> {}; template<class T, class U> struct ordered_ring_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : ordered_ring_operators1<T, U> {}; template <class T, class B> struct ordered_ring_operators<T, T, B, operators_detail::false_t> : ordered_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ordered_ring_operators<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ordered_ring_operators2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< ordered_ring_operators1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct field_operators; template<class T, class U, class B> struct field_operators<T, U, B, operators_detail::false_t> : field_operators2<T, U, B> {}; template<class T, class U> struct field_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : field_operators1<T, U> {}; template <class T, class B> struct field_operators<T, T, B, operators_detail::false_t> : field_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< field_operators<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< field_operators2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< field_operators1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_field_operators; template<class T, class U, class B> struct ordered_field_operators<T, U, B, operators_detail::false_t> : ordered_field_operators2<T, U, B> {}; template<class T, class U> struct ordered_field_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : ordered_field_operators1<T, U> {}; template <class T, class B> struct ordered_field_operators<T, T, B, operators_detail::false_t> : ordered_field_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ordered_field_operators<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ordered_field_operators2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< ordered_field_operators1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct euclidian_ring_operators; template<class T, class U, class B> struct euclidian_ring_operators<T, U, B, operators_detail::false_t> : euclidian_ring_operators2<T, U, B> {}; template<class T, class U> struct euclidian_ring_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : euclidian_ring_operators1<T, U> {}; template <class T, class B> struct euclidian_ring_operators<T, T, B, operators_detail::false_t> : euclidian_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< euclidian_ring_operators<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< euclidian_ring_operators2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< euclidian_ring_operators1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_euclidian_ring_operators; template<class T, class U, class B> struct ordered_euclidian_ring_operators<T, U, B, operators_detail::false_t> : ordered_euclidian_ring_operators2<T, U, B> {}; template<class T, class U> struct ordered_euclidian_ring_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : ordered_euclidian_ring_operators1<T, U> {}; template <class T, class B> struct ordered_euclidian_ring_operators<T, T, B, operators_detail::false_t> : ordered_euclidian_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ordered_euclidian_ring_operators<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ordered_euclidian_ring_operators2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< ordered_euclidian_ring_operators1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct euclidean_ring_operators; template<class T, class U, class B> struct euclidean_ring_operators<T, U, B, operators_detail::false_t> : euclidean_ring_operators2<T, U, B> {}; template<class T, class U> struct euclidean_ring_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : euclidean_ring_operators1<T, U> {}; template <class T, class B> struct euclidean_ring_operators<T, T, B, operators_detail::false_t> : euclidean_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< euclidean_ring_operators<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< euclidean_ring_operators2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< euclidean_ring_operators1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_euclidean_ring_operators; template<class T, class U, class B> struct ordered_euclidean_ring_operators<T, U, B, operators_detail::false_t> : ordered_euclidean_ring_operators2<T, U, B> {}; template<class T, class U> struct ordered_euclidean_ring_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : ordered_euclidean_ring_operators1<T, U> {}; template <class T, class B> struct ordered_euclidean_ring_operators<T, T, B, operators_detail::false_t> : ordered_euclidean_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ordered_euclidean_ring_operators<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ordered_euclidean_ring_operators2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< ordered_euclidean_ring_operators1<T, B> > { typedef operators_detail::true_t value; };
template<class T, class U, class B> struct is_chained_base< input_iteratable<T, U, B> > { typedef operators_detail::true_t value; };
template<class T, class B> struct is_chained_base< output_iteratable<T, B> > { typedef operators_detail::true_t value; };
template<class T, class U, class B> struct is_chained_base< forward_iteratable<T, U, B> > { typedef operators_detail::true_t value; };
template<class T, class U, class B> struct is_chained_base< bidirectional_iteratable<T, U, B> > { typedef operators_detail::true_t value; };
template<class T, class U, class V, class W, class B> struct is_chained_base< random_access_iteratable<T, U, V, W, B> > { typedef operators_detail::true_t value; };







template <class T, class U>
struct operators2
    : totally_ordered2<T,U
    , integer_arithmetic2<T,U
    , bitwise2<T,U
      > > > {};

template <class T, class U = T>
struct operators : operators2<T, U> {};

template <class T> struct operators<T, T>
    : totally_ordered<T
    , integer_arithmetic<T
    , bitwise<T
    , unit_steppable<T
      > > > > {};





template <class Category,
          class T,
          class Distance = std::ptrdiff_t,
          class Pointer = T*,
          class Reference = T&>
struct iterator_helper
{
  typedef Category iterator_category;
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
};

template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V const *,
          class R = V const &>
struct input_iterator_helper
  : input_iteratable<T, P
  , iterator_helper<std::input_iterator_tag, V, D, P, R
    > > {};

template<class T>
struct output_iterator_helper
  : output_iteratable<T
  , iterator_helper<std::output_iterator_tag, void, void, void, void
  > >
{
  T& operator*() { return static_cast<T&>(*this); }
  T& operator++() { return static_cast<T&>(*this); }
};

template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V*,
          class R = V&>
struct forward_iterator_helper
  : forward_iteratable<T, P
  , iterator_helper<std::forward_iterator_tag, V, D, P, R
    > > {};

template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V*,
          class R = V&>
struct bidirectional_iterator_helper
  : bidirectional_iteratable<T, P
  , iterator_helper<std::bidirectional_iterator_tag, V, D, P, R
    > > {};

template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V*,
          class R = V&>
struct random_access_iterator_helper
  : random_access_iteratable<T, P, D, R
  , iterator_helper<std::random_access_iterator_tag, V, D, P, R
    > >
{
  friend D requires_difference_operator(const T& x, const T& y) {
    return x - y;
  }
};

}
using namespace operators_impl;

}

namespace boost{

namespace detail{

template <typename T, bool small_>
struct ct_imp2
{
   typedef const T& param_type;
};

template <typename T>
struct ct_imp2<T, true>
{
   typedef const T param_type;
};

template <typename T, bool isp, bool b1, bool b2>
struct ct_imp
{
   typedef const T& param_type;
};

template <typename T, bool isp, bool b2>
struct ct_imp<T, isp, true, b2>
{
   typedef typename ct_imp2<T, sizeof(T) <= sizeof(void*)>::param_type param_type;
};

template <typename T, bool isp, bool b1>
struct ct_imp<T, isp, b1, true>
{
   typedef typename ct_imp2<T, sizeof(T) <= sizeof(void*)>::param_type param_type;
};

template <typename T, bool b1, bool b2>
struct ct_imp<T, true, b1, b2>
{
   typedef const T param_type;
};

}

template <typename T>
struct call_traits
{
public:
   typedef T value_type;
   typedef T& reference;
   typedef const T& const_reference;






   typedef typename boost::detail::ct_imp<
      T,
      ::boost::is_pointer<T>::value,
      ::boost::is_arithmetic<T>::value,
      ::boost::is_enum<T>::value
   >::param_type param_type;
};

template <typename T>
struct call_traits<T&>
{
   typedef T& value_type;
   typedef T& reference;
   typedef const T& const_reference;
   typedef T& param_type;
};
template <typename T, std::size_t N>
struct call_traits<T [N]>
{
private:
   typedef T array_type[N];
public:

   typedef const T* value_type;
   typedef array_type& reference;
   typedef const array_type& const_reference;
   typedef const T* const param_type;
};

template <typename T, std::size_t N>
struct call_traits<const T [N]>
{
private:
   typedef const T array_type[N];
public:

   typedef const T* value_type;
   typedef array_type& reference;
   typedef const array_type& const_reference;
   typedef const T* const param_type;
};


}

namespace boost {

   template <class I>
   class rational;

   namespace integer {

      namespace gcd_detail{





         template <class T>
         inline constexpr T constexpr_min(T const& a, T const& b) noexcept(std::is_arithmetic<T>::value)
         {
            return a < b ? a : b;
         }
         template <class T>
         inline constexpr auto constexpr_swap(T&a, T& b) noexcept(std::is_arithmetic<T>::value) -> decltype(a.swap(b))
         {
            return a.swap(b);
         }
         template <class T, class U>
         inline constexpr void constexpr_swap(T&a, U& b...) noexcept(std::is_arithmetic<T>::value)
         {
            T t(static_cast<T&&>(a));
            a = static_cast<T&&>(b);
            b = static_cast<T&&>(t);
         }
      template <class T, bool a =

         std::is_unsigned<T>::value ||

         (std::numeric_limits<T>::is_specialized && !std::numeric_limits<T>::is_signed)>
      struct gcd_traits_abs_defaults
      {
         inline static constexpr const T& abs(const T& val) noexcept(std::is_arithmetic<T>::value) { return val; }
      };
      template <class T>
      struct gcd_traits_abs_defaults<T, false>
      {
         inline static T constexpr abs(const T& val) noexcept(std::is_arithmetic<T>::value)
         {

            return val < T(0) ? -val : val;
         }
      };

      enum method_type
      {
         method_euclid = 0,
         method_binary = 1,
         method_mixed = 2
      };

      struct any_convert
      {
         template <class T>
         any_convert(const T&);
      };

      struct unlikely_size
      {
         char buf[9973];
      };

      unlikely_size operator <<= (any_convert, any_convert);
      unlikely_size operator >>= (any_convert, any_convert);

      template <class T>
      struct gcd_traits_defaults : public gcd_traits_abs_defaults<T>
      {
         inline __attribute__ ((__always_inline__)) static constexpr unsigned make_odd(T& val) noexcept(std::is_arithmetic<T>::value)
         {
            unsigned r = 0;
            while(0 == (val & 1u))
            {



               val >>= 1;

               ++r;
            }
            return r;
         }
         inline static constexpr bool less(const T& a, const T& b) noexcept(std::is_arithmetic<T>::value)
         {
            return a < b;
         }

         static T& get_value();


         static const bool has_operator_left_shift_equal = sizeof(get_value() <<= 2) != sizeof(unlikely_size);
         static const bool has_operator_right_shift_equal = sizeof(get_value() >>= 2) != sizeof(unlikely_size);




         static const method_type method = std::numeric_limits<T>::is_specialized && std::numeric_limits<T>::is_integer && has_operator_left_shift_equal && has_operator_right_shift_equal ? method_mixed : method_euclid;
      };



      template <class T>
      struct gcd_traits : public gcd_traits_defaults<T> {};
      template <>
      struct gcd_traits<unsigned> : public gcd_traits_defaults<unsigned>
      {
         inline __attribute__ ((__always_inline__)) static constexpr unsigned find_lsb(unsigned mask)noexcept
         {
            return __builtin_ctz(mask);
         }
         inline __attribute__ ((__always_inline__)) static constexpr unsigned make_odd(unsigned& val)noexcept
         {
            unsigned result = find_lsb(val);
            val >>= result;
            return result;
         }
      };
      template <>
      struct gcd_traits<unsigned long> : public gcd_traits_defaults<unsigned long>
      {
         inline __attribute__ ((__always_inline__)) static constexpr unsigned find_lsb(unsigned long mask)noexcept
         {
            return __builtin_ctzl(mask);
         }
         inline __attribute__ ((__always_inline__)) static constexpr unsigned make_odd(unsigned long& val)noexcept
         {
            unsigned result = find_lsb(val);
            val >>= result;
            return result;
         }
      };
      template <>
      struct gcd_traits<boost::ulong_long_type> : public gcd_traits_defaults<boost::ulong_long_type>
      {
         inline __attribute__ ((__always_inline__)) static constexpr unsigned find_lsb(boost::ulong_long_type mask)noexcept
         {
            return __builtin_ctzll(mask);
         }
         inline __attribute__ ((__always_inline__)) static constexpr unsigned make_odd(boost::ulong_long_type& val)noexcept
         {
            unsigned result = find_lsb(val);
            val >>= result;
            return result;
         }
      };





      template <> struct gcd_traits<boost::long_long_type> : public gcd_traits_defaults<boost::long_long_type>
      {
         inline __attribute__ ((__always_inline__)) static constexpr unsigned make_odd(boost::long_long_type& val)noexcept { unsigned result = gcd_traits<boost::ulong_long_type>::find_lsb(val); val >>= result; return result; }
      };
      template <> struct gcd_traits<long> : public gcd_traits_defaults<long>
      {
         inline __attribute__ ((__always_inline__)) static constexpr unsigned make_odd(long& val)noexcept { unsigned result = gcd_traits<unsigned long>::find_lsb(val); val >>= result; return result; }
      };
      template <> struct gcd_traits<int> : public gcd_traits_defaults<int>
      {
         inline __attribute__ ((__always_inline__)) static constexpr unsigned make_odd(int& val)noexcept { unsigned result = gcd_traits<unsigned long>::find_lsb(val); val >>= result; return result; }
      };
      template <> struct gcd_traits<unsigned short> : public gcd_traits_defaults<unsigned short>
      {
         inline __attribute__ ((__always_inline__)) static constexpr unsigned make_odd(unsigned short& val)noexcept { unsigned result = gcd_traits<unsigned>::find_lsb(val); val >>= result; return result; }
      };
      template <> struct gcd_traits<short> : public gcd_traits_defaults<short>
      {
         inline __attribute__ ((__always_inline__)) static constexpr unsigned make_odd(short& val)noexcept { unsigned result = gcd_traits<unsigned>::find_lsb(val); val >>= result; return result; }
      };
      template <> struct gcd_traits<unsigned char> : public gcd_traits_defaults<unsigned char>
      {
         inline __attribute__ ((__always_inline__)) static constexpr unsigned make_odd(unsigned char& val)noexcept { unsigned result = gcd_traits<unsigned>::find_lsb(val); val >>= result; return result; }
      };
      template <> struct gcd_traits<signed char> : public gcd_traits_defaults<signed char>
      {
         inline __attribute__ ((__always_inline__)) static constexpr unsigned make_odd(signed char& val)noexcept { unsigned result = gcd_traits<unsigned>::find_lsb(val); val >>= result; return result; }
      };
      template <> struct gcd_traits<char> : public gcd_traits_defaults<char>
      {
         inline __attribute__ ((__always_inline__)) static constexpr unsigned make_odd(char& val)noexcept { unsigned result = gcd_traits<unsigned>::find_lsb(val); val >>= result; return result; }
      };

      template <> struct gcd_traits<wchar_t> : public gcd_traits_defaults<wchar_t>
      {
         inline __attribute__ ((__always_inline__)) static constexpr unsigned make_odd(wchar_t& val)noexcept { unsigned result = gcd_traits<unsigned>::find_lsb(val); val >>= result; return result; }
      };







   template <class T>
   constexpr T mixed_binary_gcd(T u, T v) noexcept(std::is_arithmetic<T>::value)
   {
      if(gcd_traits<T>::less(u, v))
         constexpr_swap(u, v);

      unsigned shifts = 0;

      if(u == T(0))
         return v;
      if(v == T(0))
         return u;

      shifts = constexpr_min(gcd_traits<T>::make_odd(u), gcd_traits<T>::make_odd(v));

      while(gcd_traits<T>::less(1, v))
      {
         u %= v;
         v -= u;
         if(u == T(0))
            return v << shifts;
         if(v == T(0))
            return u << shifts;
         gcd_traits<T>::make_odd(u);
         gcd_traits<T>::make_odd(v);
         if(gcd_traits<T>::less(u, v))
            constexpr_swap(u, v);
      }
      return (v == 1 ? v : u) << shifts;
   }





    template <typename SteinDomain>
    constexpr SteinDomain Stein_gcd(SteinDomain m, SteinDomain n) noexcept(std::is_arithmetic<SteinDomain>::value)
    {
        (__builtin_expect(!(m >= 0), 0) ? __assert_rtn(__func__, "./boost/integer/common_factor_rt.hpp", 369, "m >= 0") : (void)0);
        (__builtin_expect(!(n >= 0), 0) ? __assert_rtn(__func__, "./boost/integer/common_factor_rt.hpp", 370, "n >= 0") : (void)0);
        if (m == SteinDomain(0))
            return n;
        if (n == SteinDomain(0))
            return m;

        unsigned d_m = gcd_traits<SteinDomain>::make_odd(m);
        unsigned d_n = gcd_traits<SteinDomain>::make_odd(n);

        while (m != n)
        {
            if (n > m)
               constexpr_swap(n, m);
            m -= n;
            gcd_traits<SteinDomain>::make_odd(m);
        }

        m <<= constexpr_min(d_m, d_n);
        return m;
    }







    template <typename EuclideanDomain>
    inline constexpr EuclideanDomain Euclid_gcd(EuclideanDomain a, EuclideanDomain b) noexcept(std::is_arithmetic<EuclideanDomain>::value)
    {
        while (b != EuclideanDomain(0))
        {
            a %= b;
            constexpr_swap(a, b);
        }
        return a;
    }


    template <typename T>
    inline constexpr typename enable_if_c<gcd_traits<T>::method == method_mixed, T>::type
       optimal_gcd_select(T const &a, T const &b) noexcept(std::is_arithmetic<T>::value)
    {
       return gcd_detail::mixed_binary_gcd(a, b);
    }

    template <typename T>
    inline constexpr typename enable_if_c<gcd_traits<T>::method == method_binary, T>::type
       optimal_gcd_select(T const &a, T const &b) noexcept(std::is_arithmetic<T>::value)
    {
       return gcd_detail::Stein_gcd(a, b);
    }

    template <typename T>
    inline constexpr typename enable_if_c<gcd_traits<T>::method == method_euclid, T>::type
       optimal_gcd_select(T const &a, T const &b) noexcept(std::is_arithmetic<T>::value)
    {
       return gcd_detail::Euclid_gcd(a, b);
    }

    template <class T>
    inline constexpr T lcm_imp(const T& a, const T& b) noexcept(std::is_arithmetic<T>::value)
    {
       T temp = boost::integer::gcd_detail::optimal_gcd_select(a, b);



       return temp != T(0) ? T(a / temp * b) : T(0);

    }

}


template <typename Integer>
inline constexpr Integer gcd(Integer const &a, Integer const &b) noexcept(std::is_arithmetic<Integer>::value)
{
    if(a == (std::numeric_limits<Integer>::min)())
       return a == static_cast<Integer>(0) ? gcd_detail::gcd_traits<Integer>::abs(b) : boost::integer::gcd(static_cast<Integer>(a % b), b);
    else if (b == (std::numeric_limits<Integer>::min)())
       return b == static_cast<Integer>(0) ? gcd_detail::gcd_traits<Integer>::abs(a) : boost::integer::gcd(a, static_cast<Integer>(b % a));
    return gcd_detail::optimal_gcd_select(static_cast<Integer>(gcd_detail::gcd_traits<Integer>::abs(a)), static_cast<Integer>(gcd_detail::gcd_traits<Integer>::abs(b)));
}

template <typename Integer>
inline constexpr Integer lcm(Integer const &a, Integer const &b) noexcept(std::is_arithmetic<Integer>::value)
{
   return gcd_detail::lcm_imp(static_cast<Integer>(gcd_detail::gcd_traits<Integer>::abs(a)), static_cast<Integer>(gcd_detail::gcd_traits<Integer>::abs(b)));
}





template <typename Integer, typename... Args>
inline constexpr Integer gcd(Integer const &a, Integer const &b, const Integer& c, Args const&... args) noexcept(std::is_arithmetic<Integer>::value)
{
   Integer t = gcd(b, c, args...);
   return t == 1 ? 1 : gcd(a, t);
}

template <typename Integer, typename... Args>
inline constexpr Integer lcm(Integer const &a, Integer const &b, Integer const& c, Args const&... args) noexcept(std::is_arithmetic<Integer>::value)
{
   return lcm(a, lcm(b, c, args...));
}




template <typename Integer>
inline typename boost::enable_if_c<std::numeric_limits<Integer>::is_specialized, boost::rational<Integer> >::type gcd(boost::rational<Integer> const &a, boost::rational<Integer> const &b)
{
   return boost::rational<Integer>(static_cast<Integer>(gcd(a.numerator(), b.numerator())), static_cast<Integer>(lcm(a.denominator(), b.denominator())));
}

template <typename Integer>
inline typename boost::enable_if_c<std::numeric_limits<Integer>::is_specialized, boost::rational<Integer> >::type lcm(boost::rational<Integer> const &a, boost::rational<Integer> const &b)
{
   return boost::rational<Integer>(static_cast<Integer>(lcm(a.numerator(), b.numerator())), static_cast<Integer>(gcd(a.denominator(), b.denominator())));
}
template <typename I>
std::pair<typename std::iterator_traits<I>::value_type, I>
gcd_range(I first, I last) noexcept(std::is_arithmetic<I>::value)
{
    (__builtin_expect(!(first != last), 0) ? __assert_rtn(__func__, "./boost/integer/common_factor_rt.hpp", 508, "first != last") : (void)0);
    typedef typename std::iterator_traits<I>::value_type T;

    T d = *first++;
    while (d != T(1) && first != last)
    {
        d = gcd(d, *first);
        first++;
    }
    return std::make_pair(d, first);
}
template <typename I>
std::pair<typename std::iterator_traits<I>::value_type, I>
lcm_range(I first, I last) noexcept(std::is_arithmetic<I>::value)
{
    (__builtin_expect(!(first != last), 0) ? __assert_rtn(__func__, "./boost/integer/common_factor_rt.hpp", 523, "first != last") : (void)0);
    typedef typename std::iterator_traits<I>::value_type T;

    T d = *first++;
    while (d != T(1) && first != last)
    {
        d = lcm(d, *first);
        first++;
    }
    return std::make_pair(d, first);
}

template < typename IntegerType >
class gcd_evaluator



{
public:

   typedef IntegerType first_argument_type;
   typedef IntegerType second_argument_type;
   typedef IntegerType result_type;

   IntegerType operator()(IntegerType const &a, IntegerType const &b)const
   {
      return boost::integer::gcd(a, b);
   }
};

template < typename IntegerType >
class lcm_evaluator



{
public:

   typedef IntegerType first_argument_type;
   typedef IntegerType second_argument_type;
   typedef IntegerType result_type;

   IntegerType operator()(IntegerType const &a, IntegerType const &b)const
   {
      return boost::integer::lcm(a, b);
   }
};

}
}
namespace boost {


template <typename IntType>
IntType gcd(IntType n, IntType m)
{

    return integer::gcd( n, m );
}

template <typename IntType>
IntType lcm(IntType n, IntType m)
{

    return integer::lcm( n, m );
}


namespace rational_detail{

   template <class FromInt, class ToInt>
   struct is_compatible_integer
   {
      static const bool value = ((std::numeric_limits<FromInt>::is_specialized && std::numeric_limits<FromInt>::is_integer && (std::numeric_limits<FromInt>::digits <= std::numeric_limits<ToInt>::digits) && (std::numeric_limits<FromInt>::radix == std::numeric_limits<ToInt>::radix) && ((std::numeric_limits<FromInt>::is_signed == false) || (std::numeric_limits<ToInt>::is_signed == true)) && is_convertible<FromInt, ToInt>::value) || is_same<FromInt, ToInt>::value) || (is_class<ToInt>::value && is_class<FromInt>::value && is_convertible<FromInt, ToInt>::value);






   };

}

class bad_rational : public std::domain_error
{
public:
    explicit bad_rational() : std::domain_error("bad rational: zero denominator") {}
    explicit bad_rational( char const *what ) : std::domain_error( what ) {}
};

template <typename IntType>
class rational
{

    static_assert(::std::numeric_limits<IntType>::is_specialized, "::std::numeric_limits<IntType>::is_specialized");


    typedef typename boost::call_traits<IntType>::param_type param_type;

    struct helper { IntType parts[2]; };
    typedef IntType (helper::* bool_type)[2];

public:

    typedef IntType int_type;

    constexpr
    rational() : num(0), den(1) {}
    template <class T>
    constexpr rational(const T& n, typename enable_if_c<
       rational_detail::is_compatible_integer<T, IntType>::value
    >::type const* = 0) : num(n), den(1) {}
    template <class T, class U>
    constexpr rational(const T& n, const U& d, typename enable_if_c<
       rational_detail::is_compatible_integer<T, IntType>::value && rational_detail::is_compatible_integer<U, IntType>::value
    >::type const* = 0) : num(n), den(d) {
       normalize();
    }

    template < typename NewType >
    constexpr explicit
       rational(rational<NewType> const &r, typename enable_if_c<rational_detail::is_compatible_integer<NewType, IntType>::value>::type const* = 0)
       : num(r.numerator()), den(is_normalized(int_type(r.numerator()),
       int_type(r.denominator())) ? r.denominator() :
       (::boost::exception_detail::throw_exception_(bad_rational("bad rational: denormalized conversion"),__PRETTY_FUNCTION__,"./boost/rational.hpp",171), 0)){}

    template < typename NewType >
    constexpr explicit
       rational(rational<NewType> const &r, typename disable_if_c<rational_detail::is_compatible_integer<NewType, IntType>::value>::type const* = 0)
       : num(r.numerator()), den(is_normalized(int_type(r.numerator()),
       int_type(r.denominator())) && is_safe_narrowing_conversion(r.denominator()) && is_safe_narrowing_conversion(r.numerator()) ? r.denominator() :
       (::boost::exception_detail::throw_exception_(bad_rational("bad rational: denormalized conversion"),__PRETTY_FUNCTION__,"./boost/rational.hpp",178), 0)){}



    template <class T>
    constexpr typename enable_if_c<
       rational_detail::is_compatible_integer<T, IntType>::value, rational &
    >::type operator=(const T& n) { return assign(static_cast<IntType>(n), static_cast<IntType>(1)); }


    template <class T, class U>
    constexpr typename enable_if_c<
       rational_detail::is_compatible_integer<T, IntType>::value && rational_detail::is_compatible_integer<U, IntType>::value, rational &
    >::type assign(const T& n, const U& d)
    {
       return *this = rational<IntType>(static_cast<IntType>(n), static_cast<IntType>(d));
    }
    template <class T>
    constexpr rational(const T& n, typename enable_if_c<
       std::numeric_limits<T>::is_specialized && std::numeric_limits<T>::is_integer
       && !rational_detail::is_compatible_integer<T, IntType>::value
       && (std::numeric_limits<T>::radix == std::numeric_limits<IntType>::radix)
       && is_convertible<T, IntType>::value
    >::type const* = 0)
    {
       assign(n, static_cast<T>(1));
    }
    template <class T, class U>
    constexpr rational(const T& n, const U& d, typename enable_if_c<
       (!rational_detail::is_compatible_integer<T, IntType>::value
       || !rational_detail::is_compatible_integer<U, IntType>::value)
       && std::numeric_limits<T>::is_specialized && std::numeric_limits<T>::is_integer
       && (std::numeric_limits<T>::radix == std::numeric_limits<IntType>::radix)
       && is_convertible<T, IntType>::value &&
       std::numeric_limits<U>::is_specialized && std::numeric_limits<U>::is_integer
       && (std::numeric_limits<U>::radix == std::numeric_limits<IntType>::radix)
       && is_convertible<U, IntType>::value
    >::type const* = 0)
    {
       assign(n, d);
    }
    template <class T>
    constexpr typename enable_if_c<
       std::numeric_limits<T>::is_specialized && std::numeric_limits<T>::is_integer
       && !rational_detail::is_compatible_integer<T, IntType>::value
       && (std::numeric_limits<T>::radix == std::numeric_limits<IntType>::radix)
       && is_convertible<T, IntType>::value,
       rational &
    >::type operator=(const T& n) { return assign(n, static_cast<T>(1)); }

    template <class T, class U>
    constexpr typename enable_if_c<
       (!rational_detail::is_compatible_integer<T, IntType>::value
          || !rational_detail::is_compatible_integer<U, IntType>::value)
       && std::numeric_limits<T>::is_specialized && std::numeric_limits<T>::is_integer
       && (std::numeric_limits<T>::radix == std::numeric_limits<IntType>::radix)
       && is_convertible<T, IntType>::value &&
       std::numeric_limits<U>::is_specialized && std::numeric_limits<U>::is_integer
       && (std::numeric_limits<U>::radix == std::numeric_limits<IntType>::radix)
       && is_convertible<U, IntType>::value,
       rational &
    >::type assign(const T& n, const U& d)
    {
       if(!is_safe_narrowing_conversion(n) || !is_safe_narrowing_conversion(d))
          ::boost::exception_detail::throw_exception_(bad_rational(),__PRETTY_FUNCTION__,"./boost/rational.hpp",250);
       return *this = rational<IntType>(static_cast<IntType>(n), static_cast<IntType>(d));
    }


    constexpr
    const IntType& numerator() const { return num; }
    constexpr
    const IntType& denominator() const { return den; }


    constexpr rational& operator+= (const rational& r);
    constexpr rational& operator-= (const rational& r);
    constexpr rational& operator*= (const rational& r);
    constexpr rational& operator/= (const rational& r);

    template <class T>
    constexpr typename boost::enable_if_c<rational_detail::is_compatible_integer<T, IntType>::value, rational&>::type operator+= (const T& i)
    {
       num += i * den;
       return *this;
    }
    template <class T>
    constexpr typename boost::enable_if_c<rational_detail::is_compatible_integer<T, IntType>::value, rational&>::type operator-= (const T& i)
    {
       num -= i * den;
       return *this;
    }
    template <class T>
    constexpr typename boost::enable_if_c<rational_detail::is_compatible_integer<T, IntType>::value, rational&>::type operator*= (const T& i)
    {

       IntType gcd = integer::gcd(static_cast<IntType>(i), den);
       num *= i / gcd;
       den /= gcd;
       return *this;
    }
    template <class T>
    constexpr typename boost::enable_if_c<rational_detail::is_compatible_integer<T, IntType>::value, rational&>::type operator/= (const T& i)
    {

       IntType const zero(0);

       if(i == zero) ::boost::exception_detail::throw_exception_(bad_rational(),__PRETTY_FUNCTION__,"./boost/rational.hpp",293);
       if(num == zero) return *this;


       IntType const gcd = integer::gcd(num, static_cast<IntType>(i));
       num /= gcd;
       den *= i / gcd;

       if(den < zero) {
          num = -num;
          den = -den;
       }

       return *this;
    }


    constexpr const rational& operator++() { num += den; return *this; }
    constexpr const rational& operator--() { num -= den; return *this; }

    constexpr rational operator++(int)
    {
       rational t(*this);
       ++(*this);
       return t;
    }
    constexpr rational operator--(int)
    {
       rational t(*this);
       --(*this);
       return t;
    }


    constexpr
    bool operator!() const { return !num; }
    constexpr
    operator bool_type() const { return operator !() ? 0 : &helper::parts; }






    constexpr bool operator< (const rational& r) const;
    constexpr bool operator> (const rational& r) const { return r < *this; }
    constexpr
    bool operator== (const rational& r) const;

    template <class T>
    constexpr typename boost::enable_if_c<rational_detail::is_compatible_integer<T, IntType>::value, bool>::type operator< (const T& i) const
    {

       int_type const zero(0);


       (__builtin_expect(!(this->den > zero), 0) ? __assert_rtn(__func__, "./boost/rational.hpp", 359, "this->den > zero") : (void)0);
       int_type q = this->num / this->den, r = this->num % this->den;
       while(r < zero) { r += this->den; --q; }





       return q < i;
    }
    template <class T>
    constexpr typename boost::enable_if_c<rational_detail::is_compatible_integer<T, IntType>::value, bool>::type operator>(const T& i) const
    {
       return operator==(i) ? false : !operator<(i);
    }
    template <class T>
    constexpr typename boost::enable_if_c<rational_detail::is_compatible_integer<T, IntType>::value, bool>::type operator== (const T& i) const
    {
       return ((den == IntType(1)) && (num == i));
    }

private:


    IntType num;
    IntType den;


    static constexpr
    int_type inner_gcd( param_type a, param_type b, int_type const &zero =
     int_type(0) )
    { return b == zero ? a : inner_gcd(b, a % b, zero); }

    static constexpr
    int_type inner_abs( param_type x, int_type const &zero = int_type(0) )
    { return x < zero ? -x : +x; }





    constexpr bool test_invariant() const;
    constexpr void normalize();

    static constexpr
    bool is_normalized( param_type n, param_type d, int_type const &zero =
     int_type(0), int_type const &one = int_type(1) )
    {
        return d > zero && ( n != zero || d == one ) && inner_abs( inner_gcd(n,
         d, zero), zero ) == one;
    }





    template <class T>
    constexpr static typename boost::enable_if_c<(std::numeric_limits<T>::digits > std::numeric_limits<IntType>::digits) && (std::numeric_limits<T>::is_signed == false), bool>::type is_safe_narrowing_conversion(const T& val)
    {
       return val < (T(1) << std::numeric_limits<IntType>::digits);
    }



    template <class T>
    constexpr static typename boost::enable_if_c<(std::numeric_limits<T>::digits > std::numeric_limits<IntType>::digits) && (std::numeric_limits<T>::is_signed == true) && (std::numeric_limits<IntType>::is_signed == true), bool>::type is_safe_narrowing_conversion(const T& val)
    {




       return (val < (T(1) << std::numeric_limits<IntType>::digits)) && (val >= -(T(1) << std::numeric_limits<IntType>::digits));
    }



    template <class T>
    constexpr static typename boost::enable_if_c<(std::numeric_limits<T>::digits > std::numeric_limits<IntType>::digits) && (std::numeric_limits<T>::is_signed == true) && (std::numeric_limits<IntType>::is_signed == false), bool>::type is_safe_narrowing_conversion(const T& val)
    {
       return (val < (T(1) << std::numeric_limits<IntType>::digits)) && (val >= 0);
    }



    template <class T>
    constexpr static typename boost::enable_if_c<(std::numeric_limits<T>::digits <= std::numeric_limits<IntType>::digits) && (std::numeric_limits<T>::is_signed == true) && (std::numeric_limits<IntType>::is_signed == false), bool>::type is_safe_narrowing_conversion(const T& val)
    {
       return val >= 0;
    }



    template <class T>
    constexpr static typename boost::enable_if_c<(std::numeric_limits<T>::digits <= std::numeric_limits<IntType>::digits) && (std::numeric_limits<T>::is_signed == false) && (std::numeric_limits<IntType>::is_signed == true), bool>::type is_safe_narrowing_conversion(const T&)
    {
       return true;
    }



    template <class T>
    constexpr static typename boost::enable_if_c<(std::numeric_limits<T>::digits <= std::numeric_limits<IntType>::digits) && (std::numeric_limits<T>::is_signed == false) && (std::numeric_limits<IntType>::is_signed == false), bool>::type is_safe_narrowing_conversion(const T&)
    {
       return true;
    }



    template <class T>
    constexpr static typename boost::enable_if_c<(std::numeric_limits<T>::digits <= std::numeric_limits<IntType>::digits) && (std::numeric_limits<T>::is_signed == true) && (std::numeric_limits<IntType>::is_signed == true), bool>::type is_safe_narrowing_conversion(const T&)
    {
       return true;
    }
};


template <typename IntType>
constexpr
inline rational<IntType> operator+ (const rational<IntType>& r)
{
    return r;
}

template <typename IntType>
constexpr
inline rational<IntType> operator- (const rational<IntType>& r)
{
    return rational<IntType>(static_cast<IntType>(-r.numerator()), r.denominator());
}


template <typename IntType>
constexpr rational<IntType>& rational<IntType>::operator+= (const rational<IntType>& r)
{
    IntType r_num = r.num;
    IntType r_den = r.den;

    IntType g = integer::gcd(den, r_den);
    den /= g;
    num = num * (r_den / g) + r_num * den;
    g = integer::gcd(num, g);
    num /= g;
    den *= r_den/g;

    return *this;
}

template <typename IntType>
constexpr rational<IntType>& rational<IntType>::operator-= (const rational<IntType>& r)
{

    IntType r_num = r.num;
    IntType r_den = r.den;



    IntType g = integer::gcd(den, r_den);
    den /= g;
    num = num * (r_den / g) - r_num * den;
    g = integer::gcd(num, g);
    num /= g;
    den *= r_den/g;

    return *this;
}

template <typename IntType>
constexpr rational<IntType>& rational<IntType>::operator*= (const rational<IntType>& r)
{

    IntType r_num = r.num;
    IntType r_den = r.den;


    IntType gcd1 = integer::gcd(num, r_den);
    IntType gcd2 = integer::gcd(r_num, den);
    num = (num/gcd1) * (r_num/gcd2);
    den = (den/gcd2) * (r_den/gcd1);
    return *this;
}

template <typename IntType>
constexpr rational<IntType>& rational<IntType>::operator/= (const rational<IntType>& r)
{

    IntType r_num = r.num;
    IntType r_den = r.den;


    IntType zero(0);


    if (r_num == zero)
        ::boost::exception_detail::throw_exception_(bad_rational(),__PRETTY_FUNCTION__,"./boost/rational.hpp",571);
    if (num == zero)
        return *this;


    IntType gcd1 = integer::gcd(num, r_num);
    IntType gcd2 = integer::gcd(r_den, den);
    num = (num/gcd1) * (r_den/gcd2);
    den = (den/gcd2) * (r_num/gcd1);

    if (den < zero) {
        num = -num;
        den = -den;
    }
    return *this;
}
template <class IntType, class Arg>
constexpr
inline typename boost::enable_if_c <
   rational_detail::is_compatible_integer<Arg, IntType>::value || is_same<rational<IntType>, Arg>::value, rational<IntType> >::type
   operator + (const rational<IntType>& a, const Arg& b)
{
      rational<IntType> t(a);
      return t += b;
}
template <class Arg, class IntType>
constexpr
inline typename boost::enable_if_c <
   rational_detail::is_compatible_integer<Arg, IntType>::value, rational<IntType> >::type
   operator + (const Arg& b, const rational<IntType>& a)
{
      rational<IntType> t(a);
      return t += b;
}

template <class IntType, class Arg>
constexpr
inline typename boost::enable_if_c <
   rational_detail::is_compatible_integer<Arg, IntType>::value || is_same<rational<IntType>, Arg>::value, rational<IntType> >::type
   operator - (const rational<IntType>& a, const Arg& b)
{
      rational<IntType> t(a);
      return t -= b;
}
template <class Arg, class IntType>
constexpr
inline typename boost::enable_if_c <
   rational_detail::is_compatible_integer<Arg, IntType>::value, rational<IntType> >::type
   operator - (const Arg& b, const rational<IntType>& a)
{
      rational<IntType> t(a);
      return -(t -= b);
}

template <class IntType, class Arg>
constexpr
inline typename boost::enable_if_c <
   rational_detail::is_compatible_integer<Arg, IntType>::value || is_same<rational<IntType>, Arg>::value, rational<IntType> >::type
   operator * (const rational<IntType>& a, const Arg& b)
{
      rational<IntType> t(a);
      return t *= b;
}
template <class Arg, class IntType>
constexpr
inline typename boost::enable_if_c <
   rational_detail::is_compatible_integer<Arg, IntType>::value, rational<IntType> >::type
   operator * (const Arg& b, const rational<IntType>& a)
{
      rational<IntType> t(a);
      return t *= b;
}

template <class IntType, class Arg>
constexpr
inline typename boost::enable_if_c <
   rational_detail::is_compatible_integer<Arg, IntType>::value || is_same<rational<IntType>, Arg>::value, rational<IntType> >::type
   operator / (const rational<IntType>& a, const Arg& b)
{
      rational<IntType> t(a);
      return t /= b;
}
template <class Arg, class IntType>
constexpr
inline typename boost::enable_if_c <
   rational_detail::is_compatible_integer<Arg, IntType>::value, rational<IntType> >::type
   operator / (const Arg& b, const rational<IntType>& a)
{
      rational<IntType> t(b);
      return t /= a;
}

template <class IntType, class Arg>
constexpr
inline typename boost::enable_if_c <
   rational_detail::is_compatible_integer<Arg, IntType>::value || is_same<rational<IntType>, Arg>::value, bool>::type
   operator <= (const rational<IntType>& a, const Arg& b)
{
      return !(a > b);
}
template <class Arg, class IntType>
constexpr
inline typename boost::enable_if_c <
   rational_detail::is_compatible_integer<Arg, IntType>::value, bool>::type
   operator <= (const Arg& b, const rational<IntType>& a)
{
      return a >= b;
}

template <class IntType, class Arg>
constexpr
inline typename boost::enable_if_c <
   rational_detail::is_compatible_integer<Arg, IntType>::value || is_same<rational<IntType>, Arg>::value, bool>::type
   operator >= (const rational<IntType>& a, const Arg& b)
{
      return !(a < b);
}
template <class Arg, class IntType>
constexpr
inline typename boost::enable_if_c <
   rational_detail::is_compatible_integer<Arg, IntType>::value, bool>::type
   operator >= (const Arg& b, const rational<IntType>& a)
{
      return a <= b;
}

template <class IntType, class Arg>
constexpr
inline typename boost::enable_if_c <
   rational_detail::is_compatible_integer<Arg, IntType>::value || is_same<rational<IntType>, Arg>::value, bool>::type
   operator != (const rational<IntType>& a, const Arg& b)
{
      return !(a == b);
}
template <class Arg, class IntType>
constexpr
inline typename boost::enable_if_c <
   rational_detail::is_compatible_integer<Arg, IntType>::value, bool>::type
   operator != (const Arg& b, const rational<IntType>& a)
{
      return !(b == a);
}

template <class Arg, class IntType>
constexpr
inline typename boost::enable_if_c <
   rational_detail::is_compatible_integer<Arg, IntType>::value, bool>::type
   operator < (const Arg& b, const rational<IntType>& a)
{
      return a > b;
}
template <class Arg, class IntType>
constexpr
inline typename boost::enable_if_c <
   rational_detail::is_compatible_integer<Arg, IntType>::value, bool>::type
   operator > (const Arg& b, const rational<IntType>& a)
{
      return a < b;
}
template <class Arg, class IntType>
constexpr
inline typename boost::enable_if_c <
   rational_detail::is_compatible_integer<Arg, IntType>::value, bool>::type
   operator == (const Arg& b, const rational<IntType>& a)
{
      return a == b;
}


template <typename IntType>
constexpr
bool rational<IntType>::operator< (const rational<IntType>& r) const
{

    int_type const zero( 0 );





    (__builtin_expect(!(this->den > zero), 0) ? __assert_rtn(__func__, "./boost/rational.hpp", 768, "this->den > zero") : (void)0);
    (__builtin_expect(!(r.den > zero), 0) ? __assert_rtn(__func__, "./boost/rational.hpp", 769, "r.den > zero") : (void)0);



    struct { int_type n, d, q, r; }
     ts = { this->num, this->den, static_cast<int_type>(this->num / this->den),
     static_cast<int_type>(this->num % this->den) },
     rs = { r.num, r.den, static_cast<int_type>(r.num / r.den),
     static_cast<int_type>(r.num % r.den) };
    unsigned reverse = 0u;






    while ( ts.r < zero ) { ts.r += ts.d; --ts.q; }
    while ( rs.r < zero ) { rs.r += rs.d; --rs.q; }


    for ( ;; )
    {



        if ( ts.q != rs.q )
        {



            return reverse ? ts.q > rs.q : ts.q < rs.q;
        }


        reverse ^= 1u;

        if ( (ts.r == zero) || (rs.r == zero) )
        {

            break;
        }

        ts.n = ts.d; ts.d = ts.r;
        ts.q = ts.n / ts.d; ts.r = ts.n % ts.d;
        rs.n = rs.d; rs.d = rs.r;
        rs.q = rs.n / rs.d; rs.r = rs.n % rs.d;
    }


    if ( ts.r == rs.r )
    {



        return false;
    }
    else
    {
        return ( ts.r != zero ) != static_cast<bool>( reverse );



    }
}

template <typename IntType>
constexpr
inline bool rational<IntType>::operator== (const rational<IntType>& r) const
{
    return ((num == r.num) && (den == r.den));
}


template <typename IntType>
constexpr
inline bool rational<IntType>::test_invariant() const
{
    return ( this->den > int_type(0) ) && ( integer::gcd(this->num, this->den) ==
     int_type(1) );
}


template <typename IntType>
constexpr void rational<IntType>::normalize()
{

    IntType zero(0);

    if (den == zero)
       ::boost::exception_detail::throw_exception_(bad_rational(),__PRETTY_FUNCTION__,"./boost/rational.hpp",866);


    if (num == zero) {
        den = IntType(1);
        return;
    }

    IntType g = integer::gcd(num, den);

    num /= g;
    den /= g;

    if (den < -(std::numeric_limits<IntType>::max)()) {
        ::boost::exception_detail::throw_exception_(bad_rational("bad rational: non-zero singular denominator"),__PRETTY_FUNCTION__,"./boost/rational.hpp",880);
    }


    if (den < zero) {
        num = -num;
        den = -den;
    }

    (__builtin_expect(!(this->test_invariant()), 0) ? __assert_rtn(__func__, "./boost/rational.hpp", 889, "this->test_invariant()") : (void)0);
}


namespace detail {



    struct resetter {
        resetter(std::istream& is) : is_(is), f_(is.flags()) {}
        ~resetter() { is_.flags(f_); }
        std::istream& is_;
        std::istream::fmtflags f_;
    };

}


template <typename IntType>
std::istream& operator>> (std::istream& is, rational<IntType>& r)
{
    using std::ios;

    IntType n = IntType(0), d = IntType(1);
    char c = 0;
    detail::resetter sentry(is);

    if ( is >> n )
    {
        if ( is.get(c) )
        {
            if ( c == '/' )
            {
                if ( is >> std::noskipws >> d )
                    try {
                        r.assign( n, d );
                    } catch ( bad_rational & ) {
                        try { is.setstate(ios::failbit); }
                        catch ( ... ) {}
                        if ( is.exceptions() & ios::failbit )
                            throw;

                    }
            }
            else
                is.setstate( ios::failbit );
        }
    }

    return is;
}


template <typename IntType>
std::ostream& operator<< (std::ostream& os, const rational<IntType>& r)
{

    std::ostringstream ss;

    ss.copyfmt( os );
    ss.tie( __null );
    ss.exceptions( std::ios::goodbit );
    ss.width( 0 );
    ss << std::noshowpos << std::noshowbase << '/' << r.denominator();


    std::string const tail = ss.str();
    std::streamsize const w =
        os.width() - static_cast<std::streamsize>( tail.size() );

    ss.clear();
    ss.str( "" );
    ss.flags( os.flags() );
    ss << std::setw( w < 0 || (os.flags() & std::ios::adjustfield) !=
                     std::ios::internal ? 0 : w ) << r.numerator();
    return os << ss.str() + tail;
}



template <typename T, typename IntType>
constexpr
inline T rational_cast(const rational<IntType>& src)
{
    return static_cast<T>(src.numerator())/static_cast<T>(src.denominator());
}




template <typename IntType>
constexpr
inline rational<IntType> abs(const rational<IntType>& r)
{
    return r.numerator() >= IntType(0)? r: -r;
}

namespace integer {

template <typename IntType>
struct gcd_evaluator< rational<IntType> >
{
    typedef rational<IntType> result_type,
                              first_argument_type, second_argument_type;
    result_type operator() ( first_argument_type const &a
                           , second_argument_type const &b
                           ) const
    {
        return result_type(integer::gcd(a.numerator(), b.numerator()),
                           integer::lcm(a.denominator(), b.denominator()));
    }
};

template <typename IntType>
struct lcm_evaluator< rational<IntType> >
{
    typedef rational<IntType> result_type,
                              first_argument_type, second_argument_type;
    result_type operator() ( first_argument_type const &a
                           , second_argument_type const &b
                           ) const
    {
        return result_type(integer::lcm(a.numerator(), b.numerator()),
                           integer::gcd(a.denominator(), b.denominator()));
    }
};

}

}




namespace boost{
namespace multiprecision{
namespace backends{

template <class IntBackend>
struct rational_adaptor
{
   typedef number<IntBackend> integer_type;
   typedef boost::rational<integer_type> rational_type;

   typedef typename IntBackend::signed_types signed_types;
   typedef typename IntBackend::unsigned_types unsigned_types;
   typedef typename IntBackend::float_types float_types;

   rational_adaptor() noexcept((noexcept(rational_type()))) {}
   rational_adaptor(const rational_adaptor& o) noexcept((noexcept(std::declval<rational_type&>() = std::declval<const rational_type&>())))
   {
      m_value = o.m_value;
   }
   rational_adaptor(const IntBackend& o) noexcept((noexcept(rational_type(std::declval<const IntBackend&>())))) : m_value(o) {}

   template <class U>
   rational_adaptor(const U& u, typename enable_if_c<is_convertible<U, IntBackend>::value>::type* = 0)
      : m_value(static_cast<integer_type>(u)){}
   template <class U>
   explicit rational_adaptor(const U& u,
      typename enable_if_c<
         boost::multiprecision::detail::is_explicitly_convertible<U, IntBackend>::value && !is_convertible<U, IntBackend>::value
      >::type* = 0)
      : m_value(IntBackend(u)){}
   template <class U>
   typename enable_if_c<(boost::multiprecision::detail::is_explicitly_convertible<U, IntBackend>::value && !is_arithmetic<U>::value), rational_adaptor&>::type operator = (const U& u)
   {
      m_value = IntBackend(u);
      return *this;
   }


   rational_adaptor(rational_adaptor&& o) noexcept((noexcept(rational_type(std::declval<rational_type>())))) : m_value(static_cast<rational_type&&>(o.m_value)) {}
   rational_adaptor(IntBackend&& o) noexcept((noexcept(rational_type(std::declval<IntBackend>())))) : m_value(static_cast<IntBackend&&>(o)) {}
   rational_adaptor& operator = (rational_adaptor&& o) noexcept((noexcept(std::declval<rational_type&>() = std::declval<rational_type>())))
   {
      m_value = static_cast<rational_type&&>(o.m_value);
      return *this;
   }

   rational_adaptor& operator = (const rational_adaptor& o)
   {
      m_value = o.m_value;
      return *this;
   }
   rational_adaptor& operator = (const IntBackend& o)
   {
      m_value = o;
      return *this;
   }
   template <class Int>
   typename enable_if<is_integral<Int>, rational_adaptor&>::type operator = (Int i)
   {
      m_value = i;
      return *this;
   }
   template <class Float>
   typename enable_if<is_floating_point<Float>, rational_adaptor&>::type operator = (Float i)
   {
      int e;
      Float f = std::frexp(i, &e);
      f = std::ldexp(f, std::numeric_limits<Float>::digits);
      e -= std::numeric_limits<Float>::digits;
      integer_type num(f);
      integer_type denom(1u);
      if(e > 0)
      {
         num <<= e;
      }
      else if(e < 0)
      {
         denom <<= -e;
      }
      m_value.assign(num, denom);
      return *this;
   }
   rational_adaptor& operator = (const char* s)
   {
      std::string s1;
      multiprecision::number<IntBackend> v1, v2;
      char c;
      bool have_hex = false;
      const char* p = s;

      while((0 != (c = *s)) && (c == 'x' || c == 'X' || c == '-' || c == '+' || (c >= '0' && c <= '9') || (have_hex && (c >= 'a' && c <= 'f')) || (have_hex && (c >= 'A' && c <= 'F'))))
      {
         if(c == 'x' || c == 'X')
            have_hex = true;
         s1.append(1, c);
         ++s;
      }
      v1.assign(s1);
      s1.erase();
      if(c == '/')
      {
         ++s;
         while((0 != (c = *s)) && (c == 'x' || c == 'X' || c == '-' || c == '+' || (c >= '0' && c <= '9') || (have_hex && (c >= 'a' && c <= 'f')) || (have_hex && (c >= 'A' && c <= 'F'))))
         {
            if(c == 'x' || c == 'X')
               have_hex = true;
            s1.append(1, c);
            ++s;
         }
         v2.assign(s1);
      }
      else
         v2 = 1;
      if(*s)
      {
         ::boost::exception_detail::throw_exception_(std::runtime_error(std::string("Could not parse the string \"") + p + std::string("\" as a valid rational number.")),__PRETTY_FUNCTION__,"./boost/multiprecision/rational_adaptor.hpp",139);
      }
      data().assign(v1, v2);
      return *this;
   }
   void swap(rational_adaptor& o)
   {
      std::swap(m_value, o.m_value);
   }
   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const
   {



      std::string result = data().numerator().str(digits, f);
      if(data().denominator() != 1)
      {
         result.append(1, '/');
         result.append(data().denominator().str(digits, f));
      }
      return result;
   }
   void negate()
   {
      m_value = -m_value;
   }
   int compare(const rational_adaptor& o)const
   {
      return m_value > o.m_value ? 1 : (m_value < o.m_value ? -1 : 0);
   }
   template <class Arithmatic>
   typename enable_if_c<is_arithmetic<Arithmatic>::value && !is_floating_point<Arithmatic>::value, int>::type compare(Arithmatic i)const
   {
      return m_value > i ? 1 : (m_value < i ? -1 : 0);
   }
   template <class Arithmatic>
   typename enable_if_c<is_floating_point<Arithmatic>::value, int>::type compare(Arithmatic i)const
   {
      rational_adaptor r;
      r = i;
      return this->compare(r);
   }
   rational_type& data() { return m_value; }
   const rational_type& data()const { return m_value; }

   template <class Archive>
   void serialize(Archive& ar, const mpl::true_&)
   {

      integer_type n(m_value.numerator()), d(m_value.denominator());
      ar & n;
      ar & d;
   }
   template <class Archive>
   void serialize(Archive& ar, const mpl::false_&)
   {

      integer_type n, d;
      ar & n;
      ar & d;
      m_value.assign(n, d);
   }
   template <class Archive>
   void serialize(Archive& ar, const unsigned int )
   {
      typedef typename Archive::is_saving tag;
      serialize(ar, tag());
   }
private:
   rational_type m_value;
};

template <class IntBackend>
inline void eval_add(rational_adaptor<IntBackend>& result, const rational_adaptor<IntBackend>& o)
{
   result.data() += o.data();
}
template <class IntBackend>
inline void eval_subtract(rational_adaptor<IntBackend>& result, const rational_adaptor<IntBackend>& o)
{
   result.data() -= o.data();
}
template <class IntBackend>
inline void eval_multiply(rational_adaptor<IntBackend>& result, const rational_adaptor<IntBackend>& o)
{
   result.data() *= o.data();
}
template <class IntBackend>
inline void eval_divide(rational_adaptor<IntBackend>& result, const rational_adaptor<IntBackend>& o)
{
   using default_ops::eval_is_zero;
   if(eval_is_zero(o))
   {
      ::boost::exception_detail::throw_exception_(std::overflow_error("Divide by zero."),__PRETTY_FUNCTION__,"./boost/multiprecision/rational_adaptor.hpp",232);
   }
   result.data() /= o.data();
}

template <class R, class IntBackend>
inline typename enable_if_c<number_category<R>::value == number_kind_floating_point>::type eval_convert_to(R* result, const rational_adaptor<IntBackend>& backend)
{



   ::boost::multiprecision::detail::generic_convert_rational_to_float(*result, backend);
}

template <class R, class IntBackend>
inline typename enable_if_c<(number_category<R>::value != number_kind_integer) && (number_category<R>::value != number_kind_floating_point)>::type eval_convert_to(R* result, const rational_adaptor<IntBackend>& backend)
{
   typedef typename component_type<number<rational_adaptor<IntBackend> > >::type comp_t;
   comp_t num(backend.data().numerator());
   comp_t denom(backend.data().denominator());
   *result = num.template convert_to<R>();
   *result /= denom.template convert_to<R>();
}

template <class R, class IntBackend>
inline typename enable_if_c<number_category<R>::value == number_kind_integer>::type eval_convert_to(R* result, const rational_adaptor<IntBackend>& backend)
{
   typedef typename component_type<number<rational_adaptor<IntBackend> > >::type comp_t;
   comp_t t = backend.data().numerator();
   t /= backend.data().denominator();
   *result = t.template convert_to<R>();
}

template <class IntBackend>
inline bool eval_is_zero(const rational_adaptor<IntBackend>& val)
{
   using default_ops::eval_is_zero;
   return eval_is_zero(val.data().numerator().backend());
}
template <class IntBackend>
inline int eval_get_sign(const rational_adaptor<IntBackend>& val)
{
   using default_ops::eval_get_sign;
   return eval_get_sign(val.data().numerator().backend());
}

template<class IntBackend, class V>
inline void assign_components(rational_adaptor<IntBackend>& result, const V& v1, const V& v2)
{
   result.data().assign(v1, v2);
}

template <class IntBackend>
inline std::size_t hash_value(const rational_adaptor<IntBackend>& val)
{
   std::size_t result = hash_value(val.data().numerator());
   boost::hash_combine(result, val.data().denominator());
   return result;
}


}

template<class IntBackend>
struct expression_template_default<backends::rational_adaptor<IntBackend> > : public expression_template_default<IntBackend> {};

template<class IntBackend>
struct number_category<backends::rational_adaptor<IntBackend> > : public mpl::int_<number_kind_rational>{};

using boost::multiprecision::backends::rational_adaptor;

template <class Backend, expression_template_option ExpressionTemplates>
struct component_type<number<backends::rational_adaptor<Backend>, ExpressionTemplates> >
{
   typedef number<Backend, ExpressionTemplates> type;
};

template <class IntBackend, expression_template_option ET>
inline number<IntBackend, ET> numerator(const number<rational_adaptor<IntBackend>, ET>& val)
{
   return val.backend().data().numerator();
}
template <class IntBackend, expression_template_option ET>
inline number<IntBackend, ET> denominator(const number<rational_adaptor<IntBackend>, ET>& val)
{
   return val.backend().data().denominator();
}
}}


namespace std{

template <class IntBackend, boost::multiprecision::expression_template_option ExpressionTemplates>
class numeric_limits<boost::multiprecision::number<boost::multiprecision::rational_adaptor<IntBackend>, ExpressionTemplates> > : public std::numeric_limits<boost::multiprecision::number<IntBackend, ExpressionTemplates> >
{
   typedef std::numeric_limits<boost::multiprecision::number<IntBackend> > base_type;
   typedef boost::multiprecision::number<boost::multiprecision::rational_adaptor<IntBackend> > number_type;
public:
   static constexpr bool is_integer = false;
   static constexpr bool is_exact = true;
   static constexpr number_type (min)() { return (base_type::min)(); }
   static constexpr number_type (max)() { return (base_type::max)(); }
   static constexpr number_type lowest() { return -(max)(); }
   static constexpr number_type epsilon() { return base_type::epsilon(); }
   static constexpr number_type round_error() { return epsilon() / 2; }
   static constexpr number_type infinity() { return base_type::infinity(); }
   static constexpr number_type quiet_NaN() { return base_type::quiet_NaN(); }
   static constexpr number_type signaling_NaN() { return base_type::signaling_NaN(); }
   static constexpr number_type denorm_min() { return base_type::denorm_min(); }
};



template <class IntBackend, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr bool numeric_limits<boost::multiprecision::number<boost::multiprecision::rational_adaptor<IntBackend>, ExpressionTemplates> >::is_integer;
template <class IntBackend, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr bool numeric_limits<boost::multiprecision::number<boost::multiprecision::rational_adaptor<IntBackend>, ExpressionTemplates> >::is_exact;




}
namespace boost{ namespace multiprecision{ namespace detail{

   template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_member_value_type { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::value_type>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
   template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_member_const_iterator { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::const_iterator>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };

   template <class C, bool b>
   struct is_byte_container_imp
   {
      static const bool value = boost::is_integral<typename C::value_type>::value && (sizeof(typename C::value_type) == 1);
   };

   template <class C>
   struct is_byte_container_imp<C, false> : public boost::false_type {};

   template <class C>
   struct is_byte_container : public is_byte_container_imp<C, has_member_value_type<C>::value && has_member_const_iterator<C>::value> {};


}}}
namespace boost
{




template <static_min_max_signed_type Value1, static_min_max_signed_type Value2>
struct static_signed_min
{
    static const static_min_max_signed_type value = (Value1 > Value2) ? Value2 : Value1;
};

template <static_min_max_signed_type Value1, static_min_max_signed_type Value2>
struct static_signed_max
{
    static const static_min_max_signed_type value = (Value1 < Value2) ? Value2 : Value1;
};

template <static_min_max_unsigned_type Value1, static_min_max_unsigned_type Value2>
struct static_unsigned_min
{
    static const static_min_max_unsigned_type value = (Value1 > Value2) ? Value2 : Value1;

};

template <static_min_max_unsigned_type Value1, static_min_max_unsigned_type Value2>
struct static_unsigned_max
{
    static const static_min_max_unsigned_type value = (Value1 < Value2) ? Value2 : Value1;

};


}
namespace boost
{

namespace type_traits_detail
{




template<template<class...> class F, class... T>
struct mp_valid_impl
{
    template<template<class...> class G, class = G<T...>>
    static boost::true_type check_s(int);

    template<template<class...> class>
    static boost::false_type check_s(...);

    using type = decltype(check_s<F>(0));
};

template<template<class...> class F, class... T>
using mp_valid = typename mp_valid_impl<F, T...>::type;



struct mp_empty
{
};

template<template<class...> class F, class... T> struct mp_defer_impl
{
    using type = F<T...>;
};

template<template<class...> class F, class... T> using mp_defer = typename boost::conditional<mp_valid<F, T...>::value, mp_defer_impl<F, T...>, mp_empty>::type;

}

}


namespace boost
{





template<class... T> struct common_type
{
};



template<class... T> using common_type_t = typename common_type<T...>::type;

namespace type_traits_detail
{

template<class T1, class T2, class... T> using common_type_fold = common_type_t<common_type_t<T1, T2>, T...>;

}

template<class T1, class T2, class... T>
struct common_type<T1, T2, T...>: type_traits_detail::mp_defer<type_traits_detail::common_type_fold, T1, T2, T...>
{
};
template<class T> struct common_type<T>: boost::decay<T>
{
   static_assert(::boost::is_complete<T>::value || ::boost::is_void<T>::value || ::boost::is_array<T>::value, "Arguments to common_type must both be complete types");
};



namespace type_traits_detail
{
template<class T1, class T2> using builtin_common_type = typename boost::decay<decltype( boost::declval<bool>()? boost::declval<T1>(): boost::declval<T2>() )>::type;

template<class T1, class T2> struct common_type_impl: mp_defer<builtin_common_type, T1, T2>
{
};
template<class T1, class T2, class T1d = typename boost::decay<T1>::type, class T2d = typename boost::decay<T2>::type> struct common_type_decay_helper: boost::common_type<T1d, T2d>
{
};

template<class T1, class T2> struct common_type_decay_helper<T1, T2, T1, T2>: common_type_impl<T1, T2>
{
};

}

template<class T1, class T2> struct common_type<T1, T2>: type_traits_detail::common_type_decay_helper<T1, T2>
{
   static_assert(::boost::is_complete<T1>::value || ::boost::is_void<T1>::value || ::boost::is_array<T1>::value, "Arguments to common_type must both be complete types");
   static_assert(::boost::is_complete<T2>::value || ::boost::is_void<T2>::value || ::boost::is_array<T2>::value, "Arguments to common_type must both be complete types");
};

}
namespace boost {

template <class T>
struct make_signed
{
private:
   static_assert(( ::boost::is_integral<T>::value || ::boost::is_enum<T>::value), "The template argument to make_signed must be an integer or enum type.");
   static_assert(!(::boost::is_same<typename remove_cv<T>::type, bool>::value), "The template argument to make_signed must not be the type bool.");

   typedef typename remove_cv<T>::type t_no_cv;
   typedef typename conditional<
      (::boost::is_signed<T>::value
      && ::boost::is_integral<T>::value
      && ! ::boost::is_same<t_no_cv, char>::value
      && ! ::boost::is_same<t_no_cv, wchar_t>::value
      && ! ::boost::is_same<t_no_cv, bool>::value),
      T,
      typename conditional<
         (::boost::is_integral<T>::value
         && ! ::boost::is_same<t_no_cv, char>::value
         && ! ::boost::is_same<t_no_cv, wchar_t>::value
         && ! ::boost::is_same<t_no_cv, bool>::value),
         typename conditional<
            is_same<t_no_cv, unsigned char>::value,
            signed char,
            typename conditional<
               is_same<t_no_cv, unsigned short>::value,
               signed short,
               typename conditional<
                  is_same<t_no_cv, unsigned int>::value,
                  int,
                  typename conditional<
                     is_same<t_no_cv, unsigned long>::value,
                     long,


                     typename conditional<
                        sizeof(t_no_cv) == sizeof(boost::long_long_type),
                        boost::long_long_type,
                        boost::int128_type
                     >::type
                  >::type
               >::type
            >::type
         >::type,

         typename conditional<
            sizeof(t_no_cv) == sizeof(unsigned char),
            signed char,
            typename conditional<
               sizeof(t_no_cv) == sizeof(unsigned short),
               signed short,
               typename conditional<
                  sizeof(t_no_cv) == sizeof(unsigned int),
                  int,
                  typename conditional<
                     sizeof(t_no_cv) == sizeof(unsigned long),
                     long,


                     typename conditional<
                        sizeof(t_no_cv) == sizeof(boost::long_long_type),
                        boost::long_long_type,
                        boost::int128_type
                     >::type
                  >::type
               >::type
            >::type
         >::type
      >::type
   >::type base_integer_type;


   typedef typename conditional<
      is_const<T>::value,
      typename add_const<base_integer_type>::type,
      base_integer_type
   >::type const_base_integer_type;
public:

   typedef typename conditional<
      is_volatile<T>::value,
      typename add_volatile<const_base_integer_type>::type,
      const_base_integer_type
   >::type type;
};



   template <class T> using make_signed_t = typename make_signed<T>::type;



}








namespace boost{ namespace multiprecision{ namespace backends{ namespace detail{






inline void raise_overflow(std::string op)
{
   ::boost::exception_detail::throw_exception_(std::overflow_error("overflow in " + op),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/checked.hpp",18);
}
inline void raise_add_overflow()
{
   raise_overflow("addition");
}
inline void raise_subtract_overflow()
{
   ::boost::exception_detail::throw_exception_(std::range_error("Subtraction resulted in a negative value, but the type is unsigned"),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/checked.hpp",26);
}
inline void raise_mul_overflow()
{
   raise_overflow("multiplication");
}
inline void raise_div_overflow()
{
   raise_overflow("division");
}

template <class A>
inline A checked_add_imp(A a, A b, const mpl::true_&)
{
   if(a > 0)
   {
      if((b > 0) && ((integer_traits<A>::const_max - b) < a))
         raise_add_overflow();
   }
   else
   {
      if((b < 0) && ((integer_traits<A>::const_min - b) > a))
         raise_add_overflow();
   }
   return a + b;
}
template <class A>
inline A checked_add_imp(A a, A b, const mpl::false_&)
{
   if((integer_traits<A>::const_max - b) < a)
      raise_add_overflow();
   return a + b;
}
template <class A>
inline A checked_add(A a, A b, const mpl::int_<checked>&)
{
   return checked_add_imp(a, b, boost::is_signed<A>());
}
template <class A>
inline A checked_add(A a, A b, const mpl::int_<unchecked>&)
{
   return a + b;
}

template <class A>
inline A checked_subtract_imp(A a, A b, const mpl::true_&)
{
   if(a > 0)
   {
      if((b < 0) && ((integer_traits<A>::const_max + b) < a))
         raise_subtract_overflow();
   }
   else
   {
      if((b > 0) && ((integer_traits<A>::const_min + b) > a))
         raise_subtract_overflow();
   }
   return a - b;
}
template <class A>
inline A checked_subtract_imp(A a, A b, const mpl::false_&)
{
   if(a < b)
      raise_subtract_overflow();
   return a - b;
}
template <class A>
inline A checked_subtract(A a, A b, const mpl::int_<checked>&)
{
   return checked_subtract_imp(a, b, boost::is_signed<A>());
}
template <class A>
inline A checked_subtract(A a, A b, const mpl::int_<unchecked>&)
{
   return a - b;
}

template <class A>
inline A checked_multiply(A a, A b, const mpl::int_<checked>&)
{
   using boost::multiprecision::detail::abs;
   if(a && (integer_traits<A>::const_max / abs(a) < abs(b)))
      raise_mul_overflow();
   return a * b;
}
template <class A>
inline A checked_multiply(A a, A b, const mpl::int_<unchecked>&)
{
   return a * b;
}

template <class A>
inline A checked_divide(A a, A b, const mpl::int_<checked>&)
{
   if(b == 0)
      raise_div_overflow();
   return a / b;
}
template <class A>
inline A checked_divide(A a, A b, const mpl::int_<unchecked>&)
{
   return a / b;
}

template <class A>
inline A checked_left_shift(A a, boost::ulong_long_type shift, const mpl::int_<checked>&)
{
   if(a && shift)
   {
      if((shift > sizeof(A) * 8) || (a >> (sizeof(A) * 8 - shift)))
         ::boost::exception_detail::throw_exception_(std::overflow_error("Shift out of range"),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/checked.hpp",136);
   }
   return a << shift;
}
template <class A>
inline A checked_left_shift(A a, boost::ulong_long_type shift, const mpl::int_<unchecked>&)
{
   return (shift >= sizeof(A) * 8) ? 0 : a << shift;
}

}}}}









namespace boost{ namespace multiprecision{

namespace literals{ namespace detail{

template <limb_type...VALUES>
struct value_pack
{
   constexpr value_pack(){}

   typedef value_pack<0, VALUES...> next_type;
};
template <class T>
struct is_value_pack{ static constexpr bool value = false; };
template <limb_type...VALUES>
struct is_value_pack<value_pack<VALUES...> >{ static constexpr bool value = true; };

struct negate_tag{};

constexpr negate_tag make_negate_tag()
{
   return negate_tag();
}


}}}}


namespace boost{
namespace multiprecision{
namespace backends{

  using boost::enable_if;
template <unsigned MinBits = 0, unsigned MaxBits = 0, boost::multiprecision::cpp_integer_type SignType = signed_magnitude, cpp_int_check_type Checked = unchecked, class Allocator = typename mpl::if_c<MinBits && (MinBits == MaxBits), void, std::allocator<limb_type> >::type >
struct cpp_int_backend;

}

namespace detail {

   template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, cpp_int_check_type Checked, class Allocator>
   struct is_byte_container<backends::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> > : public boost::false_type {};

}

namespace backends{

template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked, class Allocator, bool trivial = false>
struct cpp_int_base;



template <class T> struct max_precision;

template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked, class Allocator>
struct max_precision<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >
{
   static const unsigned value = is_void<Allocator>::value ?
      static_unsigned_max<MinBits, MaxBits>::value
      : (((MaxBits >= MinBits) && MaxBits) ? MaxBits : (2147483647 *2U +1U));
};

template <class T> struct min_precision;

template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked, class Allocator>
struct min_precision<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >
{
   static const unsigned value = (is_void<Allocator>::value ? static_unsigned_max<MinBits, MaxBits>::value : MinBits);
};




template <class T>
struct is_trivial_cpp_int
{
   static const bool value = false;
};

template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked, class Allocator>
struct is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >
{
   typedef cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> self;
   static const bool value = is_void<Allocator>::value && (max_precision<self>::value <= (sizeof(double_limb_type) * 8) - (SignType == signed_packed ? 1 : 0));
};

template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked, class Allocator>
struct is_trivial_cpp_int<cpp_int_base<MinBits, MaxBits, SignType, Checked, Allocator, true> >
{
   static const bool value = true;
};

}



template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked, class Allocator>
struct is_unsigned_number<backends::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >
   : public mpl::bool_<(SignType == unsigned_magnitude) || (SignType == unsigned_packed)>{};

namespace backends{





template <class T, class U>
struct is_implicit_cpp_int_conversion;

template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked, class Allocator, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
struct is_implicit_cpp_int_conversion<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >
{
   typedef cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> t1;
   typedef cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> t2;
   static const bool value =
      (is_signed_number<t2>::value || !is_signed_number<t1>::value)
      && (max_precision<t1>::value <= max_precision<t2>::value);
};




template <class T>
struct is_non_throwing_cpp_int : public mpl::false_{};
template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType>
struct is_non_throwing_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, unchecked, void> > : public mpl::true_ {};




template <class T>
struct is_fixed_precision;
template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked, class Allocator>
struct is_fixed_precision<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >
   : public mpl::bool_<max_precision<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >::value != (2147483647 *2U +1U)> {};

namespace detail{

inline void verify_new_size(unsigned new_size, unsigned min_size, const mpl::int_<checked>&)
{
   if(new_size < min_size)
      ::boost::exception_detail::throw_exception_(std::overflow_error("Unable to allocate sufficient storage for the value of the result: value overflows the maximum allowable magnitude."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int.hpp",153);
}
inline void verify_new_size(unsigned , unsigned , const mpl::int_<unchecked>&){}

template <class U>
inline void verify_limb_mask(bool b, U limb, U mask, const mpl::int_<checked>&)
{

   if(b && (limb & ~mask))
      ::boost::exception_detail::throw_exception_(std::overflow_error("Overflow in cpp_int arithmetic: there is insufficient precision in the target type to hold all of the bits of the result."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int.hpp",162);
}
template <class U>
inline void verify_limb_mask(bool , U , U , const mpl::int_<unchecked>&){}

}





template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class Allocator>
struct cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>
   : private boost::empty_value<typename detail::rebind<limb_type, Allocator>::type>
{
   typedef typename detail::rebind<limb_type, Allocator>::type allocator_type;




   typedef typename std::allocator_traits<allocator_type>::pointer limb_pointer;
   typedef typename std::allocator_traits<allocator_type>::const_pointer const_limb_pointer;

   typedef mpl::int_<Checked> checked_type;




   static_assert(!is_void<Allocator>::value, "!is_void<Allocator>::value");

private:
   typedef boost::empty_value<allocator_type> base_type;

   struct limb_data
   {
      unsigned capacity;
      limb_pointer data;
   };

public:
   static const unsigned limb_bits = sizeof(limb_type) * 8;
   static const limb_type max_limb_value = ~static_cast<limb_type>(0u);
   static const limb_type sign_bit_mask = static_cast<limb_type>(1u) << (limb_bits - 1);
   static const unsigned internal_limb_count = MinBits ? (MinBits / limb_bits + ((MinBits % limb_bits) ? 1 : 0)) : (sizeof(limb_data) / sizeof(limb_type));



   static const bool variable = true;

private:
   union data_type
   {
      limb_data ld;
      limb_type la[internal_limb_count];
      limb_type first;
      double_limb_type double_first;

      constexpr data_type() : first(0) {}
      constexpr data_type(limb_type i) : first(i) {}
      constexpr data_type(signed_limb_type i) : first(i < 0 ? static_cast<limb_type>(boost::multiprecision::detail::unsigned_abs(i)) : i) {}

      constexpr data_type(double_limb_type i) : double_first(i) {}
      constexpr data_type(signed_double_limb_type i) : double_first(i < 0 ? static_cast<double_limb_type>(boost::multiprecision::detail::unsigned_abs(i)) : i) {}

   };

   data_type m_data;
   unsigned m_limbs;
   bool m_sign, m_internal;

public:



   inline constexpr cpp_int_base(limb_type i)noexcept
      : m_data(i), m_limbs(1), m_sign(false), m_internal(true) { }
   inline constexpr cpp_int_base(signed_limb_type i)noexcept
      : m_data(i), m_limbs(1), m_sign(i < 0), m_internal(true) { }

   inline constexpr cpp_int_base(double_limb_type i)noexcept
      : m_data(i), m_limbs(i > max_limb_value ? 2 : 1), m_sign(false), m_internal(true) { }
   inline constexpr cpp_int_base(signed_double_limb_type i)noexcept
      : m_data(i), m_limbs(i < 0 ? (static_cast<double_limb_type>(boost::multiprecision::detail::unsigned_abs(i)) > static_cast<double_limb_type>(max_limb_value) ? 2 : 1) : (i > max_limb_value ? 2 : 1)),
        m_sign(i < 0), m_internal(true) { }




   inline allocator_type& allocator() noexcept { return base_type::get(); }
   inline const allocator_type& allocator()const noexcept { return base_type::get(); }
   inline unsigned size()const noexcept { return m_limbs; }
   inline limb_pointer limbs() noexcept { return m_internal ? m_data.la : m_data.ld.data; }
   inline const_limb_pointer limbs()const noexcept { return m_internal ? m_data.la : m_data.ld.data; }
   inline unsigned capacity()const noexcept { return m_internal ? internal_limb_count : m_data.ld.capacity; }
   inline bool sign()const noexcept { return m_sign; }
   void sign(bool b) noexcept
   {
      m_sign = b;

      if(m_sign && (m_limbs == 1))
      {
         if(limbs()[0] == 0)
            m_sign = false;
      }
   }
   void resize(unsigned new_size, unsigned min_size)
   {
      static const unsigned max_limbs = MaxBits / (8 * sizeof(limb_type)) + ((MaxBits % (8 * sizeof(limb_type))) ? 1 : 0);

      if(new_size > max_limbs)
         new_size = max_limbs;
      detail::verify_new_size(new_size, min_size, checked_type());

      unsigned cap = capacity();
      if(new_size > cap)
      {

         cap = (std::min)((std::max)(cap * 4, new_size), max_limbs);
         limb_pointer pl = allocator().allocate(cap);
         std::memcpy(pl, limbs(), size() * sizeof(limbs()[0]));
         if(!m_internal)
            allocator().deallocate(limbs(), capacity());
         else
            m_internal = false;
         m_limbs = new_size;
         m_data.ld.capacity = cap;
         m_data.ld.data = pl;
      }
      else
      {
         m_limbs = new_size;
      }
   }
   inline void normalize() noexcept
   {
      limb_pointer p = limbs();
      while((m_limbs-1) && !p[m_limbs - 1])--m_limbs;
   }
   inline constexpr cpp_int_base() noexcept : m_data(), m_limbs(1), m_sign(false), m_internal(true) {}
   inline cpp_int_base(const cpp_int_base& o) : base_type(o), m_limbs(0), m_internal(true)
   {
      resize(o.size(), o.size());
      std::memcpy(limbs(), o.limbs(), o.size() * sizeof(limbs()[0]));
      m_sign = o.m_sign;
   }

   cpp_int_base(cpp_int_base&& o)
      : base_type(static_cast<base_type&&>(o)), m_limbs(o.m_limbs), m_sign(o.m_sign), m_internal(o.m_internal)
   {
      if(m_internal)
      {
         std::memcpy(limbs(), o.limbs(), o.size() * sizeof(limbs()[0]));
      }
      else
      {
         m_data.ld = o.m_data.ld;
         o.m_limbs = 0;
         o.m_internal = true;
      }
   }
   cpp_int_base& operator = (cpp_int_base&& o) noexcept
   {
      if(!m_internal)
         allocator().deallocate(m_data.ld.data, m_data.ld.capacity);
      *static_cast<base_type*>(this) = static_cast<base_type&&>(o);
      m_limbs = o.m_limbs;
      m_sign = o.m_sign;
      m_internal = o.m_internal;
      if(m_internal)
      {
         std::memcpy(limbs(), o.limbs(), o.size() * sizeof(limbs()[0]));
      }
      else
      {
         m_data.ld = o.m_data.ld;
         o.m_limbs = 0;
         o.m_internal = true;
      }
      return *this;
   }

   inline ~cpp_int_base() noexcept
   {
      if(!m_internal)
         allocator().deallocate(limbs(), capacity());
   }
   void assign(const cpp_int_base& o)
   {
      if(this != &o)
      {
         static_cast<base_type&>(*this) = static_cast<const base_type&>(o);
         m_limbs = 0;
         resize(o.size(), o.size());
         std::memcpy(limbs(), o.limbs(), o.size() * sizeof(limbs()[0]));
         m_sign = o.m_sign;
      }
   }
   inline void negate() noexcept
   {
      m_sign = !m_sign;

      if(m_sign && (m_limbs == 1))
      {
         if(limbs()[0] == 0)
            m_sign = false;
      }
   }
   inline bool isneg()const noexcept
   {
      return m_sign;
   }
   inline void do_swap(cpp_int_base& o) noexcept
   {
      std::swap(m_data, o.m_data);
      std::swap(m_sign, o.m_sign);
      std::swap(m_internal, o.m_internal);
      std::swap(m_limbs, o.m_limbs);
   }
protected:
   template <class A>
   void check_in_range(const A&) noexcept {}
};



template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class Allocator>
const unsigned cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::limb_bits;
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class Allocator>
const limb_type cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::max_limb_value;
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class Allocator>
const limb_type cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::sign_bit_mask;
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class Allocator>
const unsigned cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::internal_limb_count;
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class Allocator>
const bool cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::variable;



template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class Allocator>
struct cpp_int_base<MinBits, MaxBits, unsigned_magnitude, Checked, Allocator, false>
   : private boost::empty_value<typename detail::rebind<limb_type, Allocator>::type>
{




   static_assert(((sizeof(Allocator) == 0) && !is_void<Allocator>::value), "There is curently no support for unsigned arbitrary precision integers.");
};



template <unsigned MinBits, cpp_int_check_type Checked>
struct cpp_int_base<MinBits, MinBits, signed_magnitude, Checked, void, false>
{
   typedef limb_type* limb_pointer;
   typedef const limb_type* const_limb_pointer;
   typedef mpl::int_<Checked> checked_type;




   static_assert(MinBits > sizeof(double_limb_type) * 8, "Template parameter MinBits is inconsistent with the parameter trivial - did you mistakingly try to override the trivial parameter?");

public:
   static const unsigned limb_bits = sizeof(limb_type) * 8;
   static const limb_type max_limb_value = ~static_cast<limb_type>(0u);
   static const limb_type sign_bit_mask = static_cast<limb_type>(1u) << (limb_bits - 1);
   static const unsigned internal_limb_count = MinBits / limb_bits + ((MinBits % limb_bits) ? 1 : 0);
   static const bool variable = false;
   static const limb_type upper_limb_mask = (MinBits % limb_bits) ? (limb_type(1) << (MinBits % limb_bits)) -1 : (~limb_type(0));
   static_assert(internal_limb_count >= 2, "A fixed precision integer type must have at least 2 limbs");

private:
   union data_type{
      limb_type m_data[internal_limb_count];
      limb_type m_first_limb;
      double_limb_type m_double_first_limb;

      constexpr data_type() : m_first_limb(0) {}
      constexpr data_type(limb_type i) : m_first_limb(i) {}
      constexpr data_type(double_limb_type i) : m_double_first_limb(i) {}

      template <limb_type...VALUES>
      constexpr data_type(literals::detail::value_pack<VALUES...>) : m_data{ VALUES... } {}

   } m_wrapper;
   boost::uint16_t m_limbs;
   bool m_sign;

public:



   inline constexpr cpp_int_base(limb_type i)noexcept
      : m_wrapper(i), m_limbs(1), m_sign(false) {}
   inline constexpr cpp_int_base(signed_limb_type i)noexcept
      : m_wrapper(limb_type(i < 0 ? static_cast<limb_type>(-static_cast<signed_double_limb_type>(i)) : i)), m_limbs(1), m_sign(i < 0) {}

   inline constexpr cpp_int_base(double_limb_type i)noexcept
      : m_wrapper(i), m_limbs(i > max_limb_value ? 2 : 1), m_sign(false) {}
   inline constexpr cpp_int_base(signed_double_limb_type i)noexcept
      : m_wrapper(double_limb_type(i < 0 ? static_cast<double_limb_type>(boost::multiprecision::detail::unsigned_abs(i)) : i)),
        m_limbs(i < 0 ? (static_cast<double_limb_type>(boost::multiprecision::detail::unsigned_abs(i)) > max_limb_value ? 2 : 1) : (i > max_limb_value ? 2 : 1)),
        m_sign(i < 0) {}


      template <limb_type...VALUES>
      constexpr cpp_int_base(literals::detail::value_pack<VALUES...> i)
         : m_wrapper(i), m_limbs(sizeof...(VALUES)), m_sign(false) {}
      constexpr cpp_int_base(literals::detail::value_pack<> i)
         : m_wrapper(i), m_limbs(1), m_sign(false) {}
      constexpr cpp_int_base(const cpp_int_base& a, const literals::detail::negate_tag&)
         : m_wrapper(a.m_wrapper), m_limbs(a.m_limbs), m_sign((a.m_limbs == 1) && (*a.limbs() == 0) ? false : !a.m_sign) {}




   inline unsigned size()const noexcept { return m_limbs; }
   inline limb_pointer limbs() noexcept { return m_wrapper.m_data; }
   inline constexpr const_limb_pointer limbs()const noexcept { return m_wrapper.m_data; }
   inline constexpr bool sign()const noexcept { return m_sign; }
   inline void sign(bool b) noexcept
   {
      m_sign = b;

      if(m_sign && (m_limbs == 1))
      {
         if(limbs()[0] == 0)
            m_sign = false;
      }
   }
   inline void resize(unsigned new_size, unsigned min_size) noexcept(((Checked == unchecked)))
   {
      m_limbs = static_cast<boost::uint16_t>((std::min)(new_size, internal_limb_count));
      detail::verify_new_size(m_limbs, min_size, checked_type());
   }
   inline void normalize() noexcept(((Checked == unchecked)))
   {
      limb_pointer p = limbs();
      detail::verify_limb_mask(m_limbs == internal_limb_count, p[internal_limb_count-1], upper_limb_mask, checked_type());
      p[internal_limb_count-1] &= upper_limb_mask;
      while((m_limbs-1) && !p[m_limbs - 1])--m_limbs;
      if((m_limbs == 1) && (!*p)) m_sign = false;
   }

   inline constexpr cpp_int_base()noexcept : m_wrapper(limb_type(0u)), m_limbs(1), m_sign(false) {}

   inline constexpr cpp_int_base(const cpp_int_base& o)noexcept
      : m_wrapper(o.m_wrapper), m_limbs(o.m_limbs), m_sign(o.m_sign) {}



   void assign(const cpp_int_base& o) noexcept
   {
      if(this != &o)
      {
         m_limbs = o.m_limbs;
         std::memcpy(limbs(), o.limbs(), o.size() * sizeof(o.limbs()[0]));
         m_sign = o.m_sign;
      }
   }
   inline void negate() noexcept
   {
      m_sign = !m_sign;

      if(m_sign && (m_limbs == 1))
      {
         if(limbs()[0] == 0)
            m_sign = false;
      }
   }
   inline bool isneg()const noexcept
   {
      return m_sign;
   }
   inline void do_swap(cpp_int_base& o) noexcept
   {
      for(unsigned i = 0; i < (std::max)(size(), o.size()); ++i)
         std::swap(m_wrapper.m_data[i], o.m_wrapper.m_data[i]);
      std::swap(m_sign, o.m_sign);
      std::swap(m_limbs, o.m_limbs);
   }
protected:
   template <class A>
   void check_in_range(const A&) noexcept {}
};


template <unsigned MinBits, cpp_int_check_type Checked>
const unsigned cpp_int_base<MinBits, MinBits, signed_magnitude, Checked, void, false>::limb_bits;
template <unsigned MinBits, cpp_int_check_type Checked>
const limb_type cpp_int_base<MinBits, MinBits, signed_magnitude, Checked, void, false>::max_limb_value;
template <unsigned MinBits, cpp_int_check_type Checked>
const limb_type cpp_int_base<MinBits, MinBits, signed_magnitude, Checked, void, false>::sign_bit_mask;
template <unsigned MinBits, cpp_int_check_type Checked>
const unsigned cpp_int_base<MinBits, MinBits, signed_magnitude, Checked, void, false>::internal_limb_count;
template <unsigned MinBits, cpp_int_check_type Checked>
const bool cpp_int_base<MinBits, MinBits, signed_magnitude, Checked, void, false>::variable;





template <unsigned MinBits, cpp_int_check_type Checked>
struct cpp_int_base<MinBits, MinBits, unsigned_magnitude, Checked, void, false>
{
   typedef limb_type* limb_pointer;
   typedef const limb_type* const_limb_pointer;
   typedef mpl::int_<Checked> checked_type;




   static_assert(MinBits > sizeof(double_limb_type) * 8, "Template parameter MinBits is inconsistent with the parameter trivial - did you mistakingly try to override the trivial parameter?");

public:
   static const unsigned limb_bits = sizeof(limb_type) * 8;
   static const limb_type max_limb_value = ~static_cast<limb_type>(0u);
   static const limb_type sign_bit_mask = static_cast<limb_type>(1u) << (limb_bits - 1);
   static const unsigned internal_limb_count = MinBits / limb_bits + ((MinBits % limb_bits) ? 1 : 0);
   static const bool variable = false;
   static const limb_type upper_limb_mask = (MinBits % limb_bits) ? (limb_type(1) << (MinBits % limb_bits)) -1 : (~limb_type(0));
   static_assert(internal_limb_count >= 2, "A fixed precision integer type must have at least 2 limbs");

private:
   union data_type{
      limb_type m_data[internal_limb_count];
      limb_type m_first_limb;
      double_limb_type m_double_first_limb;

      constexpr data_type() : m_first_limb(0) {}
      constexpr data_type(limb_type i) : m_first_limb(i) {}
      constexpr data_type(double_limb_type i) : m_double_first_limb(i) {}

      template <limb_type...VALUES>
      constexpr data_type(literals::detail::value_pack<VALUES...>) : m_data{ VALUES... } {}

   } m_wrapper;
   limb_type m_limbs;

public:



   inline constexpr cpp_int_base(limb_type i)noexcept
      : m_wrapper(i), m_limbs(1) {}
   inline cpp_int_base(signed_limb_type i)noexcept(((Checked == unchecked)))
      : m_wrapper(limb_type(i < 0 ? static_cast<limb_type>(-static_cast<signed_double_limb_type>(i)) : i)), m_limbs(1) { if(i < 0) negate(); }

   inline constexpr cpp_int_base(double_limb_type i)noexcept
      : m_wrapper(i), m_limbs(i > max_limb_value ? 2 : 1) {}
   inline cpp_int_base(signed_double_limb_type i)noexcept(((Checked == unchecked)))
      : m_wrapper(double_limb_type(i < 0 ? static_cast<double_limb_type>(boost::multiprecision::detail::unsigned_abs(i)) : i)),
      m_limbs(i < 0 ? (static_cast<double_limb_type>(boost::multiprecision::detail::unsigned_abs(i)) > max_limb_value ? 2 : 1) : (i > max_limb_value ? 2 : 1))
   {
      if (i < 0) negate();
   }


      template <limb_type...VALUES>
      constexpr cpp_int_base(literals::detail::value_pack<VALUES...> i)
         : m_wrapper(i), m_limbs(sizeof...(VALUES)) {}
      constexpr cpp_int_base(literals::detail::value_pack<>)
         : m_wrapper(static_cast<limb_type>(0u)), m_limbs(1) {}




   inline unsigned size()const noexcept { return m_limbs; }
   inline limb_pointer limbs() noexcept { return m_wrapper.m_data; }
   inline constexpr const_limb_pointer limbs()const noexcept { return m_wrapper.m_data; }
   inline constexpr bool sign()const noexcept { return false; }
   inline void sign(bool b) noexcept(((Checked == unchecked))) { if(b) negate(); }
   inline void resize(unsigned new_size, unsigned min_size) noexcept(((Checked == unchecked)))
   {
      m_limbs = (std::min)(new_size, internal_limb_count);
      detail::verify_new_size(m_limbs, min_size, checked_type());
   }
   inline void normalize() noexcept(((Checked == unchecked)))
   {
      limb_pointer p = limbs();
      detail::verify_limb_mask(m_limbs == internal_limb_count, p[internal_limb_count-1], upper_limb_mask, checked_type());
      p[internal_limb_count-1] &= upper_limb_mask;
      while((m_limbs-1) && !p[m_limbs - 1])--m_limbs;
   }

   inline constexpr cpp_int_base() noexcept
      : m_wrapper(limb_type(0u)), m_limbs(1) {}
   inline constexpr cpp_int_base(const cpp_int_base& o) noexcept
      : m_wrapper(o.m_wrapper), m_limbs(o.m_limbs) {}



   inline void assign(const cpp_int_base& o) noexcept
   {
      if(this != &o)
      {
         m_limbs = o.m_limbs;
         std::memcpy(limbs(), o.limbs(), o.size() * sizeof(limbs()[0]));
      }
   }
private:
   void check_negate(const mpl::int_<checked>&)
   {
      ::boost::exception_detail::throw_exception_(std::range_error("Attempt to negate an unsigned number."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int.hpp",666);
   }
   void check_negate(const mpl::int_<unchecked>&){}
public:
   void negate() noexcept(((Checked == unchecked)))
   {


      unsigned i;
      if((m_limbs == 1) && (m_wrapper.m_data[0] == 0))
         return;
      check_negate(checked_type());
      for(i = m_limbs; i < internal_limb_count; ++i)
         m_wrapper.m_data[i] = 0;
      m_limbs = internal_limb_count;
      for(i = 0; i < internal_limb_count; ++i)
         m_wrapper.m_data[i] = ~m_wrapper.m_data[i];
      normalize();
      eval_increment(static_cast<cpp_int_backend<MinBits, MinBits, unsigned_magnitude, Checked, void>& >(*this));
   }
   inline constexpr bool isneg()const noexcept
   {
      return false;
   }
   inline void do_swap(cpp_int_base& o) noexcept
   {
      for(unsigned i = 0; i < (std::max)(size(), o.size()); ++i)
         std::swap(m_wrapper.m_data[i], o.m_wrapper.m_data[i]);
      std::swap(m_limbs, o.m_limbs);
   }
protected:
   template <class A>
   void check_in_range(const A&) noexcept {}
};


template <unsigned MinBits, cpp_int_check_type Checked>
const unsigned cpp_int_base<MinBits, MinBits, unsigned_magnitude, Checked, void, false>::limb_bits;
template <unsigned MinBits, cpp_int_check_type Checked>
const limb_type cpp_int_base<MinBits, MinBits, unsigned_magnitude, Checked, void, false>::max_limb_value;
template <unsigned MinBits, cpp_int_check_type Checked>
const limb_type cpp_int_base<MinBits, MinBits, unsigned_magnitude, Checked, void, false>::sign_bit_mask;
template <unsigned MinBits, cpp_int_check_type Checked>
const unsigned cpp_int_base<MinBits, MinBits, unsigned_magnitude, Checked, void, false>::internal_limb_count;
template <unsigned MinBits, cpp_int_check_type Checked>
const bool cpp_int_base<MinBits, MinBits, unsigned_magnitude, Checked, void, false>::variable;






template <unsigned N, bool s>
struct trivial_limb_type_imp
{
   typedef double_limb_type type;
};

template <unsigned N>
struct trivial_limb_type_imp<N, true>
{
   typedef typename boost::uint_t<N>::least type;
};

template <unsigned N>
struct trivial_limb_type : public trivial_limb_type_imp<N, N <= sizeof(boost::long_long_type) * 8> {};



template <unsigned MinBits, cpp_int_check_type Checked>
struct cpp_int_base<MinBits, MinBits, signed_magnitude, Checked, void, true>
{
   typedef typename trivial_limb_type<MinBits>::type local_limb_type;
   typedef local_limb_type* limb_pointer;
   typedef const local_limb_type* const_limb_pointer;
   typedef mpl::int_<Checked> checked_type;
protected:
   static const unsigned limb_bits = sizeof(local_limb_type) * 8;
   static const local_limb_type limb_mask = (MinBits < limb_bits) ? local_limb_type((local_limb_type(~local_limb_type(0))) >> (limb_bits - MinBits)) : local_limb_type(~local_limb_type(0));
private:
   local_limb_type m_data;
   bool m_sign;




   static_assert(MinBits <= sizeof(double_limb_type) * 8, "Template parameter MinBits is inconsistent with the parameter trivial - did you mistakingly try to override the trivial parameter?");
protected:
   template <class T>
   typename boost::disable_if_c<!boost::is_integral<T>::value || (std::numeric_limits<T>::is_specialized && (std::numeric_limits<T>::digits <= (int)MinBits))>::type
      check_in_range(T val, const mpl::int_<checked>&)
   {
      typedef typename common_type<typename make_unsigned<T>::type, local_limb_type>::type common_type;

      if(static_cast<common_type>(boost::multiprecision::detail::unsigned_abs(val)) > static_cast<common_type>(limb_mask))
         ::boost::exception_detail::throw_exception_(std::range_error("The argument to a cpp_int constructor exceeded the largest value it can represent."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int.hpp",761);
   }
   template <class T>
   typename boost::disable_if_c<boost::is_integral<T>::value || (std::numeric_limits<T>::is_specialized && (std::numeric_limits<T>::digits <= (int)MinBits))>::type
      check_in_range(T val, const mpl::int_<checked>&)
   {
         using std::abs;
         typedef typename common_type<T, local_limb_type>::type common_type;

         if (static_cast<common_type>(abs(val)) > static_cast<common_type>(limb_mask))
            ::boost::exception_detail::throw_exception_(std::range_error("The argument to a cpp_int constructor exceeded the largest value it can represent."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int.hpp",771);
   }
   template <class T, int C>
   void check_in_range(T, const mpl::int_<C>&) noexcept {}

   template <class T>
   void check_in_range(T val) noexcept((noexcept(std::declval<cpp_int_base>().check_in_range(std::declval<T>(), checked_type()))))
   {
      check_in_range(val, checked_type());
   }

public:



   template <class SI>
   inline constexpr cpp_int_base(SI i, typename boost::enable_if_c<is_signed<SI>::value && (Checked == unchecked) >::type const* = 0) noexcept((noexcept(std::declval<cpp_int_base>().check_in_range(std::declval<SI>()))))
      : m_data(i < 0 ? static_cast<local_limb_type>(static_cast<typename make_unsigned<SI>::type>(boost::multiprecision::detail::unsigned_abs(i)) & limb_mask) : static_cast<local_limb_type>(i & limb_mask)), m_sign(i < 0) {}
   template <class SI>
   inline cpp_int_base(SI i, typename boost::enable_if_c<is_signed<SI>::value && (Checked == checked) >::type const* = 0) noexcept((noexcept(std::declval<cpp_int_base>().check_in_range(std::declval<SI>()))))
      : m_data(i < 0 ? (static_cast<local_limb_type>(static_cast<typename make_unsigned<SI>::type>(boost::multiprecision::detail::unsigned_abs(i)) & limb_mask)) : static_cast<local_limb_type>(i & limb_mask)), m_sign(i < 0)
   { check_in_range(i); }
   template <class UI>
   inline constexpr cpp_int_base(UI i, typename boost::enable_if_c<is_unsigned<UI>::value && (Checked == unchecked)>::type const* = 0) noexcept
      : m_data(static_cast<local_limb_type>(i) & limb_mask), m_sign(false) {}
   template <class UI>
   inline cpp_int_base(UI i, typename boost::enable_if_c<is_unsigned<UI>::value && (Checked == checked)>::type const* = 0) noexcept((noexcept(std::declval<cpp_int_base>().check_in_range(std::declval<UI>()))))
      : m_data(static_cast<local_limb_type>(i) & limb_mask), m_sign(false) { check_in_range(i); }
   template <class F>
   inline constexpr cpp_int_base(F i, typename boost::enable_if_c<is_floating_point<F>::value && (Checked == unchecked)>::type const* = 0) noexcept
      : m_data(static_cast<local_limb_type>(std::fabs(i)) & limb_mask), m_sign(i < 0) {}
   template <class F>
   inline cpp_int_base(F i, typename boost::enable_if_c<is_floating_point<F>::value && (Checked == checked)>::type const* = 0)
      : m_data(static_cast<local_limb_type>(std::fabs(i)) & limb_mask), m_sign(i < 0) { check_in_range(i); }

      constexpr cpp_int_base(literals::detail::value_pack<>) noexcept
         : m_data(static_cast<local_limb_type>(0u)), m_sign(false) {}
      template <limb_type a>
      constexpr cpp_int_base(literals::detail::value_pack<a>)noexcept
         : m_data(static_cast<local_limb_type>(a)), m_sign(false) {}
      template <limb_type a, limb_type b>
      constexpr cpp_int_base(literals::detail::value_pack<a, b>)noexcept
         : m_data(static_cast<local_limb_type>(a) | (static_cast<local_limb_type>(b) << bits_per_limb)), m_sign(false) {}
      constexpr cpp_int_base(const cpp_int_base& a, const literals::detail::negate_tag&)noexcept
         : m_data(a.m_data), m_sign(a.m_data ? !a.m_sign : false) {}




   inline constexpr unsigned size()const noexcept { return 1; }
   inline limb_pointer limbs() noexcept { return &m_data; }
   inline constexpr const_limb_pointer limbs()const noexcept { return &m_data; }
   inline bool sign()const noexcept { return m_sign; }
   inline void sign(bool b) noexcept
   {
      m_sign = b;

      if(m_sign && !m_data)
      {
         m_sign = false;
      }
   }
   inline void resize(unsigned new_size, unsigned min_size)
   {
      detail::verify_new_size(2, min_size, checked_type());
   }
   inline void normalize() noexcept(((Checked == unchecked)))
   {
      if(!m_data)
         m_sign = false;
      detail::verify_limb_mask(true, m_data, limb_mask, checked_type());
      m_data &= limb_mask;
   }

   inline constexpr cpp_int_base() noexcept : m_data(0), m_sign(false) {}
   inline constexpr cpp_int_base(const cpp_int_base& o) noexcept
      : m_data(o.m_data), m_sign(o.m_sign) {}

   inline void assign(const cpp_int_base& o) noexcept
   {
      m_data = o.m_data;
      m_sign = o.m_sign;
   }
   inline void negate() noexcept
   {
      m_sign = !m_sign;

      if(m_data == 0)
      {
         m_sign = false;
      }
   }
   inline bool isneg()const noexcept
   {
      return m_sign;
   }
   inline void do_swap(cpp_int_base& o) noexcept
   {
      std::swap(m_sign, o.m_sign);
      std::swap(m_data, o.m_data);
   }
};



template <unsigned MinBits, cpp_int_check_type Checked>
struct cpp_int_base<MinBits, MinBits, unsigned_magnitude, Checked, void, true>
{
   typedef typename trivial_limb_type<MinBits>::type local_limb_type;
   typedef local_limb_type* limb_pointer;
   typedef const local_limb_type* const_limb_pointer;
private:
   static const unsigned limb_bits = sizeof(local_limb_type) * 8;
   static const local_limb_type limb_mask = limb_bits != MinBits ? static_cast<local_limb_type>(static_cast<local_limb_type>(~local_limb_type(0)) >> (limb_bits - MinBits)) : static_cast<local_limb_type>(~local_limb_type(0));



   local_limb_type m_data;

   typedef mpl::int_<Checked> checked_type;




   static_assert(MinBits <= sizeof(double_limb_type) * 8, "Template parameter MinBits is inconsistent with the parameter trivial - did you mistakingly try to override the trivial parameter?");
protected:
   template <class T>
   typename boost::disable_if_c<std::numeric_limits<T>::is_specialized && (std::numeric_limits<T>::digits <= (int)MinBits)>::type
      check_in_range(T val, const mpl::int_<checked>&, const boost::false_type&)
   {
      typedef typename common_type<T, local_limb_type>::type common_type;

      if(static_cast<common_type>(val) > limb_mask)
         ::boost::exception_detail::throw_exception_(std::range_error("The argument to a cpp_int constructor exceeded the largest value it can represent."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int.hpp",904);
   }
   template <class T>
   void check_in_range(T val, const mpl::int_<checked>&, const boost::true_type&)
   {
      typedef typename common_type<T, local_limb_type>::type common_type;

      if(static_cast<common_type>(val) > limb_mask)
         ::boost::exception_detail::throw_exception_(std::range_error("The argument to a cpp_int constructor exceeded the largest value it can represent."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int.hpp",912);
      if(val < 0)
         ::boost::exception_detail::throw_exception_(std::range_error("The argument to an unsigned cpp_int constructor was negative."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int.hpp",914);
   }
   template <class T, int C, bool B>
   inline void check_in_range(T, const mpl::int_<C>&, const boost::integral_constant<bool, B>&) noexcept {}

   template <class T>
   inline void check_in_range(T val) noexcept((noexcept(std::declval<cpp_int_base>().check_in_range(std::declval<T>(), checked_type(), is_signed<T>()))))
   {
      check_in_range(val, checked_type(), is_signed<T>());
   }

public:
   template <class SI>
   inline constexpr cpp_int_base(SI i, typename boost::enable_if_c<is_signed<SI>::value && (Checked == unchecked) >::type const* = 0) noexcept
      : m_data(i < 0 ? (1 + ~static_cast<local_limb_type>(-i)) & limb_mask : static_cast<local_limb_type>(i) & limb_mask) {}
   template <class SI>
   inline cpp_int_base(SI i, typename boost::enable_if_c<is_signed<SI>::value && (Checked == checked) >::type const* = 0) noexcept((noexcept(std::declval<cpp_int_base>().check_in_range(std::declval<SI>()))))
      : m_data(i < 0 ? 1 + ~static_cast<local_limb_type>(-i) : static_cast<local_limb_type>(i)) { check_in_range(i); }
   template <class UI>
   inline constexpr cpp_int_base(UI i, typename boost::enable_if_c<is_unsigned<UI>::value && (Checked == unchecked) >::type const* = 0) noexcept
      : m_data(static_cast<local_limb_type>(i) & limb_mask) {}
   template <class UI>
   inline cpp_int_base(UI i, typename boost::enable_if_c<is_unsigned<UI>::value && (Checked == checked) >::type const* = 0) noexcept((noexcept(std::declval<cpp_int_base>().check_in_range(std::declval<UI>()))))
      : m_data(static_cast<local_limb_type>(i)) { check_in_range(i); }

   template <class F>
   inline cpp_int_base(F i, typename boost::enable_if<is_floating_point<F> >::type const* = 0) noexcept(((Checked == unchecked)))
      : m_data(static_cast<local_limb_type>(std::fabs(i)) & limb_mask)
   {
      check_in_range(i);
      if(i < 0)
         negate();
   }

      constexpr cpp_int_base(literals::detail::value_pack<>) noexcept
         : m_data(static_cast<local_limb_type>(0u)) {}
      template <limb_type a>
      constexpr cpp_int_base(literals::detail::value_pack<a>) noexcept
         : m_data(static_cast<local_limb_type>(a)) {}
      template <limb_type a, limb_type b>
      constexpr cpp_int_base(literals::detail::value_pack<a, b>) noexcept
         : m_data(static_cast<local_limb_type>(a) | (static_cast<local_limb_type>(b) << bits_per_limb)) {}




   inline constexpr unsigned size()const noexcept { return 1; }
   inline limb_pointer limbs() noexcept { return &m_data; }
   inline constexpr const_limb_pointer limbs()const noexcept { return &m_data; }
   inline constexpr bool sign()const noexcept { return false; }
   inline void sign(bool b) noexcept(((Checked == unchecked)))
   {
      if(b)
         negate();
   }
   inline void resize(unsigned, unsigned min_size)
   {
      detail::verify_new_size(2, min_size, checked_type());
   }
   inline void normalize() noexcept(((Checked == unchecked)))
   {
      detail::verify_limb_mask(true, m_data, limb_mask, checked_type());
      m_data &= limb_mask;
   }

   inline constexpr cpp_int_base() noexcept : m_data(0) {}
   inline constexpr cpp_int_base(const cpp_int_base& o) noexcept
      : m_data(o.m_data) {}

   inline void assign(const cpp_int_base& o) noexcept
   {
      m_data = o.m_data;
   }
   inline void negate() noexcept(((Checked == unchecked)))
   {
      if(Checked == checked)
      {
         ::boost::exception_detail::throw_exception_(std::range_error("Attempt to negate an unsigned type."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int.hpp",1008);
      }
      m_data = ~m_data;
      ++m_data;
   }
   inline constexpr bool isneg()const noexcept
   {
      return false;
   }
   inline void do_swap(cpp_int_base& o) noexcept
   {
      std::swap(m_data, o.m_data);
   }
};




template <class Arg, class Base>
struct is_allowed_cpp_int_base_conversion : public mpl::if_c<
      is_same<Arg, limb_type>::value || is_same<Arg, signed_limb_type>::value

      || is_same<Arg, double_limb_type>::value || is_same<Arg, signed_double_limb_type>::value


      || literals::detail::is_value_pack<Arg>::value

      || (is_trivial_cpp_int<Base>::value && is_arithmetic<Arg>::value),
      mpl::true_,
      mpl::false_
   >::type
{};



template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked, class Allocator>
struct cpp_int_backend
   : public cpp_int_base<
               min_precision<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >::value,
               max_precision<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >::value,
               SignType,
               Checked,
               Allocator,
               is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >::value>
{
   typedef cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> self_type;
   typedef cpp_int_base<
               min_precision<self_type>::value,
               max_precision<self_type>::value,
               SignType,
               Checked,
               Allocator,
               is_trivial_cpp_int<self_type>::value> base_type;
   typedef mpl::bool_<is_trivial_cpp_int<self_type>::value> trivial_tag;
public:
   typedef typename mpl::if_<
      trivial_tag,
      mpl::list<
      signed char, short, int, long,
      boost::long_long_type, signed_double_limb_type>,
      mpl::list<signed_limb_type, signed_double_limb_type>
   >::type signed_types;
   typedef typename mpl::if_<
      trivial_tag,
      mpl::list<unsigned char, unsigned short, unsigned,
      unsigned long, boost::ulong_long_type, double_limb_type>,
      mpl::list<limb_type, double_limb_type>
   >::type unsigned_types;
   typedef typename mpl::if_<
      trivial_tag,
      mpl::list<float, double, long double>,
      mpl::list<long double>
   >::type float_types;
   typedef mpl::int_<Checked> checked_type;

   inline constexpr cpp_int_backend() noexcept{}
   inline constexpr cpp_int_backend(const cpp_int_backend& o) noexcept((boost::is_void<Allocator>::value)) : base_type(o) {}

   inline constexpr cpp_int_backend(cpp_int_backend&& o) noexcept
      : base_type(static_cast<base_type&&>(o)) {}




   template <class Arg>
   inline constexpr cpp_int_backend(Arg i, typename boost::enable_if_c<is_allowed_cpp_int_base_conversion<Arg, base_type>::value >::type const* = 0)noexcept((noexcept(base_type(std::declval<Arg>()))))
      : base_type(i) {}

private:
   template <unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
   void do_assign(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& other, mpl::true_ const&, mpl::true_ const &)
   {

      this->check_in_range(*other.limbs());
      *this->limbs() = static_cast<typename self_type::local_limb_type>(*other.limbs());
      this->sign(other.sign());
      this->normalize();
   }
   template <unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
   void do_assign(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& other, mpl::true_ const&, mpl::false_ const &)
   {

      double_limb_type v = *other.limbs();
      if(other.size() > 1)
      {
         v |= static_cast<double_limb_type>(other.limbs()[1]) << bits_per_limb;
         if((Checked == checked) && (other.size() > 2))
         {
            ::boost::exception_detail::throw_exception_(std::range_error("Assignment of a cpp_int that is out of range for the target type."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int.hpp",1116);
         }
      }
      *this = v;
      this->sign(other.sign());
      this->normalize();
   }
   template <unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
   void do_assign(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& other, mpl::false_ const&, mpl::true_ const &)
   {

       *this = static_cast<
            typename boost::multiprecision::detail::canonical<
               typename cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>::local_limb_type,
               cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>
            >::type
         >(*other.limbs());
       this->sign(other.sign());
   }
   template <unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
   void do_assign(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& other, mpl::false_ const&, mpl::false_ const &)
   {

      this->resize(other.size(), other.size());
      std::memcpy(this->limbs(), other.limbs(), (std::min)(other.size(), this->size()) * sizeof(this->limbs()[0]));
      this->sign(other.sign());
      this->normalize();
   }
public:
   template <unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
   cpp_int_backend(
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& other,
      typename boost::enable_if_c<is_implicit_cpp_int_conversion<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>, self_type>::value>::type* = 0)
      : base_type()
   {
      do_assign(
         other,
         mpl::bool_<is_trivial_cpp_int<self_type>::value>(),
         mpl::bool_<is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value>());
   }
   template <unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
   explicit cpp_int_backend(
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& other,
      typename boost::disable_if_c<is_implicit_cpp_int_conversion<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>, self_type>::value>::type* = 0)
      : base_type()
   {
      do_assign(
         other,
         mpl::bool_<is_trivial_cpp_int<self_type>::value>(),
         mpl::bool_<is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value>());
   }
   template <unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
   cpp_int_backend& operator=(
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& other)
   {
      do_assign(
         other,
         mpl::bool_<is_trivial_cpp_int<self_type>::value>(),
         mpl::bool_<is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value>());
      return *this;
   }

   constexpr cpp_int_backend(const cpp_int_backend& a, const literals::detail::negate_tag& tag)
      : base_type(static_cast<const base_type&>(a), tag){}


   inline cpp_int_backend& operator = (const cpp_int_backend& o) noexcept((noexcept(std::declval<cpp_int_backend>().assign(std::declval<const cpp_int_backend&>()))))
   {
      this->assign(o);
      return *this;
   }

   inline cpp_int_backend& operator = (cpp_int_backend&& o) noexcept((noexcept(std::declval<base_type&>() = std::declval<base_type>())))
   {
      *static_cast<base_type*>(this) = static_cast<base_type&&>(o);
      return *this;
   }

private:
   template <class A>
   typename boost::enable_if<is_unsigned<A> >::type do_assign_arithmetic(A val, const mpl::true_&)
         noexcept((noexcept(std::declval<cpp_int_backend>().check_in_range(std::declval<A>()))))
   {
      this->check_in_range(val);
      *this->limbs() = static_cast<typename self_type::local_limb_type>(val);
      this->sign(false);
      this->normalize();
   }
   template <class A>
   typename boost::disable_if_c<is_unsigned<A>::value || !is_integral<A>::value >::type do_assign_arithmetic(A val, const mpl::true_&)
         noexcept((noexcept(std::declval<cpp_int_backend>().check_in_range(std::declval<A>())) && noexcept(std::declval<cpp_int_backend>().sign(true))))
   {
      this->check_in_range(val);
      *this->limbs() = (val < 0) ? static_cast<typename self_type::local_limb_type>(boost::multiprecision::detail::unsigned_abs(val)) : static_cast<typename self_type::local_limb_type>(val);
      this->sign(val < 0);
      this->normalize();
   }
   template <class A>
   typename boost::enable_if_c< !is_integral<A>::value>::type do_assign_arithmetic(A val, const mpl::true_&)
   {
      this->check_in_range(val);
      *this->limbs() = (val < 0) ? static_cast<typename self_type::local_limb_type>(boost::multiprecision::detail::abs(val)) : static_cast<typename self_type::local_limb_type>(val);
      this->sign(val < 0);
      this->normalize();
   }
   inline void do_assign_arithmetic(limb_type i, const mpl::false_&) noexcept
   {
      this->resize(1, 1);
      *this->limbs() = i;
      this->sign(false);
   }
   inline void do_assign_arithmetic(signed_limb_type i, const mpl::false_&) noexcept((noexcept(std::declval<cpp_int_backend>().sign(true))))
   {
      this->resize(1, 1);
      *this->limbs() = static_cast<limb_type>(boost::multiprecision::detail::unsigned_abs(i));
      this->sign(i < 0);
   }
   void do_assign_arithmetic(double_limb_type i, const mpl::false_&) noexcept
   {
      static_assert(sizeof(i) == 2 * sizeof(limb_type), "sizeof(i) == 2 * sizeof(limb_type)");
      static_assert(base_type::internal_limb_count >= 2, "base_type::internal_limb_count >= 2");
      typename base_type::limb_pointer p = this->limbs();



      *p = static_cast<limb_type>(i);

      p[1] = static_cast<limb_type>(i >> base_type::limb_bits);
      this->resize(p[1] ? 2 : 1, p[1] ? 2 : 1);
      this->sign(false);
   }
   void do_assign_arithmetic(signed_double_limb_type i, const mpl::false_&) noexcept((noexcept(std::declval<cpp_int_backend>().sign(true))))
   {
      static_assert(sizeof(i) == 2 * sizeof(limb_type), "sizeof(i) == 2 * sizeof(limb_type)");
      static_assert(base_type::internal_limb_count >= 2, "base_type::internal_limb_count >= 2");
      bool s = false;
      double_limb_type ui;
      if(i < 0)
         s = true;
      ui = static_cast<double_limb_type>(boost::multiprecision::detail::unsigned_abs(i));
      typename base_type::limb_pointer p = this->limbs();



      *p = static_cast<limb_type>(ui);

      p[1] = static_cast<limb_type>(ui >> base_type::limb_bits);
      this->resize(p[1] ? 2 : 1, p[1] ? 2 : 1);
      this->sign(s);
   }

   void do_assign_arithmetic(long double a, const mpl::false_&)
   {
      using default_ops::eval_add;
      using default_ops::eval_subtract;
      using std::frexp;
      using std::ldexp;
      using std::floor;

      if(a < 0)
      {
         do_assign_arithmetic(-a, mpl::false_());
         this->sign(true);
         return;
      }

      if (a == 0) {
         *this = static_cast<limb_type>(0u);
      }

      if (a == 1) {
         *this = static_cast<limb_type>(1u);
      }

      if ((boost::math::isinf)(a) || (boost::math::isnan)(a))
      {
         ::boost::exception_detail::throw_exception_(std::runtime_error("Cannot convert a non-finite number to an integer."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int.hpp",1292);
      }

      int e;
      long double f, term;
      *this = static_cast<limb_type>(0u);

      f = frexp(a, &e);

      static const limb_type shift = std::numeric_limits<limb_type>::digits;

      while(f)
      {

         f = ldexp(f, shift);
         term = floor(f);
         e -= shift;
         eval_left_shift(*this, shift);
         if(term > 0)
            eval_add(*this, static_cast<limb_type>(term));
         else
            eval_subtract(*this, static_cast<limb_type>(-term));
         f -= term;
      }
      if(e > 0)
         eval_left_shift(*this, e);
      else if(e < 0)
         eval_right_shift(*this, -e);
   }
public:
   template <class Arithmetic>
   inline typename boost::enable_if_c<!boost::multiprecision::detail::is_byte_container<Arithmetic>::value, cpp_int_backend&>::type operator = (Arithmetic val) noexcept((noexcept(std::declval<cpp_int_backend>().do_assign_arithmetic(std::declval<Arithmetic>(), trivial_tag()))))
   {
      do_assign_arithmetic(val, trivial_tag());
      return *this;
   }
private:
   void do_assign_string(const char* s, const mpl::true_&)
   {
      std::size_t n = s ? std::strlen(s) : 0;
      *this = 0;
      unsigned radix = 10;
      bool isneg = false;
      if(n && (*s == '-'))
      {
         --n;
         ++s;
         isneg = true;
      }
      if(n && (*s == '0'))
      {
         if((n > 1) && ((s[1] == 'x') || (s[1] == 'X')))
         {
            radix = 16;
            s +=2;
            n -= 2;
         }
         else
         {
            radix = 8;
            n -= 1;
         }
      }
      if(n)
      {
         unsigned val;
         while(*s)
         {
            if(*s >= '0' && *s <= '9')
               val = *s - '0';
            else if(*s >= 'a' && *s <= 'f')
               val = 10 + *s - 'a';
            else if(*s >= 'A' && *s <= 'F')
               val = 10 + *s - 'A';
            else
               val = radix + 1;
            if(val >= radix)
            {
               ::boost::exception_detail::throw_exception_(std::runtime_error("Unexpected content found while parsing character string."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int.hpp",1370);
            }
            *this->limbs() = detail::checked_multiply(*this->limbs(), static_cast<typename base_type::local_limb_type>(radix), checked_type());
            *this->limbs() = detail::checked_add(*this->limbs(), static_cast<typename base_type::local_limb_type>(val), checked_type());
            ++s;
         }
      }
      if(isneg)
         this->negate();
   }
   void do_assign_string(const char* s, const mpl::false_&)
   {
      using default_ops::eval_multiply;
      using default_ops::eval_add;
      std::size_t n = s ? std::strlen(s) : 0;
      *this = static_cast<limb_type>(0u);
      unsigned radix = 10;
      bool isneg = false;
      if(n && (*s == '-'))
      {
         --n;
         ++s;
         isneg = true;
      }
      if(n && (*s == '0'))
      {
         if((n > 1) && ((s[1] == 'x') || (s[1] == 'X')))
         {
            radix = 16;
            s +=2;
            n -= 2;
         }
         else
         {
            radix = 8;
            n -= 1;
         }
      }





      cpp_int_backend result;
      if(n)
      {
         if(radix == 16)
         {
            while(*s == '0') ++s;
            std::size_t bitcount = 4 * std::strlen(s);
            limb_type val;
            std::size_t limb, shift;
            if(bitcount > 4)
               bitcount -= 4;
            else
               bitcount = 0;
            std::size_t newsize = bitcount / (sizeof(limb_type) * 8) + 1;
            result.resize(static_cast<unsigned>(newsize), static_cast<unsigned>(newsize));
            std::memset(result.limbs(), 0, result.size() * sizeof(limb_type));
            while(*s)
            {
               if(*s >= '0' && *s <= '9')
                  val = *s - '0';
               else if(*s >= 'a' && *s <= 'f')
                  val = 10 + *s - 'a';
               else if(*s >= 'A' && *s <= 'F')
                  val = 10 + *s - 'A';
               else
               {
                  ::boost::exception_detail::throw_exception_(std::runtime_error("Unexpected content found while parsing character string."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int.hpp",1439);
               }
               limb = bitcount / (sizeof(limb_type) * 8);
               shift = bitcount % (sizeof(limb_type) * 8);
               val <<= shift;
               if(result.size() > limb)
               {
                  result.limbs()[limb] |= val;
               }
               ++s;
               bitcount -= 4;
            }
            result.normalize();
         }
         else if(radix == 8)
         {
            while(*s == '0') ++s;
            std::size_t bitcount = 3 * std::strlen(s);
            limb_type val;
            std::size_t limb, shift;
            if(bitcount > 3)
               bitcount -= 3;
            else
               bitcount = 0;
            std::size_t newsize = bitcount / (sizeof(limb_type) * 8) + 1;
            result.resize(static_cast<unsigned>(newsize), static_cast<unsigned>(newsize));
            std::memset(result.limbs(), 0, result.size() * sizeof(limb_type));
            while(*s)
            {
               if(*s >= '0' && *s <= '7')
                  val = *s - '0';
               else
               {
                  ::boost::exception_detail::throw_exception_(std::runtime_error("Unexpected content found while parsing character string."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int.hpp",1472);
               }
               limb = bitcount / (sizeof(limb_type) * 8);
               shift = bitcount % (sizeof(limb_type) * 8);
               if(result.size() > limb)
               {
                  result.limbs()[limb] |= (val << shift);
                  if(shift > sizeof(limb_type) * 8 - 3)
                  {

                     val >>= (sizeof(limb_type) * 8 - shift);
                     if(val)
                     {

                        if(limb + 1 == newsize)
                           result.resize(static_cast<unsigned>(newsize + 1), static_cast<unsigned>(newsize + 1));
                        if(result.size() > limb + 1)
                        {
                           result.limbs()[limb + 1] |= val;
                        }
                     }
                  }
               }
               ++s;
               bitcount -= 3;
            }
            result.normalize();
         }
         else
         {


            limb_type block_mult = max_block_10;
            while(*s)
            {
               limb_type block = 0;
               for(unsigned i = 0; i < digits_per_block_10; ++i)
               {
                  limb_type val;
                  if(*s >= '0' && *s <= '9')
                     val = *s - '0';
                  else
                     ::boost::exception_detail::throw_exception_(std::runtime_error("Unexpected character encountered in input."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int.hpp",1514);
                  block *= 10;
                  block += val;
                  if(!*++s)
                  {
                     block_mult = block_multiplier(i);
                     break;
                  }
               }
               eval_multiply(result, block_mult);
               eval_add(result, block);
            }
         }
      }
      if(isneg)
         result.negate();
      result.swap(*this);
   }
public:
   cpp_int_backend& operator = (const char* s)
   {
      do_assign_string(s, trivial_tag());
      return *this;
   }
   inline void swap(cpp_int_backend& o) noexcept
   {
      this->do_swap(o);
   }
private:
   std::string do_get_trivial_string(std::ios_base::fmtflags f, const mpl::false_&)const
   {
      typedef typename mpl::if_c<sizeof(typename base_type::local_limb_type) == 1, unsigned, typename base_type::local_limb_type>::type io_type;
      if(this->sign() && (((f & std::ios_base::hex) == std::ios_base::hex) || ((f & std::ios_base::oct) == std::ios_base::oct)))
         ::boost::exception_detail::throw_exception_(std::runtime_error("Base 8 or 16 printing of negative numbers is not supported."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int.hpp",1547);
      std::stringstream ss;
      ss.flags(f & ~std::ios_base::showpos);
      ss << static_cast<io_type>(*this->limbs());
      std::string result;
      if(this->sign())
         result += '-';
      else if(f & std::ios_base::showpos)
         result += '+';
      result += ss.str();
      return result;
   }
   std::string do_get_trivial_string(std::ios_base::fmtflags f, const mpl::true_&)const
   {

      int base = 10;
      if((f & std::ios_base::oct) == std::ios_base::oct)
         base = 8;
      else if((f & std::ios_base::hex) == std::ios_base::hex)
         base = 16;
      std::string result;

      unsigned Bits = sizeof(typename base_type::local_limb_type) * 8;

      if(base == 8 || base == 16)
      {
         if(this->sign())
            ::boost::exception_detail::throw_exception_(std::runtime_error("Base 8 or 16 printing of negative numbers is not supported."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int.hpp",1574);
         limb_type shift = base == 8 ? 3 : 4;
         limb_type mask = static_cast<limb_type>((1u << shift) - 1);
         typename base_type::local_limb_type v = *this->limbs();
         result.assign(Bits / shift + (Bits % shift ? 1 : 0), '0');
         std::string::difference_type pos = result.size() - 1;
         for(unsigned i = 0; i < Bits / shift; ++i)
         {
            char c = '0' + static_cast<char>(v & mask);
            if(c > '9')
               c += 'A' - '9' - 1;
            result[pos--] = c;
            v >>= shift;
         }
         if(Bits % shift)
         {
            mask = static_cast<limb_type>((1u << (Bits % shift)) - 1);
            char c = '0' + static_cast<char>(v & mask);
            if(c > '9')
               c += 'A' - '9';
            result[pos] = c;
         }



         std::string::size_type n = result.find_first_not_of('0');
         if(!result.empty() && (n == std::string::npos))
            n = result.size() - 1;
         result.erase(0, n);
         if(f & std::ios_base::showbase)
         {
            const char* pp = base == 8 ? "0" : "0x";
            result.insert(static_cast<std::string::size_type>(0), pp);
         }
      }
      else
      {
         result.assign(Bits / 3 + 1, '0');
         std::string::difference_type pos = result.size() - 1;
         typename base_type::local_limb_type v(*this->limbs());
         bool neg = false;
         if(this->sign())
         {
            neg = true;
         }
         while(v)
         {
            result[pos] = (v % 10) + '0';
            --pos;
            v /= 10;
         }
         std::string::size_type n = result.find_first_not_of('0');
         result.erase(0, n);
         if(result.empty())
            result = "0";
         if(neg)
            result.insert(static_cast<std::string::size_type>(0), 1, '-');
         else if(f & std::ios_base::showpos)
            result.insert(static_cast<std::string::size_type>(0), 1, '+');
      }
      return result;
   }
   std::string do_get_string(std::ios_base::fmtflags f, const mpl::true_&)const
   {

      return do_get_trivial_string(f, mpl::bool_<is_same<typename base_type::local_limb_type, double_limb_type>::value>());



   }
   std::string do_get_string(std::ios_base::fmtflags f, const mpl::false_&)const
   {
      using default_ops::eval_get_sign;
      int base = 10;
      if((f & std::ios_base::oct) == std::ios_base::oct)
         base = 8;
      else if((f & std::ios_base::hex) == std::ios_base::hex)
         base = 16;
      std::string result;

      unsigned Bits = this->size() * base_type::limb_bits;

      if(base == 8 || base == 16)
      {
         if(this->sign())
            ::boost::exception_detail::throw_exception_(std::runtime_error("Base 8 or 16 printing of negative numbers is not supported."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int.hpp",1659);
         limb_type shift = base == 8 ? 3 : 4;
         limb_type mask = static_cast<limb_type>((1u << shift) - 1);
         cpp_int_backend t(*this);
         result.assign(Bits / shift + ((Bits % shift) ? 1 : 0), '0');
         std::string::difference_type pos = result.size() - 1;
         for(unsigned i = 0; i < Bits / shift; ++i)
         {
            char c = '0' + static_cast<char>(t.limbs()[0] & mask);
            if(c > '9')
               c += 'A' - '9' - 1;
            result[pos--] = c;
            eval_right_shift(t, shift);
         }
         if(Bits % shift)
         {
            mask = static_cast<limb_type>((1u << (Bits % shift)) - 1);
            char c = '0' + static_cast<char>(t.limbs()[0] & mask);
            if(c > '9')
               c += 'A' - '9';
            result[pos] = c;
         }



         std::string::size_type n = result.find_first_not_of('0');
         if(!result.empty() && (n == std::string::npos))
            n = result.size() - 1;
         result.erase(0, n);
         if(f & std::ios_base::showbase)
         {
            const char* pp = base == 8 ? "0" : "0x";
            result.insert(static_cast<std::string::size_type>(0), pp);
         }
      }
      else
      {
         result.assign(Bits / 3 + 1, '0');
         std::string::difference_type pos = result.size() - 1;
         cpp_int_backend t(*this);
         cpp_int_backend r;
         bool neg = false;
         if(t.sign())
         {
            t.negate();
            neg = true;
         }
         if(this->size() == 1)
         {
            result = boost::lexical_cast<std::string>(t.limbs()[0]);
         }
         else
         {
            cpp_int_backend block10;
            block10 = max_block_10;
            while(eval_get_sign(t) != 0)
            {
               cpp_int_backend t2;
               divide_unsigned_helper(&t2, t, block10, r);
               t = t2;
               limb_type v = r.limbs()[0];
               for(unsigned i = 0; i < digits_per_block_10; ++i)
               {
                  char c = '0' + v % 10;
                  v /= 10;
                  result[pos] = c;
                  if(pos-- == 0)
                     break;
               }
            }
         }
         std::string::size_type n = result.find_first_not_of('0');
         result.erase(0, n);
         if(result.empty())
            result = "0";
         if(neg)
            result.insert(static_cast<std::string::size_type>(0), 1, '-');
         else if(f & std::ios_base::showpos)
            result.insert(static_cast<std::string::size_type>(0), 1, '+');
      }
      return result;
   }
public:
   std::string str(std::streamsize , std::ios_base::fmtflags f)const
   {
      return do_get_string(f, trivial_tag());
   }
private:
   template <class Container>
   void construct_from_container(const Container& c, const mpl::false_&)
   {



      unsigned newsize = static_cast<unsigned>(c.size() / sizeof(limb_type));
      if(c.size() % sizeof(limb_type))
      {
         ++newsize;
      }
      if(newsize)
      {
         this->resize(newsize, newsize);
         std::memset(this->limbs(), 0, this->size());
         typename Container::const_iterator i(c.begin()), j(c.end());
         unsigned byte_location = static_cast<unsigned>(c.size() - 1);
         while(i != j)
         {
            unsigned limb = byte_location / sizeof(limb_type);
            unsigned shift = (byte_location % sizeof(limb_type)) * 8;
            if(this->size() > limb)
               this->limbs()[limb] |= static_cast<limb_type>(static_cast<unsigned char>(*i)) << shift;
            ++i;
            --byte_location;
         }
      }
   }
   template <class Container>
   void construct_from_container(const Container& c, const mpl::true_&)
   {



      typedef typename base_type::local_limb_type local_limb_type;
      *this->limbs() = 0;
      if(c.size())
      {
         typename Container::const_iterator i(c.begin()), j(c.end());
         unsigned byte_location = static_cast<unsigned>(c.size() - 1);
         while(i != j)
         {
            unsigned limb = byte_location / sizeof(local_limb_type);
            unsigned shift = (byte_location % sizeof(local_limb_type)) * 8;
            if(limb == 0)
               this->limbs()[0] |= static_cast<limb_type>(static_cast<unsigned char>(*i)) << shift;
            ++i;
            --byte_location;
         }
      }
   }
public:
   template <class Container>
   cpp_int_backend(const Container& c, typename boost::enable_if_c<boost::multiprecision::detail::is_byte_container<Container>::value>::type const* = 0)
   {



      construct_from_container(c, trivial_tag());
   }
   template <unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
   int compare_imp(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::false_&, const mpl::false_&)const noexcept
   {
      if(this->sign() != o.sign())
         return this->sign() ? -1 : 1;


      int result = compare_unsigned(o);

      if(this->sign())
         result = -result;
      return result;
   }
   template <unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
   int compare_imp(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::true_&, const mpl::false_&)const
   {
      cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> t(*this);
      return t.compare(o);
   }
   template <unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
   int compare_imp(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::false_&, const mpl::true_&)const
   {
      cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> t(o);
      return compare(t);
   }
   template <unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
   int compare_imp(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::true_&, const mpl::true_&)const noexcept
   {
      if(this->sign())
      {
         if(o.sign())
         {
            return *this->limbs() < *o.limbs() ? 1 : (*this->limbs() > *o.limbs() ? -1 : 0);
         }
         else
            return -1;
      }
      else
      {
         if(o.sign())
            return 1;
         return *this->limbs() < *o.limbs() ? -1 : (*this->limbs() > *o.limbs() ? 1 : 0);
      }
   }
   template <unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
   int compare(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o)const noexcept
   {
      typedef mpl::bool_<is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >::value> t1;
      typedef mpl::bool_<is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value> t2;
      return compare_imp(o, t1(), t2());
   }
   template <unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
   int compare_unsigned(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o)const noexcept
   {
      if(this->size() != o.size())
      {
         return this->size() > o.size() ? 1 : -1;
      }
      typename base_type::const_limb_pointer pa = this->limbs();
      typename base_type::const_limb_pointer pb = o.limbs();
      for(int i = this->size() - 1; i >= 0; --i)
      {
         if(pa[i] != pb[i])
            return pa[i] > pb[i] ? 1 : -1;
      }
      return 0;
   }
   template <class Arithmetic>
   inline typename boost::enable_if<is_arithmetic<Arithmetic>, int>::type compare(Arithmetic i)const
   {

      cpp_int_backend t;
      t = i;
      return compare(t);
   }
};

}

namespace default_ops{

template <class Backend>
struct double_precision_type;

template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked, class Allocator>
struct double_precision_type<backends::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >
{
   typedef typename mpl::if_c<
      backends::is_fixed_precision<backends::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >::value,
      backends::cpp_int_backend<
         (is_void<Allocator>::value ?
            2 * backends::max_precision<backends::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >::value
            : MinBits),
         2 * backends::max_precision<backends::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >::value,
         SignType,
         Checked,
         Allocator>,
      backends::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>
   >::type type;
};


}

template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked>
struct expression_template_default<backends::cpp_int_backend<MinBits, MaxBits, SignType, Checked, void> >
{
   static const expression_template_option value = et_off;
};

using boost::multiprecision::backends::cpp_int_backend;

template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked, class Allocator>
struct number_category<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> > : public mpl::int_<number_kind_integer>{};

typedef number<cpp_int_backend<> > cpp_int;
typedef rational_adaptor<cpp_int_backend<> > cpp_rational_backend;
typedef number<cpp_rational_backend> cpp_rational;


typedef number<cpp_int_backend<128, 128, unsigned_magnitude, unchecked, void> > uint128_t;
typedef number<cpp_int_backend<256, 256, unsigned_magnitude, unchecked, void> > uint256_t;
typedef number<cpp_int_backend<512, 512, unsigned_magnitude, unchecked, void> > uint512_t;
typedef number<cpp_int_backend<1024, 1024, unsigned_magnitude, unchecked, void> > uint1024_t;


typedef number<cpp_int_backend<128, 128, signed_magnitude, unchecked, void> > int128_t;
typedef number<cpp_int_backend<256, 256, signed_magnitude, unchecked, void> > int256_t;
typedef number<cpp_int_backend<512, 512, signed_magnitude, unchecked, void> > int512_t;
typedef number<cpp_int_backend<1024, 1024, signed_magnitude, unchecked, void> > int1024_t;


typedef number<cpp_int_backend<0, 0, signed_magnitude, checked> > checked_cpp_int;
typedef rational_adaptor<cpp_int_backend<0, 0, signed_magnitude, checked> > checked_cpp_rational_backend;
typedef number<checked_cpp_rational_backend> checked_cpp_rational;

typedef number<cpp_int_backend<128, 128, unsigned_magnitude, checked, void> > checked_uint128_t;
typedef number<cpp_int_backend<256, 256, unsigned_magnitude, checked, void> > checked_uint256_t;
typedef number<cpp_int_backend<512, 512, unsigned_magnitude, checked, void> > checked_uint512_t;
typedef number<cpp_int_backend<1024, 1024, unsigned_magnitude, checked, void> > checked_uint1024_t;


typedef number<cpp_int_backend<128, 128, signed_magnitude, checked, void> > checked_int128_t;
typedef number<cpp_int_backend<256, 256, signed_magnitude, checked, void> > checked_int256_t;
typedef number<cpp_int_backend<512, 512, signed_magnitude, checked, void> > checked_int512_t;
typedef number<cpp_int_backend<1024, 1024, signed_magnitude, checked, void> > checked_int1024_t;
}}





namespace boost{ namespace multiprecision{ namespace backends{
template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked, class Allocator>
inline typename enable_if_c<
      !is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >::value,
      bool
   >::type
   eval_eq(const cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>& a, const cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>& b) noexcept
{






   return (a.sign() == b.sign())
      && (a.size() == b.size())
      && std::equal(a.limbs(), a.limbs() + a.size(), b.limbs());

}
template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<
      !is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
      && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value,
      bool
   >::type
   eval_eq(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& b) noexcept
{





   return (a.sign() == b.sign())
      && (a.size() == b.size())
      && std::equal(a.limbs(), a.limbs() + a.size(), b.limbs());

}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class Allocator>
inline typename enable_if_c<
      !is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, Allocator> >::value,
      bool
   >::type eval_eq(const cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, Allocator>& a, limb_type b) noexcept
{
   return (a.sign() == false)
      && (a.size() == 1)
      && (*a.limbs() == b);
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class Allocator>
inline typename enable_if_c<
      !is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, Allocator> >::value,
      bool
   >::type eval_eq(const cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, Allocator>& a, signed_limb_type b) noexcept
{
   return (a.sign() == (b < 0))
      && (a.size() == 1)
      && (*a.limbs() == boost::multiprecision::detail::unsigned_abs(b));
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class Allocator>
inline typename enable_if_c<
      !is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, Allocator> >::value,
      bool
   >::type eval_eq(const cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, Allocator>& a, limb_type b) noexcept
{
   return (a.size() == 1)
      && (*a.limbs() == b);
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class Allocator>
inline typename enable_if_c<
      !is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, Allocator> >::value,
      bool
   >::type eval_eq(const cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, Allocator>& a, signed_limb_type b) noexcept
{
   return (b < 0) ? eval_eq(a, cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, Allocator>(b)) : eval_eq(a, static_cast<limb_type>(b));
}

template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class Allocator>
inline typename enable_if_c<
      !is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, Allocator> >::value,
      bool
   >::type eval_lt(const cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, Allocator>& a, limb_type b) noexcept
{
   if(a.sign())
      return true;
   if(a.size() > 1)
      return false;
   return *a.limbs() < b;
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class Allocator>
inline typename enable_if_c<
      !is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, Allocator> >::value,
      bool
   >::type eval_lt(const cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, Allocator>& a, signed_limb_type b) noexcept
{
   if((b == 0) || (a.sign() != (b < 0)))
      return a.sign();
   if(a.sign())
   {
      if(a.size() > 1)
         return true;
      return *a.limbs() > boost::multiprecision::detail::unsigned_abs(b);
   }
   else
   {
      if(a.size() > 1)
         return false;
      return *a.limbs() < boost::multiprecision::detail::unsigned_abs(b);
   }
}

template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class Allocator>
inline typename enable_if_c<
      !is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, Allocator> >::value,
      bool
   >::type eval_lt(const cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, Allocator>& a, limb_type b) noexcept
{
   if(a.size() > 1)
      return false;
   return *a.limbs() < b;
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class Allocator>
inline typename enable_if_c<
      !is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, Allocator> >::value,
      bool
   >::type eval_lt(const cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, Allocator>& a, signed_limb_type b) noexcept
{
   return (b < 0) ? a.compare(b) < 0 : eval_lt(a, static_cast<limb_type>(b));
}

template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class Allocator>
inline typename enable_if_c<
      !is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, Allocator> >::value,
      bool
   >::type eval_gt(const cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, Allocator>& a, limb_type b) noexcept
{
   if(a.sign())
      return false;
   if(a.size() > 1)
      return true;
   return *a.limbs() > b;
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class Allocator>
inline typename enable_if_c<
      !is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, Allocator> >::value,
      bool
   >::type eval_gt(const cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, Allocator>& a, signed_limb_type b) noexcept
{
   if(b == 0)
      return !a.sign() && ((a.size() > 1) || *a.limbs());
   if(a.sign() != (b < 0))
      return !a.sign();
   if(a.sign())
   {
      if(a.size() > 1)
         return false;
      return *a.limbs() < boost::multiprecision::detail::unsigned_abs(b);
   }
   else
   {
      if(a.size() > 1)
         return true;
      return *a.limbs() > boost::multiprecision::detail::unsigned_abs(b);
   }
}

template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class Allocator>
inline typename enable_if_c<
      !is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, Allocator> >::value,
      bool
   >::type eval_gt(const cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, Allocator>& a, limb_type b) noexcept
{
   if(a.size() > 1)
      return true;
   return *a.limbs() > b;
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class Allocator>
inline typename enable_if_c<
      !is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, Allocator> >::value,
      bool
   >::type eval_gt(const cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, Allocator>& a, signed_limb_type b) noexcept
{
   return (b < 0) ? a.compare(b) > 0 : eval_gt(a, static_cast<limb_type>(b));
}



template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked>
inline typename enable_if_c<
      is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, void> >::value,
      bool
   >::value eval_eq(const cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, void>& a, const cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, void>& b) noexcept
{
   return (a.sign() == b.sign()) && (*a.limbs() == *b.limbs());
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked>
inline typename enable_if_c<
      is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void> >::value,
      bool
   >::value eval_eq(const cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void>& a, const cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void>& b) noexcept
{
   return *a.limbs() == *b.limbs();
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class U>
inline typename enable_if_c<
      is_unsigned<U>::value && is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, void> >::value,
      bool
   >::type eval_eq(const cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, void>& a, U b) noexcept
{
   return !a.sign() && (*a.limbs() == b);
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class S>
inline typename enable_if_c<
      is_signed<S>::value && is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, void> >::value,
      bool
   >::type eval_eq(const cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, void>& a, S b) noexcept
{
   return (a.sign() == (b < 0)) && (*a.limbs() == boost::multiprecision::detail::unsigned_abs(b));
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class U>
inline typename enable_if_c<
      is_unsigned<U>::value && is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void> >::value,
      bool
   >::type eval_eq(const cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void>& a, U b) noexcept
{
   return *a.limbs() == b;
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class S>
inline typename enable_if_c<
      is_signed<S>::value && is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void> >::value,
      bool
   >::type eval_eq(const cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void>& a, S b) noexcept
{
   typedef typename make_unsigned<S>::type ui_type;
   if(b < 0)
   {
      cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void> t(b);
      return *a.limbs() == *t.limbs();
   }
   else
   {
      return *a.limbs() == static_cast<ui_type>(b);
   }
}

template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked>
inline typename enable_if_c<
      is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, void> >::value,
      bool
   >::type eval_lt(const cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, void>& a, const cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void>& b) noexcept
{
   if(a.sign() != b.sign())
      return a.sign();
   return a.sign() ? *a.limbs() > *b.limbs() : *a.limbs() < *b.limbs();
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked>
inline typename enable_if_c<
      is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void> >::value,
      bool
   >::type eval_lt(const cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void>& a, const cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void>& b) noexcept
{
   return *a.limbs() < *b.limbs();
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class U>
inline typename enable_if_c<
      is_unsigned<U>::value && is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, void> >::value,
      bool
   >::type eval_lt(const cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, void>& a, U b) noexcept
{
   if(a.sign())
      return true;
   return *a.limbs() < b;
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class S>
inline typename enable_if_c<
      is_signed<S>::value && is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, void> >::value,
      bool
   >::type eval_lt(const cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, void>& a, S b) noexcept
{
   if(a.sign() != (b < 0))
      return a.sign();
   return a.sign() ? (*a.limbs() > boost::multiprecision::detail::unsigned_abs(b)) : (*a.limbs() < boost::multiprecision::detail::unsigned_abs(b));
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class U>
inline typename enable_if_c<
      is_unsigned<U>::value && is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void> >::value,
      bool
   >::type eval_lt(const cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void>& a, U b) noexcept
{
   return *a.limbs() < b;
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class S>
inline typename enable_if_c<
      is_signed<S>::value && is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void> >::value,
      bool
   >::type eval_lt(const cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void>& a, S b) noexcept
{
   typedef typename make_unsigned<S>::type ui_type;
   if(b < 0)
   {
      cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void> t(b);
      return *a.limbs() < *t.limbs();
   }
   else
   {
      return *a.limbs() < static_cast<ui_type>(b);
   }
}

template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked>
inline typename enable_if_c<
      is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, void> >::value,
      bool
   >::type eval_gt(const cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, void>& a, const cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, void>& b) noexcept
{
   if(a.sign() != b.sign())
      return !a.sign();
   return a.sign() ? *a.limbs() < *b.limbs() : *a.limbs() > *b.limbs();
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked>
inline typename enable_if_c<
      is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void> >::value,
      bool
   >::type eval_gt(const cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void>& a, const cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void>& b) noexcept
{
   return *a.limbs() > *b.limbs();
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class U>
inline typename enable_if_c<
      is_unsigned<U>::value && is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, void> >::value,
      bool
   >::type eval_gt(const cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, void>& a, U b) noexcept
{
   if(a.sign())
      return false;
   return *a.limbs() > b;
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class S>
inline typename enable_if_c<
      is_signed<S>::value && is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, void> >::value,
      bool
   >::type eval_gt(const cpp_int_backend<MinBits, MaxBits, signed_magnitude, Checked, void>& a, S b) noexcept
{
   if(a.sign() != (b < 0))
      return !a.sign();
   return a.sign() ? (*a.limbs() < boost::multiprecision::detail::unsigned_abs(b)) : (*a.limbs() > boost::multiprecision::detail::unsigned_abs(b));
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class U>
inline typename enable_if_c<
      is_unsigned<U>::value && is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void> >::value,
      bool
   >::type eval_gt(const cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void>& a, U b) noexcept
{
   return *a.limbs() > b;
}
template <unsigned MinBits, unsigned MaxBits, cpp_int_check_type Checked, class S>
inline typename enable_if_c<
      is_signed<S>::value && is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void> >::value,
      bool
   >::type eval_gt(const cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void>& a, S b) noexcept
{
   typedef typename make_unsigned<S>::type ui_type;
   if(b < 0)
   {
      cpp_int_backend<MinBits, MaxBits, unsigned_magnitude, Checked, void> t(b);
      return *a.limbs() > *t.limbs();
   }
   else
   {
      return *a.limbs() > static_cast<ui_type>(b);
   }
}





}}}
namespace boost{ namespace multiprecision{ namespace backends{
template <class CppInt1, class CppInt2, class CppInt3>
inline void add_unsigned(CppInt1& result, const CppInt2& a, const CppInt3& b) noexcept((is_non_throwing_cpp_int<CppInt1>::value))
{
   using std::swap;


   double_limb_type carry = 0;
   unsigned m, x;
   unsigned as = a.size();
   unsigned bs = b.size();
   minmax(as, bs, m, x);
   if(x == 1)
   {
      bool s = a.sign();
      result = static_cast<double_limb_type>(*a.limbs()) + static_cast<double_limb_type>(*b.limbs());
      result.sign(s);
      return;
   }
   result.resize(x, x);
   typename CppInt2::const_limb_pointer pa = a.limbs();
   typename CppInt3::const_limb_pointer pb = b.limbs();
   typename CppInt1::limb_pointer pr = result.limbs();
   typename CppInt1::limb_pointer pr_end = pr + m;

   if(as < bs)
      swap(pa, pb);


   while(pr != pr_end)
   {
      carry += static_cast<double_limb_type>(*pa) + static_cast<double_limb_type>(*pb);



      *pr = static_cast<limb_type>(carry);

      carry >>= CppInt1::limb_bits;
      ++pr, ++pa, ++pb;
   }
   pr_end += x - m;

   while(pr != pr_end)
   {
      if(!carry)
      {
         if(pa != pr)



            std::copy(pa, pa + (pr_end - pr), pr);

         break;
      }
      carry += static_cast<double_limb_type>(*pa);



      *pr = static_cast<limb_type>(carry);

      carry >>= CppInt1::limb_bits;
      ++pr, ++pa;
   }
   if(carry)
   {

      result.resize(x + 1, x + 1);
      if(result.size() > x)
         result.limbs()[x] = static_cast<limb_type>(carry);
   }
   result.normalize();
   result.sign(a.sign());
}



template <class CppInt1, class CppInt2>
inline void add_unsigned(CppInt1& result, const CppInt2& a, const limb_type& o) noexcept((is_non_throwing_cpp_int<CppInt1>::value))
{


   if(&result != &a)
      result.resize(a.size(), a.size());
   double_limb_type carry = o;
   typename CppInt1::limb_pointer pr = result.limbs();
   typename CppInt2::const_limb_pointer pa = a.limbs();
   unsigned i = 0;

   for(; carry && (i < result.size()); ++i)
   {
      carry += static_cast<double_limb_type>(pa[i]);



      pr[i] = static_cast<limb_type>(carry);

      carry >>= CppInt1::limb_bits;
   }

   if(&a != &result)
   {
      for(; i < result.size(); ++i)
         pr[i] = pa[i];
   }
   if(carry)
   {

      unsigned x = result.size();
      result.resize(x + 1, x + 1);
      if(result.size() > x)
         result.limbs()[x] = static_cast<limb_type>(carry);
   }
   result.normalize();
   result.sign(a.sign());
}



template <class CppInt1, class CppInt2, class CppInt3>
inline void subtract_unsigned(CppInt1& result, const CppInt2& a, const CppInt3& b) noexcept((is_non_throwing_cpp_int<CppInt1>::value))
{
   using std::swap;


   double_limb_type borrow = 0;
   unsigned m, x;
   minmax(a.size(), b.size(), m, x);



   if(x == 1)
   {
      bool s = a.sign();
      limb_type al = *a.limbs();
      limb_type bl = *b.limbs();
      if(bl > al)
      {
         std::swap(al, bl);
         s = !s;
      }
      result = al - bl;
      result.sign(s);
      return;
   }


   int c = a.compare_unsigned(b);

   result.resize(x, x);

   typename CppInt2::const_limb_pointer pa = a.limbs();
   typename CppInt3::const_limb_pointer pb = b.limbs();
   typename CppInt1::limb_pointer pr = result.limbs();
   bool swapped = false;
   if(c < 0)
   {
      swap(pa, pb);
      swapped = true;
   }
   else if(c == 0)
   {
      result = static_cast<limb_type>(0);
      return;
   }

   unsigned i = 0;

   while(i < m)
   {
      borrow = static_cast<double_limb_type>(pa[i]) - static_cast<double_limb_type>(pb[i]) - borrow;
      pr[i] = static_cast<limb_type>(borrow);
      borrow = (borrow >> CppInt1::limb_bits) & 1u;
      ++i;
   }

   while(borrow && (i < x))
   {
      borrow = static_cast<double_limb_type>(pa[i]) - borrow;
      pr[i] = static_cast<limb_type>(borrow);
      borrow = (borrow >> CppInt1::limb_bits) & 1u;
      ++i;
   }

   if((x != i) && (pa != pr))



      std::copy(pa + i, pa + x, pr + i);

   (__builtin_expect(!(0 == borrow), 0) ? __assert_rtn(__func__, "./boost/multiprecision/cpp_int/add.hpp", 209, "0 == borrow") : (void)0);




   result.normalize();
   result.sign(a.sign());
   if(swapped)
      result.negate();
}



template <class CppInt1, class CppInt2>
inline void subtract_unsigned(CppInt1& result, const CppInt2& a, const limb_type& b) noexcept((is_non_throwing_cpp_int<CppInt1>::value))
{


   static const double_limb_type borrow = static_cast<double_limb_type>(CppInt1::max_limb_value) + 1;
   result.resize(a.size(), a.size());
   typename CppInt1::limb_pointer pr = result.limbs();
   typename CppInt2::const_limb_pointer pa = a.limbs();
   if(*pa >= b)
   {
      *pr = *pa - b;
      if(&result != &a)
      {



         std::copy(pa + 1, pa + a.size(), pr + 1);

         result.sign(a.sign());
      }
      else if((result.size() == 1) && (*pr == 0))
      {
         result.sign(false);
      }
   }
   else if(result.size() == 1)
   {
      *pr = b - *pa;
      result.sign(!a.sign());
   }
   else
   {
      *pr = static_cast<limb_type>((borrow + *pa) - b);
      unsigned i = 1;
      while(!pa[i])
      {
         pr[i] = CppInt1::max_limb_value;
         ++i;
      }
      pr[i] = pa[i] - 1;
      if(&result != &a)
      {
         ++i;



         std::copy(pa + i, pa + a.size(), pr + i);

      }
      result.normalize();
      result.sign(a.sign());
   }
}




template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value >::type
   eval_add(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   eval_add(result, result, o);
}
template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2, unsigned MinBits3, unsigned MaxBits3, cpp_integer_type SignType3, cpp_int_check_type Checked3, class Allocator3>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3> >::value >::type
   eval_add(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a,
      const cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>& b) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   if(a.sign() != b.sign())
   {
      subtract_unsigned(result, a, b);
      return;
   }
   add_unsigned(result, a, b);
}
template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_add(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const limb_type& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   if(result.sign())
   {
      subtract_unsigned(result, result, o);
   }
   else
      add_unsigned(result, result, o);
}
template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value >::type
   eval_add(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a,
      const limb_type& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   if(a.sign())
   {
      subtract_unsigned(result, a, o);
   }
   else
      add_unsigned(result, a, o);
}
template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_add(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const signed_limb_type& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   if(o < 0)
      eval_subtract(result, static_cast<limb_type>(boost::multiprecision::detail::unsigned_abs(o)));
   else if(o > 0)
      eval_add(result, static_cast<limb_type>(o));
}
template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value >::type
   eval_add(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a,
      const signed_limb_type& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   if(o < 0)
      eval_subtract(result, a, static_cast<limb_type>(boost::multiprecision::detail::unsigned_abs(o)));
   else if(o > 0)
      eval_add(result, a, static_cast<limb_type>(o));
   else if(&result != &a)
      result = a;
}
template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_subtract(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const limb_type& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   if(result.sign())
   {
      add_unsigned(result, result, o);
   }
   else
      subtract_unsigned(result, result, o);
}
template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value >::type
   eval_subtract(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a,
      const limb_type& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   if(a.sign())
   {
      add_unsigned(result, a, o);
   }
   else
   {
      subtract_unsigned(result, a, o);
   }
}
template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_subtract(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const signed_limb_type& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   if(o)
   {
      if(o < 0)
         eval_add(result, static_cast<limb_type>(boost::multiprecision::detail::unsigned_abs(o)));
      else
         eval_subtract(result, static_cast<limb_type>(o));
   }
}
template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value >::type
   eval_subtract(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a,
      const signed_limb_type& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   if(o)
   {
      if(o < 0)
         eval_add(result, a, static_cast<limb_type>(boost::multiprecision::detail::unsigned_abs(o)));
      else
         eval_subtract(result, a, static_cast<limb_type>(o));
   }
   else if(&result != &a)
      result = a;
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_increment(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   static const limb_type one = 1;
   if(!result.sign() && (result.limbs()[0] < cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::max_limb_value))
      ++result.limbs()[0];
   else if (result.sign() && result.limbs()[0])
   {
      --result.limbs()[0];
      if (!result.limbs()[0])
         result.sign(false);
   }
   else
      eval_add(result, one);
}
template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_decrement(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   static const limb_type one = 1;
   if(!result.sign() && result.limbs()[0])
      --result.limbs()[0];
   else if (result.sign() && (result.limbs()[0] < cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::max_limb_value))
      ++result.limbs()[0];
   else
      eval_subtract(result, one);
}
template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value >::type
   eval_subtract(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   eval_subtract(result, result, o);
}
template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2, unsigned MinBits3, unsigned MaxBits3, cpp_integer_type SignType3, cpp_int_check_type Checked3, class Allocator3>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3> >::value >::type
   eval_subtract(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a,
      const cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>& b) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   if(a.sign() != b.sign())
   {
      add_unsigned(result, a, b);
      return;
   }
   subtract_unsigned(result, a, b);
}






template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<
         is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && (is_signed_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value || is_signed_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
         >::type
   eval_add(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   if(result.sign() != o.sign())
   {
      if(*o.limbs() > *result.limbs())
      {
         *result.limbs() = detail::checked_subtract(*o.limbs(), *result.limbs(), typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());
         result.negate();
      }
      else
         *result.limbs() = detail::checked_subtract(*result.limbs(), *o.limbs(), typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());
   }
   else
      *result.limbs() = detail::checked_add(*result.limbs(), *o.limbs(), typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());
   result.normalize();
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<
         is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_unsigned_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_unsigned_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         >::type
   eval_add(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   *result.limbs() = detail::checked_add(*result.limbs(), *o.limbs(), typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());
   result.normalize();
}


template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<
         is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && (is_signed_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value || is_signed_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
         >::type
   eval_subtract(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   if(result.sign() != o.sign())
   {
      *result.limbs() = detail::checked_add(*result.limbs(), *o.limbs(), typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());
   }
   else if(*result.limbs() < *o.limbs())
   {
      *result.limbs() = detail::checked_subtract(*o.limbs(), *result.limbs(), typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());
      result.negate();
   }
   else
      *result.limbs() = detail::checked_subtract(*result.limbs(), *o.limbs(), typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());
   result.normalize();
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<
         is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_unsigned_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_unsigned_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         >::type
   eval_subtract(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   *result.limbs() = detail::checked_subtract(*result.limbs(), *o.limbs(), typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());
   result.normalize();
}





}}}
namespace boost{ namespace multiprecision{ namespace backends{






   template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value >::type
   eval_multiply(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a,
      const limb_type& val) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   if(!val)
   {
      result = static_cast<limb_type>(0);
      return;
   }
   if((void*)&a != (void*)&result)
      result.resize(a.size(), a.size());
   double_limb_type carry = 0;
   typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_pointer p = result.limbs();
   typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_pointer pe = result.limbs() + result.size();
   typename cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>::const_limb_pointer pa = a.limbs();
   while(p != pe)
   {
      carry += static_cast<double_limb_type>(*pa) * static_cast<double_limb_type>(val);



      *p = static_cast<limb_type>(carry);

      carry >>= cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_bits;
      ++p, ++pa;
   }
   if(carry)
   {
      unsigned i = result.size();
      result.resize(i + 1, i + 1);
      if(result.size() > i)
         result.limbs()[i] = static_cast<limb_type>(carry);
   }
   result.sign(a.sign());
   if(!cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::variable)
      result.normalize();
}






template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline void resize_for_carry(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& , unsigned ){}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, class Allocator1>
inline void resize_for_carry(cpp_int_backend<MinBits1, MaxBits1, SignType1, checked, Allocator1>& result, unsigned required)
{
   if(result.size() < required)
      result.resize(required, required);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2, unsigned MinBits3, unsigned MaxBits3, cpp_integer_type SignType3, cpp_int_check_type Checked3, class Allocator3>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3> >::value >::type
   eval_multiply(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a,
      const cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>& b) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{





   unsigned as = a.size();
   unsigned bs = b.size();
   typename cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>::const_limb_pointer pa = a.limbs();
   typename cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>::const_limb_pointer pb = b.limbs();
   if(as == 1)
   {
      bool s = b.sign() != a.sign();
      if(bs == 1)
      {
         result = static_cast<double_limb_type>(*pa) * static_cast<double_limb_type>(*pb);
      }
      else
      {
         limb_type l = *pa;
         eval_multiply(result, b, l);
      }
      result.sign(s);
      return;
   }
   if(bs == 1)
   {
      bool s = b.sign() != a.sign();
      limb_type l = *pb;
      eval_multiply(result, a, l);
      result.sign(s);
      return;
   }

   if((void*)&result == (void*)&a)
   {
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> t(a);
      eval_multiply(result, t, b);
      return;
   }
   if((void*)&result == (void*)&b)
   {
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> t(b);
      eval_multiply(result, a, t);
      return;
   }

   result.resize(as + bs, as + bs - 1);
   typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_pointer pr = result.limbs();

   static const double_limb_type limb_max = ~static_cast<limb_type>(0u);
   static const double_limb_type double_limb_max = ~static_cast<double_limb_type>(0u);
   static_assert(double_limb_max - 2 * limb_max >= limb_max * limb_max, "double_limb_max - 2 * limb_max >= limb_max * limb_max");

   double_limb_type carry = 0;
   std::memset(pr, 0, result.size() * sizeof(limb_type));
   for(unsigned i = 0; i < as; ++i)
   {
      unsigned inner_limit = cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::variable ? bs : (std::min)(result.size() - i, bs);
      unsigned j;
      for(j = 0; j < inner_limit; ++j)
      {
         (__builtin_expect(!(i+j < result.size()), 0) ? __assert_rtn(__func__, "./boost/multiprecision/cpp_int/multiply.hpp", 142, "i+j < result.size()") : (void)0);

         (__builtin_expect(!(!std::numeric_limits<double_limb_type>::is_specialized || ((std::numeric_limits<double_limb_type>::max)() - carry > static_cast<double_limb_type>(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::max_limb_value) * static_cast<double_limb_type>(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::max_limb_value))), 0) ? __assert_rtn(__func__, "./boost/multiprecision/cpp_int/multiply.hpp", 147, "!std::numeric_limits<double_limb_type>::is_specialized || ((std::numeric_limits<double_limb_type>::max)() - carry > static_cast<double_limb_type>(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::max_limb_value) * static_cast<double_limb_type>(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::max_limb_value))") : (void)0);




         carry += static_cast<double_limb_type>(pa[i]) * static_cast<double_limb_type>(pb[j]);
         (__builtin_expect(!(!std::numeric_limits<double_limb_type>::is_specialized || ((std::numeric_limits<double_limb_type>::max)() - carry >= pr[i+j])), 0) ? __assert_rtn(__func__, "./boost/multiprecision/cpp_int/multiply.hpp", 150, "!std::numeric_limits<double_limb_type>::is_specialized || ((std::numeric_limits<double_limb_type>::max)() - carry >= pr[i+j])") : (void)0);
         carry += pr[i + j];



         pr[i + j] = static_cast<limb_type>(carry);

         carry >>= cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_bits;
         (__builtin_expect(!(carry <= (cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::max_limb_value)), 0) ? __assert_rtn(__func__, "./boost/multiprecision/cpp_int/multiply.hpp", 158, "carry <= (cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::max_limb_value)") : (void)0);
      }
      if(carry)
      {
         resize_for_carry(result, i + j + 1);
         if(i + j < result.size())



            pr[i + j] = static_cast<limb_type>(carry);

      }
      carry = 0;
   }
   result.normalize();



   result.sign(a.sign() != b.sign());
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value >::type
   eval_multiply(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
    eval_multiply(result, result, a);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_multiply(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const limb_type& val) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   eval_multiply(result, result, val);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value >::type
   eval_multiply(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a,
      const double_limb_type& val) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   if(val <= (std::numeric_limits<limb_type>::max)())
   {
      eval_multiply(result, a, static_cast<limb_type>(val));
   }
   else
   {

      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> t(val);




      eval_multiply(result, a, t);
   }
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_multiply(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const double_limb_type& val) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   eval_multiply(result, result, val);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value >::type
   eval_multiply(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a,
      const signed_limb_type& val) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   if(val > 0)
      eval_multiply(result, a, static_cast<limb_type>(val));
   else
   {
      eval_multiply(result, a, static_cast<limb_type>(boost::multiprecision::detail::unsigned_abs(val)));
      result.negate();
   }
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_multiply(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const signed_limb_type& val) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   eval_multiply(result, result, val);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value >::type
   eval_multiply(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a,
      const signed_double_limb_type& val) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   if(val > 0)
   {
      if(val <= (std::numeric_limits<limb_type>::max)())
      {
         eval_multiply(result, a, static_cast<limb_type>(val));
         return;
      }
   }
   else if(val >= -static_cast<signed_double_limb_type>((std::numeric_limits<limb_type>::max)()))
   {
      eval_multiply(result, a, static_cast<limb_type>(boost::multiprecision::detail::unsigned_abs(val)));
      result.negate();
      return;
   }

   cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> t(val);




   eval_multiply(result, a, t);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_multiply(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const signed_double_limb_type& val) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   eval_multiply(result, result, val);
}




template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<
         is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && (is_signed_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
            || is_signed_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
         >::type
   eval_multiply(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   *result.limbs() = detail::checked_multiply(*result.limbs(), *o.limbs(), typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());
   result.sign(result.sign() != o.sign());
   result.normalize();
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<
         is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_unsigned_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         >::type
   eval_multiply(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   *result.limbs() = detail::checked_multiply(*result.limbs(), *o.limbs(), typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());
   result.normalize();
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<
         is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && (is_signed_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
            || is_signed_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
         >::type
   eval_multiply(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a,
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& b) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   *result.limbs() = detail::checked_multiply(*a.limbs(), *b.limbs(), typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());
   result.sign(a.sign() != b.sign());
   result.normalize();
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<
         is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_unsigned_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         >::type
   eval_multiply(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a,
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& b) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   *result.limbs() = detail::checked_multiply(*a.limbs(), *b.limbs(), typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());
   result.normalize();
}




template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<
            !is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         >::type
   eval_multiply(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      signed_double_limb_type a, signed_double_limb_type b)
{
   static const signed_double_limb_type mask = ~static_cast<limb_type>(0);
   static const unsigned limb_bits = sizeof(limb_type) * 8;
   bool s = false;
   double_limb_type w, x, y, z;
   if(a < 0)
   {
      a = -a;
      s = true;
   }
   if(b < 0)
   {
      b = -b;
      s = !s;
   }
   w = a & mask;
   x = a >> limb_bits;
   y = b & mask;
   z = b >> limb_bits;

   result.resize(4, 4);
   limb_type* pr = result.limbs();

   double_limb_type carry = w * y;
   pr[0] = static_cast<limb_type>(carry);
   carry >>= limb_bits;
   carry += w * z + x * y;
   pr[1] = static_cast<limb_type>(carry);
   carry >>= limb_bits;
   carry += x * z;
   pr[2] = static_cast<limb_type>(carry);
   pr[3] = static_cast<limb_type>(carry >> limb_bits);

   result.sign(s);
   result.normalize();
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<
            !is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         >::type
   eval_multiply(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      double_limb_type a, double_limb_type b)
{
   static const signed_double_limb_type mask = ~static_cast<limb_type>(0);
   static const unsigned limb_bits = sizeof(limb_type) * 8;

   double_limb_type w, x, y, z;
   w = a & mask;
   x = a >> limb_bits;
   y = b & mask;
   z = b >> limb_bits;

   result.resize(4, 4);
   limb_type* pr = result.limbs();

   double_limb_type carry = w * y;
   pr[0] = static_cast<limb_type>(carry);
   carry >>= limb_bits;
   carry += w * z;
   pr[1] = static_cast<limb_type>(carry);
   carry >>= limb_bits;
   pr[2] = static_cast<limb_type>(carry);
   carry = x * y + pr[1];
   pr[1] = static_cast<limb_type>(carry);
   carry >>= limb_bits;
   carry += pr[2] + x * z;
   pr[2] = static_cast<limb_type>(carry);
   pr[3] = static_cast<limb_type>(carry >> limb_bits);

   result.sign(false);
   result.normalize();
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1,
          unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<
            !is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
            && is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value
            && is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value
         >::type
   eval_multiply(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> const& a,
      cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> const& b)
{
   typedef typename boost::multiprecision::detail::canonical<typename cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>::local_limb_type, cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::type canonical_type;
   eval_multiply(result, static_cast<canonical_type>(*a.limbs()), static_cast<canonical_type>(*b.limbs()));
   result.sign(a.sign() != b.sign());
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, class SI>
inline typename enable_if_c<is_signed<SI>::value && (sizeof(SI) <= sizeof(signed_double_limb_type) / 2)>::type
   eval_multiply(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      SI a, SI b)
{
   result = static_cast<signed_double_limb_type>(a) * static_cast<signed_double_limb_type>(b);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, class UI>
inline typename enable_if_c<is_unsigned<UI>::value && (sizeof(UI) <= sizeof(signed_double_limb_type) / 2)>::type
   eval_multiply(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      UI a, UI b)
{
   result = static_cast<double_limb_type>(a) * static_cast<double_limb_type>(b);
}





}}}
namespace boost{ namespace multiprecision{ namespace backends{

template <class CppInt1, class CppInt2, class CppInt3>
void divide_unsigned_helper(
   CppInt1* result,
   const CppInt2& x,
   const CppInt3& y,
   CppInt1& r)
{
   if(((void*)result == (void*)&x) || ((void*)&r == (void*)&x))
   {
      CppInt2 t(x);
      divide_unsigned_helper(result, t, y, r);
      return;
   }
   if(((void*)result == (void*)&y) || ((void*)&r == (void*)&y))
   {
      CppInt3 t(y);
      divide_unsigned_helper(result, x, t, r);
      return;
   }
   using default_ops::eval_subtract;

   if(result == &r)
   {
      CppInt1 rem;
      divide_unsigned_helper(result, x, y, rem);
      r = rem;
      return;
   }




   limb_type y_order = y.size() - 1;

   if(y_order == 0)
   {





      divide_unsigned_helper(result, x, y.limbs()[y_order], r);
      return;
   }

   typename CppInt2::const_limb_pointer px = x.limbs();
   typename CppInt3::const_limb_pointer py = y.limbs();

   limb_type r_order = x.size() - 1;
   if((r_order == 0) && (*px == 0))
   {

      r = x;
      if(result)
         *result = x;
      return;
   }

   r = x;
   r.sign(false);
   if(result)
      *result = static_cast<limb_type>(0u);





   if(r_order <= y_order)
   {
      if((r_order < y_order) || (r.compare_unsigned(y) < 0))
      {
         return;
      }
   }

   CppInt1 t;
   bool r_neg = false;




   if(r_order == 0)
   {
      if(result)
      {
         *result = px[0] / py[0];
      }
      r = px[0] % py[0];
      return;
   }
   else if(r_order == 1)
   {
      double_limb_type a, b;
      a = (static_cast<double_limb_type>(px[1]) << CppInt1::limb_bits) | px[0];
      b = y_order ?
         (static_cast<double_limb_type>(py[1]) << CppInt1::limb_bits) | py[0]
         : py[0];
      if(result)
      {
         *result = a / b;
      }
      r = a % b;
      return;
   }



   if(result)
      result->resize(1 + r_order - y_order, 1 + r_order - y_order);
   typename CppInt1::const_limb_pointer prem = r.limbs();

   typename CppInt1::limb_pointer pr
      = typename CppInt1::limb_pointer();
   if(result)
   {
      pr = result->limbs();
      for(unsigned i = 1; i < 1 + r_order - y_order; ++i)
         pr[i] = 0;
   }
   bool first_pass = true;

   do
   {



      limb_type guess;
      if((prem[r_order] <= py[y_order]) && (r_order > 0))
      {
         double_limb_type a, b, v;
         a = (static_cast<double_limb_type>(prem[r_order]) << CppInt1::limb_bits) | prem[r_order - 1];
         b = py[y_order];
         v = a / b;
         if(v > CppInt1::max_limb_value)
            guess = 1;
         else
         {
            guess = static_cast<limb_type>(v);
            --r_order;
         }
      }
      else if(r_order == 0)
      {
         guess = prem[0] / py[y_order];
      }
      else
      {
         double_limb_type a, b, v;
         a = (static_cast<double_limb_type>(prem[r_order]) << CppInt1::limb_bits) | prem[r_order - 1];
         b = (y_order > 0) ? (static_cast<double_limb_type>(py[y_order]) << CppInt1::limb_bits) | py[y_order - 1] : (static_cast<double_limb_type>(py[y_order]) << CppInt1::limb_bits);
         v = a / b;
         guess = static_cast<limb_type>(v);
      }
      (__builtin_expect(!(guess), 0) ? __assert_rtn(__func__, "./boost/multiprecision/cpp_int/divide.hpp", 186, "guess") : (void)0);



      limb_type shift = r_order - y_order;
      if(result)
      {
         if(r_neg)
         {
            if(pr[shift] > guess)
               pr[shift] -= guess;
            else
            {
               t.resize(shift + 1, shift + 1);
               t.limbs()[shift] = guess;
               for(unsigned i = 0; i < shift; ++i)
                  t.limbs()[i] = 0;
               eval_subtract(*result, t);
            }
         }
         else if(CppInt1::max_limb_value - pr[shift] > guess)
            pr[shift] += guess;
         else
         {
            t.resize(shift + 1, shift + 1);
            t.limbs()[shift] = guess;
            for(unsigned i = 0; i < shift; ++i)
               t.limbs()[i] = 0;
            eval_add(*result, t);
         }
      }




      double_limb_type carry = 0;
      t.resize(y.size() + shift + 1, y.size() + shift);
      bool truncated_t = (t.size() != y.size() + shift + 1);
      typename CppInt1::limb_pointer pt = t.limbs();
      for(unsigned i = 0; i < shift; ++i)
         pt[i] = 0;
      for(unsigned i = 0; i < y.size(); ++i)
      {
         carry += static_cast<double_limb_type>(py[i]) * static_cast<double_limb_type>(guess);



         pt[i + shift] = static_cast<limb_type>(carry);

         carry >>= CppInt1::limb_bits;
      }
      if(carry && !truncated_t)
      {



         pt[t.size() - 1] = static_cast<limb_type>(carry);

      }
      else if(!truncated_t)
      {
         t.resize(t.size() - 1, t.size() - 1);
      }




      if(truncated_t && carry)
      {





         for(unsigned i = 0; i <= r_order; ++i)
            r.limbs()[i] = ~prem[i];
         r.normalize();
         eval_increment(r);
         eval_add(r, t);
         r_neg = !r_neg;
      }
      else if(r.compare(t) > 0)
      {
         eval_subtract(r, t);
      }
      else
      {
         r.swap(t);
         eval_subtract(r, t);
         prem = r.limbs();
         r_neg = !r_neg;
      }




      if(result && first_pass)
      {
         first_pass = false;
         while(pr[result->size() - 1] == 0)
            result->resize(result->size() - 1, result->size() - 1);
      }



      r_order = r.size() - 1;
      if(r_order < y_order)
         break;
   }


   while((r_order > y_order) || (r.compare_unsigned(y) >= 0));




   if(r_neg && eval_get_sign(r))
   {

      if(result)
         eval_decrement(*result);
      if(y.sign())
      {
         r.negate();
         eval_subtract(r, y);
      }
      else
         eval_subtract(r, y, r);
   }

   (__builtin_expect(!(r.compare_unsigned(y) < 0), 0) ? __assert_rtn(__func__, "./boost/multiprecision/cpp_int/divide.hpp", 316, "r.compare_unsigned(y) < 0") : (void)0);
}

template <class CppInt1, class CppInt2>
void divide_unsigned_helper(
   CppInt1* result,
   const CppInt2& x,
   limb_type y,
   CppInt1& r)
{
   if(((void*)result == (void*)&x) || ((void*)&r == (void*)&x))
   {
      CppInt2 t(x);
      divide_unsigned_helper(result, t, y, r);
      return;
   }

   if(result == &r)
   {
      CppInt1 rem;
      divide_unsigned_helper(result, x, y, rem);
      r = rem;
      return;
   }



   using default_ops::eval_subtract;

   if(y == 0)
   {
      ::boost::exception_detail::throw_exception_(std::overflow_error("Integer Division by zero."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/divide.hpp",347);
   }



   limb_type r_order = x.size() - 1;




   r = x;
   r.sign(false);
   typename CppInt1::limb_pointer pr = r.limbs();





   if((r_order == 0) && (*pr < y))
   {
      if(result)
         *result = static_cast<limb_type>(0u);
      return;
   }




   if(r_order == 0)
   {
      if(result)
      {
         *result = *pr / y;
         result->sign(x.sign());
      }
      *pr %= y;
      r.sign(x.sign());
      return;
   }
   else if(r_order == 1)
   {
      double_limb_type a;
      a = (static_cast<double_limb_type>(pr[r_order]) << CppInt1::limb_bits) | pr[0];
      if(result)
      {
         *result = a / y;
         result->sign(x.sign());
      }
      r = a % y;
      r.sign(x.sign());
      return;
   }


   typename CppInt1::limb_pointer pres = typename CppInt1::limb_pointer();
   if(result)
   {
      result->resize(r_order + 1, r_order + 1);
      pres = result->limbs();
      if(result->size() > r_order)
         pres[r_order] = 0;
   }

   do
   {



      if((pr[r_order] < y) && r_order)
      {
         double_limb_type a, b;
         a = (static_cast<double_limb_type>(pr[r_order]) << CppInt1::limb_bits) | pr[r_order - 1];
         b = a % y;
         r.resize(r.size() - 1, r.size() - 1);
         --r_order;
         pr[r_order] = static_cast<limb_type>(b);
         if(result)
            pres[r_order] = static_cast<limb_type>(a / y);
         if(r_order && pr[r_order] == 0)
         {
            --r_order;
            r.resize(r.size() - 1, r.size() - 1);
            if(result)
               pres[r_order] = static_cast<limb_type>(0u);
         }
      }
      else
      {
         if(result)
            pres[r_order] = pr[r_order] / y;
         pr[r_order] %= y;
         if(r_order && pr[r_order] == 0)
         {
            --r_order;
            r.resize(r.size() - 1, r.size() - 1);
            if(result)
               pres[r_order] = static_cast<limb_type>(0u);
         }
      }
   }


   while(r_order || (pr[r_order] >= y));

   if(result)
   {
      result->normalize();
      result->sign(x.sign());
   }
   r.normalize();
   r.sign(x.sign());

   (__builtin_expect(!(r.compare(y) < 0), 0) ? __assert_rtn(__func__, "./boost/multiprecision/cpp_int/divide.hpp", 459, "r.compare(y) < 0") : (void)0);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2, unsigned MinBits3, unsigned MaxBits3, cpp_integer_type SignType3, cpp_int_check_type Checked3, class Allocator3>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3> >::value >::type
   eval_divide(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a,
      const cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>& b)
{
   cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> r;
   bool s = a.sign() != b.sign();
   divide_unsigned_helper(&result, a, b, r);
   result.sign(s);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value >::type
   eval_divide(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a,
      limb_type& b)
{
   cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> r;
   bool s = a.sign();
   divide_unsigned_helper(&result, a, b, r);
   result.sign(s);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value >::type
   eval_divide(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a,
      signed_limb_type& b)
{
   cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> r;
   bool s = a.sign() != (b < 0);
   divide_unsigned_helper(&result, a, static_cast<limb_type>(boost::multiprecision::detail::unsigned_abs(b)), r);
   result.sign(s);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value >::type
   eval_divide(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& b)
{

   cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> a(result);
   eval_divide(result, a, b);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_divide(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      limb_type b)
{

   cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> a(result);
   eval_divide(result, a, b);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_divide(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      signed_limb_type b)
{

   cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> a(result);
   eval_divide(result, a, b);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2, unsigned MinBits3, unsigned MaxBits3, cpp_integer_type SignType3, cpp_int_check_type Checked3, class Allocator3>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3> >::value >::type
   eval_modulus(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a,
      const cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>& b)
{
   bool s = a.sign();
   divide_unsigned_helper(static_cast<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>* >(0), a, b, result);
   result.sign(s);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value >::type
   eval_modulus(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, limb_type b)
{
   bool s = a.sign();
   divide_unsigned_helper(static_cast<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>* >(0), a, b, result);
   result.sign(s);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value >::type
   eval_modulus(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a,
      signed_limb_type b)
{
   bool s = a.sign();
   divide_unsigned_helper(static_cast<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>* >(0), a, static_cast<limb_type>(boost::multiprecision::detail::unsigned_abs(b)), result);
   result.sign(s);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value >::type
   eval_modulus(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& b)
{

   cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> a(result);
   eval_modulus(result, a, b);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_modulus(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      limb_type b)
{

   cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> a(result);
   eval_modulus(result, a, b);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_modulus(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      signed_limb_type b)
{

   cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> a(result);
   eval_modulus(result, a, b);
}




template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<
         is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && (is_signed_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
            || is_signed_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
         >::type
   eval_divide(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o)
{
   if(!*o.limbs())
      ::boost::exception_detail::throw_exception_(std::overflow_error("Division by zero."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/divide.hpp",617);
   *result.limbs() /= *o.limbs();
   result.sign(result.sign() != o.sign());
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<
         is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_unsigned_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_unsigned_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
      >::type
   eval_divide(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o)
{
   if(!*o.limbs())
      ::boost::exception_detail::throw_exception_(std::overflow_error("Division by zero."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/divide.hpp",634);
   *result.limbs() /= *o.limbs();
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<
         is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
      >::type
   eval_modulus(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o)
{
   if(!*o.limbs())
      ::boost::exception_detail::throw_exception_(std::overflow_error("Division by zero."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/divide.hpp",648);
   *result.limbs() %= *o.limbs();
   result.sign(result.sign());
}

}}}
namespace boost{ namespace multiprecision{ namespace backends{

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
void is_valid_bitwise_op(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::int_<checked>&)
{
   if(result.sign() || o.sign())
      ::boost::exception_detail::throw_exception_(std::range_error("Bitwise operations on negative values results in undefined behavior."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/bitwise.hpp",24);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
void is_valid_bitwise_op(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>&,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& , const mpl::int_<unchecked>&){}

template <unsigned MinBits1, unsigned MaxBits1, cpp_int_check_type Checked1, class Allocator1>
void is_valid_bitwise_op(
      const cpp_int_backend<MinBits1, MaxBits1, signed_magnitude, Checked1, Allocator1>& result, const mpl::int_<checked>&)
{
   if(result.sign())
      ::boost::exception_detail::throw_exception_(std::range_error("Bitwise operations on negative values results in undefined behavior."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/bitwise.hpp",37);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_int_check_type Checked1, class Allocator1>
void is_valid_bitwise_op(
   const cpp_int_backend<MinBits1, MaxBits1, unsigned_magnitude, Checked1, Allocator1>&, const mpl::int_<checked>&){}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
void is_valid_bitwise_op(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>&, const mpl::int_<unchecked>&){}

template <class CppInt1, class CppInt2, class Op>
void bitwise_op(
   CppInt1& result,
   const CppInt2& o,
   Op op, const mpl::true_&) noexcept(((is_non_throwing_cpp_int<CppInt1>::value)))
{
   is_valid_bitwise_op(result, o, typename CppInt1::checked_type());



   unsigned rs = result.size();
   unsigned os = o.size();
   unsigned m, x;
   minmax(rs, os, m, x);
   result.resize(x, x);
   typename CppInt1::limb_pointer pr = result.limbs();
   typename CppInt2::const_limb_pointer po = o.limbs();
   for(unsigned i = rs; i < x; ++i)
      pr[i] = 0;

   limb_type next_limb = 0;

   if(!result.sign())
   {
      if(!o.sign())
      {
         for(unsigned i = 0; i < os; ++i)
            pr[i] = op(pr[i], po[i]);
         for(unsigned i = os; i < x; ++i)
            pr[i] = op(pr[i], limb_type(0));
      }
      else
      {

         double_limb_type carry = 1;
         for(unsigned i = 0; i < os; ++i)
         {
            carry += static_cast<double_limb_type>(~po[i]);
            pr[i] = op(pr[i], static_cast<limb_type>(carry));
            carry >>= CppInt1::limb_bits;
         }
         for(unsigned i = os; i < x; ++i)
         {
            carry += static_cast<double_limb_type>(~limb_type(0));
            pr[i] = op(pr[i], static_cast<limb_type>(carry));
            carry >>= CppInt1::limb_bits;
         }

         carry += static_cast<double_limb_type>(~limb_type(0));
         next_limb = op(limb_type(0), static_cast<limb_type>(carry));
      }
   }
   else
   {
      if(!o.sign())
      {

         double_limb_type carry = 1;
         for(unsigned i = 0; i < os; ++i)
         {
            carry += static_cast<double_limb_type>(~pr[i]);
            pr[i] = op(static_cast<limb_type>(carry), po[i]);
            carry >>= CppInt1::limb_bits;
         }
         for(unsigned i = os; i < x; ++i)
         {
            carry += static_cast<double_limb_type>(~pr[i]);
            pr[i] = op(static_cast<limb_type>(carry), limb_type(0));
            carry >>= CppInt1::limb_bits;
         }

         carry += static_cast<double_limb_type>(~limb_type(0));
         next_limb = op(static_cast<limb_type>(carry), limb_type(0));
      }
      else
      {

         double_limb_type r_carry = 1;
         double_limb_type o_carry = 1;
         for(unsigned i = 0; i < os; ++i)
         {
            r_carry += static_cast<double_limb_type>(~pr[i]);
            o_carry += static_cast<double_limb_type>(~po[i]);
            pr[i] = op(static_cast<limb_type>(r_carry), static_cast<limb_type>(o_carry));
            r_carry >>= CppInt1::limb_bits;
            o_carry >>= CppInt1::limb_bits;
         }
         for(unsigned i = os; i < x; ++i)
         {
            r_carry += static_cast<double_limb_type>(~pr[i]);
            o_carry += static_cast<double_limb_type>(~limb_type(0));
            pr[i] = op(static_cast<limb_type>(r_carry), static_cast<limb_type>(o_carry));
            r_carry >>= CppInt1::limb_bits;
            o_carry >>= CppInt1::limb_bits;
         }

         r_carry += static_cast<double_limb_type>(~limb_type(0));
         o_carry += static_cast<double_limb_type>(~limb_type(0));
         next_limb = op(static_cast<limb_type>(r_carry), static_cast<limb_type>(o_carry));
      }
   }



   if(static_cast<signed_limb_type>(next_limb) < 0)
   {
      double_limb_type carry = 1;
      for(unsigned i = 0; i < x; ++i)
      {
         carry += static_cast<double_limb_type>(~pr[i]);
         pr[i] = static_cast<limb_type>(carry);
         carry >>= CppInt1::limb_bits;
      }
      if(carry)
      {
         result.resize(x + 1, x);
         if(result.size() > x)
            result.limbs()[x] = static_cast<limb_type>(carry);
      }
      result.sign(true);
   }
   else
      result.sign(false);

   result.normalize();
}

template <class CppInt1, class CppInt2, class Op>
void bitwise_op(
   CppInt1& result,
   const CppInt2& o,
   Op op, const mpl::false_&) noexcept(((is_non_throwing_cpp_int<CppInt1>::value)))
{





   unsigned rs = result.size();
   unsigned os = o.size();
   unsigned m, x;
   minmax(rs, os, m, x);
   result.resize(x, x);
   typename CppInt1::limb_pointer pr = result.limbs();
   typename CppInt2::const_limb_pointer po = o.limbs();
   for(unsigned i = rs; i < x; ++i)
      pr[i] = 0;

   for(unsigned i = 0; i < os; ++i)
      pr[i] = op(pr[i], po[i]);
   for(unsigned i = os; i < x; ++i)
      pr[i] = op(pr[i], limb_type(0));

   result.normalize();
}

struct bit_and{ limb_type operator()(limb_type a, limb_type b)const noexcept { return a & b; } };
struct bit_or { limb_type operator()(limb_type a, limb_type b)const noexcept { return a | b; } };
struct bit_xor{ limb_type operator()(limb_type a, limb_type b)const noexcept { return a ^ b; } };

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value >::type
   eval_bitwise_and(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   bitwise_op(result, o, bit_and(),
      mpl::bool_<std::numeric_limits<number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> > >::is_signed || std::numeric_limits<number<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> > >::is_signed>());
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value >::type
   eval_bitwise_or(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   bitwise_op(result, o, bit_or(),
      mpl::bool_<std::numeric_limits<number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> > >::is_signed || std::numeric_limits<number<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> > >::is_signed>());
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value >::type
   eval_bitwise_xor(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   bitwise_op(result, o, bit_xor(),
      mpl::bool_<std::numeric_limits<number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> > >::is_signed || std::numeric_limits<number<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> > >::is_signed>());
}



template <unsigned MinBits1, unsigned MaxBits1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, unsigned_magnitude, Checked1, Allocator1> >::value>::type
   eval_bitwise_and(
      cpp_int_backend<MinBits1, MaxBits1, unsigned_magnitude, Checked1, Allocator1>& result,
      limb_type l) noexcept
{
   result.limbs()[0] &= l;
   result.resize(1, 1);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, unsigned_magnitude, Checked1, Allocator1> >::value>::type
   eval_bitwise_or(
      cpp_int_backend<MinBits1, MaxBits1, unsigned_magnitude, Checked1, Allocator1>& result,
      limb_type l) noexcept
{
   result.limbs()[0] |= l;
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, unsigned_magnitude, Checked1, Allocator1> >::value>::type
   eval_bitwise_xor(
      cpp_int_backend<MinBits1, MaxBits1, unsigned_magnitude, Checked1, Allocator1>& result,
      limb_type l) noexcept
{
   result.limbs()[0] ^= l;
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<is_signed_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value >::type
   eval_complement(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   static_assert(((Checked1 != checked) || (Checked2 != checked)), "Attempt to take the complement of a signed type results in undefined behavior.");

   result = o;
   eval_increment(result);
   result.negate();
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<is_unsigned_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value >::type
   eval_complement(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   unsigned os = o.size();
   result.resize((2147483647 *2U +1U), os);
   for(unsigned i = 0; i < os; ++i)
      result.limbs()[i] = ~o.limbs()[i];
   for(unsigned i = os; i < result.size(); ++i)
      result.limbs()[i] = ~static_cast<limb_type>(0);
   result.normalize();
}

template <class Int>
inline void left_shift_byte(Int& result, double_limb_type s)
{
   limb_type offset = static_cast<limb_type>(s / Int::limb_bits);
   limb_type shift = static_cast<limb_type>(s % Int::limb_bits);
   unsigned ors = result.size();
   if((ors == 1) && (!*result.limbs()))
      return;
   unsigned rs = ors;
   if(shift && (result.limbs()[ors - 1] >> (Int::limb_bits - shift)))
      ++rs;
   rs += offset;
   result.resize(rs, rs);
   rs = result.size();

   typename Int::limb_pointer pr = result.limbs();

   if(rs != ors)
      pr[rs - 1] = 0u;
   std::size_t bytes = static_cast<std::size_t>(s / 8);
   std::size_t len = (std::min)(ors * sizeof(limb_type), rs * sizeof(limb_type) - bytes);
   if(bytes >= rs * sizeof(limb_type))
      result = static_cast<limb_type>(0u);
   else
   {
      unsigned char* pc = reinterpret_cast<unsigned char*>(pr);
      std::memmove(pc + bytes, pc, len);
      std::memset(pc, 0, bytes);
   }
}

template <class Int>
inline void left_shift_limb(Int& result, double_limb_type s)
{
   limb_type offset = static_cast<limb_type>(s / Int::limb_bits);
   limb_type shift = static_cast<limb_type>(s % Int::limb_bits);

   unsigned ors = result.size();
   if((ors == 1) && (!*result.limbs()))
      return;
   unsigned rs = ors;
   if(shift && (result.limbs()[ors - 1] >> (Int::limb_bits - shift)))
      ++rs;
   rs += offset;
   result.resize(rs, rs);

   typename Int::limb_pointer pr = result.limbs();

   if(offset > rs)
   {

      result = static_cast<limb_type>(0);
      return;
   }

   unsigned i = rs - result.size();
   for(; i < ors; ++i)
      pr[rs - 1 - i] = pr[ors - 1 - i];
   for(; i < rs; ++i)
      pr[rs - 1 - i] = 0;
}

template <class Int>
inline void left_shift_generic(Int& result, double_limb_type s)
{
   limb_type offset = static_cast<limb_type>(s / Int::limb_bits);
   limb_type shift = static_cast<limb_type>(s % Int::limb_bits);

   unsigned ors = result.size();
   if((ors == 1) && (!*result.limbs()))
      return;
   unsigned rs = ors;
   if(shift && (result.limbs()[ors - 1] >> (Int::limb_bits - shift)))
      ++rs;
   rs += offset;
   result.resize(rs, rs);
   bool truncated = result.size() != rs;

   typename Int::limb_pointer pr = result.limbs();

   if(offset > rs)
   {

      result = static_cast<limb_type>(0);
      return;
   }

   unsigned i = rs - result.size();

   (__builtin_expect(!(shift), 0) ? __assert_rtn(__func__, "./boost/multiprecision/cpp_int/bitwise.hpp", 398, "shift") : (void)0);
   if(!truncated)
   {
      if(rs > ors + offset)
      {
         pr[rs - 1 - i] = pr[ors - 1 - i] >> (Int::limb_bits - shift);
         --rs;
      }
      else
      {
         pr[rs - 1 - i] = pr[ors - 1 - i] << shift;
         if(ors > 1)
            pr[rs - 1 - i] |= pr[ors - 2 - i] >> (Int::limb_bits - shift);
         ++i;
      }
   }
   for(; rs - i >= 2 + offset; ++i)
   {
      pr[rs - 1 - i] = pr[rs - 1 - i - offset] << shift;
      pr[rs - 1 - i] |= pr[rs - 2 - i - offset] >> (Int::limb_bits - shift);
   }
   if(rs - i >= 1 + offset)
   {
      pr[rs - 1 - i] = pr[rs - 1 - i - offset] << shift;
      ++i;
   }
   for(; i < rs; ++i)
      pr[rs - 1 - i] = 0;
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_left_shift(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      double_limb_type s) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   is_valid_bitwise_op(result, typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());
   if(!s)
      return;
   static const limb_type byte_shift_mask = 8 - 1;
   if((s & byte_shift_mask) == 0)
   {
      left_shift_byte(result, s);
   }







   else
   {
      left_shift_generic(result, s);
   }



   result.normalize();
}

template <class Int>
inline void right_shift_byte(Int& result, double_limb_type s)
{
   limb_type offset = static_cast<limb_type>(s / Int::limb_bits);
   limb_type shift;
   (__builtin_expect(!((s % 8) == 0), 0) ? __assert_rtn(__func__, "./boost/multiprecision/cpp_int/bitwise.hpp", 477, "(s % 8) == 0") : (void)0);
   unsigned ors = result.size();
   unsigned rs = ors;
   if(offset >= rs)
   {
      result = limb_type(0);
      return;
   }
   rs -= offset;
   typename Int::limb_pointer pr = result.limbs();
   unsigned char* pc = reinterpret_cast<unsigned char*>(pr);
   shift = static_cast<limb_type>(s / 8);
   std::memmove(pc, pc + shift, ors * sizeof(pr[0]) - shift);
   shift = (sizeof(limb_type) - shift % sizeof(limb_type)) * 8;
   if(shift < Int::limb_bits)
   {
      pr[ors - offset - 1] &= (static_cast<limb_type>(1u) << shift) - 1;
      if(!pr[ors - offset - 1] && (rs > 1))
         --rs;
   }
   result.resize(rs, rs);
}

template <class Int>
inline void right_shift_limb(Int& result, double_limb_type s)
{
   limb_type offset = static_cast<limb_type>(s / Int::limb_bits);
   (__builtin_expect(!((s % Int::limb_bits) == 0), 0) ? __assert_rtn(__func__, "./boost/multiprecision/cpp_int/bitwise.hpp", 504, "(s % Int::limb_bits) == 0") : (void)0);
   unsigned ors = result.size();
   unsigned rs = ors;
   if(offset >= rs)
   {
      result = limb_type(0);
      return;
   }
   rs -= offset;
   typename Int::limb_pointer pr = result.limbs();
   unsigned i = 0;
   for(; i < rs; ++i)
      pr[i] = pr[i + offset];
   result.resize(rs, rs);
}

template <class Int>
inline void right_shift_generic(Int& result, double_limb_type s)
{
   limb_type offset = static_cast<limb_type>(s / Int::limb_bits);
   limb_type shift = static_cast<limb_type>(s % Int::limb_bits);
   unsigned ors = result.size();
   unsigned rs = ors;
   if(offset >= rs)
   {
      result = limb_type(0);
      return;
   }
   rs -= offset;
   typename Int::limb_pointer pr = result.limbs();
   if((pr[ors - 1] >> shift) == 0)
   {
      if(--rs == 0)
      {
         result = limb_type(0);
         return;
      }
   }
   unsigned i = 0;


   (__builtin_expect(!(shift), 0) ? __assert_rtn(__func__, "./boost/multiprecision/cpp_int/bitwise.hpp", 545, "shift") : (void)0);
   for(; i + offset + 1 < ors; ++i)
   {
      pr[i] = pr[i + offset] >> shift;
      pr[i] |= pr[i + offset + 1] << (Int::limb_bits - shift);
   }
   pr[i] = pr[i + offset] >> shift;
   result.resize(rs, rs);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, unsigned_magnitude, Checked1, Allocator1> >::value>::type
   eval_right_shift(
      cpp_int_backend<MinBits1, MaxBits1, unsigned_magnitude, Checked1, Allocator1>& result,
      double_limb_type s) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, unsigned_magnitude, Checked1, Allocator1> >::value)))
{
   is_valid_bitwise_op(result, typename cpp_int_backend<MinBits1, MaxBits1, unsigned_magnitude, Checked1, Allocator1>::checked_type());
   if(!s)
      return;
   static const limb_type byte_shift_mask = 8 - 1;
   if((s & byte_shift_mask) == 0)
      right_shift_byte(result, s);





   else
      right_shift_generic(result, s);
}
template <unsigned MinBits1, unsigned MaxBits1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, signed_magnitude, Checked1, Allocator1> >::value>::type
   eval_right_shift(
      cpp_int_backend<MinBits1, MaxBits1, signed_magnitude, Checked1, Allocator1>& result,
      double_limb_type s) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, signed_magnitude, Checked1, Allocator1> >::value)))
{
   is_valid_bitwise_op(result, typename cpp_int_backend<MinBits1, MaxBits1, signed_magnitude, Checked1, Allocator1>::checked_type());
   if(!s)
      return;

   bool is_neg = result.sign();
   if(is_neg)
      eval_increment(result);
   static const limb_type byte_shift_mask = 8 - 1;
   if((s & byte_shift_mask) == 0)
      right_shift_byte(result, s);





   else
      right_shift_generic(result, s);
   if(is_neg)
      eval_decrement(result);
}




template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, class T>
inline typename enable_if<is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> > >::type
   eval_left_shift(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, T s) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   is_valid_bitwise_op(result, typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());
   *result.limbs() = detail::checked_left_shift(*result.limbs(), s, typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());
   result.normalize();
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, class T>
inline typename enable_if<is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> > >::type
   eval_right_shift(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, T s) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{

   is_valid_bitwise_op(result, typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());
   *result.limbs() = (static_cast<unsigned>(s) >= sizeof(*result.limbs()) * 8) ? 0 : (result.sign() ? ((--*result.limbs()) >> s) + 1 : *result.limbs() >> s);
   if(result.sign() && (*result.limbs() == 0))
      result = static_cast<signed_limb_type>(-1);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<
         is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value
         && (is_signed_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value || is_signed_number<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value)
         >::type
   eval_complement(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   static_assert(((Checked1 != checked) || (Checked2 != checked)), "Attempt to take the complement of a signed type results in undefined behavior.");



   if(o.sign())
   {
      *result.limbs() = *o.limbs() - 1;
      result.sign(false);
   }
   else
   {
      *result.limbs() = 1 + *o.limbs();
      result.sign(true);
   }
   result.normalize();
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<
         is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value
         && is_unsigned_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_unsigned_number<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value
         >::type
   eval_complement(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   *result.limbs() = ~*o.limbs();
   result.normalize();
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<
         is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value
         && is_unsigned_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_unsigned_number<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value
         >::type
   eval_bitwise_and(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   *result.limbs() &= *o.limbs();
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<
         is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value
         && (is_signed_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value || is_signed_number<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value)
         >::type
   eval_bitwise_and(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   is_valid_bitwise_op(result, o, typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());

   using default_ops::eval_bit_test;
   using default_ops::eval_increment;

   if(result.sign() || o.sign())
   {
      static const unsigned m = static_unsigned_max<static_unsigned_max<MinBits1, MinBits2>::value, static_unsigned_max<MaxBits1, MaxBits2>::value>::value;
      cpp_int_backend<m + 1, m + 1, unsigned_magnitude, unchecked, void> t1(result);
      cpp_int_backend<m + 1, m + 1, unsigned_magnitude, unchecked, void> t2(o);
      eval_bitwise_and(t1, t2);
      bool s = eval_bit_test(t1, m + 1);
      if(s)
      {
         eval_complement(t1, t1);
         eval_increment(t1);
      }
      result = t1;
      result.sign(s);
   }
   else
   {
      *result.limbs() &= *o.limbs();
   }
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<
         is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value
         && is_unsigned_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_unsigned_number<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value
         >::type
   eval_bitwise_or(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   *result.limbs() |= *o.limbs();
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<
         is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value
         && (is_signed_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value || is_signed_number<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value)
         >::type
   eval_bitwise_or(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   is_valid_bitwise_op(result, o, typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());

   using default_ops::eval_bit_test;
   using default_ops::eval_increment;

   if(result.sign() || o.sign())
   {
      static const unsigned m = static_unsigned_max<static_unsigned_max<MinBits1, MinBits2>::value, static_unsigned_max<MaxBits1, MaxBits2>::value>::value;
      cpp_int_backend<m + 1, m + 1, unsigned_magnitude, unchecked, void> t1(result);
      cpp_int_backend<m + 1, m + 1, unsigned_magnitude, unchecked, void> t2(o);
      eval_bitwise_or(t1, t2);
      bool s = eval_bit_test(t1, m + 1);
      if(s)
      {
         eval_complement(t1, t1);
         eval_increment(t1);
      }
      result = t1;
      result.sign(s);
   }
   else
   {
      *result.limbs() |= *o.limbs();
      result.normalize();
   }
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<
         is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value
         && is_unsigned_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_unsigned_number<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value
         >::type
   eval_bitwise_xor(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   *result.limbs() ^= *o.limbs();
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, unsigned MinBits2, unsigned MaxBits2, cpp_integer_type SignType2, cpp_int_check_type Checked2, class Allocator2>
inline typename enable_if_c<
         is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
         && is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value
         && (is_signed_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value || is_signed_number<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value)
         >::type
   eval_bitwise_xor(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   is_valid_bitwise_op(result, o, typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());

   using default_ops::eval_bit_test;
   using default_ops::eval_increment;

   if(result.sign() || o.sign())
   {
      static const unsigned m = static_unsigned_max<static_unsigned_max<MinBits1, MinBits2>::value, static_unsigned_max<MaxBits1, MaxBits2>::value>::value;
      cpp_int_backend<m + 1, m + 1, unsigned_magnitude, unchecked, void> t1(result);
      cpp_int_backend<m + 1, m + 1, unsigned_magnitude, unchecked, void> t2(o);
      eval_bitwise_xor(t1, t2);
      bool s = eval_bit_test(t1, m + 1);
      if(s)
      {
         eval_complement(t1, t1);
         eval_increment(t1);
      }
      result = t1;
      result.sign(s);
   }
   else
   {
      *result.limbs() ^= *o.limbs();
   }
}

}}}





namespace boost{ namespace multiprecision{ namespace detail{

template <class Unsigned>
inline unsigned find_lsb(Unsigned mask, const mpl::int_<0>&)
{
   unsigned result = 0;
   while(!(mask & 1u))
   {
      mask >>= 1;
      ++result;
   }
   return result;
}

template <class Unsigned>
inline unsigned find_msb(Unsigned mask, const mpl::int_<0>&)
{
   unsigned index = 0;
   while(mask)
   {
      ++index;
      mask >>= 1;
   }
   return --index;
}
inline __attribute__ ((__always_inline__)) unsigned find_lsb(unsigned mask, mpl::int_<1> const&)
{
   return __builtin_ctz(mask);
}
inline __attribute__ ((__always_inline__)) unsigned find_lsb(unsigned long mask, mpl::int_<2> const&)
{
   return __builtin_ctzl(mask);
}
inline __attribute__ ((__always_inline__)) unsigned find_lsb(boost::ulong_long_type mask, mpl::int_<3> const&)
{
   return __builtin_ctzll(mask);
}
inline __attribute__ ((__always_inline__)) unsigned find_msb(unsigned mask, mpl::int_<1> const&)
{
   return sizeof(unsigned) * 8 - 1 - __builtin_clz(mask);
}
inline __attribute__ ((__always_inline__)) unsigned find_msb(unsigned long mask, mpl::int_<2> const&)
{
   return sizeof(unsigned long) * 8 - 1 - __builtin_clzl(mask);
}
inline __attribute__ ((__always_inline__)) unsigned find_msb(boost::ulong_long_type mask, mpl::int_<3> const&)
{
   return sizeof(boost::ulong_long_type) * 8 - 1 - __builtin_clzll(mask);
}


__extension__ typedef unsigned __int128 uint128_type;

inline __attribute__ ((__always_inline__)) unsigned find_msb(uint128_type mask, mpl::int_<0> const&)
{
   union { uint128_type v; boost::uint64_t sv[2]; } val;
   val.v = mask;

   if(val.sv[1])
      return find_msb(val.sv[1], mpl::int_<3>()) + 64;
   return find_msb(val.sv[0], mpl::int_<3>());





}
inline __attribute__ ((__always_inline__)) unsigned find_lsb(uint128_type mask, mpl::int_<0> const&)
{
   union { uint128_type v; boost::uint64_t sv[2]; } val;
   val.v = mask;

   if(val.sv[0] == 0)
      return find_lsb(val.sv[1], mpl::int_<3>()) + 64;
   return find_lsb(val.sv[0], mpl::int_<3>());





}


template <class Unsigned>
inline __attribute__ ((__always_inline__)) unsigned find_lsb(Unsigned mask)
{
   typedef typename make_unsigned<Unsigned>::type ui_type;
   typedef typename mpl::if_c<
      sizeof(Unsigned) <= sizeof(unsigned),
      mpl::int_<1>,
      typename mpl::if_c<
         sizeof(Unsigned) <= sizeof(unsigned long),
         mpl::int_<2>,
         typename mpl::if_c<
            sizeof(Unsigned) <= sizeof(boost::ulong_long_type),
            mpl::int_<3>,
            mpl::int_<0>
         >::type
      >::type
   >::type tag_type;
   return find_lsb(static_cast<ui_type>(mask), tag_type());
}
template <class Unsigned>
inline __attribute__ ((__always_inline__)) unsigned find_msb(Unsigned mask)
{
   typedef typename make_unsigned<Unsigned>::type ui_type;
   typedef typename mpl::if_c<
      sizeof(Unsigned) <= sizeof(unsigned),
      mpl::int_<1>,
      typename mpl::if_c<
         sizeof(Unsigned) <= sizeof(unsigned long),
         mpl::int_<2>,
         typename mpl::if_c<
            sizeof(Unsigned) <= sizeof(boost::ulong_long_type),
            mpl::int_<3>,
            mpl::int_<0>
         >::type
      >::type
   >::type tag_type;
   return find_msb(static_cast<ui_type>(mask), tag_type());
}
}}}

namespace boost{ namespace multiprecision{ namespace backends{

template <class R, class CppInt>
void check_in_range(const CppInt& val, const mpl::int_<checked>&)
{
   typedef typename boost::multiprecision::detail::canonical<R, CppInt>::type cast_type;
   if(val.sign())
   {
      if(boost::is_signed<R>::value == false)
         ::boost::exception_detail::throw_exception_(std::range_error("Attempt to assign a negative value to an unsigned type."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/misc.hpp",32);
      if(val.compare(static_cast<cast_type>((std::numeric_limits<R>::min)())) < 0)
         ::boost::exception_detail::throw_exception_(std::overflow_error("Could not convert to the target type - -value is out of range."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/misc.hpp",34);
   }
   else
   {
      if(val.compare(static_cast<cast_type>((std::numeric_limits<R>::max)())) > 0)
         ::boost::exception_detail::throw_exception_(std::overflow_error("Could not convert to the target type - -value is out of range."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/misc.hpp",39);
   }
}
template <class R, class CppInt>
inline void check_in_range(const CppInt& , const mpl::int_<unchecked>&) noexcept {}

inline void check_is_negative(const mpl::true_&) noexcept {}
inline void check_is_negative(const mpl::false_&)
{
   ::boost::exception_detail::throw_exception_(std::range_error("Attempt to assign a negative value to an unsigned type."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/misc.hpp",48);
}

template <class Integer>
inline Integer negate_integer(Integer i, const mpl::true_&) noexcept
{
   return -i;
}
template <class Integer>
inline Integer negate_integer(Integer i, const mpl::false_&) noexcept
{
   return ~(i-1);
}

template <class R, unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<is_integral<R>::value && !is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value, void>::type
   eval_convert_to(R* result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& backend)
{
   typedef mpl::int_<Checked1> checked_type;
   check_in_range<R>(backend, checked_type());

   if (std::numeric_limits<R>::digits < cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_bits)
   {
      if ((backend.sign() && boost::is_signed<R>::value) && (1 + static_cast<boost::multiprecision::limb_type>((std::numeric_limits<R>::max)()) <= backend.limbs()[0]))
      {
         *result = (std::numeric_limits<R>::min)();
         return;
      }
      else if (boost::is_signed<R>::value && !backend.sign() && static_cast<boost::multiprecision::limb_type>((std::numeric_limits<R>::max)()) <= backend.limbs()[0])
      {
         *result = (std::numeric_limits<R>::max)();
         return;
      }
      else
         *result = static_cast<R>(backend.limbs()[0]);
   }
   else
      *result = static_cast<R>(backend.limbs()[0]);
   unsigned shift = cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_bits;
   unsigned i = 1;
   if (std::numeric_limits<R>::digits > cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_bits)
   {
      while ((i < backend.size()) && (shift < static_cast<unsigned>(std::numeric_limits<R>::digits - cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_bits)))
      {
         *result += static_cast<R>(backend.limbs()[i]) << shift;
         shift += cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_bits;
         ++i;
      }



      if (i < backend.size())
      {
         static const limb_type mask = std::numeric_limits<R>::digits - shift == cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_bits ?
            ~static_cast<limb_type>(0) : (static_cast<limb_type>(1u) << (std::numeric_limits<R>::digits - shift)) - 1;
         *result += (static_cast<R>(backend.limbs()[i]) & mask) << shift;
         if ((static_cast<R>(backend.limbs()[i]) & static_cast<limb_type>(~mask)) || (i + 1 < backend.size()))
         {

            if (backend.sign())
            {
               check_is_negative(boost::is_signed<R>());
               *result = (std::numeric_limits<R>::min)();
            }
            else if(boost::is_signed<R>::value)
               *result = (std::numeric_limits<R>::max)();
            return;
         }
      }
   }
   else if (backend.size() > 1)
   {

      if (backend.sign())
      {
         check_is_negative(boost::is_signed<R>());
         *result = (std::numeric_limits<R>::min)();
      }
      else if(boost::is_signed<R>::value)
         *result = (std::numeric_limits<R>::max)();
      return;
   }
   if(backend.sign())
   {
      check_is_negative(boost::is_signed<R>());
      *result = negate_integer(*result, boost::is_signed<R>());
   }
}

template <class R, unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<is_floating_point<R>::value && !is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value, void>::type
   eval_convert_to(R* result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& backend) noexcept((is_arithmetic<R>::value))
{
   typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::const_limb_pointer p = backend.limbs();
   unsigned shift = cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_bits;
   *result = static_cast<R>(*p);
   for(unsigned i = 1; i < backend.size(); ++i)
   {
      *result += static_cast<R>(std::ldexp(static_cast<long double>(p[i]), shift));
      shift += cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_bits;
   }
   if(backend.sign())
      *result = -*result;
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value, bool>::type
   eval_is_zero(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val) noexcept
{
   return (val.size() == 1) && (val.limbs()[0] == 0);
}
template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value, int>::type
   eval_get_sign(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val) noexcept
{
   return eval_is_zero(val) ? 0 : val.sign() ? -1 : 1;
}
template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_abs(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   result = val;
   result.sign(false);
}




template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value, unsigned>::type
   eval_lsb(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a)
{
   using default_ops::eval_get_sign;
   if(eval_get_sign(a) == 0)
   {
      ::boost::exception_detail::throw_exception_(std::range_error("No bits were set in the operand."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/misc.hpp",183);
   }
   if(a.sign())
   {
      ::boost::exception_detail::throw_exception_(std::range_error("Testing individual bits in negative values is not supported - results are undefined."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/misc.hpp",187);
   }




   unsigned index = 0;
   while(!a.limbs()[index] && (index < a.size()))
      ++index;



   unsigned result = boost::multiprecision::detail::find_lsb(a.limbs()[index]);

   return result + index * cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_bits;
}




template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value, unsigned>::type
eval_msb_imp(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a)
{



   return (a.size() - 1) * cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_bits + boost::multiprecision::detail::find_msb(a.limbs()[a.size() - 1]);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value, unsigned>::type
   eval_msb(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a)
{
   using default_ops::eval_get_sign;
   if(eval_get_sign(a) == 0)
   {
      ::boost::exception_detail::throw_exception_(std::range_error("No bits were set in the operand."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/misc.hpp",224);
   }
   if(a.sign())
   {
      ::boost::exception_detail::throw_exception_(std::range_error("Testing individual bits in negative values is not supported - results are undefined."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/misc.hpp",228);
   }
   return eval_msb_imp(a);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value, bool>::type
   eval_bit_test(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val, unsigned index) noexcept
{
   unsigned offset = index / cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_bits;
   unsigned shift = index % cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_bits;
   limb_type mask = shift ? limb_type(1u) << shift : limb_type(1u);
   if(offset >= val.size())
      return false;
   return val.limbs()[offset] & mask ? true : false;
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_bit_set(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val, unsigned index)
{
   unsigned offset = index / cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_bits;
   unsigned shift = index % cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_bits;
   limb_type mask = shift ? limb_type(1u) << shift : limb_type(1u);
   if(offset >= val.size())
   {
      unsigned os = val.size();
      val.resize(offset + 1, offset + 1);
      if(offset >= val.size())
         return;
      for(unsigned i = os; i <= offset; ++i)
         val.limbs()[i] = 0;
   }
   val.limbs()[offset] |= mask;
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_bit_unset(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val, unsigned index) noexcept
{
   unsigned offset = index / cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_bits;
   unsigned shift = index % cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_bits;
   limb_type mask = shift ? limb_type(1u) << shift : limb_type(1u);
   if(offset >= val.size())
      return;
   val.limbs()[offset] &= ~mask;
   val.normalize();
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_bit_flip(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val, unsigned index)
{
   unsigned offset = index / cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_bits;
   unsigned shift = index % cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::limb_bits;
   limb_type mask = shift ? limb_type(1u) << shift : limb_type(1u);
   if(offset >= val.size())
   {
      unsigned os = val.size();
      val.resize(offset + 1, offset + 1);
      if(offset >= val.size())
         return;
      for(unsigned i = os; i <= offset; ++i)
         val.limbs()[i] = 0;
   }
   val.limbs()[offset] ^= mask;
   val.normalize();
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_qr(
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& x,
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& y,
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& q,
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& r) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   divide_unsigned_helper(&q, x, y, r);
   q.sign(x.sign() != y.sign());
   r.sign(x.sign());
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_qr(
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& x,
      limb_type y,
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& q,
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& r) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   divide_unsigned_helper(&q, x, y, r);
   q.sign(x.sign());
   r.sign(x.sign());
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, class U>
inline typename enable_if_c<is_integral<U>::value>::type eval_qr(
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& x,
      U y,
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& q,
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& r) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   using default_ops::eval_qr;
   cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> t;
   t = y;
   eval_qr(x, t, q, r);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, class Integer>
inline typename enable_if_c<is_unsigned<Integer>::value && !is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value, Integer>::type
   eval_integer_modulus(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& x, Integer val)
{
   if((sizeof(Integer) <= sizeof(limb_type)) || (val <= (std::numeric_limits<limb_type>::max)()))
   {
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> d;
      divide_unsigned_helper(static_cast<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>*>(0), x, static_cast<limb_type>(val), d);
      return d.limbs()[0];
   }
   else
   {
      return default_ops::eval_integer_modulus(x, val);
   }
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, class Integer>
inline typename enable_if_c<is_signed<Integer>::value && !is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value, Integer>::type
   eval_integer_modulus(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& x, Integer val)
{
   return eval_integer_modulus(x, boost::multiprecision::detail::unsigned_abs(val));
}

inline limb_type integer_gcd_reduce(limb_type u, limb_type v)
{
   do
   {
      if(u > v)
         std::swap(u, v);
      if(u == v)
         break;
      v -= u;
      v >>= boost::multiprecision::detail::find_lsb(v);
   } while(true);
   return u;
}

inline double_limb_type integer_gcd_reduce(double_limb_type u, double_limb_type v)
{
   do
   {
      if(u > v)
         std::swap(u, v);
      if(u == v)
         break;
      if(v <= ~static_cast<limb_type>(0))
      {
         u = integer_gcd_reduce(static_cast<limb_type>(v), static_cast<limb_type>(u));
         break;
      }
      v -= u;



      while((static_cast<unsigned>(v) & 1u) == 0)

         v >>= 1;
   } while(true);
   return u;
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_gcd(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a,
      limb_type v)
{
   using default_ops::eval_lsb;
   using default_ops::eval_is_zero;
   using default_ops::eval_get_sign;

   int shift;

   cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> u(a);

   int s = eval_get_sign(u);


   if(s < 0)
   {
      u.negate();
   }
   else if(s == 0)
   {
      result = v;
      return;
   }
   if(v == 0)
   {
      result = u;
      return;
   }




   unsigned us = eval_lsb(u);
   unsigned vs = boost::multiprecision::detail::find_lsb(v);
   shift = (std::min)(us, vs);
   eval_right_shift(u, us);
   if(vs)
      v >>= vs;

   do
   {


      if(u.size() <= 2)
      {
         if(u.size() == 1)
            v = integer_gcd_reduce(*u.limbs(), v);
         else
         {
            double_limb_type i;
            i = u.limbs()[0] | (static_cast<double_limb_type>(u.limbs()[1]) << sizeof(limb_type) * 8);
            v = static_cast<limb_type>(integer_gcd_reduce(i, static_cast<double_limb_type>(v)));
         }
         break;
      }
      eval_subtract(u, v);
      us = eval_lsb(u);
      eval_right_shift(u, us);
   }
   while(true);

   result = v;
   eval_left_shift(result, shift);
}
template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, class Integer>
inline typename enable_if_c<is_unsigned<Integer>::value && (sizeof(Integer) <= sizeof(limb_type)) && !is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_gcd(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a,
      const Integer& v)
{
   eval_gcd(result, a, static_cast<limb_type>(v));
}
template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1, class Integer>
inline typename enable_if_c<is_signed<Integer>::value && (sizeof(Integer) <= sizeof(limb_type)) && !is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_gcd(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a,
      const Integer& v)
{
   eval_gcd(result, a, static_cast<limb_type>(v < 0 ? -v : v));
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<!is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_gcd(
      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result,
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a,
      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& b)
{
   using default_ops::eval_lsb;
   using default_ops::eval_is_zero;
   using default_ops::eval_get_sign;

   if(a.size() == 1)
   {
      eval_gcd(result, b, *a.limbs());
      return;
   }
   if(b.size() == 1)
   {
      eval_gcd(result, a, *b.limbs());
      return;
   }

   int shift;

   cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> u(a), v(b);

   int s = eval_get_sign(u);


   if(s < 0)
   {
      u.negate();
   }
   else if(s == 0)
   {
      result = v;
      return;
   }
   s = eval_get_sign(v);
   if(s < 0)
   {
      v.negate();
   }
   else if(s == 0)
   {
      result = u;
      return;
   }




   unsigned us = eval_lsb(u);
   unsigned vs = eval_lsb(v);
   shift = (std::min)(us, vs);
   eval_right_shift(u, us);
   eval_right_shift(v, vs);

   do
   {


      s = u.compare(v);
      if(s > 0)
         u.swap(v);
      if(s == 0)
         break;
      if(v.size() <= 2)
      {
         if(v.size() == 1)
            u = integer_gcd_reduce(*v.limbs(), *u.limbs());
         else
         {
            double_limb_type i, j;
            i = v.limbs()[0] | (static_cast<double_limb_type>(v.limbs()[1]) << sizeof(limb_type) * 8);
            j = (u.size() == 1) ? *u.limbs() : u.limbs()[0] | (static_cast<double_limb_type>(u.limbs()[1]) << sizeof(limb_type) * 8);
            u = integer_gcd_reduce(i, j);
         }
         break;
      }
      eval_subtract(v, u);
      vs = eval_lsb(v);
      eval_right_shift(v, vs);
   }
   while(true);

   result = u;
   eval_left_shift(result, shift);
}



template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value>::type
   eval_gcd(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& b) noexcept
{
   *result.limbs() = boost::integer::gcd(*a.limbs(), *b.limbs());
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value && (Checked1 == unchecked)>::type
   eval_lcm(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& b) noexcept(((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)))
{
   *result.limbs() = boost::integer::lcm(*a.limbs(), *b.limbs());
   result.normalize();
}

inline void conversion_overflow(const mpl::int_<checked>&)
{
   ::boost::exception_detail::throw_exception_(std::overflow_error("Overflow in conversion to narrower type"),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/misc.hpp",593);
}
inline void conversion_overflow(const mpl::int_<unchecked>&){}

template <class R, unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<
            is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
            && is_signed_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
            && boost::is_convertible<typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::local_limb_type, R>::value
         >::type
   eval_convert_to(R* result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val)
{
   typedef typename common_type<R, typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::local_limb_type>::type common_type;
   if(std::numeric_limits<R>::is_specialized && (static_cast<common_type>(*val.limbs()) > static_cast<common_type>((std::numeric_limits<R>::max)())))
   {
      if(val.isneg())
      {
         check_is_negative(mpl::bool_<boost::is_signed<R>::value || (number_category<R>::value == number_kind_floating_point)>());
         if(static_cast<common_type>(*val.limbs()) > -static_cast<common_type>((std::numeric_limits<R>::min)()))
            conversion_overflow(typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());
         *result = (std::numeric_limits<R>::min)();
      }
      else
      {
         conversion_overflow(typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());
         *result = boost::is_signed<R>::value ? (std::numeric_limits<R>::max)() : static_cast<R>(*val.limbs());
      }
   }
   else
   {
      *result = static_cast<R>(*val.limbs());
      if(val.isneg())
      {
         check_is_negative(mpl::bool_<boost::is_signed<R>::value || (number_category<R>::value == number_kind_floating_point)>());
         *result = negate_integer(*result, mpl::bool_<is_signed_number<R>::value || (number_category<R>::value == number_kind_floating_point)>());
      }
   }
}

template <class R, unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<
            is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
            && is_unsigned_number<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value
            && boost::is_convertible<typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::local_limb_type, R>::value
         >::type
   eval_convert_to(R* result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val)
{
   typedef typename common_type<R, typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::local_limb_type>::type common_type;
   if(std::numeric_limits<R>::is_specialized && (static_cast<common_type>(*val.limbs()) > static_cast<common_type>((std::numeric_limits<R>::max)())))
   {
      conversion_overflow(typename cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>::checked_type());
      *result = boost::is_signed<R>::value ? (std::numeric_limits<R>::max)() : static_cast<R>(*val.limbs());
   }
   else
      *result = static_cast<R>(*val.limbs());
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value, unsigned>::type
   eval_lsb(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a)
{
   using default_ops::eval_get_sign;
   if(eval_get_sign(a) == 0)
   {
      ::boost::exception_detail::throw_exception_(std::range_error("No bits were set in the operand."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/misc.hpp",657);
   }
   if(a.sign())
   {
      ::boost::exception_detail::throw_exception_(std::range_error("Testing individual bits in negative values is not supported - results are undefined."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/misc.hpp",661);
   }



   return boost::multiprecision::detail::find_lsb(*a.limbs());
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value, unsigned>::type
eval_msb_imp(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a)
{



   return boost::multiprecision::detail::find_msb(*a.limbs());
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline typename enable_if_c<is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value, unsigned>::type
   eval_msb(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a)
{
   using default_ops::eval_get_sign;
   if(eval_get_sign(a) == 0)
   {
      ::boost::exception_detail::throw_exception_(std::range_error("No bits were set in the operand."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/misc.hpp",686);
   }
   if(a.sign())
   {
      ::boost::exception_detail::throw_exception_(std::range_error("Testing individual bits in negative values is not supported - results are undefined."),__PRETTY_FUNCTION__,"./boost/multiprecision/cpp_int/misc.hpp",690);
   }
   return eval_msb_imp(a);
}

template <unsigned MinBits1, unsigned MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
inline std::size_t hash_value(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val) noexcept
{
   std::size_t result = 0;
   for(unsigned i = 0; i < val.size(); ++i)
   {
      boost::hash_combine(result, val.limbs()[i]);
   }
   boost::hash_combine(result, val.sign());
   return result;
}





}}}
namespace std{

namespace detail{






template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
inline boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>
   get_min(const boost::mpl::true_&, const boost::mpl::true_&)
{

   typedef boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> result_type;
   typedef boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MaxBits, MaxBits, boost::multiprecision::unsigned_magnitude, boost::multiprecision::unchecked>, ExpressionTemplates> ui_type;
   static const result_type val = -result_type(~ui_type(0));
   return val;
}

template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
inline boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>
   get_min(const boost::mpl::true_&, const boost::mpl::false_&)
{

   static const boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> val(0u);
   return val;
}

template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
inline boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>
   get_min(const boost::mpl::false_&, const boost::mpl::true_&)
{


   static const boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> val(0u);
   return val;
}

template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
inline boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>
   get_min(const boost::mpl::false_&, const boost::mpl::false_&)
{

   static const boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> val(0u);
   return val;
}

template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
inline boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>
   get_max(const boost::mpl::true_&, const boost::mpl::true_&)
{

   typedef boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> result_type;
   typedef boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MaxBits, MaxBits, boost::multiprecision::unsigned_magnitude, boost::multiprecision::unchecked>, ExpressionTemplates> ui_type;
   static const result_type val = ~ui_type(0);
   return val;
}

template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
inline boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>
   get_max(const boost::mpl::true_&, const boost::mpl::false_&)
{

   typedef boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> result_type;
   typedef boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, boost::multiprecision::unsigned_magnitude, boost::multiprecision::unchecked, Allocator>, ExpressionTemplates> ui_type;
   static const result_type val = ~ui_type(0);
   return val;
}

template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
inline boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>
   get_max(const boost::mpl::false_&, const boost::mpl::true_&)
{


   static const boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> val(0u);
   return val;
}

template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
inline boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>
   get_max(const boost::mpl::false_&, const boost::mpl::false_&)
{

   static const boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> val(0u);
   return val;
}

}

template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
class numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >
{
   typedef boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> backend_type;
   typedef boost::multiprecision::number<backend_type, ExpressionTemplates> number_type;

   struct inititializer
   {
      inititializer()
      {
         (std::numeric_limits<number_type>::max)();
         (std::numeric_limits<number_type>::min)();
      }
      void do_nothing()const{}
   };

   static const inititializer init;

public:
   static constexpr bool is_specialized = true;




   static number_type (min)()
   {
      init.do_nothing();
      return detail::get_min<MinBits, MaxBits, SignType, Checked, Allocator, ExpressionTemplates>(boost::multiprecision::backends::is_fixed_precision<backend_type>(), boost::multiprecision::is_signed_number<backend_type>());
   }
   static number_type (max)()
   {
      init.do_nothing();
      return detail::get_max<MinBits, MaxBits, SignType, Checked, Allocator, ExpressionTemplates>(boost::multiprecision::backends::is_fixed_precision<backend_type>(), boost::multiprecision::is_signed_number<backend_type>());
   }
   static number_type lowest() { return (min)(); }
   static constexpr int digits = boost::multiprecision::backends::max_precision<backend_type>::value == (2147483647 *2U +1U) ? 2147483647 : boost::multiprecision::backends::max_precision<backend_type>::value;
   static constexpr int digits10 = (digits > 2147483647 / 301) ? (digits / 1000) * 301L : (digits * 301) / 1000;
   static constexpr int max_digits10 = digits10 + 3;
   static constexpr bool is_signed = boost::multiprecision::is_signed_number<backend_type>::value;
   static constexpr bool is_integer = true;
   static constexpr bool is_exact = true;
   static constexpr int radix = 2;
   static number_type epsilon() { return 0; }
   static number_type round_error() { return 0; }
   static constexpr int min_exponent = 0;
   static constexpr int min_exponent10 = 0;
   static constexpr int max_exponent = 0;
   static constexpr int max_exponent10 = 0;
   static constexpr bool has_infinity = false;
   static constexpr bool has_quiet_NaN = false;
   static constexpr bool has_signaling_NaN = false;
   static constexpr float_denorm_style has_denorm = denorm_absent;
   static constexpr bool has_denorm_loss = false;
   static number_type infinity() { return 0; }
   static number_type quiet_NaN() { return 0; }
   static number_type signaling_NaN() { return 0; }
   static number_type denorm_min() { return 0; }
   static constexpr bool is_iec559 = false;
   static constexpr bool is_bounded = boost::multiprecision::backends::is_fixed_precision<backend_type>::value;
   static constexpr bool is_modulo = (boost::multiprecision::backends::is_fixed_precision<backend_type>::value && (Checked == boost::multiprecision::unchecked));
   static constexpr bool traps = false;
   static constexpr bool tinyness_before = false;
   static constexpr float_round_style round_style = round_toward_zero;
};

template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
const typename numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::inititializer numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::init;



template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::digits;
template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::digits10;
template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::max_digits10;
template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::is_signed;
template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::is_integer;
template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::is_exact;
template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::radix;
template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::min_exponent;
template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::min_exponent10;
template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::max_exponent;
template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::max_exponent10;
template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::has_infinity;
template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::has_quiet_NaN;
template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::has_signaling_NaN;
template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr float_denorm_style numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::has_denorm;
template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::has_denorm_loss;
template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::is_iec559;
template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::is_bounded;
template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::is_modulo;
template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::traps;
template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::tinyness_before;
template <unsigned MinBits, unsigned MaxBits, boost::multiprecision::cpp_integer_type SignType, boost::multiprecision::cpp_int_check_type Checked, class Allocator, boost::multiprecision::expression_template_option ExpressionTemplates>
constexpr float_round_style numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::round_style;






}

namespace boost{ namespace multiprecision{

namespace literals{ namespace detail{

template <char> struct hex_value;
template <> struct hex_value<'0'> { static constexpr limb_type value = 0; };
template <> struct hex_value<'1'> { static constexpr limb_type value = 1; };
template <> struct hex_value<'2'> { static constexpr limb_type value = 2; };
template <> struct hex_value<'3'> { static constexpr limb_type value = 3; };
template <> struct hex_value<'4'> { static constexpr limb_type value = 4; };
template <> struct hex_value<'5'> { static constexpr limb_type value = 5; };
template <> struct hex_value<'6'> { static constexpr limb_type value = 6; };
template <> struct hex_value<'7'> { static constexpr limb_type value = 7; };
template <> struct hex_value<'8'> { static constexpr limb_type value = 8; };
template <> struct hex_value<'9'> { static constexpr limb_type value = 9; };
template <> struct hex_value<'a'> { static constexpr limb_type value = 10; };
template <> struct hex_value<'b'> { static constexpr limb_type value = 11; };
template <> struct hex_value<'c'> { static constexpr limb_type value = 12; };
template <> struct hex_value<'d'> { static constexpr limb_type value = 13; };
template <> struct hex_value<'e'> { static constexpr limb_type value = 14; };
template <> struct hex_value<'f'> { static constexpr limb_type value = 15; };
template <> struct hex_value<'A'> { static constexpr limb_type value = 10; };
template <> struct hex_value<'B'> { static constexpr limb_type value = 11; };
template <> struct hex_value<'C'> { static constexpr limb_type value = 12; };
template <> struct hex_value<'D'> { static constexpr limb_type value = 13; };
template <> struct hex_value<'E'> { static constexpr limb_type value = 14; };
template <> struct hex_value<'F'> { static constexpr limb_type value = 15; };

template <class Pack, limb_type value>
struct combine_value_to_pack;
template <limb_type first, limb_type...ARGS, limb_type value>
struct combine_value_to_pack<value_pack<first, ARGS...>, value>
{
   typedef value_pack<first | value, ARGS...> type;
};

template <char NextChar, char...CHARS>
struct pack_values
{
   static constexpr unsigned chars_per_limb = sizeof(limb_type) * 8 / 4;
   static constexpr unsigned shift = ((sizeof...(CHARS)) % chars_per_limb) * 4;
   static constexpr limb_type value_to_add = shift ? hex_value<NextChar>::value << shift : hex_value<NextChar>::value;

   typedef typename pack_values<CHARS...>::type recursive_packed_type;
   typedef typename boost::mpl::if_c<shift == 0,
      typename recursive_packed_type::next_type,
      recursive_packed_type>::type pack_type;
   typedef typename combine_value_to_pack<pack_type, value_to_add>::type type;
};
template <char NextChar>
struct pack_values<NextChar>
{
   static constexpr limb_type value_to_add = hex_value<NextChar>::value;

   typedef value_pack<value_to_add> type;
};

template <class T>
struct strip_leading_zeros_from_pack;
template <limb_type...PACK>
struct strip_leading_zeros_from_pack<value_pack<PACK...> >
{
   typedef value_pack<PACK...> type;
};
template <limb_type...PACK>
struct strip_leading_zeros_from_pack<value_pack<0u, PACK...> >
{
   typedef typename strip_leading_zeros_from_pack<value_pack<PACK...> >::type type;
};

template <limb_type v, class PACK>
struct append_value_to_pack;
template <limb_type v, limb_type...PACK>
struct append_value_to_pack<v, value_pack<PACK...> >
{
   typedef value_pack<PACK..., v> type;
};

template <class T>
struct reverse_value_pack;
template <limb_type v, limb_type...VALUES>
struct reverse_value_pack<value_pack<v, VALUES...> >
{
   typedef typename reverse_value_pack<value_pack<VALUES...> >::type lead_values;
   typedef typename append_value_to_pack<v, lead_values>::type type;
};
template <limb_type v>
struct reverse_value_pack<value_pack<v> >
{
   typedef value_pack<v> type;
};
template <>
struct reverse_value_pack<value_pack<> >
{
   typedef value_pack<> type;
};

template <char l1, char l2, char...STR>
struct make_packed_value_from_str
{
   static_assert(l1 == '0', "Multi-precision integer literals must be in hexadecimal notation.");
   static_assert((l2 == 'X') || (l2 == 'x'), "Multi-precision integer literals must be in hexadecimal notation.");
   typedef typename pack_values<STR...>::type packed_type;
   typedef typename strip_leading_zeros_from_pack<packed_type>::type stripped_type;
   typedef typename reverse_value_pack<stripped_type>::type type;
};

template <class Pack, class B>
struct make_backend_from_pack
{
   static constexpr Pack p = {};
   static constexpr B value = p;
};

template <class Pack, class B>
constexpr B make_backend_from_pack<Pack, B>::value;

template <unsigned Digits>
struct signed_cpp_int_literal_result_type
{
   static constexpr unsigned bits = Digits * 4;
   typedef boost::multiprecision::backends::cpp_int_backend<bits, bits, signed_magnitude, unchecked, void> backend_type;
   typedef number<backend_type, et_off> number_type;
};

template <unsigned Digits>
struct unsigned_cpp_int_literal_result_type
{
   static constexpr unsigned bits = Digits * 4;
   typedef boost::multiprecision::backends::cpp_int_backend<bits, bits, unsigned_magnitude, unchecked, void> backend_type;
   typedef number<backend_type, et_off> number_type;
};

}

template <char... STR>
constexpr typename boost::multiprecision::literals::detail::signed_cpp_int_literal_result_type<(sizeof...(STR)) - 2>::number_type operator "" _cppi()
{
   typedef typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type pt;
   return boost::multiprecision::literals::detail::make_backend_from_pack<pt, typename boost::multiprecision::literals::detail::signed_cpp_int_literal_result_type<(sizeof...(STR)) - 2>::backend_type>::value;
}

template <char... STR>
constexpr typename boost::multiprecision::literals::detail::unsigned_cpp_int_literal_result_type<(sizeof...(STR)) - 2>::number_type operator "" _cppui()
{
   typedef typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type pt;
   return boost::multiprecision::literals::detail::make_backend_from_pack<pt, typename boost::multiprecision::literals::detail::unsigned_cpp_int_literal_result_type<(sizeof...(STR)) - 2>::backend_type>::value;
}
template <char... STR> constexpr boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<128, 128, boost::multiprecision::signed_magnitude, boost::multiprecision::unchecked, void> > operator "" _cppi128(){ typedef typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type pt; return boost::multiprecision::literals::detail::make_backend_from_pack< pt, boost::multiprecision::backends::cpp_int_backend<128, 128, boost::multiprecision::signed_magnitude, boost::multiprecision::unchecked, void> >::value;}template <char... STR> constexpr boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<128, 128, boost::multiprecision::unsigned_magnitude, boost::multiprecision::unchecked, void> > operator "" _cppui128(){ typedef typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type pt; return boost::multiprecision::literals::detail::make_backend_from_pack< pt, boost::multiprecision::backends::cpp_int_backend<128, 128, boost::multiprecision::unsigned_magnitude, boost::multiprecision::unchecked, void> >::value;}
template <char... STR> constexpr boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<256, 256, boost::multiprecision::signed_magnitude, boost::multiprecision::unchecked, void> > operator "" _cppi256(){ typedef typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type pt; return boost::multiprecision::literals::detail::make_backend_from_pack< pt, boost::multiprecision::backends::cpp_int_backend<256, 256, boost::multiprecision::signed_magnitude, boost::multiprecision::unchecked, void> >::value;}template <char... STR> constexpr boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<256, 256, boost::multiprecision::unsigned_magnitude, boost::multiprecision::unchecked, void> > operator "" _cppui256(){ typedef typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type pt; return boost::multiprecision::literals::detail::make_backend_from_pack< pt, boost::multiprecision::backends::cpp_int_backend<256, 256, boost::multiprecision::unsigned_magnitude, boost::multiprecision::unchecked, void> >::value;}
template <char... STR> constexpr boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<512, 512, boost::multiprecision::signed_magnitude, boost::multiprecision::unchecked, void> > operator "" _cppi512(){ typedef typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type pt; return boost::multiprecision::literals::detail::make_backend_from_pack< pt, boost::multiprecision::backends::cpp_int_backend<512, 512, boost::multiprecision::signed_magnitude, boost::multiprecision::unchecked, void> >::value;}template <char... STR> constexpr boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<512, 512, boost::multiprecision::unsigned_magnitude, boost::multiprecision::unchecked, void> > operator "" _cppui512(){ typedef typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type pt; return boost::multiprecision::literals::detail::make_backend_from_pack< pt, boost::multiprecision::backends::cpp_int_backend<512, 512, boost::multiprecision::unsigned_magnitude, boost::multiprecision::unchecked, void> >::value;}
template <char... STR> constexpr boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<1024, 1024, boost::multiprecision::signed_magnitude, boost::multiprecision::unchecked, void> > operator "" _cppi1024(){ typedef typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type pt; return boost::multiprecision::literals::detail::make_backend_from_pack< pt, boost::multiprecision::backends::cpp_int_backend<1024, 1024, boost::multiprecision::signed_magnitude, boost::multiprecision::unchecked, void> >::value;}template <char... STR> constexpr boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<1024, 1024, boost::multiprecision::unsigned_magnitude, boost::multiprecision::unchecked, void> > operator "" _cppui1024(){ typedef typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type pt; return boost::multiprecision::literals::detail::make_backend_from_pack< pt, boost::multiprecision::backends::cpp_int_backend<1024, 1024, boost::multiprecision::unsigned_magnitude, boost::multiprecision::unchecked, void> >::value;}

}




template <unsigned MinBits, cpp_int_check_type Checked>
constexpr number<cpp_int_backend<MinBits, MinBits, signed_magnitude, Checked, void>, et_off>
   operator - (const number<cpp_int_backend<MinBits, MinBits, signed_magnitude, Checked, void>, et_off>& a)
{
   return cpp_int_backend<MinBits, MinBits, signed_magnitude, Checked, void>(a.backend(), boost::multiprecision::literals::detail::make_negate_tag());
}
template <unsigned MinBits, cpp_int_check_type Checked>
constexpr number<cpp_int_backend<MinBits, MinBits, signed_magnitude, Checked, void>, et_off>
   operator - (number<cpp_int_backend<MinBits, MinBits, signed_magnitude, Checked, void>, et_off>&& a)
{
   return cpp_int_backend<MinBits, MinBits, signed_magnitude, Checked, void>(static_cast<const number<cpp_int_backend<MinBits, MinBits, signed_magnitude, Checked, void>, et_off>&>(a).backend(), boost::multiprecision::literals::detail::make_negate_tag());
}

}}









namespace boost {

namespace archive{

class binary_oarchive;
class binary_iarchive;

}

namespace serialization {

namespace mp = boost::multiprecision;

namespace cpp_int_detail{

using namespace boost::multiprecision;
using namespace boost::multiprecision::backends;

template <class T>
struct is_binary_archive : public mpl::false_ {};
template <>
struct is_binary_archive<boost::archive::binary_oarchive> : public mpl::true_ {};
template <>
struct is_binary_archive<boost::archive::binary_iarchive> : public mpl::true_ {};







template <class Archive, class Int>
void do_serialize(Archive& ar, Int& val, mpl::false_ const&, mpl::false_ const&, mpl::false_ const&)
{




   bool s;
   ar & s;
   std::size_t limb_count;
   std::size_t byte_count;
   ar & byte_count;
   limb_count = byte_count / sizeof(limb_type) + ((byte_count % sizeof(limb_type)) ? 1 : 0);
   val.resize(limb_count, limb_count);
   limb_type* pl = val.limbs();
   for(std::size_t i = 0; i < limb_count; ++i)
   {
      pl[i] = 0;
      for(std::size_t j = 0; (j < sizeof(limb_type)) && byte_count; ++j)
      {
         unsigned char byte;
         ar & byte;
         pl[i] |= static_cast<limb_type>(byte) << (j * 8);
         --byte_count;
      }
   }
   if(s != val.sign())
      val.negate();
   val.normalize();
}
template <class Archive, class Int>
void do_serialize(Archive& ar, Int& val, mpl::true_ const&, mpl::false_ const&, mpl::false_ const&)
{




   bool s = val.sign();
   ar & s;
   limb_type* pl = val.limbs();
   std::size_t limb_count = val.size();
   std::size_t byte_count = limb_count * sizeof(limb_type);
   ar & byte_count;

   for(std::size_t i = 0; i < limb_count; ++i)
   {
      limb_type l = pl[i];
      for(std::size_t j = 0; j < sizeof(limb_type); ++j)
      {
         unsigned char byte = static_cast<unsigned char>((l >> (j * 8)) & ((1u << 8) - 1));
         ar & byte;
      }
   }
}
template <class Archive, class Int>
void do_serialize(Archive& ar, Int& val, mpl::false_ const&, mpl::true_ const&, mpl::false_ const&)
{



   bool s;
   typename Int::local_limb_type l = 0;
   ar & s;
   std::size_t byte_count;
   ar & byte_count;
   for(std::size_t i = 0; i < byte_count; ++i)
   {
      unsigned char b;
      ar & b;
      l |= static_cast<typename Int::local_limb_type>(b) << (i * 8);
   }
   *val.limbs() = l;
   if(s != val.sign())
      val.negate();
}
template <class Archive, class Int>
void do_serialize(Archive& ar, Int& val, mpl::true_ const&, mpl::true_ const&, mpl::false_ const&)
{



   bool s = val.sign();
   typename Int::local_limb_type l = *val.limbs();
   ar & s;
   std::size_t limb_count = sizeof(l);
   ar & limb_count;
   for(std::size_t i = 0; i < limb_count; ++i)
   {
      unsigned char b = static_cast<unsigned char>(static_cast<typename Int::local_limb_type>(l >> (i * 8)) & static_cast<typename Int::local_limb_type>((1u << 8) - 1));
      ar & b;
   }
}
template <class Archive, class Int>
void do_serialize(Archive& ar, Int& val, mpl::false_ const&, mpl::false_ const&, mpl::true_ const&)
{



   bool s;
   std::size_t c;
   ar & s;
   ar & c;
   val.resize(c, c);
   ar.load_binary(val.limbs(), c * sizeof(limb_type));
   if(s != val.sign())
      val.negate();
   val.normalize();
}
template <class Archive, class Int>
void do_serialize(Archive& ar, Int& val, mpl::true_ const&, mpl::false_ const&, mpl::true_ const&)
{



   bool s = val.sign();
   std::size_t c = val.size();
   ar & s;
   ar & c;
   ar.save_binary(val.limbs(), c * sizeof(limb_type));
}
template <class Archive, class Int>
void do_serialize(Archive& ar, Int& val, mpl::false_ const&, mpl::true_ const&, mpl::true_ const&)
{



   bool s;
   ar & s;
   ar.load_binary(val.limbs(), sizeof(*val.limbs()));
   if(s != val.sign())
      val.negate();
}
template <class Archive, class Int>
void do_serialize(Archive& ar, Int& val, mpl::true_ const&, mpl::true_ const&, mpl::true_ const&)
{



   bool s = val.sign();
   ar & s;
   ar.save_binary(val.limbs(), sizeof(*val.limbs()));
}

}

template<class Archive, unsigned MinBits, unsigned MaxBits, mp::cpp_integer_type SignType, mp::cpp_int_check_type Checked, class Allocator>
void serialize(Archive & ar, mp::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>& val, const unsigned int )
{
   typedef typename Archive::is_saving save_tag;
   typedef mpl::bool_<mp::backends::is_trivial_cpp_int<mp::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >::value> trivial_tag;
   typedef typename cpp_int_detail::is_binary_archive<Archive>::type binary_tag;


   cpp_int_detail::do_serialize(ar, val, save_tag(), trivial_tag(), binary_tag());
}

}}
namespace boost {
   namespace multiprecision {

      namespace detail {

         template <class Backend, class Unsigned>
         void assign_bits(Backend& val, Unsigned bits, unsigned bit_location, unsigned chunk_bits, const mpl::false_& tag)
         {
            unsigned limb = bit_location / (sizeof(limb_type) * 8);
            unsigned shift = bit_location % (sizeof(limb_type) * 8);

            limb_type mask = chunk_bits >= sizeof(limb_type) * 8 ? ~static_cast<limb_type>(0u) : (static_cast<limb_type>(1u) << chunk_bits) - 1;

            limb_type value = static_cast<limb_type>(bits & mask) << shift;
            if(value)
            {
               if(val.size() == limb)
               {
                  val.resize(limb + 1, limb + 1);
                  if(val.size() > limb)
                     val.limbs()[limb] = value;
               }
               else if(val.size() > limb)
                  val.limbs()[limb] |= value;
            }
            if(chunk_bits > sizeof(limb_type) * 8 - shift)
            {
               shift = sizeof(limb_type) * 8 - shift;
               chunk_bits -= shift;
               bit_location += shift;
               bits >>= shift;
               if(bits)
                  assign_bits(val, bits, bit_location, chunk_bits, tag);
            }
         }
         template <class Backend, class Unsigned>
         void assign_bits(Backend& val, Unsigned bits, unsigned bit_location, unsigned chunk_bits, const mpl::true_&)
         {
            typedef typename Backend::local_limb_type local_limb_type;




            if((bit_location >= sizeof(local_limb_type) * 8) && bits)
               val.resize(2, 2);
            else
            {
               local_limb_type mask = chunk_bits >= sizeof(local_limb_type) * 8 ? ~static_cast<local_limb_type>(0u) : (static_cast<local_limb_type>(1u) << chunk_bits) - 1;
               local_limb_type value = (static_cast<local_limb_type>(bits) & mask) << bit_location;
               *val.limbs() |= value;



               bit_location = sizeof(local_limb_type) * 8 - bit_location;
               if((bit_location < sizeof(bits)*8) && (bits >>= bit_location))
                  val.resize(2, 2);
            }
         }

         template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked, class Allocator>
         inline void resize_to_bit_size(cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>& newval, unsigned bits, const mpl::false_&)
         {
            unsigned limb_count = static_cast<unsigned>(bits / (sizeof(limb_type) * 8));
            if(bits % (sizeof(limb_type) * 8))
               ++limb_count;
            static const unsigned max_limbs = MaxBits ? MaxBits / (8 * sizeof(limb_type)) + ((MaxBits % (8 * sizeof(limb_type))) ? 1 : 0) : (std::numeric_limits<unsigned>::max)();
            if(limb_count > max_limbs)
               limb_count = max_limbs;
            newval.resize(limb_count, limb_count);
            std::memset(newval.limbs(), 0, newval.size() * sizeof(limb_type));
         }
         template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked, class Allocator>
         inline void resize_to_bit_size(cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>& newval, unsigned, const mpl::true_&)
         {
            *newval.limbs() = 0;
         }

         template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked, class Allocator, expression_template_option ExpressionTemplates, class Iterator>
         number<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>&
            import_bits_generic(
               number<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>& val, Iterator i, Iterator j, unsigned chunk_size = 0, bool msv_first = true)
         {
            typename number<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>::backend_type newval;

            typedef typename std::iterator_traits<Iterator>::value_type value_type;
            typedef typename boost::make_unsigned<value_type>::type unsigned_value_type;
            typedef typename std::iterator_traits<Iterator>::difference_type difference_type;
            typedef typename boost::make_unsigned<difference_type>::type size_type;
            typedef typename cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>::trivial_tag tag_type;

            if(!chunk_size)
               chunk_size = std::numeric_limits<value_type>::digits;

            size_type limbs = std::distance(i, j);
            size_type bits = limbs * chunk_size;

            detail::resize_to_bit_size(newval, static_cast<unsigned>(bits), tag_type());

            difference_type bit_location = msv_first ? bits - chunk_size : 0;
            difference_type bit_location_change = msv_first ? -static_cast<difference_type>(chunk_size) : chunk_size;

            while(i != j)
            {
               detail::assign_bits(newval, static_cast<unsigned_value_type>(*i), static_cast<unsigned>(bit_location), chunk_size, tag_type());
               ++i;
               bit_location += bit_location_change;
            }

            newval.normalize();

            val.backend().swap(newval);
            return val;
         }

         template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked, class Allocator, expression_template_option ExpressionTemplates, class T>
         inline typename boost::disable_if_c<boost::multiprecision::backends::is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >::value, number<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>&>::type
            import_bits_fast(
               number<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>& val, T* i, T* j, unsigned chunk_size = 0)
         {
            std::size_t byte_len = (j - i) * (chunk_size ? chunk_size / 8 : sizeof(*i));
            std::size_t limb_len = byte_len / sizeof(limb_type);
            if(byte_len % sizeof(limb_type))
               ++limb_len;
            cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>& result = val.backend();
            result.resize(static_cast<unsigned>(limb_len), static_cast<unsigned>(limb_len));
            result.limbs()[result.size() - 1] = 0u;
            std::memcpy(result.limbs(), i, (std::min)(byte_len, result.size() * sizeof(limb_type)));
            result.normalize();
            return val;
         }
         template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked, class Allocator, expression_template_option ExpressionTemplates, class T>
         inline typename boost::enable_if_c<boost::multiprecision::backends::is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >::value, number<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>&>::type
            import_bits_fast(
               number<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>& val, T* i, T* j, unsigned chunk_size = 0)
         {
            cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>& result = val.backend();
            std::size_t byte_len = (j - i) * (chunk_size ? chunk_size / 8 : sizeof(*i));
            std::size_t limb_len = byte_len / sizeof(result.limbs()[0]);
            if(byte_len % sizeof(result.limbs()[0]))
               ++limb_len;
            result.limbs()[0] = 0u;
            result.resize(static_cast<unsigned>(limb_len), static_cast<unsigned>(limb_len));
            std::memcpy(result.limbs(), i, (std::min)(byte_len, result.size() * sizeof(result.limbs()[0])));
            result.normalize();
            return val;
         }
      }


      template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked, class Allocator, expression_template_option ExpressionTemplates, class Iterator>
      inline number<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>&
         import_bits(
            number<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>& val, Iterator i, Iterator j, unsigned chunk_size = 0, bool msv_first = true)
      {
         return detail::import_bits_generic(val, i, j, chunk_size, msv_first);
      }

      template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked, class Allocator, expression_template_option ExpressionTemplates, class T>
      inline number<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>&
         import_bits(
            number<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>& val, T* i, T* j, unsigned chunk_size = 0, bool msv_first = true)
      {

         if(((chunk_size % 8) == 0) && !msv_first)
            return detail::import_bits_fast(val, i, j, chunk_size);

         return detail::import_bits_generic(val, i, j, chunk_size, msv_first);
      }

      namespace detail {

         template <class Backend>
         boost::uintmax_t extract_bits(const Backend& val, unsigned location, unsigned count, const mpl::false_& tag)
         {
            unsigned limb = location / (sizeof(limb_type) * 8);
            unsigned shift = location % (sizeof(limb_type) * 8);
            boost::uintmax_t result = 0;
            boost::uintmax_t mask = count == std::numeric_limits<boost::uintmax_t>::digits ? ~static_cast<boost::uintmax_t>(0) : (static_cast<boost::uintmax_t>(1u) << count) - 1;
            if(count > (sizeof(limb_type) * 8 - shift))
            {
               result = extract_bits(val, location + sizeof(limb_type) * 8 - shift, count - sizeof(limb_type) * 8 + shift, tag);
               result <<= sizeof(limb_type) * 8 - shift;
            }
            if(limb < val.size())
               result |= (val.limbs()[limb] >> shift) & mask;
            return result;
         }

         template <class Backend>
         inline boost::uintmax_t extract_bits(const Backend& val, unsigned location, unsigned count, const mpl::true_&)
         {
            typename Backend::local_limb_type result = *val.limbs();
            typename Backend::local_limb_type mask = count >= std::numeric_limits<typename Backend::local_limb_type>::digits ? ~static_cast<typename Backend::local_limb_type>(0) : (static_cast<typename Backend::local_limb_type>(1u) << count) - 1;
            return (result >> location) & mask;
         }

      }

      template <unsigned MinBits, unsigned MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked, class Allocator, expression_template_option ExpressionTemplates, class OutputIterator>
      OutputIterator export_bits(
         const number<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>& val, OutputIterator out, unsigned chunk_size, bool msv_first = true)
      {




         typedef typename cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>::trivial_tag tag_type;
         if(!val)
         {
            *out = 0;
            ++out;
            return out;
         }
         unsigned bitcount = boost::multiprecision::backends::eval_msb_imp(val.backend()) + 1;
         unsigned chunks = bitcount / chunk_size;
         if(bitcount % chunk_size)
            ++chunks;

         int bit_location = msv_first ? bitcount - chunk_size : 0;
         int bit_step = msv_first ? -static_cast<int>(chunk_size) : chunk_size;
         while(bit_location % bit_step) ++bit_location;

         do
         {
            *out = detail::extract_bits(val.backend(), bit_location, chunk_size, tag_type());
            ++out;
            bit_location += bit_step;
         } while((bit_location >= 0) && (bit_location < (int)bitcount));

         return out;



      }

   }
}






signed main() {



}


