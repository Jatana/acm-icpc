<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>~/templates/cheats.txt.html</title>
<meta name="Generator" content="Vim/8.0">
<meta name="plugin-version" content="vim7.4_v2">
<meta name="syntax" content="none">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,prevent_copy=">
<meta name="colorscheme" content="none">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #000000; background-color: #ffffff; }
body { font-family: monospace; color: #000000; background-color: #ffffff; }
* { font-size: 1em; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>

========== FFTNum ==========

#define FOR(i, a, b) for (int i = (a); i &lt; (b); ++i)
#define sz(a) int((a).size())
typedef long long ll;
typedef vector&lt;int&gt; vi;
const int MOD = 119 &lt;&lt; 23 | 1;
const int FFTMOD = 119 &lt;&lt; 23 | 1;
inline void addmod(int&amp; a, int val, int p = MOD) {if ((a = (a + val)) &gt;= p) a -= p;}
inline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}

struct NTT {
    static const int MAXF = 1 &lt;&lt; 20;
    int pr;
    int rts[MAXF + 1];
    int bitrev[MAXF];
    int iv[MAXF + 1];

    int fpow(int a, int k, int p) {
        if (!k) return 1;
        int res = a, tmp = a;
        k--;
        while (k) {
            if (k &amp; 1) {
                res = (long long) res * tmp % p;
            }
            tmp = (long long) tmp * tmp % p;
            k &gt;&gt;= 1;
        }
        return res;
    }
    void init(int pr, int pw) {
        this-&gt;pr = pr;
        int k = 0; while ((1 &lt;&lt; k) &lt; MAXF) k++;
        bitrev[0] = 0;
        for (int i = 1; i &lt; MAXF; i++) {
            bitrev[i] = bitrev[i &gt;&gt; 1] &gt;&gt; 1 | ((i &amp; 1) &lt;&lt; k - 1);
        }
        pw = fpow(pw, (pr - 1) / MAXF, pr);
        rts[0] = 1;
        for (int i = 1; i &lt;= MAXF; i++) {
            rts[i] = (long long) rts[i - 1] * pw % pr;
        }
        for (int i = 1; i &lt;= MAXF; i &lt;&lt;= 1) {
            iv[i] = fpow(i, pr - 2, pr);
        }
    }
    void dft(int a[], int n, int sign) {
        int d = 0; while ((1 &lt;&lt; d) * n != MAXF) d++;
        for (int i = 0; i &lt; n; i++) {
            if (i &lt; (bitrev[i] &gt;&gt; d)) {
                swap(a[i], a[bitrev[i] &gt;&gt; d]);
            }
        }
        for (int len = 2; len &lt;= n; len &lt;&lt;= 1) {
            int delta = MAXF / len * sign;
            for (int i = 0; i &lt; n; i += len) {
                int *w = sign &gt; 0 ? rts : rts + MAXF;
                for (int k = 0; k + k &lt; len; k++) {
                    int &amp;a1 = a[i + k + (len &gt;&gt; 1)], &amp;a2 = a[i + k];
                    int t = (long long) *w * a1 % pr;
                    a1 = a2 - t;
                    a2 = a2 + t;
                    a1 += a1 &lt; 0 ? pr : 0;
                    a2 -= a2 &gt;= pr ? pr : 0;
                    w += delta;
                }
            }
        }
        if (sign &lt; 0) {
            int in = iv[n];
            for (int i = 0; i &lt; n; i++) {
                a[i] = (long long) a[i] * in % pr;
            }
        }
    }
    void multiply(int a[], int b[], int na, int nb, int c[]) {
        static int fa[MAXF], fb[MAXF];
        int n = na + nb - 1; while (n != (n &amp; -n)) n += n &amp; -n;
        for (int i = 0; i &lt; n; i++) fa[i] = fb[i] = 0;
        for (int i = 0; i &lt; na; i++) fa[i] = a[i];
        for (int i = 0; i &lt; nb; i++) fb[i] = b[i];
        dft(fa, n, 1), dft(fb, n, 1);
        for (int i = 0; i &lt; n; i++) fa[i] = (long long) fa[i] * fb[i] % pr;
        dft(fa, n, -1);
        for (int i = 0; i &lt; n; i++) c[i] = fa[i];
    }
    vector&lt;int&gt; multiply(vector&lt;int&gt; a, vector&lt;int&gt; b) {
        static int fa[MAXF], fb[MAXF], fc[MAXF];
        int na = a.size(), nb = b.size();
        for (int i = 0; i &lt; na; i++) fa[i] = a[i];
        for (int i = 0; i &lt; nb; i++) fb[i] = b[i];
        multiply(fa, fb, na, nb, fc);
        int k = na + nb - 1;
        vector&lt;int&gt; res(k);
        for (int i = 0; i &lt; k; i++) res[i] = fc[i];
        return res;
    }
} ntt;

int main(int argc, char* argv[]) {
    ios_base::sync_with_stdio(0), cin.tie(0);
    vector&lt;int&gt; A = {1, 1, 2};
    vector&lt;int&gt; B = {9, 1, 3};
    ntt.init(MOD, 3);
    vector&lt;int&gt; rez = ntt.multiply(A, B);
    for (int x : rez) {
        cout &lt;&lt; x &lt;&lt; &quot; &quot;;
    }
}

========== FFTSolver ==========

namespace FFTSolver {
	typedef complex&lt;ld&gt; plex;

	vector&lt;vector&lt;plex&gt;&gt; W;

	int __get_log(int N) {
		return 31 - __builtin_clz(N);
	}

	void construct_roots(int N) {
		int n = __get_log(N);
		while (len(W) &lt; n) {
			int layer_log = len(W);
			int k = (1 &lt;&lt; layer_log);
			W.pb(vector&lt;plex&gt;());
			W.back().resize(k);
			for (int j = 0; j &lt; k; j++) {
				W.back()[j] = (plex(cos((2 * M_PI * (ld)j) / (ld)(2 * k)), sin((2 * M_PI * (ld)j) / (ld)(2 * k))));
			}
		}
	}

	void __fft(plex *a, int N, plex e, bool inv) {
		for (int k = 1, id = 0; k &lt; N; k *= 2, id++) {
			for (int i = 0; i &lt; N; i += k * 2) {
				for (int j = 0; j &lt; k; j++) {
					if (!inv) {
						plex x = a[i + j], y = a[i + j + k];
						a[i + j] = x + W[id][j] * y;
						a[i + j + k] = x - W[id][j] * y;
					} else {
						plex x = a[i + j], y = a[i + j + k];
						a[i + j] = x + conj(W[id][j]) * y;
						a[i + j + k] = x - conj(W[id][j]) * y;
					}
				}
			}
		}
	}

	template &lt;class T&gt;
	void reverse_permutation(T *a, int N) {
		int N_2 = (N &gt;&gt; 1), r = 0;
		for (int x = 1; x &lt; N; ++ x) {
			int h = N_2;
			while (((r ^= h) &amp; h) == 0) h &gt;&gt;= 1;
			if (r &gt; x) swap(a[x], a[r]);
		}
	}

	void complex_convolution(plex *a, int N, bool inv) {
		reverse_permutation(a, N);
		construct_roots(N);
		plex e(cos(2.0 * M_PI / (ld)N), sin(2.0 * M_PI / (ld)N));
		if (inv) e = conj(e);
		__fft(a, N, e, inv);
	}

	void transform_2_convolutions(plex *a, int N) {
		plex div_x = plex(0, 1) * (4.0 * N);
		for (int i = 0; i &lt; N / 2; i++) {
			int j = (N - i) % N;
			a[i] = (a[i] + conj(a[j])) * (a[i] - conj(a[j])) / div_x;
		}
		for (int i = N - 1; i &gt; N / 2; i--) {
			a[i] = conj(a[N - i]);
		}
		a[N / 2] = (a[N / 2] + conj(a[N / 2])) * (a[N / 2] - conj(a[N / 2])) / div_x;
	}

	inline vector&lt;ll&gt; multiply(const vector&lt;ll&gt; &amp;a, const vector&lt;ll&gt; &amp;b) {
		int N = len(a) + len(b) + 1;
		while (__builtin_popcount(N) != 1) {
			N++;
		}

		plex e(cos(2 * M_PI / (ld)N), sin(2 * M_PI / (ld)N));

		vector&lt;plex&gt; mvp(N);
		for (int i = 0; i &lt; N; i++) {
			if (i &lt; len(a)) {
				mvp[i].real(a[i]);
			}
			if (i &lt; len(b)) {
				mvp[i].imag(b[i]);
			}
		}

		complex_convolution(mvp.data(), N, false);
		transform_2_convolutions(mvp.data(), N);
		complex_convolution(mvp.data(), N, true);


		vector&lt;ll&gt; final(N);
		for (int i = 0; i &lt; N; i++) {
			final[i] = round(real(mvp[i]));
		}

		return final;
	}

	template&lt;class T&gt;
	inline vector&lt;T&gt; multiply_high_precision(vector&lt;ll&gt; a, vector&lt;ll&gt; b) {
		int N = max(len(a), len(b));
		a.resize(N, 0);
		b.resize(N, 0);
		vector&lt;ll&gt; A = a;
		vector&lt;ll&gt; B = b;
		ll C = 0;
		f(i, N) {
			C = max(C, abs(a[i]));
			C = max(C, abs(b[i]));
		}
		C = sqrt(C);
		f(i, N) {
			A[i] /= C;
			B[i] /= C;
			a[i] %= C;
			b[i] %= C;
		}
		vector&lt;ll&gt; high = multiply(A, B);
		vector&lt;ll&gt; Ab = multiply(A, b);
		vector&lt;ll&gt; Ba = multiply(B, a);
		vector&lt;ll&gt; ab = multiply(a, b);
		vector&lt;T&gt; gl(len(high));

		T _C(C);

		f(i, len(gl)) {
			gl[i] = _C * _C * T(high[i]) + _C * (T(Ab[i]) + T(Ba[i])) + T(ab[i]);
		}
		return gl;
	}
};

========== Berleykamp ==========

const ll MOD = 1e9 + 7;
template&lt;ll MOD&gt;
struct Ring {
	ll value = 0;
	Ring() {}
	Ring(int _value) {
		value = _value;
		value = floor_mod(value, MOD);
	}
	Ring(ll _value) {
		value = _value;
		value = floor_mod(value, MOD);
	}
	Ring pow(ll p) const {
		if (p == 0) return 1;
		if (p &amp; 1) {
			return Ring(value).pow(p - 1) * value;
		} else {
			Ring sub = Ring(value).pow(p / 2);
			return sub * sub;
		}
	}
	Ring inv() const {
		return pow(MOD - 2);
	}
	void operator*=(const Ring&lt;MOD&gt; &amp;b) {
		value *= b.value;
		value = floor_mod(value, MOD);
	}
	friend Ring operator*(Ring&lt;MOD&gt; a, const Ring&lt;MOD&gt; &amp;b) {
		a *= b;
		return a;
	}
	void operator+=(const Ring&lt;MOD&gt; &amp;b) {
		value += b.value;
		value = floor_mod(value, MOD);
	}
	friend Ring operator+(Ring a, const Ring &amp;b) {
		a += b;
		return a;
	}
	void operator-=(const Ring&lt;MOD&gt; &amp;b) {
		value -= b.value;
		value = floor_mod(value, MOD);
	}
	friend Ring operator-(Ring a, const Ring &amp;b) {
		a -= b;
		return a;
	}
	void operator/=(const Ring&lt;MOD&gt; &amp;b) {
		(*this) *= b.inv();
	}
	friend Ring operator/(Ring a, const Ring &amp;b) {
		a /= b;
		return a;
	}
	bool operator==(const Ring&lt;MOD&gt; &amp;b) {
		return value == b.value;
	}
	friend void fast_print(const Ring&lt;MOD&gt; &amp;b) {
		fast_print(b.value);
	}
};

typedef Ring&lt;MOD&gt; num;


template&lt;class T&gt;
struct Berleykamp {
	vector&lt;T&gt; v;
	vector&lt;T&gt; rec;

	Berleykamp(const vector&lt;T&gt; &amp;_a) {
		v = _a;
		vector&lt;T&gt; cur = {1};
		vector&lt;T&gt; pref = {1};
		T dy = 1;
		for (int i = 0; i &lt; len(v); i++) {
			T dx = 0;
			f(j, len(cur)) {
				dx += v[i - len(cur) + j + 1] * cur[j];
			}
			if (dx == (T)0) {
				pref.pb(0);
			} else {
				pref.pb(0);
				vector&lt;T&gt; _new = cur;
				while (len(_new) &lt; len(pref)) {
					_new.insert(_new.begin(), 0);
				}
				f(j, len(pref)) {
					_new[len(_new) - len(pref) + j] -= pref[j] * (dx / dy);
				}
				pref = cur;
				cur = _new;
				dy = dx;
			}
		}
		rec = cur;
	}

	T interpolate(int n) {
		if (n &lt; len(v)) return v[n];
		T rez = 0;
		for (int i = 0; i &lt; len(rec) - 1; i++) {
			rez -= interpolate(n - len(rec) + i + 1) * rec[i];
		}
		assert(len(v) == n);
		v.pb(n);
		return v[n] = rez;
	}

	vector&lt;T&gt; mod(vector&lt;T&gt; a, vector&lt;T&gt; b) {
		while (!b.empty() &amp;&amp; b.back() == 0) {
			b.pop_back();
		}
		while (len(a) &gt;= len(b)) {
			while (!a.empty() &amp;&amp; a.back() == 0) {
				a.pop_back();
			}
			if (len(a) &lt; len(b)) return a;

			T factor = a.back() / b.back();

			f(i, len(b)) {
				a[len(a) - len(b) + i] -= b[i] * factor;
			}
		}
		return a;
	}

	vector&lt;T&gt; mul(vector&lt;T&gt; a, vector&lt;T&gt; b) {
		vector&lt;T&gt; c(len(a) + len(b));
		f(i, len(a)) {
			f(j, len(b)) {
				c[i + j] += a[i] * b[j];
			}
		}
		return c;
	}

	vector&lt;T&gt; fast_pow(vector&lt;T&gt; x, vector&lt;T&gt; M, int p) {
		if (p == 0) return {T(1)};
		if (p &amp; 1) {
			return mod(mul(fast_pow(x, M, p - 1), x), M);
		} else {
			vector&lt;T&gt; sub = fast_pow(x, M, p / 2);
			return mod(mul(sub, sub), M);
		}
	}

	T interpolate__fast(int n) {
		vector&lt;T&gt; x = {0, 1};
		x = fast_pow(x, rec, n);
		T final = 0;
		for (int i = 0; i &lt; len(x); i++) {
			final += x[i] * interpolate(i);
		}
		return final;
	}
};


========== HungarianDance ==========

struct Dance {
	int n, m;
	vector&lt;vector&lt;int&gt;&gt; v;
	vector&lt;int&gt; rez;
	vector&lt;int&gt; row, col;
	vector&lt;bool&gt; srow, scol;
	vector&lt;int&gt; min_value, min_pos;
	vector&lt;pii&gt; invoker;

	Dance(vector&lt;vector&lt;int&gt;&gt; _v) {
		v = _v;
		n = len(v);
		m = len(v[0]);

		row.resize(n, 0);
		col.resize(m, 0);
		rez.resize(m, -1);
	}

	int get(int i, int j) {
		return v[i][j] + row[i] + col[j];
	}

	pair&lt;vector&lt;int&gt;, int&gt; match() {
		f(cur, n) {
			min_value = vector&lt;int&gt;(m, 1e9);
			min_pos = vector&lt;int&gt;(m, -1);
			invoker = vector&lt;pii&gt;(n, mp(-1, -1));
			srow = vector&lt;bool&gt;(n, false);
			scol = vector&lt;bool&gt;(m, false);

			int next = cur;
			while (true) {
				srow[next] = true;
				f(j, m) {
					if (get(next, j) &lt; min_value[j]) {
						min_value[j] = get(next, j);
						min_pos[j] = next;
					}
				}

				pii _min = mp(-1, -1);
				f(j, m) {
					if (scol[j]) continue;
					if (_min.x == -1 || get(_min.x, _min.y) &gt; min_value[j]) {
						_min = mp(min_pos[j], j);
					}
				}

				assert(_min != mp(-1, -1));

				int d = get(_min.x, _min.y);

				f(i, n) {
					if (srow[i]) {
						row[i] -= d;
					}
				}
				f(j, m) {
					if (scol[j]) {
						col[j] += d;
					}
				}
				f(j, m) {
					min_value[j] -= d;
				}
				if (rez[_min.y] == -1) {
					int ind = _min.y;
					int p = _min.x;
					while (ind != -1) {
						rez[ind] = p;
						ind = invoker[p].y;
						p = invoker[p].x;
					}
					break;
				} else {
					scol[_min.y] = true;
					invoker[rez[_min.y]] = mp(_min.x, _min.y);
					next = rez[_min.y];
				}
			}
		}
		int total = 0;
		f(i, m) {
			total += v[rez[i]][i];
		}
		return mp(rez, total);
	}
};


========== Auto ==========

vector&lt;int&gt; suffix_array(const string &amp;s) {
    int n = s.size(), N = max(n, 257);
    vector&lt;int&gt; sa(n), ra(n);
    for (int i = 0; i &lt; n; i++) sa[i] = i, ra[i] = s[i];
    for (int k = 0; k &lt; n; k ? k &lt;&lt;= 1 : k++) {
        vector&lt;int&gt; nsa(sa), nra(n), cnt(N);
        for (int i = 0; i &lt; n; ++i) nsa[i] -= k - (nsa[i] &lt; k ? n : 0);
        for (int i = 0; i &lt; n; ++i) cnt[ra[i]]++;
        for (int i = 1; i &lt; N; ++i) cnt[i] += cnt[i - 1];
        for (int i = n - 1; i &gt;= 0; --i) sa[--cnt[ra[nsa[i]]]] = nsa[i];
        int r = 0;
        for (int i = 1; i &lt; n; ++i) {
            if (ra[sa[i]] != ra[sa[i - 1]]) r++;
            else if (ra[(sa[i] + k) % n] != ra[(sa[i - 1] + k) % n]) r++;
            nra[sa[i]] = r;
        }
        swap(ra, nra);
    }
    return sa;
}

int nodes = 0;

struct Auto {
	struct Node {
		map&lt;char, Node*&gt; go;
		int max_len = 0;
		Node *sufflink = NULL;
		int id = 0;

		Node() {
			id = nodes++;
		}
	};

	Node *clone(Node *node) {
		Node *cl = new Node();
		cl-&gt;go = node-&gt;go;
		cl-&gt;max_len = node-&gt;max_len;
		cl-&gt;sufflink = node-&gt;sufflink;
		return cl;
	}

	Node *root = new Node();
	Node *cur = NULL;

	Auto() {
		cur = root;
	}

	void add(char c) {
		Node *_new = new Node();
		_new-&gt;max_len = cur-&gt;max_len + 1;
		_new-&gt;sufflink = root;
		while (cur &amp;&amp; !cur-&gt;go.count(c)) {
			cur-&gt;go[c] = _new;
			cur = cur-&gt;sufflink;
		}
		if (cur) {
			if (cur-&gt;go[c]-&gt;max_len == cur-&gt;max_len + 1) {
				_new-&gt;sufflink = cur-&gt;go[c];
			} else {
				Node *q = cur-&gt;go[c];
				Node *p = clone(cur-&gt;go[c]);
				_new-&gt;sufflink = p;
				cur-&gt;go[c]-&gt;sufflink = p;
				p-&gt;max_len = cur-&gt;max_len + 1;

				while (cur) {
					if (cur-&gt;go[c] == q) {
						cur-&gt;go[c] = p;
						cur = cur-&gt;sufflink;
					} else {
						break;
					}
				}
			}
		}
		cur = _new;
	}

	bool check(Node *node, string &amp;s, int i) {
		if (i &gt;= len(s)) return true;
		if (!node-&gt;go.count(s[i])) return false;
		return check(node-&gt;go[s[i]], s, i + 1);
	}
};

========== z_function ==========

vector&lt;int&gt; z_function (string s) {
	int n = (int) s.length();
	vector&lt;int&gt; z (n);
	for (int i=1, l=0, r=0; i&lt;n; ++i) {
		if (i &lt;= r)
			z[i] = min (r-i+1, z[i-l]);
		while (i+z[i] &lt; n &amp;&amp; s[z[i]] == s[i+z[i]])
			++z[i];
		if (i+z[i]-1 &gt; r)
			l = i,  r = i+z[i]-1;
	}
	return z;
}


========== prefix_function ==========

vector&lt;int&gt; prefix_function (string s) {
	int n = (int) s.length();
	vector&lt;int&gt; pi (n);
	for (int i=1; i&lt;n; ++i) {
		int j = pi[i-1];
		while (j &gt; 0 &amp;&amp; s[i] != s[j])
			j = pi[j-1];
		if (s[i] == s[j])  ++j;
		pi[i] = j;
	}
	return pi;
}

========== BipolarDisorder ==========

struct BipolarDisorder {
	int n;
	vector&lt;vector&lt;int&gt;&gt; g;
	vector&lt;pii&gt; edges;
	vector&lt;int&gt; uptime;
	vector&lt;int&gt; tin;
	vector&lt;bool&gt; used;
	vector&lt;int&gt; buff;
	vector&lt;bool&gt; pick;
	vector&lt;int&gt; order;

	vector&lt;int&gt; at;

	int timer = 0;

	void init_time(int v) {
		used[v] = true;
		at[timer] = v;
		tin[v] = uptime[v] = timer++;
		for (int sub : g[v]) {
			if (used[sub]) continue;
			init_time(sub);
		}
	}

	void check(int v, int _forb) {
		used[v] = true;
		for (int sub : g[v]) {
			if (used[sub]) continue;
			if (sub == _forb) continue;
			check(sub, _forb);
		}
	}
	bool is_critical_slow(int v) {
		used = vector&lt;bool&gt;(n, false);
		int cnt = 0;
		for (int sub : g[v]) {
			if (used[sub]) continue;
			cnt++;
			check(sub, v);
		}
		return cnt &gt;= 2;
	}
	vector&lt;bool&gt; crit;
	void go(int v, int _p) {
		used[v] = true;
		for (int sub : g[v]) {
			if (sub == _p) continue;
			if (used[sub]) {
				uptime[v] = min(uptime[v], tin[sub]);
			} else {
				go(sub, v);
				uptime[v] = min(uptime[v], uptime[sub]);
				if (uptime[sub] &gt;= tin[v]) {
					crit[v] = true;
				}
			}
		}
	}

	void update_critical() {
		tin = vector&lt;int&gt;(n, 0);
		uptime = vector&lt;int&gt;(n, 0);
		used = vector&lt;bool&gt;(n, false);
		init_time(0);
		crit = vector&lt;bool&gt;(n, false);
		used = vector&lt;bool&gt;(n, false);
		go(0, -1);
		crit[0] = is_critical_slow(0);
	}

	int A = -1;

	struct Node {
		Node *l = NULL, *r = NULL, *pref = NULL;
		int prior;
		int size = 1;

		Node() {
			prior = rng();
		}
	};

	int get_size(Node *node) {
		return node ? node-&gt;size : 0;
	}

	void update(Node *node) {
		node-&gt;size = get_size(node-&gt;l) + get_size(node-&gt;r) + 1;
	}

	Node *merge(Node *l, Node *r) {
		if (!l) return r;
		if (!r) return l;
		if (l-&gt;prior &gt; r-&gt;prior) {
			l-&gt;r = merge(l-&gt;r, r);
			l-&gt;r-&gt;pref = l;
			update(l);
			return l;
		} else {
			r-&gt;l = merge(l, r-&gt;l);
			r-&gt;l-&gt;pref = r;
			update(r);
			return r;
		}
	}

	pair&lt;Node*, Node*&gt; split(Node *node, int k) {
		if (!node) return mp(node, node);
		if (get_size(node-&gt;l) &gt;= k) {
			if (node-&gt;l) node-&gt;l-&gt;pref = NULL;
			auto t = split(node-&gt;l, k);
			node-&gt;l = NULL;
			update(node);
			return mp(t.x, merge(t.y, node));
		} else {
			if (node-&gt;r) node-&gt;r-&gt;pref = NULL;
			auto t = split(node-&gt;r, k - get_size(node-&gt;l) - 1);
			node-&gt;r = NULL;
			update(node);
			return mp(merge(node, t.x), t.y);
		}
	}

	int get_id(Node *node) {
		int id = get_size(node-&gt;l);
		while (node-&gt;pref) {
			if (node-&gt;pref-&gt;r == node) {
				id += 1 + get_size(node-&gt;pref-&gt;l);
			}
			node = node-&gt;pref;
		}
		return id;
	}

	Node *cart = NULL;

	vector&lt;Node*&gt; pres;

	void dfs(int v, int _p, int end) {
		buff.pb(v);
		if (v == end) {
			for (int x : buff) {
				pres[x] = new Node();
				cart = merge(cart, pres[x]);
				pick[x] = true;
			}
		}
		at[timer] = v;
		uptime[v] = tin[v] = timer++;
		used[v] = true;
		for (int sub : g[v]) {
			if (sub == _p) continue;
			if (used[sub]) {
				uptime[v] = min(uptime[v], tin[sub]);
			} else {
				dfs(sub, v, end);
				uptime[v] = min(uptime[v], uptime[sub]);
			}
		}
		buff.pop_back();
	}

	void echo(int v, int _p) {
		used[v] = true;

		if (!pick[v]) {
			buff.pb(v);
		}

		int B = at[uptime[v]];
		if (!buff.empty() &amp;&amp; pick[B] &amp;&amp; B != A) {
			int itA = get_id(pres[A]);
			int itB = get_id(pres[B]);
			if (itA &lt; itB) {
				auto t = split(cart, itA + 1);
				for (int x : buff) {
					pres[x] = new Node();
					t.x = merge(t.x, pres[x]);
				}
				cart = merge(t.x, t.y);
			} else {
				reverse(buff.begin(), buff.end());
				auto t = split(cart, itB + 1);
				for (int x : buff) {
					pres[x] = new Node();
					t.x = merge(t.x, pres[x]);
				}
				cart = merge(t.x, t.y);
			}
			for (int x : buff) {
				pick[x] = true;
			}
			buff.clear();
		}

		for (int sub : g[v]) {
			if (sub == _p) continue;
			if (used[sub]) continue;
			if (pick[v]) {
				A = v;
			}
			echo(sub, v);
		}
	}

	set&lt;int&gt; finded_crit;
	void _index(int v) {
		used[v] = true;
		for (int sub : g[v]) {
			if (used[sub]) continue;
			if (crit[sub]) {
				finded_crit.insert(sub);
			} else {
				_index(sub);
			}
		}
	}

	void init(int _n) {
		n = _n;
		g.resize(n);
		at.resize(2 * n);
		uptime.resize(n);
		tin.resize(n);
		timer = 0;
	}

	void add_edge(int a, int b) {
		g[a].pb(b);
		g[b].pb(a);
		edges.emplace_back(a, b);
	}

	vector&lt;int&gt; get_priors() {
		{
			used = vector&lt;bool&gt;(n, false);
			update_critical();
			used = vector&lt;bool&gt;(n, false);
			vector&lt;int&gt; pos;
			f(i, n) {
				if (crit[i]) continue;
				if (!used[i]) {
					if (len(g[i]) == 1) {
						pos.pb(i);
						used[i] = true;
					} else {
						finded_crit.clear();
						_index(i);
						if (len(finded_crit) &lt;= 1) {
							pos.pb(i);
						}
					}
				}
			}
			if (len(pos) &lt;= 1) {
				pos.pb(n - 1);
			}
			if (len(pos) != 2) {
				return {};
			}

			int start = pos[0];
			int end = pos[1];
			shuffle(pos.begin(), pos.end(), rng);

			used = vector&lt;bool&gt;(n, false);
			pick = vector&lt;bool&gt;(n, false);
			pres.resize(n, NULL);
			timer = 0;
			dfs(start, -1, end);
			buff.clear();
			used = vector&lt;bool&gt;(n, false);
			echo(start, -1);
			vector&lt;int&gt; p(n);
			f(i, n) {
				if (pres[i]) {
					p[i] = get_id(pres[i]);
				} else {
					return {};
				}
			}
			vector&lt;int&gt; in(n), out(n);
			for (pii edge : edges) {
				if (p[edge.x] &gt; p[edge.y]) {
					swap(edge.x, edge.y);
				}
				in[edge.y]++;
				out[edge.x]++;
			}
			bool fail = false;
			f(i, n) {
				if (i != start &amp;&amp; in[i] == 0) {
					fail = true;
				}
				if (i != end &amp;&amp; out[i] == 0) {
					fail = true;
				}
			}
			if (!fail) {
				return p;
			} else {
				return {};
			}
		}
	}
};


========== MaxMatch ==========

struct MaxMatch {
	vector&lt;vector&lt;int&gt;&gt; g;
	vector&lt;int&gt; match;
	vector&lt;bool&gt; used;
	vector&lt;int&gt; p;

	MaxMatch(int n) {
		g.resize(n);
		match.resize(n, -1);
		p.resize(n);
		f(i, n) {
			p[i] = i;
		}
	}

	void add_edge(int a, int b) {
		g[a].pb(b);
		g[b].pb(a);
	}

	bool dfs(int v) {
		used[v] = true;
		shuffle(g[v].begin(), g[v].end(), rng);
		for (int sub : g[v]) {
			if (match[sub] == -1) {
				match[v] = sub;
				match[sub] = v;
				return true;
			}
		}
		for (int sub : g[v]) {
			int __t = match[sub];
			assert(__t != -1);
			if (used[__t]) continue;
			match[__t] = -1;
			match[sub] = v;
			match[v] = sub;
			if (dfs(__t)) {
				return true;
			} else {
				match[sub] = __t;
				match[__t] = sub;
				match[v] = -1;
			}
		}
		return false;
	}

	void upgrade() {
		shuffle(p.begin(), p.end(), rng);
		used = vector&lt;bool&gt;(len(g), false);
		for (int i : p) {
			if (match[i] == -1 &amp;&amp; !used[i]) {
				dfs(i);
			}
		}
	}

	vector&lt;pii&gt; edges() {
		vector&lt;pii&gt; rez;
		for (int i = 0; i &lt; len(g); i++) {
			if (match[i] != -1 &amp;&amp; i &lt; match[i]) {
				rez.emplace_back(i, match[i]);
			}
		}
		return rez;
	}
};

========== MaxMatchWithoutEachVertex ==========

struct DTree {
	int n;
	vector&lt;int&gt; parent, label, real;
	int cnt = 0;
	vector&lt;vector&lt;int&gt;&gt; edge, succ, pred;
	vector&lt;int&gt; semi, idom, ancestor, best;
	vector&lt;deque&lt;int&gt;&gt; bucket;

	vector&lt;vector&lt;int&gt;&gt; tree;

	void add_edge(int a, int b) {
		edge[a + 1].pb(b + 1);
	}

	DTree(int _n) {
		n = _n;
		parent.resize(n + 1);
		label.resize(n + 1);
		real.resize(n + 1);
		tree.resize(n + 1);
		edge.resize(n + 1);
		succ.resize(n + 1);
		pred.resize(n + 1);
		semi.resize(n + 1);
		idom.resize(n + 1);
		ancestor.resize(n + 1);
		best.resize(n + 1);
		bucket.resize(n + 1);
	}

	void dfs(int u) {
		label[u] = ++cnt; real[cnt] = u;
		for (vector&lt;int&gt;::iterator it = edge[u].begin(); it != edge[u].end(); ++it) {
			int v = *it;
			if (v == parent[u] || label[v] != -1) continue;
			parent[v] = u;
			dfs(v);
		}
	}

	void link(int v, int w) {
		ancestor[w] = v;
	}

	void compress(int v) {
		int a = ancestor[v];
		if (ancestor[a] == 0) return;
		compress(a);
		if (semi[best[v]] &gt; semi[best[a]]) best[v] = best[a];
		ancestor[v] = ancestor[a];
	}

	int eval(int v) {
		if (ancestor[v] == 0) return v;
		compress(v);
		return best[v];
	}

	void dominator() { // clear succ &amp; pred, let cnt = 0 first
		for (int i = 1; i &lt;= n; ++i) label[i] = -1;
		dfs(n); // n is root
		for (int u = 1; u &lt;= n; ++u) {
			for (vector&lt;int&gt;::iterator it = edge[u].begin(); it != edge[u].end(); ++it) {
				int v = *it;
				if (label[u] != -1 &amp;&amp; label[v] != -1) {
					succ[label[u]].push_back(label[v]);
					pred[label[v]].push_back(label[u]);
				}
			}
		}
		for (int i = 1; i &lt;= n; ++i) {
			semi[i] = best[i] = i;
			idom[i] = ancestor[i] = 0;
			bucket[i].clear();
		}
		for (int w = cnt; w &gt;= 2; --w) {
			int p = label[parent[real[w]]];
			for (vector&lt;int&gt;::iterator it = pred[w].begin(); it != pred[w].end(); ++it) {
				int v = *it;
				int u = eval(v);
				if (semi[w] &gt; semi[u]) semi[w] = semi[u];
			}
			bucket[semi[w]].push_back(w);
			link(p, w);
			while (!bucket[p].empty()) {
				int v = bucket[p].front();
				bucket[p].pop_front();
				int u = eval(v);
				idom[v] = (semi[u] &lt; p ? u : p);
			}
		}
		for (int w = 2; w &lt;= cnt; ++w) {
			if (idom[w] != semi[w]) idom[w] = idom[idom[w]];
		}
		idom[1] = 0;
		for (int i = 1; i &lt;= cnt; ++i) {
			int u = real[idom[i]], v = real[i];
			// u is immediate dominator of v (i == 1?)
			// print u - 1, v - 1;
		}
	}
};

int n, m;

vector&lt;vector&lt;int&gt;&gt; g;
vector&lt;bool&gt; used;
vector&lt;bool&gt; R;
vector&lt;int&gt; rez;

bool ktun(int v) {
	used[v] = true;
	for (int sub : g[v]) {
		if (rez[sub] == -1) {
			rez[sub] = v;
			return true;
		}
	}
	for (int sub : g[v]) {
		if (used[rez[sub]]) continue;
		R[sub] = true;
		if (ktun(rez[sub])) {
			rez[sub] = v;
			return true;
		}
	}
	return false;
}

pair&lt;int, vector&lt;bool&gt;&gt; match(vector&lt;pii&gt; edges) {
	g.clear();
	R.clear();
	rez.clear();
	rez.resize(n, -1);
	g.resize(n);
	R.resize(n);
	for (pii e : edges) {
		g[e.x].pb(e.y);
	}
	used = vector&lt;bool&gt;(n, false);
	f(i, n) {
		if (ktun(i)) {
			used = vector&lt;bool&gt;(n, false);
		}
	}
	DTree tree(2 * n + 1);
	f(i, n) {
		for (int sub : g[i]) {
			if (rez[sub] == i) {
				tree.add_edge(sub + n, i);
			} else {
				tree.add_edge(i, sub + n);
			}
		}
	}
	vector&lt;bool&gt; L(n);
	f(i, n) {
		if (rez[i] != -1) {
			L[rez[i]] = true;
		}
	}
	R = vector&lt;bool&gt;(n, false);
	used = vector&lt;bool&gt;(n, false);
	f(i, n) {
		if (!L[i]) {
			tree.add_edge(2 * n, i);
			ktun(i);
		}
	}
	tree.dominator();
	vector&lt;bool&gt; can_del(n, false);
	f(i, n) {
		if (!L[i]) {
			can_del[i] = true;
		}
	}
	f(i, n) {
		if (rez[i] == -1) {
		} else {
			if (R[i]) {
				bool found = false;
				int j = i + n;
				while (j != -1) {
					if (j == rez[i]) {
						found = true;
					}
					j = tree.parent[j + 1] - 1;
				}
				can_del[rez[i]] = !found;
			}
		}
	}
	int cnt = 0;
	f(i, n) {
		cnt += (rez[i] == -1);
	}
	return mp(cnt, can_del);
}

signed main(signed argc, char *argv[]) {
	scan n, m;
	vector&lt;pii&gt; edges, rev;
	f(i, m) {
		int a, b;
		scan a, b;
		a--;b--;
		edges.emplace_back(a, b);
		rev.emplace_back(b, a);
	}
	auto A = match(edges);
	auto B = match(rev);
	int y = min(A.x, B.x);
	vector&lt;int&gt; free;
	f(i, n) {
		if (A.y[i] || B.y[i]) {
			free.pb(i + 1);
		}
	}
	if (y - 1 == 0) {
		print 0;
	} else {
		print y - 1;
		print free;
	}
}


========== interpol ==========

template&lt;class T&gt;
vector&lt;T&gt; interpol(const vector&lt;pair&lt;T, T&gt;&gt; &amp;pts) {
	if (pts.empty()) return {};
	vector&lt;T&gt; holy;
	vector&lt;T&gt; zero = {1};
	auto calc = [](vector&lt;T&gt; &amp;poly, const T &amp;x) {
		T s = 0;
		T p = 1;
		f(j, len(poly)) {
			s += poly[j] * p;
			p *= x;
		}
		return s;
	};
	holy.emplace_back(pts[0].y);
	for (int i = 1; i &lt; len(pts); i++) {
		zero.insert(zero.begin(), 0);
		f(j, len(zero) - 1) {
			zero[j] -= zero[j + 1] * pts[i - 1].x;
		}
		T sub = pts[i].y - calc(holy, pts[i].x);
		T coef = sub / calc(zero, pts[i].x);
		while (len(holy) &lt; len(zero)) {
			holy.pb(0);
		}
		for (int j = 0; j &lt; len(zero); j++) {
			holy[j] += zero[j] * coef;
		}
	}
	return holy;
}

========== Bridges ==========

const int MAXN = ...;
vector&lt;int&gt; g[MAXN];
bool used[MAXN];
int timer, tin[MAXN], fup[MAXN];

void dfs (int v, int p = -1) {
	used[v] = true;
	tin[v] = fup[v] = timer++;
	for (size_t i=0; i&lt;g[v].size(); ++i) {
		int to = g[v][i];
		if (to == p)  continue;
		if (used[to])
			fup[v] = min (fup[v], tin[to]);
		else {
			dfs (to, v);
			fup[v] = min (fup[v], fup[to]);
			if (fup[to] &gt; tin[v])
				IS_BRIDGE(v,to);
		}
	}
}

void find_bridges() {
	timer = 0;
	for (int i=0; i&lt;n; ++i)
		used[i] = false;
	for (int i=0; i&lt;n; ++i)
		if (!used[i])
			dfs (i);
}

========== CriticalPoints ==========

vector&lt;int&gt; g[MAXN];
bool used[MAXN];
int timer, tin[MAXN], fup[MAXN];

void dfs (int v, int p = -1) {
	used[v] = true;
	tin[v] = fup[v] = timer++;
	int children = 0;
	for (size_t i=0; i&lt;g[v].size(); ++i) {
		int to = g[v][i];
		if (to == p)  continue;
		if (used[to])
			fup[v] = min (fup[v], tin[to]);
		else {
			dfs (to, v);
			fup[v] = min (fup[v], fup[to]);
			if (fup[to] &gt;= tin[v] &amp;&amp; p != -1)
				IS_CUTPOINT(v);
			++children;
		}
	}
	if (p == -1 &amp;&amp; children &gt; 1)
		IS_CUTPOINT(v);
}

int main() {
	int n;
B

	timer = 0;
	for (int i=0; i&lt;n; ++i)
		used[i] = false;
	dfs (0);
}

========== determinant ==========

template&lt;class T&gt;
T det(vector&lt;vector&lt;T&gt;&gt; v) {
	int n = len(v);
	T d = 1;
	for (int i = 0; i &lt; n; i++) {
		for (int j = i + 1; j &lt; n; j++) {
			if (v[j][i] != T(0)) {
				swap(v[j], v[i]);
				d *= -1;
				break;
			}
		}
		if (v[i][i] == 0) return (T)0;
		d *= v[i][i];
		for (int j = i + 1; j &lt; n; j++) {
			num coef = v[j][i] / v[i][i];
			for (int k = i; k &lt; n; k++) {
				v[j][k] -= (v[i][k] * coef);
			}
		}
	}
	return d;
}
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
